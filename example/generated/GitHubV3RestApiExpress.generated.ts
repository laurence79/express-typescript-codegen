import type {
  Request,
  Response,
  Express,
  NextFunction,
  ParamsDictionary,
  ErrorRequestHandler
} from 'express-serve-static-core';
import { Router } from 'express';
import { ParsedQs } from 'qs';
import * as ExpressJonValidator from 'express-json-validator-middleware';

export type Root = {
  readonly current_user_url: string;
  readonly current_user_authorizations_html_url: string;
  readonly authorizations_url: string;
  readonly code_search_url: string;
  readonly commit_search_url: string;
  readonly emails_url: string;
  readonly emojis_url: string;
  readonly events_url: string;
  readonly feeds_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly hub_url: string;
  readonly issue_search_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly label_search_url: string;
  readonly notifications_url: string;
  readonly organization_url: string;
  readonly organization_repositories_url: string;
  readonly organization_teams_url: string;
  readonly public_gists_url: string;
  readonly rate_limit_url: string;
  readonly repository_url: string;
  readonly repository_search_url: string;
  readonly current_user_repositories_url: string;
  readonly starred_url: string;
  readonly starred_gists_url: string;
  readonly topic_search_url?: string;
  readonly user_url: string;
  readonly user_organizations_url: string;
  readonly user_repositories_url: string;
  readonly user_search_url: string;
};

export type MetaRoot200ResponseBody = Root;

export type SimpleUser = {
  readonly name?: string | null;
  readonly email?: string | null;
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly site_admin: boolean;
  readonly starred_at?: string;
} | null;

export type GitHubApp = {
  readonly id: number;
  readonly slug?: string;
  readonly node_id: string;
  readonly owner: SimpleUser;
  readonly name: string;
  readonly description: string | null;
  readonly external_url: string;
  readonly html_url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly permissions: {
    readonly issues?: string;
    readonly checks?: string;
    readonly metadata?: string;
    readonly contents?: string;
    readonly deployments?: string;
  };
  readonly events: ReadonlyArray<string>;
  readonly installations_count?: number;
  readonly client_id?: string;
  readonly client_secret?: string;
  readonly webhook_secret?: string | null;
  readonly pem?: string;
};

export type AppsGetAuthenticated200ResponseBody = GitHubApp;

export type AppsCreateFromManifest201ResponseBody = GitHubApp & {
  readonly client_id: string;
  readonly client_secret: string;
  readonly webhook_secret: string | null;
  readonly pem: string;
};

export type BasicError = {
  readonly message?: string;
  readonly documentation_url?: string;
  readonly url?: string;
  readonly status?: string;
};

export type AppsCreateFromManifest404ResponseBody = BasicError;

export type ValidationErrorSimple = {
  readonly message: string;
  readonly documentation_url: string;
  readonly errors?: ReadonlyArray<string>;
};

export type AppsCreateFromManifest422ResponseBody = ValidationErrorSimple;

export type AppsCreateFromManifestRequestPath = { readonly code: string };

export type WebhookConfigUrl = string;

export type WebhookConfigContentType = string;

export type WebhookConfigSecret = string;

export type WebhookConfigInsecureSsl = string | number;

export type WebhookConfiguration = {
  readonly url?: WebhookConfigUrl;
  readonly content_type?: WebhookConfigContentType;
  readonly secret?: WebhookConfigSecret;
  readonly insecure_ssl?: WebhookConfigInsecureSsl;
};

export type AppsGetWebhookConfigForApp200ResponseBody = WebhookConfiguration;

export type AppsUpdateWebhookConfigForApp200ResponseBody = WebhookConfiguration;

export type AppsUpdateWebhookConfigForAppRequestBody = {
  readonly url?: WebhookConfigUrl;
  readonly content_type?: WebhookConfigContentType;
  readonly secret?: WebhookConfigSecret;
  readonly insecure_ssl?: WebhookConfigInsecureSsl;
};

export type SimpleWebhookDelivery = {
  readonly id: number;
  readonly guid: string;
  readonly delivered_at: string;
  readonly redelivery: boolean;
  readonly duration: number;
  readonly status: string;
  readonly status_code: number;
  readonly event: string;
  readonly action: string | null;
  readonly installation_id: number | null;
  readonly repository_id: number | null;
};

export type AppsListWebhookDeliveries200ResponseBody = ReadonlyArray<SimpleWebhookDelivery>;

export type AppsListWebhookDeliveries400ResponseBody = BasicError;

export type ValidationError = {
  readonly message: string;
  readonly documentation_url: string;
  readonly errors?: ReadonlyArray<{
    readonly resource?: string;
    readonly field?: string;
    readonly message?: string;
    readonly code: string;
    readonly index?: number;
    readonly value?:
      | string
      | null
      | number
      | null
      | ReadonlyArray<string>
      | null;
  }>;
};

export type AppsListWebhookDeliveries422ResponseBody = ValidationError;

export type AppsListWebhookDeliveriesRequestQuery = {
  readonly per_page?: number;
  readonly cursor?: string;
};

export type WebhookDelivery = {
  readonly id: number;
  readonly guid: string;
  readonly delivered_at: string;
  readonly redelivery: boolean;
  readonly duration: number;
  readonly status: string;
  readonly status_code: number;
  readonly event: string;
  readonly action: string | null;
  readonly installation_id: number | null;
  readonly repository_id: number | null;
  readonly url?: string;
  readonly request: {
    readonly headers: unknown | null;
    readonly payload: unknown | null;
  };
  readonly response: {
    readonly headers: unknown | null;
    readonly payload: string | null;
  };
};

export type AppsGetWebhookDelivery200ResponseBody = WebhookDelivery;

export type AppsGetWebhookDelivery400ResponseBody = BasicError;

export type AppsGetWebhookDelivery422ResponseBody = ValidationError;

export type AppsGetWebhookDeliveryRequestPath = {
  readonly delivery_id: number;
};

export type AppsRedeliverWebhookDelivery202ResponseBody = unknown;

export type AppsRedeliverWebhookDelivery400ResponseBody = BasicError;

export type AppsRedeliverWebhookDelivery422ResponseBody = ValidationError;

export type AppsRedeliverWebhookDeliveryRequestPath = {
  readonly delivery_id: number;
};

export type Enterprise = {
  readonly description?: string | null;
  readonly html_url: string;
  readonly website_url?: string | null;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly slug: string;
  readonly created_at: string | null;
  readonly updated_at: string | null;
  readonly avatar_url: string;
};

export type AppPermissions = {
  readonly actions?: 'read' | 'write';
  readonly administration?: 'read' | 'write';
  readonly checks?: 'read' | 'write';
  readonly contents?: 'read' | 'write';
  readonly deployments?: 'read' | 'write';
  readonly environments?: 'read' | 'write';
  readonly issues?: 'read' | 'write';
  readonly metadata?: 'read' | 'write';
  readonly packages?: 'read' | 'write';
  readonly pages?: 'read' | 'write';
  readonly pull_requests?: 'read' | 'write';
  readonly repository_announcement_banners?: 'read' | 'write';
  readonly repository_hooks?: 'read' | 'write';
  readonly repository_projects?: 'read' | 'write' | 'admin';
  readonly secret_scanning_alerts?: 'read' | 'write';
  readonly secrets?: 'read' | 'write';
  readonly security_events?: 'read' | 'write';
  readonly single_file?: 'read' | 'write';
  readonly statuses?: 'read' | 'write';
  readonly vulnerability_alerts?: 'read' | 'write';
  readonly workflows?: 'write';
  readonly members?: 'read' | 'write';
  readonly organization_administration?: 'read' | 'write';
  readonly organization_custom_roles?: 'read' | 'write';
  readonly organization_announcement_banners?: 'read' | 'write';
  readonly organization_hooks?: 'read' | 'write';
  readonly organization_plan?: 'read';
  readonly organization_projects?: 'read' | 'write' | 'admin';
  readonly organization_packages?: 'read' | 'write';
  readonly organization_secrets?: 'read' | 'write';
  readonly organization_self_hosted_runners?: 'read' | 'write';
  readonly organization_user_blocking?: 'read' | 'write';
  readonly team_discussions?: 'read' | 'write';
};

export type Installation = {
  readonly id: number;
  readonly account: SimpleUser | Enterprise | null;
  readonly repository_selection: 'all' | 'selected';
  readonly access_tokens_url: string;
  readonly repositories_url: string;
  readonly html_url: string;
  readonly app_id: number;
  readonly target_id: number;
  readonly target_type: string;
  readonly permissions: AppPermissions;
  readonly events: ReadonlyArray<string>;
  readonly created_at: string;
  readonly updated_at: string;
  readonly single_file_name: string | null;
  readonly has_multiple_single_files?: boolean;
  readonly single_file_paths?: ReadonlyArray<string>;
  readonly app_slug: string;
  readonly suspended_by: SimpleUser;
  readonly suspended_at: string | null;
  readonly contact_email?: string | null;
};

export type AppsListInstallations200ResponseBody = ReadonlyArray<Installation>;

export type AppsListInstallationsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly since?: string;
  readonly outdated?: string;
};

export type AppsGetInstallation200ResponseBody = Installation;

export type AppsGetInstallation404ResponseBody = BasicError;

export type AppsGetInstallationRequestPath = {
  readonly installation_id: number;
};

export type AppsDeleteInstallation404ResponseBody = BasicError;

export type AppsDeleteInstallationRequestPath = {
  readonly installation_id: number;
};

export type LicenseSimple = {
  readonly key: string;
  readonly name: string;
  readonly url: string | null;
  readonly spdx_id: string | null;
  readonly node_id: string;
  readonly html_url?: string;
} | null;

export type Repository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly license: LicenseSimple;
  readonly organization?: SimpleUser;
  readonly forks: number;
  readonly permissions?: {
    readonly admin: boolean;
    readonly pull: boolean;
    readonly triage?: boolean;
    readonly push: boolean;
    readonly maintain?: boolean;
  };
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly git_url: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly ssh_url: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly clone_url: string;
  readonly mirror_url: string | null;
  readonly hooks_url: string;
  readonly svn_url: string;
  readonly homepage: string | null;
  readonly language: string | null;
  readonly forks_count: number;
  readonly stargazers_count: number;
  readonly watchers_count: number;
  readonly size: number;
  readonly default_branch: string;
  readonly open_issues_count: number;
  readonly is_template?: boolean;
  readonly topics?: ReadonlyArray<string>;
  readonly has_issues: boolean;
  readonly has_projects: boolean;
  readonly has_wiki: boolean;
  readonly has_pages: boolean;
  readonly has_downloads: boolean;
  readonly archived: boolean;
  readonly disabled: boolean;
  readonly visibility?: string;
  readonly pushed_at: string | null;
  readonly created_at: string | null;
  readonly updated_at: string | null;
  readonly allow_rebase_merge?: boolean;
  readonly template_repository?: {
    readonly id?: number;
    readonly node_id?: string;
    readonly name?: string;
    readonly full_name?: string;
    readonly owner?: {
      readonly login?: string;
      readonly id?: number;
      readonly node_id?: string;
      readonly avatar_url?: string;
      readonly gravatar_id?: string;
      readonly url?: string;
      readonly html_url?: string;
      readonly followers_url?: string;
      readonly following_url?: string;
      readonly gists_url?: string;
      readonly starred_url?: string;
      readonly subscriptions_url?: string;
      readonly organizations_url?: string;
      readonly repos_url?: string;
      readonly events_url?: string;
      readonly received_events_url?: string;
      readonly type?: string;
      readonly site_admin?: boolean;
    };
    readonly private?: boolean;
    readonly html_url?: string;
    readonly description?: string;
    readonly fork?: boolean;
    readonly url?: string;
    readonly archive_url?: string;
    readonly assignees_url?: string;
    readonly blobs_url?: string;
    readonly branches_url?: string;
    readonly collaborators_url?: string;
    readonly comments_url?: string;
    readonly commits_url?: string;
    readonly compare_url?: string;
    readonly contents_url?: string;
    readonly contributors_url?: string;
    readonly deployments_url?: string;
    readonly downloads_url?: string;
    readonly events_url?: string;
    readonly forks_url?: string;
    readonly git_commits_url?: string;
    readonly git_refs_url?: string;
    readonly git_tags_url?: string;
    readonly git_url?: string;
    readonly issue_comment_url?: string;
    readonly issue_events_url?: string;
    readonly issues_url?: string;
    readonly keys_url?: string;
    readonly labels_url?: string;
    readonly languages_url?: string;
    readonly merges_url?: string;
    readonly milestones_url?: string;
    readonly notifications_url?: string;
    readonly pulls_url?: string;
    readonly releases_url?: string;
    readonly ssh_url?: string;
    readonly stargazers_url?: string;
    readonly statuses_url?: string;
    readonly subscribers_url?: string;
    readonly subscription_url?: string;
    readonly tags_url?: string;
    readonly teams_url?: string;
    readonly trees_url?: string;
    readonly clone_url?: string;
    readonly mirror_url?: string;
    readonly hooks_url?: string;
    readonly svn_url?: string;
    readonly homepage?: string;
    readonly language?: string;
    readonly forks_count?: number;
    readonly stargazers_count?: number;
    readonly watchers_count?: number;
    readonly size?: number;
    readonly default_branch?: string;
    readonly open_issues_count?: number;
    readonly is_template?: boolean;
    readonly topics?: ReadonlyArray<string>;
    readonly has_issues?: boolean;
    readonly has_projects?: boolean;
    readonly has_wiki?: boolean;
    readonly has_pages?: boolean;
    readonly has_downloads?: boolean;
    readonly archived?: boolean;
    readonly disabled?: boolean;
    readonly visibility?: string;
    readonly pushed_at?: string;
    readonly created_at?: string;
    readonly updated_at?: string;
    readonly permissions?: {
      readonly admin?: boolean;
      readonly maintain?: boolean;
      readonly push?: boolean;
      readonly triage?: boolean;
      readonly pull?: boolean;
    };
    readonly allow_rebase_merge?: boolean;
    readonly temp_clone_token?: string;
    readonly allow_squash_merge?: boolean;
    readonly allow_auto_merge?: boolean;
    readonly delete_branch_on_merge?: boolean;
    readonly allow_update_branch?: boolean;
    readonly use_squash_pr_title_as_default?: boolean;
    readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
    readonly squash_merge_commit_message?:
      | 'PR_BODY'
      | 'COMMIT_MESSAGES'
      | 'BLANK';
    readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
    readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
    readonly allow_merge_commit?: boolean;
    readonly subscribers_count?: number;
    readonly network_count?: number;
  } | null;
  readonly temp_clone_token?: string;
  readonly allow_squash_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_update_branch?: boolean;
  readonly use_squash_pr_title_as_default?: boolean;
  readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
  readonly squash_merge_commit_message?:
    | 'PR_BODY'
    | 'COMMIT_MESSAGES'
    | 'BLANK';
  readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
  readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
  readonly allow_merge_commit?: boolean;
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
  readonly subscribers_count?: number;
  readonly network_count?: number;
  readonly open_issues: number;
  readonly watchers: number;
  readonly master_branch?: string;
  readonly starred_at?: string;
  readonly anonymous_access_enabled?: boolean;
};

export type InstallationToken = {
  readonly token: string;
  readonly expires_at: string;
  readonly permissions?: AppPermissions;
  readonly repository_selection?: 'all' | 'selected';
  readonly repositories?: ReadonlyArray<Repository>;
  readonly single_file?: string;
  readonly has_multiple_single_files?: boolean;
  readonly single_file_paths?: ReadonlyArray<string>;
};

export type AppsCreateInstallationAccessToken201ResponseBody = InstallationToken;

export type AppsCreateInstallationAccessToken401ResponseBody = BasicError;

export type AppsCreateInstallationAccessToken403ResponseBody = BasicError;

export type AppsCreateInstallationAccessToken404ResponseBody = BasicError;

export type AppsCreateInstallationAccessToken422ResponseBody = ValidationError;

export type AppsCreateInstallationAccessTokenRequestBody = {
  readonly repositories?: ReadonlyArray<string>;
  readonly repository_ids?: ReadonlyArray<number>;
  readonly permissions?: AppPermissions;
};

export type AppsCreateInstallationAccessTokenRequestPath = {
  readonly installation_id: number;
};

export type AppsSuspendInstallation404ResponseBody = BasicError;

export type AppsSuspendInstallationRequestPath = {
  readonly installation_id: number;
};

export type AppsUnsuspendInstallation404ResponseBody = BasicError;

export type AppsUnsuspendInstallationRequestPath = {
  readonly installation_id: number;
};

export type AppsDeleteAuthorization422ResponseBody = ValidationError;

export type AppsDeleteAuthorizationRequestBody = {
  readonly access_token: string;
};

export type AppsDeleteAuthorizationRequestPath = { readonly client_id: string };

export type ScopedInstallation = {
  readonly permissions: AppPermissions;
  readonly repository_selection: 'all' | 'selected';
  readonly single_file_name: string | null;
  readonly has_multiple_single_files?: boolean;
  readonly single_file_paths?: ReadonlyArray<string>;
  readonly repositories_url: string;
  readonly account: SimpleUser;
} | null;

export type Authorization = {
  readonly id: number;
  readonly url: string;
  readonly scopes: ReadonlyArray<string> | null;
  readonly token: string;
  readonly token_last_eight: string | null;
  readonly hashed_token: string | null;
  readonly app: {
    readonly client_id: string;
    readonly name: string;
    readonly url: string;
  };
  readonly note: string | null;
  readonly note_url: string | null;
  readonly updated_at: string;
  readonly created_at: string;
  readonly fingerprint: string | null;
  readonly user?: SimpleUser;
  readonly installation?: ScopedInstallation;
  readonly expires_at: string | null;
};

export type AppsCheckToken200ResponseBody = Authorization;

export type AppsCheckToken404ResponseBody = BasicError;

export type AppsCheckToken422ResponseBody = ValidationError;

export type AppsCheckTokenRequestBody = { readonly access_token: string };

export type AppsCheckTokenRequestPath = { readonly client_id: string };

export type AppsResetToken200ResponseBody = Authorization;

export type AppsResetToken422ResponseBody = ValidationError;

export type AppsResetTokenRequestBody = { readonly access_token: string };

export type AppsResetTokenRequestPath = { readonly client_id: string };

export type AppsDeleteToken422ResponseBody = ValidationError;

export type AppsDeleteTokenRequestBody = { readonly access_token: string };

export type AppsDeleteTokenRequestPath = { readonly client_id: string };

export type AppsScopeToken200ResponseBody = Authorization;

export type AppsScopeToken401ResponseBody = BasicError;

export type AppsScopeToken403ResponseBody = BasicError;

export type AppsScopeToken404ResponseBody = BasicError;

export type AppsScopeToken422ResponseBody = ValidationError;

export type AppsScopeTokenRequestBody = {
  readonly access_token: string;
  readonly target?: string;
  readonly target_id?: number;
  readonly repositories?: ReadonlyArray<string>;
  readonly repository_ids?: ReadonlyArray<number>;
  readonly permissions?: AppPermissions;
};

export type AppsScopeTokenRequestPath = { readonly client_id: string };

export type AppsGetBySlug200ResponseBody = GitHubApp;

export type AppsGetBySlug403ResponseBody = BasicError;

export type AppsGetBySlug404ResponseBody = BasicError;

export type AppsGetBySlugRequestPath = { readonly app_slug: string };

export type CodeOfConduct = {
  readonly key: string;
  readonly name: string;
  readonly url: string;
  readonly body?: string;
  readonly html_url: string | null;
};

export type CodesOfConductGetAllCodesOfConduct200ResponseBody = ReadonlyArray<CodeOfConduct>;

export type CodesOfConductGetConductCode200ResponseBody = CodeOfConduct;

export type CodesOfConductGetConductCode404ResponseBody = BasicError;

export type CodesOfConductGetConductCodeRequestPath = { readonly key: string };

export type EmojisGet200ResponseBody = unknown;

export type ServerStatisticsProxyEndpoint = ReadonlyArray<{
  readonly server_id?: string;
  readonly collection_date?: string;
  readonly schema_version?: string;
  readonly ghes_version?: string;
  readonly host_name?: string;
  readonly github_connect?: {
    readonly features_enabled?: ReadonlyArray<string>;
  };
  readonly ghe_stats?: {
    readonly comments?: {
      readonly total_commit_comments?: number;
      readonly total_gist_comments?: number;
      readonly total_issue_comments?: number;
      readonly total_pull_request_comments?: number;
    };
    readonly gists?: {
      readonly total_gists?: number;
      readonly private_gists?: number;
      readonly public_gists?: number;
    };
    readonly hooks?: {
      readonly total_hooks?: number;
      readonly active_hooks?: number;
      readonly inactive_hooks?: number;
    };
    readonly issues?: {
      readonly total_issues?: number;
      readonly open_issues?: number;
      readonly closed_issues?: number;
    };
    readonly milestones?: {
      readonly total_milestones?: number;
      readonly open_milestones?: number;
      readonly closed_milestones?: number;
    };
    readonly orgs?: {
      readonly total_orgs?: number;
      readonly disabled_orgs?: number;
      readonly total_teams?: number;
      readonly total_team_members?: number;
    };
    readonly pages?: { readonly total_pages?: number };
    readonly pulls?: {
      readonly total_pulls?: number;
      readonly merged_pulls?: number;
      readonly mergeable_pulls?: number;
      readonly unmergeable_pulls?: number;
    };
    readonly repos?: {
      readonly total_repos?: number;
      readonly root_repos?: number;
      readonly fork_repos?: number;
      readonly org_repos?: number;
      readonly total_pushes?: number;
      readonly total_wikis?: number;
    };
    readonly users?: {
      readonly total_users?: number;
      readonly admin_users?: number;
      readonly suspended_users?: number;
    };
  };
  readonly dormant_users?: {
    readonly total_dormant_users?: number;
    readonly dormancy_threshold?: string;
  };
}>;

export type EnterpriseAdminGetServerStatistics200ResponseBody = ServerStatisticsProxyEndpoint;

export type EnterpriseAdminGetServerStatisticsRequestQuery = {
  readonly date_start?: string;
  readonly date_end?: string;
};

export type EnterpriseAdminGetServerStatisticsRequestPath = {
  readonly enterprise_or_org: string;
};

export type ActionsCacheUsageOrgEnterprise = {
  readonly total_active_caches_count: number;
  readonly total_active_caches_size_in_bytes: number;
};

export type ActionsGetActionsCacheUsageForEnterprise200ResponseBody = ActionsCacheUsageOrgEnterprise;

export type ActionsGetActionsCacheUsageForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnabledOrganizations = 'all' | 'none' | 'selected';

export type AllowedActions = 'all' | 'local_only' | 'selected';

export type SelectedActionsUrl = string;

export type ActionsEnterprisePermissions = {
  readonly enabled_organizations: EnabledOrganizations;
  readonly selected_organizations_url?: string;
  readonly allowed_actions?: AllowedActions;
  readonly selected_actions_url?: SelectedActionsUrl;
};

export type EnterpriseAdminGetGithubActionsPermissionsEnterprise200ResponseBody = ActionsEnterprisePermissions;

export type EnterpriseAdminGetGithubActionsPermissionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequestBody = {
  readonly enabled_organizations: EnabledOrganizations;
  readonly allowed_actions?: AllowedActions;
};

export type EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type OrganizationSimple = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly hooks_url: string;
  readonly issues_url: string;
  readonly members_url: string;
  readonly public_members_url: string;
  readonly avatar_url: string;
  readonly description: string | null;
};

export type EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly organizations: ReadonlyArray<OrganizationSimple>;
};

export type EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequestBody = {
  readonly selected_organization_ids: ReadonlyArray<number>;
};

export type EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly org_id: number;
};

export type EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly org_id: number;
};

export type SelectedActions = {
  readonly github_owned_allowed?: boolean;
  readonly verified_allowed?: boolean;
  readonly patterns_allowed?: ReadonlyArray<string>;
};

export type EnterpriseAdminGetAllowedActionsEnterprise200ResponseBody = SelectedActions;

export type EnterpriseAdminGetAllowedActionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminSetAllowedActionsEnterpriseRequestBody = SelectedActions;

export type EnterpriseAdminSetAllowedActionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type ActionsDefaultWorkflowPermissions = 'read' | 'write';

export type ActionsCanApprovePullRequestReviews = boolean;

export type ActionsGetDefaultWorkflowPermissions = {
  readonly default_workflow_permissions: ActionsDefaultWorkflowPermissions;
  readonly can_approve_pull_request_reviews: ActionsCanApprovePullRequestReviews;
};

export type ActionsGetGithubActionsDefaultWorkflowPermissionsEnterprise200ResponseBody = ActionsGetDefaultWorkflowPermissions;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type ActionsSetDefaultWorkflowPermissions = {
  readonly default_workflow_permissions?: ActionsDefaultWorkflowPermissions;
  readonly can_approve_pull_request_reviews?: ActionsCanApprovePullRequestReviews;
};

export type ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestBody = ActionsSetDefaultWorkflowPermissions;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type RunnerGroupsEnterprise = {
  readonly id: number;
  readonly name: string;
  readonly visibility: string;
  readonly default: boolean;
  readonly selected_organizations_url?: string;
  readonly runners_url: string;
  readonly allows_public_repositories: boolean;
  readonly workflow_restrictions_read_only?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly runner_groups: ReadonlyArray<RunnerGroupsEnterprise>;
};

export type EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly visible_to_organization?: string;
};

export type EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise201ResponseBody = RunnerGroupsEnterprise;

export type EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequestBody = {
  readonly name: string;
  readonly visibility?: 'selected' | 'all';
  readonly selected_organization_ids?: ReadonlyArray<number>;
  readonly runners?: ReadonlyArray<number>;
  readonly allows_public_repositories?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise200ResponseBody = RunnerGroupsEnterprise;

export type EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise200ResponseBody = RunnerGroupsEnterprise;

export type EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequestBody = {
  readonly name?: string;
  readonly visibility?: 'selected' | 'all';
  readonly allows_public_repositories?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly organizations: ReadonlyArray<OrganizationSimple>;
};

export type EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestBody = {
  readonly selected_organization_ids: ReadonlyArray<number>;
};

export type EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
  readonly org_id: number;
};

export type EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
  readonly org_id: number;
};

export type SelfHostedRunnerLabel = {
  readonly id?: number;
  readonly name: string;
  readonly type?: 'read-only' | 'custom';
};

export type SelfHostedRunners = {
  readonly id: number;
  readonly name: string;
  readonly os: string;
  readonly status: string;
  readonly busy: boolean;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly runners: ReadonlyArray<SelfHostedRunners>;
};

export type EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequestBody = {
  readonly runners: ReadonlyArray<number>;
};

export type EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
  readonly runner_id: number;
};

export type EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
  readonly runner_id: number;
};

export type EnterpriseAdminListSelfHostedRunnersForEnterprise200ResponseBody = {
  readonly total_count?: number;
  readonly runners?: ReadonlyArray<SelfHostedRunners>;
};

export type EnterpriseAdminListSelfHostedRunnersForEnterpriseRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type EnterpriseAdminListSelfHostedRunnersForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type RunnerApplication = {
  readonly os: string;
  readonly architecture: string;
  readonly download_url: string;
  readonly filename: string;
  readonly temp_download_token?: string;
  readonly sha256_checksum?: string;
};

export type EnterpriseAdminListRunnerApplicationsForEnterprise200ResponseBody = ReadonlyArray<RunnerApplication>;

export type EnterpriseAdminListRunnerApplicationsForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type AuthenticationToken = {
  readonly token: string;
  readonly expires_at: string;
  readonly permissions?: unknown;
  readonly repositories?: ReadonlyArray<Repository>;
  readonly single_file?: string | null;
  readonly repository_selection?: 'all' | 'selected';
};

export type EnterpriseAdminCreateRegistrationTokenForEnterprise201ResponseBody = AuthenticationToken;

export type EnterpriseAdminCreateRegistrationTokenForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminCreateRemoveTokenForEnterprise201ResponseBody = AuthenticationToken;

export type EnterpriseAdminCreateRemoveTokenForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminGetSelfHostedRunnerForEnterprise200ResponseBody = SelfHostedRunners;

export type EnterpriseAdminGetSelfHostedRunnerForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
};

export type EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
};

export type EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise404ResponseBody = BasicError;

export type EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
};

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise404ResponseBody = BasicError;

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise422ResponseBody = ValidationErrorSimple;

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequestBody = {
  readonly labels: ReadonlyArray<string>;
};

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
};

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise404ResponseBody = BasicError;

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise422ResponseBody = ValidationErrorSimple;

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequestBody = {
  readonly labels: ReadonlyArray<string>;
};

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
};

export type EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise404ResponseBody = BasicError;

export type EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise422ResponseBody = ValidationErrorSimple;

export type EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
};

export type EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise404ResponseBody = BasicError;

export type EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise422ResponseBody = ValidationErrorSimple;

export type EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
  readonly name: string;
};

export type AlertNumber = number;

export type AlertCreatedAt = string;

export type AlertUpdatedAt = string;

export type AlertUrl = string;

export type AlertHtmlUrl = string;

export type AlertInstancesUrl = string;

export type CodeScanningAlertState = 'open' | 'closed' | 'dismissed' | 'fixed';

export type AlertFixedAt = string | null;

export type AlertDismissedAt = string | null;

export type CodeScanningAlertDismissedReason =
  | null
  | 'false positive'
  | "won't fix"
  | 'used in tests'
  | null;

export type CodeScanningAlertDismissedComment = string | null;

export type CodeScanningAlertRule = {
  readonly id?: string | null;
  readonly name?: string;
  readonly severity?: 'none' | 'note' | 'warning' | 'error' | null;
  readonly security_severity_level?:
    | 'low'
    | 'medium'
    | 'high'
    | 'critical'
    | null;
  readonly description?: string;
  readonly full_description?: string;
  readonly tags?: ReadonlyArray<string> | null;
  readonly help?: string | null;
  readonly help_uri?: string | null;
};

export type CodeScanningAnalysisToolName = string;

export type CodeScanningAnalysisToolVersion = string | null;

export type CodeScanningAnalysisToolGuid = string | null;

export type CodeScanningAnalysisTool = {
  readonly name?: CodeScanningAnalysisToolName;
  readonly version?: CodeScanningAnalysisToolVersion;
  readonly guid?: CodeScanningAnalysisToolGuid;
};

export type CodeScanningRef = string;

export type CodeScanningAnalysisAnalysisKey = string;

export type CodeScanningAlertEnvironment = string;

export type CodeScanningAnalysisCategory = string;

export type CodeScanningAlertLocation = {
  readonly path?: string;
  readonly start_line?: number;
  readonly end_line?: number;
  readonly start_column?: number;
  readonly end_column?: number;
};

export type CodeScanningAlertClassification =
  | 'source'
  | 'generated'
  | 'test'
  | 'library'
  | null;

export type CodeScanningAlertInstance = {
  readonly ref?: CodeScanningRef;
  readonly analysis_key?: CodeScanningAnalysisAnalysisKey;
  readonly environment?: CodeScanningAlertEnvironment;
  readonly category?: CodeScanningAnalysisCategory;
  readonly state?: CodeScanningAlertState;
  readonly commit_sha?: string;
  readonly message?: { readonly text?: string };
  readonly location?: CodeScanningAlertLocation;
  readonly html_url?: string;
  readonly classifications?: ReadonlyArray<CodeScanningAlertClassification>;
};

export type SimpleRepository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly hooks_url: string;
};

export type CodeScanningOrganizationAlertItems = {
  readonly number: AlertNumber;
  readonly created_at: AlertCreatedAt;
  readonly updated_at?: AlertUpdatedAt;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly instances_url: AlertInstancesUrl;
  readonly state: CodeScanningAlertState;
  readonly fixed_at?: AlertFixedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_reason: CodeScanningAlertDismissedReason;
  readonly dismissed_comment?: CodeScanningAlertDismissedComment;
  readonly rule: CodeScanningAlertRule;
  readonly tool: CodeScanningAnalysisTool;
  readonly most_recent_instance: CodeScanningAlertInstance;
  readonly repository: SimpleRepository;
};

export type CodeScanningListAlertsForEnterprise200ResponseBody = ReadonlyArray<CodeScanningOrganizationAlertItems>;

export type CodeScanningListAlertsForEnterprise404ResponseBody = BasicError;

export type CodeScanningListAlertsForEnterprise503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningListAlertsForEnterpriseRequestQuery = {
  readonly tool_name?: CodeScanningAnalysisToolName;
  readonly tool_guid?: CodeScanningAnalysisToolGuid;
  readonly before?: string;
  readonly after?: string;
  readonly page?: number;
  readonly per_page?: number;
  readonly direction?: 'asc' | 'desc';
  readonly state?: CodeScanningAlertState;
  readonly sort?: 'created' | 'updated';
};

export type CodeScanningListAlertsForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type NullableAlertUpdatedAt = string | null;

export type SecretScanningAlertState = 'open' | 'resolved';

export type SecretScanningAlertResolution =
  | null
  | 'false_positive'
  | 'wont_fix'
  | 'revoked'
  | 'used_in_tests'
  | null;

export type OrganizationSecretScanningAlert = {
  readonly number?: AlertNumber;
  readonly created_at?: AlertCreatedAt;
  readonly updated_at?: NullableAlertUpdatedAt;
  readonly url?: AlertUrl;
  readonly html_url?: AlertHtmlUrl;
  readonly locations_url?: string;
  readonly state?: SecretScanningAlertState;
  readonly resolution?: SecretScanningAlertResolution;
  readonly resolved_at?: string | null;
  readonly resolved_by?: SimpleUser;
  readonly secret_type?: string;
  readonly secret_type_display_name?: string;
  readonly secret?: string;
  readonly repository?: SimpleRepository;
  readonly push_protection_bypassed?: boolean | null;
  readonly push_protection_bypassed_by?: SimpleUser;
  readonly push_protection_bypassed_at?: string | null;
  readonly resolution_comment?: string | null;
};

export type SecretScanningListAlertsForEnterprise200ResponseBody = ReadonlyArray<OrganizationSecretScanningAlert>;

export type SecretScanningListAlertsForEnterprise404ResponseBody = BasicError;

export type SecretScanningListAlertsForEnterprise503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SecretScanningListAlertsForEnterpriseRequestQuery = {
  readonly state?: 'open' | 'resolved';
  readonly secret_type?: string;
  readonly resolution?: string;
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly before?: string;
  readonly after?: string;
};

export type SecretScanningListAlertsForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type AdvancedSecurityActiveCommittersUser = {
  readonly user_login: string;
  readonly last_pushed_date: string;
};

export type AdvancedSecurityActiveCommittersRepository = {
  readonly name: string;
  readonly advanced_security_committers: number;
  readonly advanced_security_committers_breakdown: ReadonlyArray<AdvancedSecurityActiveCommittersUser>;
};

export type AdvancedSecurityActiveCommitters = {
  readonly total_advanced_security_committers?: number;
  readonly total_count?: number;
  readonly repositories: ReadonlyArray<AdvancedSecurityActiveCommittersRepository>;
};

export type BillingGetGithubAdvancedSecurityBillingGhe200ResponseBody = AdvancedSecurityActiveCommitters;

export type BillingGetGithubAdvancedSecurityBillingGhe403ResponseBody = BasicError;

export type BillingGetGithubAdvancedSecurityBillingGheRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type BillingGetGithubAdvancedSecurityBillingGheRequestPath = {
  readonly enterprise: string;
};

export type Actor = {
  readonly id: number;
  readonly login: string;
  readonly display_login?: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly avatar_url: string;
};

export type Milestone = {
  readonly url: string;
  readonly html_url: string;
  readonly labels_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly number: number;
  readonly state: 'open' | 'closed';
  readonly title: string;
  readonly description: string | null;
  readonly creator: SimpleUser;
  readonly open_issues: number;
  readonly closed_issues: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly closed_at: string | null;
  readonly due_on: string | null;
} | null;

export type AuthorAssociation =
  | 'COLLABORATOR'
  | 'CONTRIBUTOR'
  | 'FIRST_TIMER'
  | 'FIRST_TIME_CONTRIBUTOR'
  | 'MANNEQUIN'
  | 'MEMBER'
  | 'NONE'
  | 'OWNER';

export type ReactionRollup = {
  readonly url: string;
  readonly total_count: number;
  readonly '+1': number;
  readonly '-1': number;
  readonly laugh: number;
  readonly confused: number;
  readonly heart: number;
  readonly hooray: number;
  readonly eyes: number;
  readonly rocket: number;
};

export type Issue = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly repository_url: string;
  readonly labels_url: string;
  readonly comments_url: string;
  readonly events_url: string;
  readonly html_url: string;
  readonly number: number;
  readonly state: string;
  readonly state_reason?: 'completed' | 'reopened' | 'not_planned' | null;
  readonly title: string;
  readonly body?: string | null;
  readonly user: SimpleUser;
  readonly labels: ReadonlyArray<
    | string
    | {
        readonly id?: number;
        readonly node_id?: string;
        readonly url?: string;
        readonly name?: string;
        readonly description?: string | null;
        readonly color?: string | null;
        readonly default?: boolean;
      }
  >;
  readonly assignee: SimpleUser;
  readonly assignees?: ReadonlyArray<SimpleUser> | null;
  readonly milestone: Milestone;
  readonly locked: boolean;
  readonly active_lock_reason?: string | null;
  readonly comments: number;
  readonly pull_request?: {
    readonly merged_at?: string | null;
    readonly diff_url: string | null;
    readonly html_url: string | null;
    readonly patch_url: string | null;
    readonly url: string | null;
  };
  readonly closed_at: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly draft?: boolean;
  readonly closed_by?: SimpleUser;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly timeline_url?: string;
  readonly repository?: Repository;
  readonly performed_via_github_app?: GitHubApp;
  readonly author_association: AuthorAssociation;
  readonly reactions?: ReactionRollup;
};

export type IssueComment = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly body?: string;
  readonly body_text?: string;
  readonly body_html?: string;
  readonly html_url: string;
  readonly user: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly issue_url: string;
  readonly author_association: AuthorAssociation;
  readonly performed_via_github_app?: GitHubApp;
  readonly reactions?: ReactionRollup;
};

export type Event = {
  readonly id: string;
  readonly type: string | null;
  readonly actor: Actor;
  readonly repo: {
    readonly id: number;
    readonly name: string;
    readonly url: string;
  };
  readonly org?: Actor;
  readonly payload: {
    readonly action?: string;
    readonly issue?: Issue;
    readonly comment?: IssueComment;
    readonly pages?: ReadonlyArray<{
      readonly page_name?: string;
      readonly title?: string;
      readonly summary?: string | null;
      readonly action?: string;
      readonly sha?: string;
      readonly html_url?: string;
    }>;
  };
  readonly public: boolean;
  readonly created_at: string | null;
};

export type ActivityListPublicEvents200ResponseBody = ReadonlyArray<Event>;

export type ActivityListPublicEvents403ResponseBody = BasicError;

export type ActivityListPublicEvents503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type ActivityListPublicEventsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type LinkWithType = { readonly href: string; readonly type: string };

export type Feed = {
  readonly timeline_url: string;
  readonly user_url: string;
  readonly current_user_public_url?: string;
  readonly current_user_url?: string;
  readonly current_user_actor_url?: string;
  readonly current_user_organization_url?: string;
  readonly current_user_organization_urls?: ReadonlyArray<string>;
  readonly security_advisories_url?: string;
  readonly _links: {
    readonly timeline: LinkWithType;
    readonly user: LinkWithType;
    readonly security_advisories?: LinkWithType;
    readonly current_user?: LinkWithType;
    readonly current_user_public?: LinkWithType;
    readonly current_user_actor?: LinkWithType;
    readonly current_user_organization?: LinkWithType;
    readonly current_user_organizations?: ReadonlyArray<LinkWithType>;
  };
};

export type ActivityGetFeeds200ResponseBody = Feed;

export type BaseGist = {
  readonly url: string;
  readonly forks_url: string;
  readonly commits_url: string;
  readonly id: string;
  readonly node_id: string;
  readonly git_pull_url: string;
  readonly git_push_url: string;
  readonly html_url: string;
  readonly files: unknown;
  readonly public: boolean;
  readonly created_at: string;
  readonly updated_at: string;
  readonly description: string | null;
  readonly comments: number;
  readonly user: SimpleUser;
  readonly comments_url: string;
  readonly owner?: SimpleUser;
  readonly truncated?: boolean;
  readonly forks?: ReadonlyArray<unknown>;
  readonly history?: ReadonlyArray<unknown>;
};

export type GistsList200ResponseBody = ReadonlyArray<BaseGist>;

export type GistsList403ResponseBody = BasicError;

export type GistsListRequestQuery = {
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type PublicUser = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly site_admin: boolean;
  readonly name: string | null;
  readonly company: string | null;
  readonly blog: string | null;
  readonly location: string | null;
  readonly email: string | null;
  readonly hireable: boolean | null;
  readonly bio: string | null;
  readonly twitter_username?: string | null;
  readonly public_repos: number;
  readonly public_gists: number;
  readonly followers: number;
  readonly following: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly plan?: {
    readonly collaborators: number;
    readonly name: string;
    readonly space: number;
    readonly private_repos: number;
  };
  readonly suspended_at?: string | null;
  readonly private_gists?: number;
  readonly total_private_repos?: number;
  readonly owned_private_repos?: number;
  readonly disk_usage?: number;
  readonly collaborators?: number;
};

export type GistHistory = {
  readonly user?: SimpleUser;
  readonly version?: string;
  readonly committed_at?: string;
  readonly change_status?: {
    readonly total?: number;
    readonly additions?: number;
    readonly deletions?: number;
  };
  readonly url?: string;
};

export type Gist = {
  readonly url: string;
  readonly forks_url: string;
  readonly commits_url: string;
  readonly id: string;
  readonly node_id: string;
  readonly git_pull_url: string;
  readonly git_push_url: string;
  readonly html_url: string;
  readonly files: unknown;
  readonly public: boolean;
  readonly created_at: string;
  readonly updated_at: string;
  readonly description: string | null;
  readonly comments: number;
  readonly user: SimpleUser;
  readonly comments_url: string;
  readonly owner?: SimpleUser;
  readonly truncated?: boolean;
  readonly forks?: ReadonlyArray<unknown>;
  readonly history?: ReadonlyArray<unknown>;
} | null;

export type GistSimple = {
  readonly forks?: ReadonlyArray<{
    readonly id?: string;
    readonly url?: string;
    readonly user?: PublicUser;
    readonly created_at?: string;
    readonly updated_at?: string;
  }> | null;
  readonly history?: ReadonlyArray<GistHistory> | null;
  readonly fork_of?: Gist;
  readonly url?: string;
  readonly forks_url?: string;
  readonly commits_url?: string;
  readonly id?: string;
  readonly node_id?: string;
  readonly git_pull_url?: string;
  readonly git_push_url?: string;
  readonly html_url?: string;
  readonly files?: unknown;
  readonly public?: boolean;
  readonly created_at?: string;
  readonly updated_at?: string;
  readonly description?: string | null;
  readonly comments?: number;
  readonly user?: string | null;
  readonly comments_url?: string;
  readonly owner?: SimpleUser;
  readonly truncated?: boolean;
};

export type GistsCreate201ResponseBody = GistSimple;

export type GistsCreate403ResponseBody = BasicError;

export type GistsCreate404ResponseBody = BasicError;

export type GistsCreate422ResponseBody = ValidationError;

export type GistsCreateRequestBody = {
  readonly description?: string;
  readonly files: unknown;
  readonly public?: boolean | 'true' | 'false';
};

export type GistsListPublic200ResponseBody = ReadonlyArray<BaseGist>;

export type GistsListPublic403ResponseBody = BasicError;

export type GistsListPublic422ResponseBody = ValidationError;

export type GistsListPublicRequestQuery = {
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type GistsListStarred200ResponseBody = ReadonlyArray<BaseGist>;

export type GistsListStarred401ResponseBody = BasicError;

export type GistsListStarred403ResponseBody = BasicError;

export type GistsListStarredRequestQuery = {
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type GistsGet200ResponseBody = GistSimple;

export type GistsGet403ResponseBody = {
  readonly block?: {
    readonly reason?: string;
    readonly created_at?: string;
    readonly html_url?: string | null;
  };
  readonly message?: string;
  readonly documentation_url?: string;
};

export type GistsGet404ResponseBody = BasicError;

export type GistsGetRequestPath = { readonly gist_id: string };

export type GistsUpdate200ResponseBody = GistSimple;

export type GistsUpdate404ResponseBody = BasicError;

export type GistsUpdate422ResponseBody = ValidationError;

export type GistsUpdateRequestBody =
  | ({ readonly description?: string; readonly files?: unknown } & unknown)
  | null;

export type GistsUpdateRequestPath = { readonly gist_id: string };

export type GistsDelete403ResponseBody = BasicError;

export type GistsDelete404ResponseBody = BasicError;

export type GistsDeleteRequestPath = { readonly gist_id: string };

export type GistComment = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly body: string;
  readonly user: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly author_association: AuthorAssociation;
};

export type GistsListComments200ResponseBody = ReadonlyArray<GistComment>;

export type GistsListComments403ResponseBody = BasicError;

export type GistsListComments404ResponseBody = BasicError;

export type GistsListCommentsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type GistsListCommentsRequestPath = { readonly gist_id: string };

export type GistsCreateComment201ResponseBody = GistComment;

export type GistsCreateComment403ResponseBody = BasicError;

export type GistsCreateComment404ResponseBody = BasicError;

export type GistsCreateCommentRequestBody = { readonly body: string };

export type GistsCreateCommentRequestPath = { readonly gist_id: string };

export type GistsGetComment200ResponseBody = GistComment;

export type GistsGetComment403ResponseBody = {
  readonly block?: {
    readonly reason?: string;
    readonly created_at?: string;
    readonly html_url?: string | null;
  };
  readonly message?: string;
  readonly documentation_url?: string;
};

export type GistsGetComment404ResponseBody = BasicError;

export type GistsGetCommentRequestPath = {
  readonly gist_id: string;
  readonly comment_id: number;
};

export type GistsUpdateComment200ResponseBody = GistComment;

export type GistsUpdateComment404ResponseBody = BasicError;

export type GistsUpdateCommentRequestBody = { readonly body: string };

export type GistsUpdateCommentRequestPath = {
  readonly gist_id: string;
  readonly comment_id: number;
};

export type GistsDeleteComment403ResponseBody = BasicError;

export type GistsDeleteComment404ResponseBody = BasicError;

export type GistsDeleteCommentRequestPath = {
  readonly gist_id: string;
  readonly comment_id: number;
};

export type GistCommit = {
  readonly url: string;
  readonly version: string;
  readonly user: SimpleUser;
  readonly change_status: {
    readonly total?: number;
    readonly additions?: number;
    readonly deletions?: number;
  };
  readonly committed_at: string;
};

export type GistsListCommits200ResponseBody = ReadonlyArray<GistCommit>;

export type GistsListCommits403ResponseBody = BasicError;

export type GistsListCommits404ResponseBody = BasicError;

export type GistsListCommitsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type GistsListCommitsRequestPath = { readonly gist_id: string };

export type GistsListForks200ResponseBody = ReadonlyArray<GistSimple>;

export type GistsListForks403ResponseBody = BasicError;

export type GistsListForks404ResponseBody = BasicError;

export type GistsListForksRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type GistsListForksRequestPath = { readonly gist_id: string };

export type GistsFork201ResponseBody = BaseGist;

export type GistsFork403ResponseBody = BasicError;

export type GistsFork404ResponseBody = BasicError;

export type GistsFork422ResponseBody = ValidationError;

export type GistsForkRequestPath = { readonly gist_id: string };

export type GistsCheckIsStarred403ResponseBody = BasicError;

export type GistsCheckIsStarred404ResponseBody = {};

export type GistsCheckIsStarredRequestPath = { readonly gist_id: string };

export type GistsStar403ResponseBody = BasicError;

export type GistsStar404ResponseBody = BasicError;

export type GistsStarRequestPath = { readonly gist_id: string };

export type GistsUnstar403ResponseBody = BasicError;

export type GistsUnstar404ResponseBody = BasicError;

export type GistsUnstarRequestPath = { readonly gist_id: string };

export type GistsGetRevision200ResponseBody = GistSimple;

export type GistsGetRevision403ResponseBody = BasicError;

export type GistsGetRevision404ResponseBody = BasicError;

export type GistsGetRevision422ResponseBody = ValidationError;

export type GistsGetRevisionRequestPath = {
  readonly gist_id: string;
  readonly sha: string;
};

export type GitignoreGetAllTemplates200ResponseBody = ReadonlyArray<string>;

export type GitignoreTemplate = {
  readonly name: string;
  readonly source: string;
};

export type GitignoreGetTemplate200ResponseBody = GitignoreTemplate;

export type GitignoreGetTemplateRequestPath = { readonly name: string };

export type AppsListReposAccessibleToInstallation200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<Repository>;
  readonly repository_selection?: string;
};

export type AppsListReposAccessibleToInstallation401ResponseBody = BasicError;

export type AppsListReposAccessibleToInstallation403ResponseBody = BasicError;

export type AppsListReposAccessibleToInstallationRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesList200ResponseBody = ReadonlyArray<Issue>;

export type IssuesList404ResponseBody = BasicError;

export type IssuesList422ResponseBody = ValidationError;

export type IssuesListRequestQuery = {
  readonly filter?:
    | 'assigned'
    | 'created'
    | 'mentioned'
    | 'subscribed'
    | 'repos'
    | 'all';
  readonly state?: 'open' | 'closed' | 'all';
  readonly labels?: string;
  readonly sort?: 'created' | 'updated' | 'comments';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly collab?: boolean;
  readonly orgs?: boolean;
  readonly owned?: boolean;
  readonly pulls?: boolean;
  readonly per_page?: number;
  readonly page?: number;
};

export type LicensesGetAllCommonlyUsed200ResponseBody = ReadonlyArray<LicenseSimple>;

export type LicensesGetAllCommonlyUsedRequestQuery = {
  readonly featured?: boolean;
  readonly per_page?: number;
  readonly page?: number;
};

export type License = {
  readonly key: string;
  readonly name: string;
  readonly spdx_id: string | null;
  readonly url: string | null;
  readonly node_id: string;
  readonly html_url: string;
  readonly description: string;
  readonly implementation: string;
  readonly permissions: ReadonlyArray<string>;
  readonly conditions: ReadonlyArray<string>;
  readonly limitations: ReadonlyArray<string>;
  readonly body: string;
  readonly featured: boolean;
};

export type LicensesGet200ResponseBody = License;

export type LicensesGet403ResponseBody = BasicError;

export type LicensesGet404ResponseBody = BasicError;

export type LicensesGetRequestPath = { readonly license: string };

export type MarkdownRenderRequestBody = {
  readonly text: string;
  readonly mode?: 'markdown' | 'gfm';
  readonly context?: string;
};

export type MarketplaceListingPlan = {
  readonly url: string;
  readonly accounts_url: string;
  readonly id: number;
  readonly number: number;
  readonly name: string;
  readonly description: string;
  readonly monthly_price_in_cents: number;
  readonly yearly_price_in_cents: number;
  readonly price_model: string;
  readonly has_free_trial: boolean;
  readonly unit_name: string | null;
  readonly state: string;
  readonly bullets: ReadonlyArray<string>;
};

export type MarketplacePurchase = {
  readonly url: string;
  readonly type: string;
  readonly id: number;
  readonly login: string;
  readonly organization_billing_email?: string;
  readonly email?: string | null;
  readonly marketplace_pending_change?: {
    readonly is_installed?: boolean;
    readonly effective_date?: string;
    readonly unit_count?: number | null;
    readonly id?: number;
    readonly plan?: MarketplaceListingPlan;
  } | null;
  readonly marketplace_purchase: {
    readonly billing_cycle?: string;
    readonly next_billing_date?: string | null;
    readonly is_installed?: boolean;
    readonly unit_count?: number | null;
    readonly on_free_trial?: boolean;
    readonly free_trial_ends_on?: string | null;
    readonly updated_at?: string;
    readonly plan?: MarketplaceListingPlan;
  };
};

export type AppsGetSubscriptionPlanForAccount200ResponseBody = MarketplacePurchase;

export type AppsGetSubscriptionPlanForAccount401ResponseBody = BasicError;

export type AppsGetSubscriptionPlanForAccount404ResponseBody = BasicError;

export type AppsGetSubscriptionPlanForAccountRequestPath = {
  readonly account_id: number;
};

export type AppsListPlans200ResponseBody = ReadonlyArray<MarketplaceListingPlan>;

export type AppsListPlans401ResponseBody = BasicError;

export type AppsListPlans404ResponseBody = BasicError;

export type AppsListPlansRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListAccountsForPlan200ResponseBody = ReadonlyArray<MarketplacePurchase>;

export type AppsListAccountsForPlan401ResponseBody = BasicError;

export type AppsListAccountsForPlan404ResponseBody = BasicError;

export type AppsListAccountsForPlan422ResponseBody = ValidationError;

export type AppsListAccountsForPlanRequestQuery = {
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListAccountsForPlanRequestPath = { readonly plan_id: number };

export type AppsGetSubscriptionPlanForAccountStubbed200ResponseBody = MarketplacePurchase;

export type AppsGetSubscriptionPlanForAccountStubbed401ResponseBody = BasicError;

export type AppsGetSubscriptionPlanForAccountStubbedRequestPath = {
  readonly account_id: number;
};

export type AppsListPlansStubbed200ResponseBody = ReadonlyArray<MarketplaceListingPlan>;

export type AppsListPlansStubbed401ResponseBody = BasicError;

export type AppsListPlansStubbedRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListAccountsForPlanStubbed200ResponseBody = ReadonlyArray<MarketplacePurchase>;

export type AppsListAccountsForPlanStubbed401ResponseBody = BasicError;

export type AppsListAccountsForPlanStubbedRequestQuery = {
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListAccountsForPlanStubbedRequestPath = {
  readonly plan_id: number;
};

export type ApiOverview = {
  readonly verifiable_password_authentication: boolean;
  readonly ssh_key_fingerprints?: {
    readonly SHA256_RSA?: string;
    readonly SHA256_DSA?: string;
    readonly SHA256_ECDSA?: string;
    readonly SHA256_ED25519?: string;
  };
  readonly ssh_keys?: ReadonlyArray<string>;
  readonly hooks?: ReadonlyArray<string>;
  readonly web?: ReadonlyArray<string>;
  readonly api?: ReadonlyArray<string>;
  readonly git?: ReadonlyArray<string>;
  readonly packages?: ReadonlyArray<string>;
  readonly pages?: ReadonlyArray<string>;
  readonly importer?: ReadonlyArray<string>;
  readonly actions?: ReadonlyArray<string>;
  readonly dependabot?: ReadonlyArray<string>;
};

export type MetaGet200ResponseBody = ApiOverview;

export type ActivityListPublicEventsForRepoNetwork200ResponseBody = ReadonlyArray<Event>;

export type ActivityListPublicEventsForRepoNetwork301ResponseBody = BasicError;

export type ActivityListPublicEventsForRepoNetwork403ResponseBody = BasicError;

export type ActivityListPublicEventsForRepoNetwork404ResponseBody = BasicError;

export type ActivityListPublicEventsForRepoNetworkRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListPublicEventsForRepoNetworkRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MinimalRepository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly git_url?: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly ssh_url?: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly clone_url?: string;
  readonly mirror_url?: string | null;
  readonly hooks_url: string;
  readonly svn_url?: string;
  readonly homepage?: string | null;
  readonly language?: string | null;
  readonly forks_count?: number;
  readonly stargazers_count?: number;
  readonly watchers_count?: number;
  readonly size?: number;
  readonly default_branch?: string;
  readonly open_issues_count?: number;
  readonly is_template?: boolean;
  readonly topics?: ReadonlyArray<string>;
  readonly has_issues?: boolean;
  readonly has_projects?: boolean;
  readonly has_wiki?: boolean;
  readonly has_pages?: boolean;
  readonly has_downloads?: boolean;
  readonly archived?: boolean;
  readonly disabled?: boolean;
  readonly visibility?: string;
  readonly pushed_at?: string | null;
  readonly created_at?: string | null;
  readonly updated_at?: string | null;
  readonly permissions?: {
    readonly admin?: boolean;
    readonly maintain?: boolean;
    readonly push?: boolean;
    readonly triage?: boolean;
    readonly pull?: boolean;
  };
  readonly role_name?: string;
  readonly temp_clone_token?: string;
  readonly delete_branch_on_merge?: boolean;
  readonly subscribers_count?: number;
  readonly network_count?: number;
  readonly code_of_conduct?: CodeOfConduct;
  readonly license?: {
    readonly key?: string;
    readonly name?: string;
    readonly spdx_id?: string;
    readonly url?: string;
    readonly node_id?: string;
  } | null;
  readonly forks?: number;
  readonly open_issues?: number;
  readonly watchers?: number;
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
};

export type Thread = {
  readonly id: string;
  readonly repository: MinimalRepository;
  readonly subject: {
    readonly title: string;
    readonly url: string;
    readonly latest_comment_url: string;
    readonly type: string;
  };
  readonly reason: string;
  readonly unread: boolean;
  readonly updated_at: string;
  readonly last_read_at: string | null;
  readonly url: string;
  readonly subscription_url: string;
};

export type ActivityListNotificationsForAuthenticatedUser200ResponseBody = ReadonlyArray<Thread>;

export type ActivityListNotificationsForAuthenticatedUser401ResponseBody = BasicError;

export type ActivityListNotificationsForAuthenticatedUser403ResponseBody = BasicError;

export type ActivityListNotificationsForAuthenticatedUser422ResponseBody = ValidationError;

export type ActivityListNotificationsForAuthenticatedUserRequestQuery = {
  readonly all?: boolean;
  readonly participating?: boolean;
  readonly since?: string;
  readonly before?: string;
  readonly page?: number;
  readonly per_page?: number;
};

export type ActivityMarkNotificationsAsRead202ResponseBody = {
  readonly message?: string;
};

export type ActivityMarkNotificationsAsRead401ResponseBody = BasicError;

export type ActivityMarkNotificationsAsRead403ResponseBody = BasicError;

export type ActivityMarkNotificationsAsReadRequestBody = {
  readonly last_read_at?: string;
  readonly read?: boolean;
};

export type ActivityGetThread200ResponseBody = Thread;

export type ActivityGetThread401ResponseBody = BasicError;

export type ActivityGetThread403ResponseBody = BasicError;

export type ActivityGetThreadRequestPath = { readonly thread_id: number };

export type ActivityMarkThreadAsRead403ResponseBody = BasicError;

export type ActivityMarkThreadAsReadRequestPath = {
  readonly thread_id: number;
};

export type ThreadSubscription = {
  readonly subscribed: boolean;
  readonly ignored: boolean;
  readonly reason: string | null;
  readonly created_at: string | null;
  readonly url: string;
  readonly thread_url?: string;
  readonly repository_url?: string;
};

export type ActivityGetThreadSubscriptionForAuthenticatedUser200ResponseBody = ThreadSubscription;

export type ActivityGetThreadSubscriptionForAuthenticatedUser401ResponseBody = BasicError;

export type ActivityGetThreadSubscriptionForAuthenticatedUser403ResponseBody = BasicError;

export type ActivityGetThreadSubscriptionForAuthenticatedUserRequestPath = {
  readonly thread_id: number;
};

export type ActivitySetThreadSubscription200ResponseBody = ThreadSubscription;

export type ActivitySetThreadSubscription401ResponseBody = BasicError;

export type ActivitySetThreadSubscription403ResponseBody = BasicError;

export type ActivitySetThreadSubscriptionRequestBody = {
  readonly ignored?: boolean;
};

export type ActivitySetThreadSubscriptionRequestPath = {
  readonly thread_id: number;
};

export type ActivityDeleteThreadSubscription401ResponseBody = BasicError;

export type ActivityDeleteThreadSubscription403ResponseBody = BasicError;

export type ActivityDeleteThreadSubscriptionRequestPath = {
  readonly thread_id: number;
};

export type MetaGetOctocatRequestQuery = { readonly s?: string };

export type OrgsList200ResponseBody = ReadonlyArray<OrganizationSimple>;

export type OrgsListRequestQuery = {
  readonly since?: number;
  readonly per_page?: number;
};

export type OrganizationCustomRepositoryRole = {
  readonly id: number;
  readonly name: string;
  readonly description?: string | null;
  readonly base_role?: 'read' | 'triage' | 'write' | 'maintain';
  readonly permissions?: ReadonlyArray<string>;
  readonly organization?: SimpleUser;
  readonly created_at?: string;
  readonly updated_at?: string;
};

export type OrgsListCustomRoles200ResponseBody = {
  readonly total_count?: number;
  readonly custom_roles?: ReadonlyArray<OrganizationCustomRepositoryRole>;
};

export type OrgsListCustomRolesRequestPath = {
  readonly organization_id: string;
};

export type OrganizationFull = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly hooks_url: string;
  readonly issues_url: string;
  readonly members_url: string;
  readonly public_members_url: string;
  readonly avatar_url: string;
  readonly description: string | null;
  readonly name?: string;
  readonly company?: string;
  readonly blog?: string;
  readonly location?: string;
  readonly email?: string;
  readonly twitter_username?: string | null;
  readonly is_verified?: boolean;
  readonly has_organization_projects: boolean;
  readonly has_repository_projects: boolean;
  readonly public_repos: number;
  readonly public_gists: number;
  readonly followers: number;
  readonly following: number;
  readonly html_url: string;
  readonly created_at: string;
  readonly type: string;
  readonly total_private_repos?: number;
  readonly owned_private_repos?: number;
  readonly private_gists?: number | null;
  readonly disk_usage?: number | null;
  readonly collaborators?: number | null;
  readonly billing_email?: string | null;
  readonly plan?: {
    readonly name: string;
    readonly space: number;
    readonly private_repos: number;
    readonly filled_seats?: number;
    readonly seats?: number;
  };
  readonly default_repository_permission?: string | null;
  readonly members_can_create_repositories?: boolean | null;
  readonly two_factor_requirement_enabled?: boolean | null;
  readonly members_allowed_repository_creation_type?: string;
  readonly members_can_create_public_repositories?: boolean;
  readonly members_can_create_private_repositories?: boolean;
  readonly members_can_create_internal_repositories?: boolean;
  readonly members_can_create_pages?: boolean;
  readonly members_can_create_public_pages?: boolean;
  readonly members_can_create_private_pages?: boolean;
  readonly members_can_fork_private_repositories?: boolean | null;
  readonly web_commit_signoff_required?: boolean;
  readonly updated_at: string;
  readonly advanced_security_enabled_for_new_repositories?: boolean;
  readonly dependabot_alerts_enabled_for_new_repositories?: boolean;
  readonly dependabot_security_updates_enabled_for_new_repositories?: boolean;
  readonly dependency_graph_enabled_for_new_repositories?: boolean;
  readonly secret_scanning_enabled_for_new_repositories?: boolean;
  readonly secret_scanning_push_protection_enabled_for_new_repositories?: boolean;
};

export type OrgsGet200ResponseBody = OrganizationFull;

export type OrgsGet404ResponseBody = BasicError;

export type OrgsGetRequestPath = { readonly org: string };

export type OrgsUpdate200ResponseBody = OrganizationFull;

export type OrgsUpdate409ResponseBody = BasicError;

export type OrgsUpdate422ResponseBody = ValidationError | ValidationErrorSimple;

export type OrgsUpdateRequestBody = {
  readonly billing_email?: string;
  readonly company?: string;
  readonly email?: string;
  readonly twitter_username?: string;
  readonly location?: string;
  readonly name?: string;
  readonly description?: string;
  readonly has_organization_projects?: boolean;
  readonly has_repository_projects?: boolean;
  readonly default_repository_permission?: 'read' | 'write' | 'admin' | 'none';
  readonly members_can_create_repositories?: boolean;
  readonly members_can_create_internal_repositories?: boolean;
  readonly members_can_create_private_repositories?: boolean;
  readonly members_can_create_public_repositories?: boolean;
  readonly members_allowed_repository_creation_type?:
    | 'all'
    | 'private'
    | 'none';
  readonly members_can_create_pages?: boolean;
  readonly members_can_create_public_pages?: boolean;
  readonly members_can_create_private_pages?: boolean;
  readonly members_can_fork_private_repositories?: boolean;
  readonly web_commit_signoff_required?: boolean;
  readonly blog?: string;
  readonly advanced_security_enabled_for_new_repositories?: boolean;
  readonly dependabot_alerts_enabled_for_new_repositories?: boolean;
  readonly dependabot_security_updates_enabled_for_new_repositories?: boolean;
  readonly dependency_graph_enabled_for_new_repositories?: boolean;
  readonly secret_scanning_enabled_for_new_repositories?: boolean;
  readonly secret_scanning_push_protection_enabled_for_new_repositories?: boolean;
};

export type OrgsUpdateRequestPath = { readonly org: string };

export type ActionsGetActionsCacheUsageForOrg200ResponseBody = ActionsCacheUsageOrgEnterprise;

export type ActionsGetActionsCacheUsageForOrgRequestPath = {
  readonly org: string;
};

export type ActionsCacheUsageByRepository = {
  readonly full_name: string;
  readonly active_caches_size_in_bytes: number;
  readonly active_caches_count: number;
};

export type ActionsGetActionsCacheUsageByRepoForOrg200ResponseBody = {
  readonly total_count: number;
  readonly repository_cache_usages: ReadonlyArray<ActionsCacheUsageByRepository>;
};

export type ActionsGetActionsCacheUsageByRepoForOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsGetActionsCacheUsageByRepoForOrgRequestPath = {
  readonly org: string;
};

export type EnabledRepositories = 'all' | 'none' | 'selected';

export type ActionsOrganizationPermissions = {
  readonly enabled_repositories: EnabledRepositories;
  readonly selected_repositories_url?: string;
  readonly allowed_actions?: AllowedActions;
  readonly selected_actions_url?: SelectedActionsUrl;
};

export type ActionsGetGithubActionsPermissionsOrganization200ResponseBody = ActionsOrganizationPermissions;

export type ActionsGetGithubActionsPermissionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsSetGithubActionsPermissionsOrganizationRequestBody = {
  readonly enabled_repositories: EnabledRepositories;
  readonly allowed_actions?: AllowedActions;
};

export type ActionsSetGithubActionsPermissionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<Repository>;
};

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestBody = {
  readonly selected_repository_ids: ReadonlyArray<number>;
};

export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsEnableSelectedRepositoryGithubActionsOrganizationRequestPath = {
  readonly org: string;
  readonly repository_id: number;
};

export type ActionsDisableSelectedRepositoryGithubActionsOrganizationRequestPath = {
  readonly org: string;
  readonly repository_id: number;
};

export type ActionsGetAllowedActionsOrganization200ResponseBody = SelectedActions;

export type ActionsGetAllowedActionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsSetAllowedActionsOrganizationRequestBody = SelectedActions;

export type ActionsSetAllowedActionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization200ResponseBody = ActionsGetDefaultWorkflowPermissions;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequestBody = ActionsSetDefaultWorkflowPermissions;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequestPath = {
  readonly org: string;
};

export type RunnerGroupsOrg = {
  readonly id: number;
  readonly name: string;
  readonly visibility: string;
  readonly default: boolean;
  readonly selected_repositories_url?: string;
  readonly runners_url: string;
  readonly inherited: boolean;
  readonly inherited_allows_public_repositories?: boolean;
  readonly allows_public_repositories: boolean;
  readonly workflow_restrictions_read_only?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type ActionsListSelfHostedRunnerGroupsForOrg200ResponseBody = {
  readonly total_count: number;
  readonly runner_groups: ReadonlyArray<RunnerGroupsOrg>;
};

export type ActionsListSelfHostedRunnerGroupsForOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly visible_to_repository?: string;
};

export type ActionsListSelfHostedRunnerGroupsForOrgRequestPath = {
  readonly org: string;
};

export type ActionsCreateSelfHostedRunnerGroupForOrg201ResponseBody = RunnerGroupsOrg;

export type ActionsCreateSelfHostedRunnerGroupForOrgRequestBody = {
  readonly name: string;
  readonly visibility?: 'selected' | 'all' | 'private';
  readonly selected_repository_ids?: ReadonlyArray<number>;
  readonly runners?: ReadonlyArray<number>;
  readonly allows_public_repositories?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type ActionsCreateSelfHostedRunnerGroupForOrgRequestPath = {
  readonly org: string;
};

export type ActionsGetSelfHostedRunnerGroupForOrg200ResponseBody = RunnerGroupsOrg;

export type ActionsGetSelfHostedRunnerGroupForOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsUpdateSelfHostedRunnerGroupForOrg200ResponseBody = RunnerGroupsOrg;

export type ActionsUpdateSelfHostedRunnerGroupForOrgRequestBody = {
  readonly name: string;
  readonly visibility?: 'selected' | 'all' | 'private';
  readonly allows_public_repositories?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type ActionsUpdateSelfHostedRunnerGroupForOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsDeleteSelfHostedRunnerGroupFromOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<MinimalRepository>;
};

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestBody = {
  readonly selected_repository_ids: ReadonlyArray<number>;
};

export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
  readonly repository_id: number;
};

export type ActionsListSelfHostedRunnersInGroupForOrg200ResponseBody = {
  readonly total_count: number;
  readonly runners: ReadonlyArray<SelfHostedRunners>;
};

export type ActionsListSelfHostedRunnersInGroupForOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListSelfHostedRunnersInGroupForOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsSetSelfHostedRunnersInGroupForOrgRequestBody = {
  readonly runners: ReadonlyArray<number>;
};

export type ActionsSetSelfHostedRunnersInGroupForOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsAddSelfHostedRunnerToGroupForOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
  readonly runner_id: number;
};

export type ActionsRemoveSelfHostedRunnerFromGroupForOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
  readonly runner_id: number;
};

export type ActionsListSelfHostedRunnersForOrg200ResponseBody = {
  readonly total_count: number;
  readonly runners: ReadonlyArray<SelfHostedRunners>;
};

export type ActionsListSelfHostedRunnersForOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListSelfHostedRunnersForOrgRequestPath = {
  readonly org: string;
};

export type ActionsListRunnerApplicationsForOrg200ResponseBody = ReadonlyArray<RunnerApplication>;

export type ActionsListRunnerApplicationsForOrgRequestPath = {
  readonly org: string;
};

export type ActionsCreateRegistrationTokenForOrg201ResponseBody = AuthenticationToken;

export type ActionsCreateRegistrationTokenForOrgRequestPath = {
  readonly org: string;
};

export type ActionsCreateRemoveTokenForOrg201ResponseBody = AuthenticationToken;

export type ActionsCreateRemoveTokenForOrgRequestPath = {
  readonly org: string;
};

export type ActionsGetSelfHostedRunnerForOrg200ResponseBody = SelfHostedRunners;

export type ActionsGetSelfHostedRunnerForOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
};

export type ActionsDeleteSelfHostedRunnerFromOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
};

export type ActionsListLabelsForSelfHostedRunnerForOrg200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsListLabelsForSelfHostedRunnerForOrg404ResponseBody = BasicError;

export type ActionsListLabelsForSelfHostedRunnerForOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
};

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrg200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrg404ResponseBody = BasicError;

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrg422ResponseBody = ValidationErrorSimple;

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestBody = {
  readonly labels: ReadonlyArray<string>;
};

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
};

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrg200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrg404ResponseBody = BasicError;

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrg422ResponseBody = ValidationErrorSimple;

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestBody = {
  readonly labels: ReadonlyArray<string>;
};

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
};

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg404ResponseBody = BasicError;

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
};

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg404ResponseBody = BasicError;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg422ResponseBody = ValidationErrorSimple;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
  readonly name: string;
};

export type ActionsSecretForAnOrganization = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repositories_url?: string;
};

export type ActionsListOrgSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<ActionsSecretForAnOrganization>;
};

export type ActionsListOrgSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListOrgSecretsRequestPath = { readonly org: string };

export type ActionsPublicKey = {
  readonly key_id: string;
  readonly key: string;
  readonly id?: number;
  readonly url?: string;
  readonly title?: string;
  readonly created_at?: string;
};

export type ActionsGetOrgPublicKey200ResponseBody = ActionsPublicKey;

export type ActionsGetOrgPublicKeyRequestPath = { readonly org: string };

export type ActionsGetOrgSecret200ResponseBody = ActionsSecretForAnOrganization;

export type ActionsGetOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type EmptyObject = {};

export type ActionsCreateOrUpdateOrgSecret201ResponseBody = EmptyObject;

export type ActionsCreateOrUpdateOrgSecretRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id?: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repository_ids?: ReadonlyArray<number>;
};

export type ActionsCreateOrUpdateOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type ActionsDeleteOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type ActionsListSelectedReposForOrgSecret200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<MinimalRepository>;
};

export type ActionsListSelectedReposForOrgSecretRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type ActionsListSelectedReposForOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type ActionsSetSelectedReposForOrgSecretRequestBody = {
  readonly selected_repository_ids: ReadonlyArray<number>;
};

export type ActionsSetSelectedReposForOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type ActionsAddSelectedRepoToOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
  readonly repository_id: number;
};

export type ActionsRemoveSelectedRepoFromOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
  readonly repository_id: number;
};

export type OrgsListBlockedUsers200ResponseBody = ReadonlyArray<SimpleUser>;

export type OrgsListBlockedUsersRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListBlockedUsersRequestPath = { readonly org: string };

export type OrgsCheckBlockedUser404ResponseBody = BasicError;

export type OrgsCheckBlockedUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsBlockUser422ResponseBody = ValidationError;

export type OrgsBlockUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsUnblockUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type CodeScanningListAlertsForOrg200ResponseBody = ReadonlyArray<CodeScanningOrganizationAlertItems>;

export type CodeScanningListAlertsForOrg404ResponseBody = BasicError;

export type CodeScanningListAlertsForOrg503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningListAlertsForOrgRequestQuery = {
  readonly tool_name?: CodeScanningAnalysisToolName;
  readonly tool_guid?: CodeScanningAnalysisToolGuid;
  readonly before?: string;
  readonly after?: string;
  readonly page?: number;
  readonly per_page?: number;
  readonly direction?: 'asc' | 'desc';
  readonly state?: CodeScanningAlertState;
  readonly sort?: 'created' | 'updated';
};

export type CodeScanningListAlertsForOrgRequestPath = { readonly org: string };

export type CodespaceMachine = {
  readonly name: string;
  readonly display_name: string;
  readonly operating_system: string;
  readonly storage_in_bytes: number;
  readonly memory_in_bytes: number;
  readonly cpus: number;
  readonly prebuild_availability: 'none' | 'ready' | 'in_progress' | null;
} | null;

export type Codespace = {
  readonly id: number;
  readonly name: string;
  readonly display_name?: string | null;
  readonly environment_id: string | null;
  readonly owner: SimpleUser;
  readonly billable_owner: SimpleUser;
  readonly repository: MinimalRepository;
  readonly machine: CodespaceMachine;
  readonly devcontainer_path?: string | null;
  readonly prebuild: boolean | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly last_used_at: string;
  readonly state:
    | 'Unknown'
    | 'Created'
    | 'Queued'
    | 'Provisioning'
    | 'Available'
    | 'Awaiting'
    | 'Unavailable'
    | 'Deleted'
    | 'Moved'
    | 'Shutdown'
    | 'Archived'
    | 'Starting'
    | 'ShuttingDown'
    | 'Failed'
    | 'Exporting'
    | 'Updating'
    | 'Rebuilding';
  readonly url: string;
  readonly git_status: {
    readonly ahead?: number;
    readonly behind?: number;
    readonly has_unpushed_changes?: boolean;
    readonly has_uncommitted_changes?: boolean;
    readonly ref?: string;
  };
  readonly location: 'EastUs' | 'SouthEastAsia' | 'WestEurope' | 'WestUs2';
  readonly idle_timeout_minutes: number | null;
  readonly web_url: string;
  readonly machines_url: string;
  readonly start_url: string;
  readonly stop_url: string;
  readonly pulls_url: string | null;
  readonly recent_folders: ReadonlyArray<string>;
  readonly runtime_constraints?: {
    readonly allowed_port_privacy_settings?: ReadonlyArray<string> | null;
  };
  readonly pending_operation?: boolean | null;
  readonly pending_operation_disabled_reason?: string | null;
  readonly idle_timeout_notice?: string | null;
  readonly retention_period_minutes?: number | null;
  readonly retention_expires_at?: string | null;
  readonly last_known_stop_notice?: string | null;
};

export type CodespacesListInOrganization200ResponseBody = {
  readonly total_count: number;
  readonly codespaces: ReadonlyArray<Codespace>;
};

export type CodespacesListInOrganization401ResponseBody = BasicError;

export type CodespacesListInOrganization403ResponseBody = BasicError;

export type CodespacesListInOrganization404ResponseBody = BasicError;

export type CodespacesListInOrganization500ResponseBody = BasicError;

export type CodespacesListInOrganizationRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesListInOrganizationRequestPath = { readonly org: string };

export type CodespacesSetCodespacesBilling404ResponseBody = BasicError;

export type CodespacesSetCodespacesBilling422ResponseBody = ValidationError;

export type CodespacesSetCodespacesBilling500ResponseBody = BasicError;

export type CodespacesSetCodespacesBillingRequestBody = {
  readonly visibility:
    | 'disabled'
    | 'selected_members'
    | 'all_members'
    | 'all_members_and_outside_collaborators';
  readonly selected_usernames?: ReadonlyArray<string>;
};

export type CodespacesSetCodespacesBillingRequestPath = {
  readonly org: string;
};

export type CodespacesSecret = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repositories_url?: string;
};

export type CodespacesListOrgSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<CodespacesSecret>;
};

export type CodespacesListOrgSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesListOrgSecretsRequestPath = { readonly org: string };

export type CodespacesPublicKey = {
  readonly key_id: string;
  readonly key: string;
  readonly id?: number;
  readonly url?: string;
  readonly title?: string;
  readonly created_at?: string;
};

export type CodespacesGetOrgPublicKey200ResponseBody = CodespacesPublicKey;

export type CodespacesGetOrgPublicKeyRequestPath = { readonly org: string };

export type CodespacesGetOrgSecret200ResponseBody = CodespacesSecret;

export type CodespacesGetOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type CodespacesCreateOrUpdateOrgSecret201ResponseBody = EmptyObject;

export type CodespacesCreateOrUpdateOrgSecret404ResponseBody = BasicError;

export type CodespacesCreateOrUpdateOrgSecret422ResponseBody = ValidationError;

export type CodespacesCreateOrUpdateOrgSecretRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id?: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repository_ids?: ReadonlyArray<number>;
};

export type CodespacesCreateOrUpdateOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type CodespacesDeleteOrgSecret404ResponseBody = BasicError;

export type CodespacesDeleteOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type CodespacesListSelectedReposForOrgSecret200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<MinimalRepository>;
};

export type CodespacesListSelectedReposForOrgSecret404ResponseBody = BasicError;

export type CodespacesListSelectedReposForOrgSecretRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type CodespacesListSelectedReposForOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type CodespacesSetSelectedReposForOrgSecret404ResponseBody = BasicError;

export type CodespacesSetSelectedReposForOrgSecretRequestBody = {
  readonly selected_repository_ids: ReadonlyArray<number>;
};

export type CodespacesSetSelectedReposForOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type CodespacesAddSelectedRepoToOrgSecret404ResponseBody = BasicError;

export type CodespacesAddSelectedRepoToOrgSecret422ResponseBody = ValidationError;

export type CodespacesAddSelectedRepoToOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
  readonly repository_id: number;
};

export type CodespacesRemoveSelectedRepoFromOrgSecret404ResponseBody = BasicError;

export type CodespacesRemoveSelectedRepoFromOrgSecret422ResponseBody = ValidationError;

export type CodespacesRemoveSelectedRepoFromOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
  readonly repository_id: number;
};

export type OrgsCreateCustomRole201ResponseBody = OrganizationCustomRepositoryRole;

export type OrgsCreateCustomRole404ResponseBody = BasicError;

export type OrgsCreateCustomRole422ResponseBody = ValidationError;

export type OrgsCreateCustomRoleRequestBody = {
  readonly name: string;
  readonly description?: string;
  readonly base_role: 'read' | 'triage' | 'write' | 'maintain';
  readonly permissions: ReadonlyArray<string>;
};

export type OrgsCreateCustomRoleRequestPath = { readonly org: string };

export type OrgsGetCustomRole200ResponseBody = OrganizationCustomRepositoryRole;

export type OrgsGetCustomRole404ResponseBody = BasicError;

export type OrgsGetCustomRoleRequestPath = {
  readonly org: string;
  readonly role_id: number;
};

export type OrgsUpdateCustomRole200ResponseBody = OrganizationCustomRepositoryRole;

export type OrgsUpdateCustomRole404ResponseBody = BasicError;

export type OrgsUpdateCustomRole422ResponseBody = ValidationError;

export type OrgsUpdateCustomRoleRequestBody = {
  readonly name?: string;
  readonly description?: string;
  readonly base_role?: 'read' | 'triage' | 'write' | 'maintain';
  readonly permissions?: ReadonlyArray<string>;
};

export type OrgsUpdateCustomRoleRequestPath = {
  readonly org: string;
  readonly role_id: number;
};

export type OrgsDeleteCustomRoleRequestPath = {
  readonly org: string;
  readonly role_id: number;
};

export type DependabotAlertPackage = {
  readonly ecosystem: string;
  readonly name: string;
};

export type DependabotAlertSecurityVulnerability = {
  readonly package: DependabotAlertPackage;
  readonly severity: 'low' | 'medium' | 'high' | 'critical';
  readonly vulnerable_version_range: string;
  readonly first_patched_version: { readonly identifier: string } | null;
};

export type DependabotAlertSecurityAdvisory = {
  readonly ghsa_id: string;
  readonly cve_id: string | null;
  readonly summary: string;
  readonly description: string;
  readonly vulnerabilities: ReadonlyArray<DependabotAlertSecurityVulnerability>;
  readonly severity: 'low' | 'medium' | 'high' | 'critical';
  readonly cvss: {
    readonly score: number;
    readonly vector_string: string | null;
  };
  readonly cwes: ReadonlyArray<{
    readonly cwe_id: string;
    readonly name: string;
  }>;
  readonly identifiers: ReadonlyArray<{
    readonly type: 'CVE' | 'GHSA';
    readonly value: string;
  }>;
  readonly references: ReadonlyArray<{ readonly url: string }>;
  readonly published_at: string;
  readonly updated_at: string;
  readonly withdrawn_at: string | null;
};

export type DependabotAlertWithRepository = {
  readonly number: AlertNumber;
  readonly state: 'dismissed' | 'fixed' | 'open';
  readonly dependency: {
    readonly package?: DependabotAlertPackage;
    readonly manifest_path?: string;
    readonly scope?: 'development' | 'runtime' | null;
  };
  readonly security_advisory: DependabotAlertSecurityAdvisory;
  readonly security_vulnerability: DependabotAlertSecurityVulnerability;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly created_at: AlertCreatedAt;
  readonly updated_at: AlertUpdatedAt;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_reason:
    | 'fix_started'
    | 'inaccurate'
    | 'no_bandwidth'
    | 'not_used'
    | 'tolerable_risk'
    | null;
  readonly dismissed_comment: string | null;
  readonly fixed_at: AlertFixedAt;
  readonly repository: SimpleRepository;
};

export type DependabotListAlertsForOrg200ResponseBody = ReadonlyArray<DependabotAlertWithRepository>;

export type DependabotListAlertsForOrg400ResponseBody = BasicError;

export type DependabotListAlertsForOrg403ResponseBody = BasicError;

export type DependabotListAlertsForOrg404ResponseBody = BasicError;

export type DependabotListAlertsForOrg422ResponseBody = ValidationErrorSimple;

export type DependabotListAlertsForOrgRequestQuery = {
  readonly state?: string;
  readonly severity?: string;
  readonly ecosystem?: string;
  readonly package?: string;
  readonly scope?: 'development' | 'runtime';
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly before?: string;
  readonly after?: string;
  readonly first?: number;
  readonly last?: number;
};

export type DependabotListAlertsForOrgRequestPath = { readonly org: string };

export type DependabotSecretForAnOrganization = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repositories_url?: string;
};

export type DependabotListOrgSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<DependabotSecretForAnOrganization>;
};

export type DependabotListOrgSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type DependabotListOrgSecretsRequestPath = { readonly org: string };

export type DependabotPublicKey = {
  readonly key_id: string;
  readonly key: string;
};

export type DependabotGetOrgPublicKey200ResponseBody = DependabotPublicKey;

export type DependabotGetOrgPublicKeyRequestPath = { readonly org: string };

export type DependabotGetOrgSecret200ResponseBody = DependabotSecretForAnOrganization;

export type DependabotGetOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type DependabotCreateOrUpdateOrgSecret201ResponseBody = EmptyObject;

export type DependabotCreateOrUpdateOrgSecretRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id?: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repository_ids?: ReadonlyArray<string>;
};

export type DependabotCreateOrUpdateOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type DependabotDeleteOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type DependabotListSelectedReposForOrgSecret200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<MinimalRepository>;
};

export type DependabotListSelectedReposForOrgSecretRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type DependabotListSelectedReposForOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type DependabotSetSelectedReposForOrgSecretRequestBody = {
  readonly selected_repository_ids: ReadonlyArray<number>;
};

export type DependabotSetSelectedReposForOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type DependabotAddSelectedRepoToOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
  readonly repository_id: number;
};

export type DependabotRemoveSelectedRepoFromOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
  readonly repository_id: number;
};

export type ActivityListPublicOrgEvents200ResponseBody = ReadonlyArray<Event>;

export type ActivityListPublicOrgEventsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListPublicOrgEventsRequestPath = { readonly org: string };

export type OrganizationInvitation = {
  readonly id: number;
  readonly login: string | null;
  readonly email: string | null;
  readonly role: string;
  readonly created_at: string;
  readonly failed_at?: string | null;
  readonly failed_reason?: string | null;
  readonly inviter: SimpleUser;
  readonly team_count: number;
  readonly node_id: string;
  readonly invitation_teams_url: string;
};

export type OrgsListFailedInvitations200ResponseBody = ReadonlyArray<OrganizationInvitation>;

export type OrgsListFailedInvitations404ResponseBody = BasicError;

export type OrgsListFailedInvitationsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListFailedInvitationsRequestPath = { readonly org: string };

export type OrganizationFineGrainedPermission = {
  readonly name: string;
  readonly description: string;
};

export type OrgsListFineGrainedPermissions200ResponseBody = ReadonlyArray<OrganizationFineGrainedPermission>;

export type OrgsListFineGrainedPermissionsRequestPath = {
  readonly org: string;
};

export type OrgHook = {
  readonly id: number;
  readonly url: string;
  readonly ping_url: string;
  readonly deliveries_url?: string;
  readonly name: string;
  readonly events: ReadonlyArray<string>;
  readonly active: boolean;
  readonly config: {
    readonly url?: string;
    readonly insecure_ssl?: string;
    readonly content_type?: string;
    readonly secret?: string;
  };
  readonly updated_at: string;
  readonly created_at: string;
  readonly type: string;
};

export type OrgsListWebhooks200ResponseBody = ReadonlyArray<OrgHook>;

export type OrgsListWebhooks404ResponseBody = BasicError;

export type OrgsListWebhooksRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListWebhooksRequestPath = { readonly org: string };

export type OrgsCreateWebhook201ResponseBody = OrgHook;

export type OrgsCreateWebhook404ResponseBody = BasicError;

export type OrgsCreateWebhook422ResponseBody = ValidationError;

export type OrgsCreateWebhookRequestBody = {
  readonly name: string;
  readonly config: {
    readonly url: WebhookConfigUrl;
    readonly content_type?: WebhookConfigContentType;
    readonly secret?: WebhookConfigSecret;
    readonly insecure_ssl?: WebhookConfigInsecureSsl;
    readonly username?: string;
    readonly password?: string;
  };
  readonly events?: ReadonlyArray<string>;
  readonly active?: boolean;
};

export type OrgsCreateWebhookRequestPath = { readonly org: string };

export type OrgsGetWebhook200ResponseBody = OrgHook;

export type OrgsGetWebhook404ResponseBody = BasicError;

export type OrgsGetWebhookRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type OrgsUpdateWebhook200ResponseBody = OrgHook;

export type OrgsUpdateWebhook404ResponseBody = BasicError;

export type OrgsUpdateWebhook422ResponseBody = ValidationError;

export type OrgsUpdateWebhookRequestBody = {
  readonly config?: {
    readonly url: WebhookConfigUrl;
    readonly content_type?: WebhookConfigContentType;
    readonly secret?: WebhookConfigSecret;
    readonly insecure_ssl?: WebhookConfigInsecureSsl;
  };
  readonly events?: ReadonlyArray<string>;
  readonly active?: boolean;
  readonly name?: string;
};

export type OrgsUpdateWebhookRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type OrgsDeleteWebhook404ResponseBody = BasicError;

export type OrgsDeleteWebhookRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type OrgsGetWebhookConfigForOrg200ResponseBody = WebhookConfiguration;

export type OrgsGetWebhookConfigForOrgRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type OrgsUpdateWebhookConfigForOrg200ResponseBody = WebhookConfiguration;

export type OrgsUpdateWebhookConfigForOrgRequestBody = {
  readonly url?: WebhookConfigUrl;
  readonly content_type?: WebhookConfigContentType;
  readonly secret?: WebhookConfigSecret;
  readonly insecure_ssl?: WebhookConfigInsecureSsl;
};

export type OrgsUpdateWebhookConfigForOrgRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type OrgsListWebhookDeliveries200ResponseBody = ReadonlyArray<SimpleWebhookDelivery>;

export type OrgsListWebhookDeliveries400ResponseBody = BasicError;

export type OrgsListWebhookDeliveries422ResponseBody = ValidationError;

export type OrgsListWebhookDeliveriesRequestQuery = {
  readonly per_page?: number;
  readonly cursor?: string;
};

export type OrgsListWebhookDeliveriesRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type OrgsGetWebhookDelivery200ResponseBody = WebhookDelivery;

export type OrgsGetWebhookDelivery400ResponseBody = BasicError;

export type OrgsGetWebhookDelivery422ResponseBody = ValidationError;

export type OrgsGetWebhookDeliveryRequestPath = {
  readonly org: string;
  readonly hook_id: number;
  readonly delivery_id: number;
};

export type OrgsRedeliverWebhookDelivery202ResponseBody = unknown;

export type OrgsRedeliverWebhookDelivery400ResponseBody = BasicError;

export type OrgsRedeliverWebhookDelivery422ResponseBody = ValidationError;

export type OrgsRedeliverWebhookDeliveryRequestPath = {
  readonly org: string;
  readonly hook_id: number;
  readonly delivery_id: number;
};

export type OrgsPingWebhook404ResponseBody = BasicError;

export type OrgsPingWebhookRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type AppsGetOrgInstallation200ResponseBody = Installation;

export type AppsGetOrgInstallationRequestPath = { readonly org: string };

export type OrgsListAppInstallations200ResponseBody = {
  readonly total_count: number;
  readonly installations: ReadonlyArray<Installation>;
};

export type OrgsListAppInstallationsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListAppInstallationsRequestPath = { readonly org: string };

export type InteractionGroup =
  | 'existing_users'
  | 'contributors_only'
  | 'collaborators_only';

export type InteractionLimits = {
  readonly limit: InteractionGroup;
  readonly origin: string;
  readonly expires_at: string;
};

export type InteractionsGetRestrictionsForOrg200ResponseBody =
  | InteractionLimits
  | {};

export type InteractionsGetRestrictionsForOrgRequestPath = {
  readonly org: string;
};

export type InteractionsSetRestrictionsForOrg200ResponseBody = InteractionLimits;

export type InteractionsSetRestrictionsForOrg422ResponseBody = ValidationError;

export type InteractionExpiry =
  | 'one_day'
  | 'three_days'
  | 'one_week'
  | 'one_month'
  | 'six_months';

export type InteractionRestrictions = {
  readonly limit: InteractionGroup;
  readonly expiry?: InteractionExpiry;
};

export type InteractionsSetRestrictionsForOrgRequestBody = InteractionRestrictions;

export type InteractionsSetRestrictionsForOrgRequestPath = {
  readonly org: string;
};

export type InteractionsRemoveRestrictionsForOrgRequestPath = {
  readonly org: string;
};

export type OrgsListPendingInvitations200ResponseBody = ReadonlyArray<OrganizationInvitation>;

export type OrgsListPendingInvitations404ResponseBody = BasicError;

export type OrgsListPendingInvitationsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListPendingInvitationsRequestPath = { readonly org: string };

export type OrgsCreateInvitation201ResponseBody = OrganizationInvitation;

export type OrgsCreateInvitation404ResponseBody = BasicError;

export type OrgsCreateInvitation422ResponseBody = ValidationError;

export type OrgsCreateInvitationRequestBody = {
  readonly invitee_id?: number;
  readonly email?: string;
  readonly role?: 'admin' | 'direct_member' | 'billing_manager';
  readonly team_ids?: ReadonlyArray<number>;
};

export type OrgsCreateInvitationRequestPath = { readonly org: string };

export type OrgsCancelInvitation404ResponseBody = BasicError;

export type OrgsCancelInvitation422ResponseBody = ValidationError;

export type OrgsCancelInvitationRequestPath = {
  readonly org: string;
  readonly invitation_id: number;
};

export type TeamSimple = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly members_url: string;
  readonly name: string;
  readonly description: string | null;
  readonly permission: string;
  readonly privacy?: string;
  readonly html_url: string;
  readonly repositories_url: string;
  readonly slug: string;
  readonly ldap_dn?: string;
} | null;

export type Team = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly slug: string;
  readonly description: string | null;
  readonly privacy?: string;
  readonly permission: string;
  readonly permissions?: {
    readonly pull: boolean;
    readonly triage: boolean;
    readonly push: boolean;
    readonly maintain: boolean;
    readonly admin: boolean;
  };
  readonly url: string;
  readonly html_url: string;
  readonly members_url: string;
  readonly repositories_url: string;
  readonly parent: TeamSimple;
};

export type OrgsListInvitationTeams200ResponseBody = ReadonlyArray<Team>;

export type OrgsListInvitationTeams404ResponseBody = BasicError;

export type OrgsListInvitationTeamsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListInvitationTeamsRequestPath = {
  readonly org: string;
  readonly invitation_id: number;
};

export type IssuesListForOrg200ResponseBody = ReadonlyArray<Issue>;

export type IssuesListForOrg404ResponseBody = BasicError;

export type IssuesListForOrgRequestQuery = {
  readonly filter?:
    | 'assigned'
    | 'created'
    | 'mentioned'
    | 'subscribed'
    | 'repos'
    | 'all';
  readonly state?: 'open' | 'closed' | 'all';
  readonly labels?: string;
  readonly sort?: 'created' | 'updated' | 'comments';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListForOrgRequestPath = { readonly org: string };

export type OrgsListMembers200ResponseBody = ReadonlyArray<SimpleUser>;

export type OrgsListMembers422ResponseBody = ValidationError;

export type OrgsListMembersRequestQuery = {
  readonly filter?: '2fa_disabled' | 'all';
  readonly role?: 'all' | 'admin' | 'member';
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListMembersRequestPath = { readonly org: string };

export type OrgsCheckMembershipForUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsRemoveMember403ResponseBody = BasicError;

export type OrgsRemoveMemberRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type CodespacesGetCodespacesForUserInOrg200ResponseBody = {
  readonly total_count: number;
  readonly codespaces: ReadonlyArray<Codespace>;
};

export type CodespacesGetCodespacesForUserInOrg401ResponseBody = BasicError;

export type CodespacesGetCodespacesForUserInOrg403ResponseBody = BasicError;

export type CodespacesGetCodespacesForUserInOrg404ResponseBody = BasicError;

export type CodespacesGetCodespacesForUserInOrg500ResponseBody = BasicError;

export type CodespacesGetCodespacesForUserInOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesGetCodespacesForUserInOrgRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type CodespacesDeleteFromOrganization202ResponseBody = unknown;

export type CodespacesDeleteFromOrganization401ResponseBody = BasicError;

export type CodespacesDeleteFromOrganization403ResponseBody = BasicError;

export type CodespacesDeleteFromOrganization404ResponseBody = BasicError;

export type CodespacesDeleteFromOrganization500ResponseBody = BasicError;

export type CodespacesDeleteFromOrganizationRequestPath = {
  readonly org: string;
  readonly username: string;
  readonly codespace_name: string;
};

export type CodespacesStopInOrganization200ResponseBody = Codespace;

export type CodespacesStopInOrganization401ResponseBody = BasicError;

export type CodespacesStopInOrganization403ResponseBody = BasicError;

export type CodespacesStopInOrganization404ResponseBody = BasicError;

export type CodespacesStopInOrganization500ResponseBody = BasicError;

export type CodespacesStopInOrganizationRequestPath = {
  readonly org: string;
  readonly username: string;
  readonly codespace_name: string;
};

export type OrgMembership = {
  readonly url: string;
  readonly state: 'active' | 'pending';
  readonly role: 'admin' | 'member' | 'billing_manager';
  readonly organization_url: string;
  readonly organization: OrganizationSimple;
  readonly user: SimpleUser;
  readonly permissions?: { readonly can_create_repository: boolean };
};

export type OrgsGetMembershipForUser200ResponseBody = OrgMembership;

export type OrgsGetMembershipForUser403ResponseBody = BasicError;

export type OrgsGetMembershipForUser404ResponseBody = BasicError;

export type OrgsGetMembershipForUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsSetMembershipForUser200ResponseBody = OrgMembership;

export type OrgsSetMembershipForUser403ResponseBody = BasicError;

export type OrgsSetMembershipForUser422ResponseBody = ValidationError;

export type OrgsSetMembershipForUserRequestBody = {
  readonly role?: 'admin' | 'member';
};

export type OrgsSetMembershipForUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsRemoveMembershipForUser403ResponseBody = BasicError;

export type OrgsRemoveMembershipForUser404ResponseBody = BasicError;

export type OrgsRemoveMembershipForUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type Migration = {
  readonly id: number;
  readonly owner: SimpleUser;
  readonly guid: string;
  readonly state: string;
  readonly lock_repositories: boolean;
  readonly exclude_metadata: boolean;
  readonly exclude_git_data: boolean;
  readonly exclude_attachments: boolean;
  readonly exclude_releases: boolean;
  readonly exclude_owner_projects: boolean;
  readonly org_metadata_only: boolean;
  readonly repositories: ReadonlyArray<Repository>;
  readonly url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly node_id: string;
  readonly archive_url?: string;
  readonly exclude?: ReadonlyArray<unknown>;
};

export type MigrationsListForOrg200ResponseBody = ReadonlyArray<Migration>;

export type MigrationsListForOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly exclude?: ReadonlyArray<'repositories'> | 'repositories';
};

export type MigrationsListForOrgRequestPath = { readonly org: string };

export type MigrationsStartForOrg201ResponseBody = Migration;

export type MigrationsStartForOrg404ResponseBody = BasicError;

export type MigrationsStartForOrg422ResponseBody = ValidationError;

export type MigrationsStartForOrgRequestBody = {
  readonly repositories: ReadonlyArray<string>;
  readonly lock_repositories?: boolean;
  readonly exclude_metadata?: boolean;
  readonly exclude_git_data?: boolean;
  readonly exclude_attachments?: boolean;
  readonly exclude_releases?: boolean;
  readonly exclude_owner_projects?: boolean;
  readonly org_metadata_only?: boolean;
  readonly exclude?: ReadonlyArray<'repositories'>;
};

export type MigrationsStartForOrgRequestPath = { readonly org: string };

export type MigrationsGetStatusForOrg200ResponseBody = Migration;

export type MigrationsGetStatusForOrg404ResponseBody = BasicError;

export type MigrationsGetStatusForOrgRequestQuery = {
  readonly exclude?: ReadonlyArray<'repositories'> | 'repositories';
};

export type MigrationsGetStatusForOrgRequestPath = {
  readonly org: string;
  readonly migration_id: number;
};

export type MigrationsDownloadArchiveForOrg404ResponseBody = BasicError;

export type MigrationsDownloadArchiveForOrgRequestPath = {
  readonly org: string;
  readonly migration_id: number;
};

export type MigrationsDeleteArchiveForOrg404ResponseBody = BasicError;

export type MigrationsDeleteArchiveForOrgRequestPath = {
  readonly org: string;
  readonly migration_id: number;
};

export type MigrationsUnlockRepoForOrg404ResponseBody = BasicError;

export type MigrationsUnlockRepoForOrgRequestPath = {
  readonly org: string;
  readonly migration_id: number;
  readonly repo_name: string;
};

export type MigrationsListReposForOrg200ResponseBody = ReadonlyArray<MinimalRepository>;

export type MigrationsListReposForOrg404ResponseBody = BasicError;

export type MigrationsListReposForOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type MigrationsListReposForOrgRequestPath = {
  readonly org: string;
  readonly migration_id: number;
};

export type OrgsListOutsideCollaborators200ResponseBody = ReadonlyArray<SimpleUser>;

export type OrgsListOutsideCollaboratorsRequestQuery = {
  readonly filter?: '2fa_disabled' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListOutsideCollaboratorsRequestPath = { readonly org: string };

export type OrgsConvertMemberToOutsideCollaborator202ResponseBody = {};

export type OrgsConvertMemberToOutsideCollaborator404ResponseBody = BasicError;

export type OrgsConvertMemberToOutsideCollaboratorRequestBody = {
  readonly async?: boolean;
};

export type OrgsConvertMemberToOutsideCollaboratorRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsRemoveOutsideCollaborator422ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
};

export type OrgsRemoveOutsideCollaboratorRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type Package = {
  readonly id: number;
  readonly name: string;
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly url: string;
  readonly html_url: string;
  readonly version_count: number;
  readonly visibility: 'private' | 'public';
  readonly owner?: SimpleUser;
  readonly repository?: MinimalRepository;
  readonly created_at: string;
  readonly updated_at: string;
};

export type PackagesListPackagesForOrganization200ResponseBody = ReadonlyArray<Package>;

export type PackagesListPackagesForOrganization401ResponseBody = BasicError;

export type PackagesListPackagesForOrganization403ResponseBody = BasicError;

export type PackagesListPackagesForOrganizationRequestQuery = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly visibility?: 'public' | 'private' | 'internal';
};

export type PackagesListPackagesForOrganizationRequestPath = {
  readonly org: string;
};

export type PackagesGetPackageForOrganization200ResponseBody = Package;

export type PackagesGetPackageForOrganizationRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
};

export type PackagesDeletePackageForOrg401ResponseBody = BasicError;

export type PackagesDeletePackageForOrg403ResponseBody = BasicError;

export type PackagesDeletePackageForOrg404ResponseBody = BasicError;

export type PackagesDeletePackageForOrgRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
};

export type PackagesRestorePackageForOrg401ResponseBody = BasicError;

export type PackagesRestorePackageForOrg403ResponseBody = BasicError;

export type PackagesRestorePackageForOrg404ResponseBody = BasicError;

export type PackagesRestorePackageForOrgRequestQuery = {
  readonly token?: string;
};

export type PackagesRestorePackageForOrgRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
};

export type ContainerMetadata = { readonly tags: ReadonlyArray<string> };

export type DockerMetadata = { readonly tag?: ReadonlyArray<string> };

export type PackageVersionMetadata = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly container?: ContainerMetadata;
  readonly docker?: DockerMetadata;
};

export type PackageVersion = {
  readonly id: number;
  readonly name: string;
  readonly url: string;
  readonly package_html_url: string;
  readonly html_url?: string;
  readonly license?: string;
  readonly description?: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly deleted_at?: string;
  readonly metadata?: PackageVersionMetadata;
};

export type PackagesGetAllPackageVersionsForPackageOwnedByOrg200ResponseBody = ReadonlyArray<PackageVersion>;

export type PackagesGetAllPackageVersionsForPackageOwnedByOrg401ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByOrg403ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByOrg404ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByOrgRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
  readonly state?: 'active' | 'deleted';
};

export type PackagesGetAllPackageVersionsForPackageOwnedByOrgRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
};

export type PackagesGetPackageVersionForOrganization200ResponseBody = PackageVersion;

export type PackagesGetPackageVersionForOrganizationRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
  readonly package_version_id: number;
};

export type PackagesDeletePackageVersionForOrg401ResponseBody = BasicError;

export type PackagesDeletePackageVersionForOrg403ResponseBody = BasicError;

export type PackagesDeletePackageVersionForOrg404ResponseBody = BasicError;

export type PackagesDeletePackageVersionForOrgRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
  readonly package_version_id: number;
};

export type PackagesRestorePackageVersionForOrg401ResponseBody = BasicError;

export type PackagesRestorePackageVersionForOrg403ResponseBody = BasicError;

export type PackagesRestorePackageVersionForOrg404ResponseBody = BasicError;

export type PackagesRestorePackageVersionForOrgRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
  readonly package_version_id: number;
};

export type Project = {
  readonly owner_url: string;
  readonly url: string;
  readonly html_url: string;
  readonly columns_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly body: string | null;
  readonly number: number;
  readonly state: string;
  readonly creator: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly organization_permission?: 'read' | 'write' | 'admin' | 'none';
  readonly private?: boolean;
};

export type ProjectsListForOrg200ResponseBody = ReadonlyArray<Project>;

export type ProjectsListForOrg422ResponseBody = ValidationErrorSimple;

export type ProjectsListForOrgRequestQuery = {
  readonly state?: 'open' | 'closed' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type ProjectsListForOrgRequestPath = { readonly org: string };

export type ProjectsCreateForOrg201ResponseBody = Project;

export type ProjectsCreateForOrg401ResponseBody = BasicError;

export type ProjectsCreateForOrg403ResponseBody = BasicError;

export type ProjectsCreateForOrg404ResponseBody = BasicError;

export type ProjectsCreateForOrg410ResponseBody = BasicError;

export type ProjectsCreateForOrg422ResponseBody = ValidationErrorSimple;

export type ProjectsCreateForOrgRequestBody = {
  readonly name: string;
  readonly body?: string;
};

export type ProjectsCreateForOrgRequestPath = { readonly org: string };

export type OrgsListPublicMembers200ResponseBody = ReadonlyArray<SimpleUser>;

export type OrgsListPublicMembersRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListPublicMembersRequestPath = { readonly org: string };

export type OrgsCheckPublicMembershipForUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsSetPublicMembershipForAuthenticatedUser403ResponseBody = BasicError;

export type OrgsSetPublicMembershipForAuthenticatedUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsRemovePublicMembershipForAuthenticatedUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type ReposListForOrg200ResponseBody = ReadonlyArray<MinimalRepository>;

export type ReposListForOrgRequestQuery = {
  readonly type?:
    | 'all'
    | 'public'
    | 'private'
    | 'forks'
    | 'sources'
    | 'member'
    | 'internal';
  readonly sort?: 'created' | 'updated' | 'pushed' | 'full_name';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListForOrgRequestPath = { readonly org: string };

export type ReposCreateInOrg201ResponseBody = Repository;

export type ReposCreateInOrg403ResponseBody = BasicError;

export type ReposCreateInOrg422ResponseBody = ValidationError;

export type ReposCreateInOrgRequestBody = {
  readonly name: string;
  readonly description?: string;
  readonly homepage?: string;
  readonly private?: boolean;
  readonly visibility?: 'public' | 'private' | 'internal';
  readonly has_issues?: boolean;
  readonly has_projects?: boolean;
  readonly has_wiki?: boolean;
  readonly is_template?: boolean;
  readonly team_id?: number;
  readonly auto_init?: boolean;
  readonly gitignore_template?: string;
  readonly license_template?: string;
  readonly allow_squash_merge?: boolean;
  readonly allow_merge_commit?: boolean;
  readonly allow_rebase_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly use_squash_pr_title_as_default?: boolean;
  readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
  readonly squash_merge_commit_message?:
    | 'PR_BODY'
    | 'COMMIT_MESSAGES'
    | 'BLANK';
  readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
  readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
};

export type ReposCreateInOrgRequestPath = { readonly org: string };

export type SecretScanningListAlertsForOrg200ResponseBody = ReadonlyArray<OrganizationSecretScanningAlert>;

export type SecretScanningListAlertsForOrg404ResponseBody = BasicError;

export type SecretScanningListAlertsForOrg503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SecretScanningListAlertsForOrgRequestQuery = {
  readonly state?: 'open' | 'resolved';
  readonly secret_type?: string;
  readonly resolution?: string;
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly page?: number;
  readonly per_page?: number;
  readonly before?: string;
  readonly after?: string;
};

export type SecretScanningListAlertsForOrgRequestPath = {
  readonly org: string;
};

export type OrgsListSecurityManagerTeams200ResponseBody = ReadonlyArray<TeamSimple>;

export type OrgsListSecurityManagerTeamsRequestPath = { readonly org: string };

export type OrgsAddSecurityManagerTeamRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type OrgsRemoveSecurityManagerTeamRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type ActionsBillingUsage = {
  readonly total_minutes_used: number;
  readonly total_paid_minutes_used: number;
  readonly included_minutes: number;
  readonly minutes_used_breakdown: {
    readonly UBUNTU?: number;
    readonly MACOS?: number;
    readonly WINDOWS?: number;
    readonly ubuntu_4_core?: number;
    readonly ubuntu_8_core?: number;
    readonly ubuntu_16_core?: number;
    readonly ubuntu_32_core?: number;
    readonly ubuntu_64_core?: number;
    readonly windows_4_core?: number;
    readonly windows_8_core?: number;
    readonly windows_16_core?: number;
    readonly windows_32_core?: number;
    readonly windows_64_core?: number;
    readonly total?: number;
  };
};

export type BillingGetGithubActionsBillingOrg200ResponseBody = ActionsBillingUsage;

export type BillingGetGithubActionsBillingOrgRequestPath = {
  readonly org: string;
};

export type BillingGetGithubAdvancedSecurityBillingOrg200ResponseBody = AdvancedSecurityActiveCommitters;

export type BillingGetGithubAdvancedSecurityBillingOrg403ResponseBody = BasicError;

export type BillingGetGithubAdvancedSecurityBillingOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type BillingGetGithubAdvancedSecurityBillingOrgRequestPath = {
  readonly org: string;
};

export type PackagesBillingUsage = {
  readonly total_gigabytes_bandwidth_used: number;
  readonly total_paid_gigabytes_bandwidth_used: number;
  readonly included_gigabytes_bandwidth: number;
};

export type BillingGetGithubPackagesBillingOrg200ResponseBody = PackagesBillingUsage;

export type BillingGetGithubPackagesBillingOrgRequestPath = {
  readonly org: string;
};

export type CombinedBillingUsage = {
  readonly days_left_in_billing_cycle: number;
  readonly estimated_paid_storage_for_month: number;
  readonly estimated_storage_for_month: number;
};

export type BillingGetSharedStorageBillingOrg200ResponseBody = CombinedBillingUsage;

export type BillingGetSharedStorageBillingOrgRequestPath = {
  readonly org: string;
};

export type TeamsList200ResponseBody = ReadonlyArray<Team>;

export type TeamsList403ResponseBody = BasicError;

export type TeamsListRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListRequestPath = { readonly org: string };

export type TeamOrganization = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly hooks_url: string;
  readonly issues_url: string;
  readonly members_url: string;
  readonly public_members_url: string;
  readonly avatar_url: string;
  readonly description: string | null;
  readonly name?: string;
  readonly company?: string;
  readonly blog?: string;
  readonly location?: string;
  readonly email?: string;
  readonly twitter_username?: string | null;
  readonly is_verified?: boolean;
  readonly has_organization_projects: boolean;
  readonly has_repository_projects: boolean;
  readonly public_repos: number;
  readonly public_gists: number;
  readonly followers: number;
  readonly following: number;
  readonly html_url: string;
  readonly created_at: string;
  readonly type: string;
  readonly total_private_repos?: number;
  readonly owned_private_repos?: number;
  readonly private_gists?: number | null;
  readonly disk_usage?: number | null;
  readonly collaborators?: number | null;
  readonly billing_email?: string | null;
  readonly plan?: {
    readonly name: string;
    readonly space: number;
    readonly private_repos: number;
    readonly filled_seats?: number;
    readonly seats?: number;
  };
  readonly default_repository_permission?: string | null;
  readonly members_can_create_repositories?: boolean | null;
  readonly two_factor_requirement_enabled?: boolean | null;
  readonly members_allowed_repository_creation_type?: string;
  readonly members_can_create_public_repositories?: boolean;
  readonly members_can_create_private_repositories?: boolean;
  readonly members_can_create_internal_repositories?: boolean;
  readonly members_can_create_pages?: boolean;
  readonly members_can_create_public_pages?: boolean;
  readonly members_can_create_private_pages?: boolean;
  readonly members_can_fork_private_repositories?: boolean | null;
  readonly web_commit_signoff_required?: boolean;
  readonly updated_at: string;
};

export type FullTeam = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly html_url: string;
  readonly name: string;
  readonly slug: string;
  readonly description: string | null;
  readonly privacy?: 'closed' | 'secret';
  readonly permission: string;
  readonly members_url: string;
  readonly repositories_url: string;
  readonly parent?: TeamSimple;
  readonly members_count: number;
  readonly repos_count: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly organization: TeamOrganization;
  readonly ldap_dn?: string;
};

export type TeamsCreate201ResponseBody = FullTeam;

export type TeamsCreate403ResponseBody = BasicError;

export type TeamsCreate422ResponseBody = ValidationError;

export type TeamsCreateRequestBody = {
  readonly name: string;
  readonly description?: string;
  readonly maintainers?: ReadonlyArray<string>;
  readonly repo_names?: ReadonlyArray<string>;
  readonly privacy?: 'secret' | 'closed';
  readonly permission?: 'pull' | 'push';
  readonly parent_team_id?: number;
};

export type TeamsCreateRequestPath = { readonly org: string };

export type TeamsGetByName200ResponseBody = FullTeam;

export type TeamsGetByName404ResponseBody = BasicError;

export type TeamsGetByNameRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamsUpdateInOrg200ResponseBody = FullTeam;

export type TeamsUpdateInOrg201ResponseBody = FullTeam;

export type TeamsUpdateInOrg403ResponseBody = BasicError;

export type TeamsUpdateInOrg404ResponseBody = BasicError;

export type TeamsUpdateInOrg422ResponseBody = ValidationError;

export type TeamsUpdateInOrgRequestBody = {
  readonly name?: string;
  readonly description?: string;
  readonly privacy?: 'secret' | 'closed';
  readonly permission?: 'pull' | 'push' | 'admin';
  readonly parent_team_id?: number | null;
};

export type TeamsUpdateInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamsDeleteInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamDiscussion = {
  readonly author: SimpleUser;
  readonly body: string;
  readonly body_html: string;
  readonly body_version: string;
  readonly comments_count: number;
  readonly comments_url: string;
  readonly created_at: string;
  readonly last_edited_at: string | null;
  readonly html_url: string;
  readonly node_id: string;
  readonly number: number;
  readonly pinned: boolean;
  readonly private: boolean;
  readonly team_url: string;
  readonly title: string;
  readonly updated_at: string;
  readonly url: string;
  readonly reactions?: ReactionRollup;
};

export type TeamsListDiscussionsInOrg200ResponseBody = ReadonlyArray<TeamDiscussion>;

export type TeamsListDiscussionsInOrgRequestQuery = {
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
  readonly pinned?: string;
};

export type TeamsListDiscussionsInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamsCreateDiscussionInOrg201ResponseBody = TeamDiscussion;

export type TeamsCreateDiscussionInOrgRequestBody = {
  readonly title: string;
  readonly body: string;
  readonly private?: boolean;
};

export type TeamsCreateDiscussionInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamsGetDiscussionInOrg200ResponseBody = TeamDiscussion;

export type TeamsGetDiscussionInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type TeamsUpdateDiscussionInOrg200ResponseBody = TeamDiscussion;

export type TeamsUpdateDiscussionInOrgRequestBody = {
  readonly title?: string;
  readonly body?: string;
};

export type TeamsUpdateDiscussionInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type TeamsDeleteDiscussionInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type TeamDiscussionComment = {
  readonly author: SimpleUser;
  readonly body: string;
  readonly body_html: string;
  readonly body_version: string;
  readonly created_at: string;
  readonly last_edited_at: string | null;
  readonly discussion_url: string;
  readonly html_url: string;
  readonly node_id: string;
  readonly number: number;
  readonly updated_at: string;
  readonly url: string;
  readonly reactions?: ReactionRollup;
};

export type TeamsListDiscussionCommentsInOrg200ResponseBody = ReadonlyArray<TeamDiscussionComment>;

export type TeamsListDiscussionCommentsInOrgRequestQuery = {
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListDiscussionCommentsInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type TeamsCreateDiscussionCommentInOrg201ResponseBody = TeamDiscussionComment;

export type TeamsCreateDiscussionCommentInOrgRequestBody = {
  readonly body: string;
};

export type TeamsCreateDiscussionCommentInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type TeamsGetDiscussionCommentInOrg200ResponseBody = TeamDiscussionComment;

export type TeamsGetDiscussionCommentInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type TeamsUpdateDiscussionCommentInOrg200ResponseBody = TeamDiscussionComment;

export type TeamsUpdateDiscussionCommentInOrgRequestBody = {
  readonly body: string;
};

export type TeamsUpdateDiscussionCommentInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type TeamsDeleteDiscussionCommentInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type Reaction = {
  readonly id: number;
  readonly node_id: string;
  readonly user: SimpleUser;
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly created_at: string;
};

export type ReactionsListForTeamDiscussionCommentInOrg200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForTeamDiscussionCommentInOrgRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForTeamDiscussionCommentInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type ReactionsCreateForTeamDiscussionCommentInOrg200ResponseBody = Reaction;

export type ReactionsCreateForTeamDiscussionCommentInOrg201ResponseBody = Reaction;

export type ReactionsCreateForTeamDiscussionCommentInOrgRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForTeamDiscussionCommentInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type ReactionsDeleteForTeamDiscussionCommentRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly comment_number: number;
  readonly reaction_id: number;
};

export type ReactionsListForTeamDiscussionInOrg200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForTeamDiscussionInOrgRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForTeamDiscussionInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type ReactionsCreateForTeamDiscussionInOrg200ResponseBody = Reaction;

export type ReactionsCreateForTeamDiscussionInOrg201ResponseBody = Reaction;

export type ReactionsCreateForTeamDiscussionInOrgRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForTeamDiscussionInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type ReactionsDeleteForTeamDiscussionRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly reaction_id: number;
};

export type TeamsListPendingInvitationsInOrg200ResponseBody = ReadonlyArray<OrganizationInvitation>;

export type TeamsListPendingInvitationsInOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListPendingInvitationsInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamsListMembersInOrg200ResponseBody = ReadonlyArray<SimpleUser>;

export type TeamsListMembersInOrgRequestQuery = {
  readonly role?: 'member' | 'maintainer' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListMembersInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamMembership = {
  readonly url: string;
  readonly role: 'member' | 'maintainer';
  readonly state: 'active' | 'pending';
};

export type TeamsGetMembershipForUserInOrg200ResponseBody = TeamMembership;

export type TeamsGetMembershipForUserInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly username: string;
};

export type TeamsAddOrUpdateMembershipForUserInOrg200ResponseBody = TeamMembership;

export type TeamsAddOrUpdateMembershipForUserInOrgRequestBody = {
  readonly role?: 'member' | 'maintainer';
};

export type TeamsAddOrUpdateMembershipForUserInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly username: string;
};

export type TeamsRemoveMembershipForUserInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly username: string;
};

export type TeamProject = {
  readonly owner_url: string;
  readonly url: string;
  readonly html_url: string;
  readonly columns_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly body: string | null;
  readonly number: number;
  readonly state: string;
  readonly creator: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly organization_permission?: string;
  readonly private?: boolean;
  readonly permissions: {
    readonly read: boolean;
    readonly write: boolean;
    readonly admin: boolean;
  };
};

export type TeamsListProjectsInOrg200ResponseBody = ReadonlyArray<TeamProject>;

export type TeamsListProjectsInOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListProjectsInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamsCheckPermissionsForProjectInOrg200ResponseBody = TeamProject;

export type TeamsCheckPermissionsForProjectInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly project_id: number;
};

export type TeamsAddOrUpdateProjectPermissionsInOrg403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
};

export type TeamsAddOrUpdateProjectPermissionsInOrgRequestBody = {
  readonly permission?: 'read' | 'write' | 'admin';
} | null;

export type TeamsAddOrUpdateProjectPermissionsInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly project_id: number;
};

export type TeamsRemoveProjectInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly project_id: number;
};

export type TeamsListReposInOrg200ResponseBody = ReadonlyArray<MinimalRepository>;

export type TeamsListReposInOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListReposInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamRepository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly license: LicenseSimple;
  readonly forks: number;
  readonly permissions?: {
    readonly admin: boolean;
    readonly pull: boolean;
    readonly triage?: boolean;
    readonly push: boolean;
    readonly maintain?: boolean;
  };
  readonly role_name?: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly git_url: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly ssh_url: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly clone_url: string;
  readonly mirror_url: string | null;
  readonly hooks_url: string;
  readonly svn_url: string;
  readonly homepage: string | null;
  readonly language: string | null;
  readonly forks_count: number;
  readonly stargazers_count: number;
  readonly watchers_count: number;
  readonly size: number;
  readonly default_branch: string;
  readonly open_issues_count: number;
  readonly is_template?: boolean;
  readonly topics?: ReadonlyArray<string>;
  readonly has_issues: boolean;
  readonly has_projects: boolean;
  readonly has_wiki: boolean;
  readonly has_pages: boolean;
  readonly has_downloads: boolean;
  readonly archived: boolean;
  readonly disabled: boolean;
  readonly visibility?: string;
  readonly pushed_at: string | null;
  readonly created_at: string | null;
  readonly updated_at: string | null;
  readonly allow_rebase_merge?: boolean;
  readonly template_repository?: Repository;
  readonly temp_clone_token?: string;
  readonly allow_squash_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_merge_commit?: boolean;
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
  readonly subscribers_count?: number;
  readonly network_count?: number;
  readonly open_issues: number;
  readonly watchers: number;
  readonly master_branch?: string;
};

export type TeamsCheckPermissionsForRepoInOrg200ResponseBody = TeamRepository;

export type TeamsCheckPermissionsForRepoInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly owner: string;
  readonly repo: string;
};

export type TeamsAddOrUpdateRepoPermissionsInOrgRequestBody = {
  readonly permission?: string;
};

export type TeamsAddOrUpdateRepoPermissionsInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly owner: string;
  readonly repo: string;
};

export type TeamsRemoveRepoInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly owner: string;
  readonly repo: string;
};

export type TeamsListChildInOrg200ResponseBody = ReadonlyArray<Team>;

export type TeamsListChildInOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListChildInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestPath = {
  readonly org: string;
  readonly security_product:
    | 'dependency_graph'
    | 'dependabot_alerts'
    | 'dependabot_security_updates'
    | 'advanced_security'
    | 'secret_scanning'
    | 'secret_scanning_push_protection';
  readonly enablement: 'enable_all' | 'disable_all';
};

export type ProjectCard = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly note: string | null;
  readonly creator: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly archived?: boolean;
  readonly column_name?: string;
  readonly project_id?: string;
  readonly column_url: string;
  readonly content_url?: string;
  readonly project_url: string;
};

export type ProjectsGetCard200ResponseBody = ProjectCard;

export type ProjectsGetCard401ResponseBody = BasicError;

export type ProjectsGetCard403ResponseBody = BasicError;

export type ProjectsGetCard404ResponseBody = BasicError;

export type ProjectsGetCardRequestPath = { readonly card_id: number };

export type ProjectsUpdateCard200ResponseBody = ProjectCard;

export type ProjectsUpdateCard401ResponseBody = BasicError;

export type ProjectsUpdateCard403ResponseBody = BasicError;

export type ProjectsUpdateCard404ResponseBody = BasicError;

export type ProjectsUpdateCard422ResponseBody = ValidationErrorSimple;

export type ProjectsUpdateCardRequestBody = {
  readonly note?: string | null;
  readonly archived?: boolean;
};

export type ProjectsUpdateCardRequestPath = { readonly card_id: number };

export type ProjectsDeleteCard401ResponseBody = BasicError;

export type ProjectsDeleteCard403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
  readonly errors?: ReadonlyArray<string>;
};

export type ProjectsDeleteCard404ResponseBody = BasicError;

export type ProjectsDeleteCardRequestPath = { readonly card_id: number };

export type ProjectsMoveCard201ResponseBody = {};

export type ProjectsMoveCard401ResponseBody = BasicError;

export type ProjectsMoveCard403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
  readonly errors?: ReadonlyArray<{
    readonly code?: string;
    readonly message?: string;
    readonly resource?: string;
    readonly field?: string;
  }>;
};

export type ProjectsMoveCard422ResponseBody = ValidationError;

export type ProjectsMoveCard503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
  readonly errors?: ReadonlyArray<{
    readonly code?: string;
    readonly message?: string;
  }>;
};

export type ProjectsMoveCardRequestBody = {
  readonly position: string;
  readonly column_id?: number;
};

export type ProjectsMoveCardRequestPath = { readonly card_id: number };

export type ProjectColumn = {
  readonly url: string;
  readonly project_url: string;
  readonly cards_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
};

export type ProjectsGetColumn200ResponseBody = ProjectColumn;

export type ProjectsGetColumn401ResponseBody = BasicError;

export type ProjectsGetColumn403ResponseBody = BasicError;

export type ProjectsGetColumn404ResponseBody = BasicError;

export type ProjectsGetColumnRequestPath = { readonly column_id: number };

export type ProjectsUpdateColumn200ResponseBody = ProjectColumn;

export type ProjectsUpdateColumn401ResponseBody = BasicError;

export type ProjectsUpdateColumn403ResponseBody = BasicError;

export type ProjectsUpdateColumnRequestBody = { readonly name: string };

export type ProjectsUpdateColumnRequestPath = { readonly column_id: number };

export type ProjectsDeleteColumn401ResponseBody = BasicError;

export type ProjectsDeleteColumn403ResponseBody = BasicError;

export type ProjectsDeleteColumnRequestPath = { readonly column_id: number };

export type ProjectsListCards200ResponseBody = ReadonlyArray<ProjectCard>;

export type ProjectsListCards401ResponseBody = BasicError;

export type ProjectsListCards403ResponseBody = BasicError;

export type ProjectsListCardsRequestQuery = {
  readonly archived_state?: 'all' | 'archived' | 'not_archived';
  readonly per_page?: number;
  readonly page?: number;
};

export type ProjectsListCardsRequestPath = { readonly column_id: number };

export type ProjectsCreateCard201ResponseBody = ProjectCard;

export type ProjectsCreateCard401ResponseBody = BasicError;

export type ProjectsCreateCard403ResponseBody = BasicError;

export type ProjectsCreateCard422ResponseBody =
  | ValidationError
  | ValidationErrorSimple;

export type ProjectsCreateCard503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
  readonly errors?: ReadonlyArray<{
    readonly code?: string;
    readonly message?: string;
  }>;
};

export type ProjectsCreateCardRequestBody =
  | { readonly note: string | null }
  | { readonly content_id: number; readonly content_type: string };

export type ProjectsCreateCardRequestPath = { readonly column_id: number };

export type ProjectsMoveColumn201ResponseBody = {};

export type ProjectsMoveColumn401ResponseBody = BasicError;

export type ProjectsMoveColumn403ResponseBody = BasicError;

export type ProjectsMoveColumn422ResponseBody = ValidationErrorSimple;

export type ProjectsMoveColumnRequestBody = { readonly position: string };

export type ProjectsMoveColumnRequestPath = { readonly column_id: number };

export type ProjectsGet200ResponseBody = Project;

export type ProjectsGet401ResponseBody = BasicError;

export type ProjectsGet403ResponseBody = BasicError;

export type ProjectsGetRequestPath = { readonly project_id: number };

export type ProjectsUpdate200ResponseBody = Project;

export type ProjectsUpdate401ResponseBody = BasicError;

export type ProjectsUpdate403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
  readonly errors?: ReadonlyArray<string>;
};

export type ProjectsUpdate410ResponseBody = BasicError;

export type ProjectsUpdate422ResponseBody = ValidationErrorSimple;

export type ProjectsUpdateRequestBody = {
  readonly name?: string;
  readonly body?: string | null;
  readonly state?: string;
  readonly organization_permission?: 'read' | 'write' | 'admin' | 'none';
  readonly private?: boolean;
};

export type ProjectsUpdateRequestPath = { readonly project_id: number };

export type ProjectsDelete401ResponseBody = BasicError;

export type ProjectsDelete403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
  readonly errors?: ReadonlyArray<string>;
};

export type ProjectsDelete404ResponseBody = BasicError;

export type ProjectsDelete410ResponseBody = BasicError;

export type ProjectsDeleteRequestPath = { readonly project_id: number };

export type ProjectsListCollaborators200ResponseBody = ReadonlyArray<SimpleUser>;

export type ProjectsListCollaborators401ResponseBody = BasicError;

export type ProjectsListCollaborators403ResponseBody = BasicError;

export type ProjectsListCollaborators404ResponseBody = BasicError;

export type ProjectsListCollaborators422ResponseBody = ValidationError;

export type ProjectsListCollaboratorsRequestQuery = {
  readonly affiliation?: 'outside' | 'direct' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type ProjectsListCollaboratorsRequestPath = {
  readonly project_id: number;
};

export type ProjectsAddCollaborator401ResponseBody = BasicError;

export type ProjectsAddCollaborator403ResponseBody = BasicError;

export type ProjectsAddCollaborator404ResponseBody = BasicError;

export type ProjectsAddCollaborator422ResponseBody = ValidationError;

export type ProjectsAddCollaboratorRequestBody = {
  readonly permission?: 'read' | 'write' | 'admin';
} | null;

export type ProjectsAddCollaboratorRequestPath = {
  readonly project_id: number;
  readonly username: string;
};

export type ProjectsRemoveCollaborator401ResponseBody = BasicError;

export type ProjectsRemoveCollaborator403ResponseBody = BasicError;

export type ProjectsRemoveCollaborator404ResponseBody = BasicError;

export type ProjectsRemoveCollaborator422ResponseBody = ValidationError;

export type ProjectsRemoveCollaboratorRequestPath = {
  readonly project_id: number;
  readonly username: string;
};

export type ProjectCollaboratorPermission = {
  readonly permission: string;
  readonly user: SimpleUser;
};

export type ProjectsGetPermissionForUser200ResponseBody = ProjectCollaboratorPermission;

export type ProjectsGetPermissionForUser401ResponseBody = BasicError;

export type ProjectsGetPermissionForUser403ResponseBody = BasicError;

export type ProjectsGetPermissionForUser404ResponseBody = BasicError;

export type ProjectsGetPermissionForUser422ResponseBody = ValidationError;

export type ProjectsGetPermissionForUserRequestPath = {
  readonly project_id: number;
  readonly username: string;
};

export type ProjectsListColumns200ResponseBody = ReadonlyArray<ProjectColumn>;

export type ProjectsListColumns401ResponseBody = BasicError;

export type ProjectsListColumns403ResponseBody = BasicError;

export type ProjectsListColumnsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ProjectsListColumnsRequestPath = { readonly project_id: number };

export type ProjectsCreateColumn201ResponseBody = ProjectColumn;

export type ProjectsCreateColumn401ResponseBody = BasicError;

export type ProjectsCreateColumn403ResponseBody = BasicError;

export type ProjectsCreateColumn422ResponseBody = ValidationErrorSimple;

export type ProjectsCreateColumnRequestBody = { readonly name: string };

export type ProjectsCreateColumnRequestPath = { readonly project_id: number };

export type RateLimit = {
  readonly limit: number;
  readonly remaining: number;
  readonly reset: number;
  readonly used: number;
};

export type RateLimitOverview = {
  readonly resources: {
    readonly core: RateLimit;
    readonly graphql?: RateLimit;
    readonly search: RateLimit;
    readonly source_import?: RateLimit;
    readonly integration_manifest?: RateLimit;
    readonly code_scanning_upload?: RateLimit;
    readonly actions_runner_registration?: RateLimit;
    readonly scim?: RateLimit;
    readonly dependency_snapshots?: RateLimit;
  };
  readonly rate: RateLimit;
};

export type RateLimitGet200ResponseBody = RateLimitOverview;

export type RateLimitGet404ResponseBody = BasicError;

export type CodeOfConductSimple = {
  readonly url: string;
  readonly key: string;
  readonly name: string;
  readonly html_url: string | null;
};

export type SecurityAndAnalysis = {
  readonly advanced_security?: { readonly status?: 'enabled' | 'disabled' };
  readonly secret_scanning?: { readonly status?: 'enabled' | 'disabled' };
  readonly secret_scanning_push_protection?: {
    readonly status?: 'enabled' | 'disabled';
  };
} | null;

export type FullRepository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly git_url: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly ssh_url: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly clone_url: string;
  readonly mirror_url: string | null;
  readonly hooks_url: string;
  readonly svn_url: string;
  readonly homepage: string | null;
  readonly language: string | null;
  readonly forks_count: number;
  readonly stargazers_count: number;
  readonly watchers_count: number;
  readonly size: number;
  readonly default_branch: string;
  readonly open_issues_count: number;
  readonly is_template?: boolean;
  readonly topics?: ReadonlyArray<string>;
  readonly has_issues: boolean;
  readonly has_projects: boolean;
  readonly has_wiki: boolean;
  readonly has_pages: boolean;
  readonly has_downloads: boolean;
  readonly archived: boolean;
  readonly disabled: boolean;
  readonly visibility?: string;
  readonly pushed_at: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly permissions?: {
    readonly admin: boolean;
    readonly maintain?: boolean;
    readonly push: boolean;
    readonly triage?: boolean;
    readonly pull: boolean;
  };
  readonly allow_rebase_merge?: boolean;
  readonly template_repository?: Repository;
  readonly temp_clone_token?: string | null;
  readonly allow_squash_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_merge_commit?: boolean;
  readonly allow_update_branch?: boolean;
  readonly use_squash_pr_title_as_default?: boolean;
  readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
  readonly squash_merge_commit_message?:
    | 'PR_BODY'
    | 'COMMIT_MESSAGES'
    | 'BLANK';
  readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
  readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
  readonly subscribers_count: number;
  readonly network_count: number;
  readonly license: LicenseSimple;
  readonly organization?: SimpleUser;
  readonly parent?: Repository;
  readonly source?: Repository;
  readonly forks: number;
  readonly master_branch?: string;
  readonly open_issues: number;
  readonly watchers: number;
  readonly anonymous_access_enabled?: boolean;
  readonly code_of_conduct?: CodeOfConductSimple;
  readonly security_and_analysis?: SecurityAndAnalysis;
};

export type ReposGet200ResponseBody = FullRepository;

export type ReposGet301ResponseBody = BasicError;

export type ReposGet403ResponseBody = BasicError;

export type ReposGet404ResponseBody = BasicError;

export type ReposGetRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposUpdate200ResponseBody = FullRepository;

export type ReposUpdate307ResponseBody = BasicError;

export type ReposUpdate403ResponseBody = BasicError;

export type ReposUpdate404ResponseBody = BasicError;

export type ReposUpdate422ResponseBody = ValidationError;

export type ReposUpdateRequestBody = {
  readonly name?: string;
  readonly description?: string;
  readonly homepage?: string;
  readonly private?: boolean;
  readonly visibility?: 'public' | 'private' | 'internal';
  readonly security_and_analysis?: {
    readonly advanced_security?: { readonly status?: string };
    readonly secret_scanning?: { readonly status?: string };
    readonly secret_scanning_push_protection?: { readonly status?: string };
  } | null;
  readonly has_issues?: boolean;
  readonly has_projects?: boolean;
  readonly has_wiki?: boolean;
  readonly is_template?: boolean;
  readonly default_branch?: string;
  readonly allow_squash_merge?: boolean;
  readonly allow_merge_commit?: boolean;
  readonly allow_rebase_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_update_branch?: boolean;
  readonly use_squash_pr_title_as_default?: boolean;
  readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
  readonly squash_merge_commit_message?:
    | 'PR_BODY'
    | 'COMMIT_MESSAGES'
    | 'BLANK';
  readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
  readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
  readonly archived?: boolean;
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
};

export type ReposUpdateRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDelete307ResponseBody = BasicError;

export type ReposDelete403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
};

export type ReposDelete404ResponseBody = BasicError;

export type ReposDeleteRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type Artifact = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly size_in_bytes: number;
  readonly url: string;
  readonly archive_download_url: string;
  readonly expired: boolean;
  readonly created_at: string | null;
  readonly expires_at: string | null;
  readonly updated_at: string | null;
  readonly workflow_run?: {
    readonly id?: number;
    readonly repository_id?: number;
    readonly head_repository_id?: number;
    readonly head_branch?: string;
    readonly head_sha?: string;
  } | null;
};

export type ActionsListArtifactsForRepo200ResponseBody = {
  readonly total_count: number;
  readonly artifacts: ReadonlyArray<Artifact>;
};

export type ActionsListArtifactsForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly name?: string;
};

export type ActionsListArtifactsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetArtifact200ResponseBody = Artifact;

export type ActionsGetArtifactRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly artifact_id: number;
};

export type ActionsDeleteArtifactRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly artifact_id: number;
};

export type ActionsDownloadArtifact410ResponseBody = BasicError;

export type ActionsDownloadArtifactRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly artifact_id: number;
  readonly archive_format: string;
};

export type ActionsGetActionsCacheUsage200ResponseBody = ActionsCacheUsageByRepository;

export type ActionsGetActionsCacheUsageRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type RepositoryActionsCaches = {
  readonly total_count: number;
  readonly actions_caches: ReadonlyArray<{
    readonly id?: number;
    readonly ref?: string;
    readonly key?: string;
    readonly version?: string;
    readonly last_accessed_at?: string;
    readonly created_at?: string;
    readonly size_in_bytes?: number;
  }>;
};

export type ActionsGetActionsCacheList200ResponseBody = RepositoryActionsCaches;

export type ActionsGetActionsCacheListRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly ref?: CodeScanningRef;
  readonly key?: string;
  readonly sort?: 'created_at' | 'last_accessed_at' | 'size_in_bytes';
  readonly direction?: 'asc' | 'desc';
};

export type ActionsGetActionsCacheListRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsDeleteActionsCacheByKey200ResponseBody = RepositoryActionsCaches;

export type ActionsDeleteActionsCacheByKeyRequestQuery = {
  readonly key: string;
  readonly ref?: CodeScanningRef;
};

export type ActionsDeleteActionsCacheByKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsDeleteActionsCacheByIdRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly cache_id: number;
};

export type Job = {
  readonly id: number;
  readonly run_id: number;
  readonly run_url: string;
  readonly run_attempt?: number;
  readonly node_id: string;
  readonly head_sha: string;
  readonly url: string;
  readonly html_url: string | null;
  readonly status: 'queued' | 'in_progress' | 'completed';
  readonly conclusion:
    | 'success'
    | 'failure'
    | 'neutral'
    | 'cancelled'
    | 'skipped'
    | 'timed_out'
    | 'action_required'
    | null;
  readonly started_at: string;
  readonly completed_at: string | null;
  readonly name: string;
  readonly steps?: ReadonlyArray<{
    readonly status: 'queued' | 'in_progress' | 'completed';
    readonly conclusion: string | null;
    readonly name: string;
    readonly number: number;
    readonly started_at?: string | null;
    readonly completed_at?: string | null;
  }>;
  readonly check_run_url: string;
  readonly labels: ReadonlyArray<string>;
  readonly runner_id: number | null;
  readonly runner_name: string | null;
  readonly runner_group_id: number | null;
  readonly runner_group_name: string | null;
};

export type ActionsGetJobForWorkflowRun200ResponseBody = Job;

export type ActionsGetJobForWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly job_id: number;
};

export type ActionsDownloadJobLogsForWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly job_id: number;
};

export type ActionsReRunJobForWorkflowRun201ResponseBody = EmptyObject;

export type ActionsReRunJobForWorkflowRun403ResponseBody = BasicError;

export type ActionsReRunJobForWorkflowRunRequestBody = {
  readonly enable_debug_logging?: boolean;
} | null;

export type ActionsReRunJobForWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly job_id: number;
};

export type ActionsEnabled = boolean;

export type ActionsRepositoryPermissions = {
  readonly enabled: ActionsEnabled;
  readonly allowed_actions?: AllowedActions;
  readonly selected_actions_url?: SelectedActionsUrl;
};

export type ActionsGetGithubActionsPermissionsRepository200ResponseBody = ActionsRepositoryPermissions;

export type ActionsGetGithubActionsPermissionsRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsSetGithubActionsPermissionsRepositoryRequestBody = {
  readonly enabled: ActionsEnabled;
  readonly allowed_actions?: AllowedActions;
};

export type ActionsSetGithubActionsPermissionsRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsWorkflowAccessToRepository = {
  readonly access_level: 'none' | 'organization' | 'enterprise';
};

export type ActionsGetWorkflowAccessToRepository200ResponseBody = ActionsWorkflowAccessToRepository;

export type ActionsGetWorkflowAccessToRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsSetWorkflowAccessToRepositoryRequestBody = ActionsWorkflowAccessToRepository;

export type ActionsSetWorkflowAccessToRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetAllowedActionsRepository200ResponseBody = SelectedActions;

export type ActionsGetAllowedActionsRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsSetAllowedActionsRepositoryRequestBody = SelectedActions;

export type ActionsSetAllowedActionsRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepository200ResponseBody = ActionsGetDefaultWorkflowPermissions;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequestBody = ActionsSetDefaultWorkflowPermissions;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsListSelfHostedRunnersForRepo200ResponseBody = {
  readonly total_count: number;
  readonly runners: ReadonlyArray<SelfHostedRunners>;
};

export type ActionsListSelfHostedRunnersForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListSelfHostedRunnersForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsListRunnerApplicationsForRepo200ResponseBody = ReadonlyArray<RunnerApplication>;

export type ActionsListRunnerApplicationsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsCreateRegistrationTokenForRepo201ResponseBody = AuthenticationToken;

export type ActionsCreateRegistrationTokenForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsCreateRemoveTokenForRepo201ResponseBody = AuthenticationToken;

export type ActionsCreateRemoveTokenForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetSelfHostedRunnerForRepo200ResponseBody = SelfHostedRunners;

export type ActionsGetSelfHostedRunnerForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
};

export type ActionsDeleteSelfHostedRunnerFromRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
};

export type ActionsListLabelsForSelfHostedRunnerForRepo200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsListLabelsForSelfHostedRunnerForRepo404ResponseBody = BasicError;

export type ActionsListLabelsForSelfHostedRunnerForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
};

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepo200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepo404ResponseBody = BasicError;

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepo422ResponseBody = ValidationErrorSimple;

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestBody = {
  readonly labels: ReadonlyArray<string>;
};

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
};

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepo200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepo404ResponseBody = BasicError;

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepo422ResponseBody = ValidationErrorSimple;

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestBody = {
  readonly labels: ReadonlyArray<string>;
};

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
};

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo404ResponseBody = BasicError;

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
};

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo404ResponseBody = BasicError;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo422ResponseBody = ValidationErrorSimple;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
  readonly name: string;
};

export type ReferencedWorkflow = {
  readonly path: string;
  readonly sha: string;
  readonly ref?: string;
};

export type PullRequestMinimal = {
  readonly id: number;
  readonly number: number;
  readonly url: string;
  readonly head: {
    readonly ref: string;
    readonly sha: string;
    readonly repo: {
      readonly id: number;
      readonly url: string;
      readonly name: string;
    };
  };
  readonly base: {
    readonly ref: string;
    readonly sha: string;
    readonly repo: {
      readonly id: number;
      readonly url: string;
      readonly name: string;
    };
  };
};

export type SimpleCommit = {
  readonly id: string;
  readonly tree_id: string;
  readonly message: string;
  readonly timestamp: string;
  readonly author: { readonly name: string; readonly email: string } | null;
  readonly committer: { readonly name: string; readonly email: string } | null;
} | null;

export type WorkflowRun = {
  readonly id: number;
  readonly name?: string | null;
  readonly node_id: string;
  readonly check_suite_id?: number;
  readonly check_suite_node_id?: string;
  readonly head_branch: string | null;
  readonly head_sha: string;
  readonly path: string;
  readonly run_number: number;
  readonly run_attempt?: number;
  readonly referenced_workflows?: ReadonlyArray<ReferencedWorkflow> | null;
  readonly event: string;
  readonly status: string | null;
  readonly conclusion: string | null;
  readonly workflow_id: number;
  readonly url: string;
  readonly html_url: string;
  readonly pull_requests: ReadonlyArray<PullRequestMinimal> | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly actor?: SimpleUser;
  readonly triggering_actor?: SimpleUser;
  readonly run_started_at?: string;
  readonly jobs_url: string;
  readonly logs_url: string;
  readonly check_suite_url: string;
  readonly artifacts_url: string;
  readonly cancel_url: string;
  readonly rerun_url: string;
  readonly previous_attempt_url?: string | null;
  readonly workflow_url: string;
  readonly head_commit: SimpleCommit;
  readonly repository: MinimalRepository;
  readonly head_repository: MinimalRepository;
  readonly head_repository_id?: number;
  readonly display_title: string;
};

export type ActionsListWorkflowRunsForRepo200ResponseBody = {
  readonly total_count: number;
  readonly workflow_runs: ReadonlyArray<WorkflowRun>;
};

export type ActionsListWorkflowRunsForRepoRequestQuery = {
  readonly actor?: string;
  readonly branch?: string;
  readonly event?: string;
  readonly status?:
    | 'completed'
    | 'action_required'
    | 'cancelled'
    | 'failure'
    | 'neutral'
    | 'skipped'
    | 'stale'
    | 'success'
    | 'timed_out'
    | 'in_progress'
    | 'queued'
    | 'requested'
    | 'waiting';
  readonly per_page?: number;
  readonly page?: number;
  readonly created?: string;
  readonly exclude_pull_requests?: boolean;
  readonly check_suite_id?: number;
  readonly head_sha?: string;
};

export type ActionsListWorkflowRunsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetWorkflowRun200ResponseBody = WorkflowRun;

export type ActionsGetWorkflowRunRequestQuery = {
  readonly exclude_pull_requests?: boolean;
};

export type ActionsGetWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsDeleteWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type EnvironmentApproval = {
  readonly environments: ReadonlyArray<{
    readonly id?: number;
    readonly node_id?: string;
    readonly name?: string;
    readonly url?: string;
    readonly html_url?: string;
    readonly created_at?: string;
    readonly updated_at?: string;
  }>;
  readonly state: 'approved' | 'rejected';
  readonly user: SimpleUser;
  readonly comment: string;
};

export type ActionsGetReviewsForRun200ResponseBody = ReadonlyArray<EnvironmentApproval>;

export type ActionsGetReviewsForRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsApproveWorkflowRun201ResponseBody = EmptyObject;

export type ActionsApproveWorkflowRun403ResponseBody = BasicError;

export type ActionsApproveWorkflowRun404ResponseBody = BasicError;

export type ActionsApproveWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsListWorkflowRunArtifacts200ResponseBody = {
  readonly total_count: number;
  readonly artifacts: ReadonlyArray<Artifact>;
};

export type ActionsListWorkflowRunArtifactsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListWorkflowRunArtifactsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsGetWorkflowRunAttempt200ResponseBody = WorkflowRun;

export type ActionsGetWorkflowRunAttemptRequestQuery = {
  readonly exclude_pull_requests?: boolean;
};

export type ActionsGetWorkflowRunAttemptRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
  readonly attempt_number: number;
};

export type ActionsListJobsForWorkflowRunAttempt200ResponseBody = {
  readonly total_count: number;
  readonly jobs: ReadonlyArray<Job>;
};

export type ActionsListJobsForWorkflowRunAttempt404ResponseBody = BasicError;

export type ActionsListJobsForWorkflowRunAttemptRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListJobsForWorkflowRunAttemptRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
  readonly attempt_number: number;
};

export type ActionsDownloadWorkflowRunAttemptLogsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
  readonly attempt_number: number;
};

export type ActionsCancelWorkflowRun202ResponseBody = EmptyObject;

export type ActionsCancelWorkflowRun409ResponseBody = BasicError;

export type ActionsCancelWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsListJobsForWorkflowRun200ResponseBody = {
  readonly total_count: number;
  readonly jobs: ReadonlyArray<Job>;
};

export type ActionsListJobsForWorkflowRunRequestQuery = {
  readonly filter?: 'latest' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListJobsForWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsDownloadWorkflowRunLogsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsDeleteWorkflowRunLogs403ResponseBody = BasicError;

export type ActionsDeleteWorkflowRunLogs500ResponseBody = BasicError;

export type ActionsDeleteWorkflowRunLogsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type DeploymentReviewerType = 'User' | 'Team';

export type PendingDeployment = {
  readonly environment: {
    readonly id?: number;
    readonly node_id?: string;
    readonly name?: string;
    readonly url?: string;
    readonly html_url?: string;
  };
  readonly wait_timer: number;
  readonly wait_timer_started_at: string | null;
  readonly current_user_can_approve: boolean;
  readonly reviewers: ReadonlyArray<{
    readonly type?: DeploymentReviewerType;
    readonly reviewer?: SimpleUser | Team;
  }>;
};

export type ActionsGetPendingDeploymentsForRun200ResponseBody = ReadonlyArray<PendingDeployment>;

export type ActionsGetPendingDeploymentsForRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type Deployment = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly sha: string;
  readonly ref: string;
  readonly task: string;
  readonly payload: unknown | string;
  readonly original_environment?: string;
  readonly environment: string;
  readonly description: string | null;
  readonly creator: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly statuses_url: string;
  readonly repository_url: string;
  readonly transient_environment?: boolean;
  readonly production_environment?: boolean;
  readonly performed_via_github_app?: GitHubApp;
};

export type ActionsReviewPendingDeploymentsForRun200ResponseBody = ReadonlyArray<Deployment>;

export type ActionsReviewPendingDeploymentsForRunRequestBody = {
  readonly environment_ids: ReadonlyArray<number>;
  readonly state: 'approved' | 'rejected';
  readonly comment: string;
};

export type ActionsReviewPendingDeploymentsForRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsReRunWorkflow201ResponseBody = EmptyObject;

export type ActionsReRunWorkflowRequestBody = {
  readonly enable_debug_logging?: boolean;
} | null;

export type ActionsReRunWorkflowRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsReRunWorkflowFailedJobs201ResponseBody = EmptyObject;

export type ActionsReRunWorkflowFailedJobsRequestBody = {
  readonly enable_debug_logging?: boolean;
} | null;

export type ActionsReRunWorkflowFailedJobsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type WorkflowRunUsage = {
  readonly billable: {
    readonly UBUNTU?: {
      readonly total_ms: number;
      readonly jobs: number;
      readonly job_runs?: ReadonlyArray<{
        readonly job_id: number;
        readonly duration_ms: number;
      }>;
    };
    readonly MACOS?: {
      readonly total_ms: number;
      readonly jobs: number;
      readonly job_runs?: ReadonlyArray<{
        readonly job_id: number;
        readonly duration_ms: number;
      }>;
    };
    readonly WINDOWS?: {
      readonly total_ms: number;
      readonly jobs: number;
      readonly job_runs?: ReadonlyArray<{
        readonly job_id: number;
        readonly duration_ms: number;
      }>;
    };
  };
  readonly run_duration_ms?: number;
};

export type ActionsGetWorkflowRunUsage200ResponseBody = WorkflowRunUsage;

export type ActionsGetWorkflowRunUsageRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsSecret = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
};

export type ActionsListRepoSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<ActionsSecret>;
};

export type ActionsListRepoSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListRepoSecretsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetRepoPublicKey200ResponseBody = ActionsPublicKey;

export type ActionsGetRepoPublicKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetRepoSecret200ResponseBody = ActionsSecret;

export type ActionsGetRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type ActionsCreateOrUpdateRepoSecret201ResponseBody = EmptyObject;

export type ActionsCreateOrUpdateRepoSecretRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id?: string;
};

export type ActionsCreateOrUpdateRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type ActionsDeleteRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type Workflow = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly path: string;
  readonly state:
    | 'active'
    | 'deleted'
    | 'disabled_fork'
    | 'disabled_inactivity'
    | 'disabled_manually';
  readonly created_at: string;
  readonly updated_at: string;
  readonly url: string;
  readonly html_url: string;
  readonly badge_url: string;
  readonly deleted_at?: string;
};

export type ActionsListRepoWorkflows200ResponseBody = {
  readonly total_count: number;
  readonly workflows: ReadonlyArray<Workflow>;
};

export type ActionsListRepoWorkflowsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListRepoWorkflowsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetWorkflow200ResponseBody = Workflow;

export type ActionsGetWorkflowRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly workflow_id: number | string;
};

export type ActionsDisableWorkflowRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly workflow_id: number | string;
};

export type ActionsCreateWorkflowDispatchRequestBody = {
  readonly ref: string;
  readonly inputs?: unknown;
};

export type ActionsCreateWorkflowDispatchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly workflow_id: number | string;
};

export type ActionsEnableWorkflowRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly workflow_id: number | string;
};

export type ActionsListWorkflowRuns200ResponseBody = {
  readonly total_count: number;
  readonly workflow_runs: ReadonlyArray<WorkflowRun>;
};

export type ActionsListWorkflowRunsRequestQuery = {
  readonly actor?: string;
  readonly branch?: string;
  readonly event?: string;
  readonly status?:
    | 'completed'
    | 'action_required'
    | 'cancelled'
    | 'failure'
    | 'neutral'
    | 'skipped'
    | 'stale'
    | 'success'
    | 'timed_out'
    | 'in_progress'
    | 'queued'
    | 'requested'
    | 'waiting';
  readonly per_page?: number;
  readonly page?: number;
  readonly created?: string;
  readonly exclude_pull_requests?: boolean;
  readonly check_suite_id?: number;
  readonly head_sha?: string;
};

export type ActionsListWorkflowRunsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly workflow_id: number | string;
};

export type WorkflowUsage = {
  readonly billable: {
    readonly UBUNTU?: { readonly total_ms?: number };
    readonly MACOS?: { readonly total_ms?: number };
    readonly WINDOWS?: { readonly total_ms?: number };
  };
};

export type ActionsGetWorkflowUsage200ResponseBody = WorkflowUsage;

export type ActionsGetWorkflowUsageRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly workflow_id: number | string;
};

export type IssuesListAssignees200ResponseBody = ReadonlyArray<SimpleUser>;

export type IssuesListAssignees404ResponseBody = BasicError;

export type IssuesListAssigneesRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListAssigneesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesCheckUserCanBeAssigned404ResponseBody = BasicError;

export type IssuesCheckUserCanBeAssignedRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly assignee: string;
};

export type AutolinkReference = {
  readonly id: number;
  readonly key_prefix: string;
  readonly url_template: string;
  readonly is_alphanumeric: boolean;
};

export type ReposListAutolinks200ResponseBody = ReadonlyArray<AutolinkReference>;

export type ReposListAutolinksRequestQuery = { readonly page?: number };

export type ReposListAutolinksRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateAutolink201ResponseBody = AutolinkReference;

export type ReposCreateAutolink422ResponseBody = ValidationError;

export type ReposCreateAutolinkRequestBody = {
  readonly key_prefix: string;
  readonly url_template: string;
  readonly is_alphanumeric?: boolean;
};

export type ReposCreateAutolinkRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetAutolink200ResponseBody = AutolinkReference;

export type ReposGetAutolink404ResponseBody = BasicError;

export type ReposGetAutolinkRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly autolink_id: number;
};

export type ReposDeleteAutolink404ResponseBody = BasicError;

export type ReposDeleteAutolinkRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly autolink_id: number;
};

export type ReposEnableAutomatedSecurityFixesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDisableAutomatedSecurityFixesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ProtectedBranchRequiredStatusCheck = {
  readonly url?: string;
  readonly enforcement_level?: string;
  readonly contexts: ReadonlyArray<string>;
  readonly checks: ReadonlyArray<{
    readonly context: string;
    readonly app_id: number | null;
  }>;
  readonly contexts_url?: string;
  readonly strict?: boolean;
};

export type ProtectedBranchAdminEnforced = {
  readonly url: string;
  readonly enabled: boolean;
};

export type ProtectedBranchPullRequestReview = {
  readonly url?: string;
  readonly dismissal_restrictions?: {
    readonly users?: ReadonlyArray<SimpleUser>;
    readonly teams?: ReadonlyArray<Team>;
    readonly apps?: ReadonlyArray<GitHubApp>;
    readonly url?: string;
    readonly users_url?: string;
    readonly teams_url?: string;
  };
  readonly bypass_pull_request_allowances?: {
    readonly users?: ReadonlyArray<SimpleUser>;
    readonly teams?: ReadonlyArray<Team>;
    readonly apps?: ReadonlyArray<GitHubApp>;
  };
  readonly dismiss_stale_reviews: boolean;
  readonly require_code_owner_reviews: boolean;
  readonly required_approving_review_count?: number;
  readonly require_last_push_approval?: boolean;
};

export type BranchRestrictionPolicy = {
  readonly url: string;
  readonly users_url: string;
  readonly teams_url: string;
  readonly apps_url: string;
  readonly users: ReadonlyArray<{
    readonly login?: string;
    readonly id?: number;
    readonly node_id?: string;
    readonly avatar_url?: string;
    readonly gravatar_id?: string;
    readonly url?: string;
    readonly html_url?: string;
    readonly followers_url?: string;
    readonly following_url?: string;
    readonly gists_url?: string;
    readonly starred_url?: string;
    readonly subscriptions_url?: string;
    readonly organizations_url?: string;
    readonly repos_url?: string;
    readonly events_url?: string;
    readonly received_events_url?: string;
    readonly type?: string;
    readonly site_admin?: boolean;
  }>;
  readonly teams: ReadonlyArray<{
    readonly id?: number;
    readonly node_id?: string;
    readonly url?: string;
    readonly html_url?: string;
    readonly name?: string;
    readonly slug?: string;
    readonly description?: string | null;
    readonly privacy?: string;
    readonly permission?: string;
    readonly members_url?: string;
    readonly repositories_url?: string;
    readonly parent?: string | null;
  }>;
  readonly apps: ReadonlyArray<{
    readonly id?: number;
    readonly slug?: string;
    readonly node_id?: string;
    readonly owner?: {
      readonly login?: string;
      readonly id?: number;
      readonly node_id?: string;
      readonly url?: string;
      readonly repos_url?: string;
      readonly events_url?: string;
      readonly hooks_url?: string;
      readonly issues_url?: string;
      readonly members_url?: string;
      readonly public_members_url?: string;
      readonly avatar_url?: string;
      readonly description?: string;
      readonly gravatar_id?: string;
      readonly html_url?: string;
      readonly followers_url?: string;
      readonly following_url?: string;
      readonly gists_url?: string;
      readonly starred_url?: string;
      readonly subscriptions_url?: string;
      readonly organizations_url?: string;
      readonly received_events_url?: string;
      readonly type?: string;
      readonly site_admin?: boolean;
    };
    readonly name?: string;
    readonly description?: string;
    readonly external_url?: string;
    readonly html_url?: string;
    readonly created_at?: string;
    readonly updated_at?: string;
    readonly permissions?: {
      readonly metadata?: string;
      readonly contents?: string;
      readonly issues?: string;
      readonly single_file?: string;
    };
    readonly events?: ReadonlyArray<string>;
  }>;
};

export type BranchProtection = {
  readonly url?: string;
  readonly enabled?: boolean;
  readonly required_status_checks?: ProtectedBranchRequiredStatusCheck;
  readonly enforce_admins?: ProtectedBranchAdminEnforced;
  readonly required_pull_request_reviews?: ProtectedBranchPullRequestReview;
  readonly restrictions?: BranchRestrictionPolicy;
  readonly required_linear_history?: { readonly enabled?: boolean };
  readonly allow_force_pushes?: { readonly enabled?: boolean };
  readonly allow_deletions?: { readonly enabled?: boolean };
  readonly block_creations?: { readonly enabled?: boolean };
  readonly required_conversation_resolution?: { readonly enabled?: boolean };
  readonly name?: string;
  readonly protection_url?: string;
  readonly required_signatures?: {
    readonly url: string;
    readonly enabled: boolean;
  };
  readonly lock_branch?: { readonly enabled?: boolean };
  readonly allow_fork_syncing?: { readonly enabled?: boolean };
};

export type ShortBranch = {
  readonly name: string;
  readonly commit: { readonly sha: string; readonly url: string };
  readonly protected: boolean;
  readonly protection?: BranchProtection;
  readonly protection_url?: string;
};

export type ReposListBranches200ResponseBody = ReadonlyArray<ShortBranch>;

export type ReposListBranches404ResponseBody = BasicError;

export type ReposListBranchesRequestQuery = {
  readonly protected?: boolean;
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListBranchesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type GitUser = {
  readonly name?: string;
  readonly email?: string;
  readonly date?: string;
} | null;

export type Verification = {
  readonly verified: boolean;
  readonly reason: string;
  readonly payload: string | null;
  readonly signature: string | null;
};

export type DiffEntry = {
  readonly sha: string;
  readonly filename: string;
  readonly status:
    | 'added'
    | 'removed'
    | 'modified'
    | 'renamed'
    | 'copied'
    | 'changed'
    | 'unchanged';
  readonly additions: number;
  readonly deletions: number;
  readonly changes: number;
  readonly blob_url: string;
  readonly raw_url: string;
  readonly contents_url: string;
  readonly patch?: string;
  readonly previous_filename?: string;
};

export type Commit = {
  readonly url: string;
  readonly sha: string;
  readonly node_id: string;
  readonly html_url: string;
  readonly comments_url: string;
  readonly commit: {
    readonly url: string;
    readonly author: GitUser;
    readonly committer: GitUser;
    readonly message: string;
    readonly comment_count: number;
    readonly tree: { readonly sha: string; readonly url: string };
    readonly verification?: Verification;
  };
  readonly author: SimpleUser;
  readonly committer: SimpleUser;
  readonly parents: ReadonlyArray<{
    readonly sha: string;
    readonly url: string;
    readonly html_url?: string;
  }>;
  readonly stats?: {
    readonly additions?: number;
    readonly deletions?: number;
    readonly total?: number;
  };
  readonly files?: ReadonlyArray<DiffEntry>;
};

export type BranchWithProtection = {
  readonly name: string;
  readonly commit: Commit;
  readonly _links: { readonly html: string; readonly self: string };
  readonly protected: boolean;
  readonly protection: BranchProtection;
  readonly protection_url: string;
  readonly pattern?: string;
  readonly required_approving_review_count?: number;
};

export type ReposGetBranch200ResponseBody = BranchWithProtection;

export type ReposGetBranch301ResponseBody = BasicError;

export type ReposGetBranch404ResponseBody = BasicError;

export type ReposGetBranchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetBranchProtection200ResponseBody = BranchProtection;

export type ReposGetBranchProtection404ResponseBody = BasicError;

export type ReposGetBranchProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type StatusCheckPolicy = {
  readonly url: string;
  readonly strict: boolean;
  readonly contexts: ReadonlyArray<string>;
  readonly checks: ReadonlyArray<{
    readonly context: string;
    readonly app_id: number | null;
  }>;
  readonly contexts_url: string;
};

export type ProtectedBranch = {
  readonly url: string;
  readonly required_status_checks?: StatusCheckPolicy;
  readonly required_pull_request_reviews?: {
    readonly url: string;
    readonly dismiss_stale_reviews?: boolean;
    readonly require_code_owner_reviews?: boolean;
    readonly required_approving_review_count?: number;
    readonly require_last_push_approval?: boolean;
    readonly dismissal_restrictions?: {
      readonly url: string;
      readonly users_url: string;
      readonly teams_url: string;
      readonly users: ReadonlyArray<SimpleUser>;
      readonly teams: ReadonlyArray<Team>;
      readonly apps?: ReadonlyArray<GitHubApp>;
    };
    readonly bypass_pull_request_allowances?: {
      readonly users: ReadonlyArray<SimpleUser>;
      readonly teams: ReadonlyArray<Team>;
      readonly apps?: ReadonlyArray<GitHubApp>;
    };
  };
  readonly required_signatures?: {
    readonly url: string;
    readonly enabled: boolean;
  };
  readonly enforce_admins?: { readonly url: string; readonly enabled: boolean };
  readonly required_linear_history?: { readonly enabled: boolean };
  readonly allow_force_pushes?: { readonly enabled: boolean };
  readonly allow_deletions?: { readonly enabled: boolean };
  readonly restrictions?: BranchRestrictionPolicy;
  readonly required_conversation_resolution?: { readonly enabled?: boolean };
  readonly block_creations?: { readonly enabled: boolean };
  readonly lock_branch?: { readonly enabled?: boolean };
  readonly allow_fork_syncing?: { readonly enabled?: boolean };
};

export type ReposUpdateBranchProtection200ResponseBody = ProtectedBranch;

export type ReposUpdateBranchProtection403ResponseBody = BasicError;

export type ReposUpdateBranchProtection404ResponseBody = BasicError;

export type ReposUpdateBranchProtection422ResponseBody = ValidationErrorSimple;

export type ReposUpdateBranchProtectionRequestBody = {
  readonly required_status_checks: {
    readonly strict: boolean;
    readonly contexts: ReadonlyArray<string>;
    readonly checks?: ReadonlyArray<{
      readonly context: string;
      readonly app_id?: number;
    }>;
  } | null;
  readonly enforce_admins: boolean | null;
  readonly required_pull_request_reviews: {
    readonly dismissal_restrictions?: {
      readonly users?: ReadonlyArray<string>;
      readonly teams?: ReadonlyArray<string>;
      readonly apps?: ReadonlyArray<string>;
    };
    readonly dismiss_stale_reviews?: boolean;
    readonly require_code_owner_reviews?: boolean;
    readonly required_approving_review_count?: number;
    readonly require_last_push_approval?: boolean;
    readonly bypass_pull_request_allowances?: {
      readonly users?: ReadonlyArray<string>;
      readonly teams?: ReadonlyArray<string>;
      readonly apps?: ReadonlyArray<string>;
    };
  } | null;
  readonly restrictions: {
    readonly users: ReadonlyArray<string>;
    readonly teams: ReadonlyArray<string>;
    readonly apps?: ReadonlyArray<string>;
  } | null;
  readonly required_linear_history?: boolean;
  readonly allow_force_pushes?: boolean | null;
  readonly allow_deletions?: boolean;
  readonly block_creations?: boolean;
  readonly required_conversation_resolution?: boolean;
  readonly lock_branch?: boolean;
  readonly allow_fork_syncing?: boolean;
};

export type ReposUpdateBranchProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposDeleteBranchProtection403ResponseBody = BasicError;

export type ReposDeleteBranchProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetAdminBranchProtection200ResponseBody = ProtectedBranchAdminEnforced;

export type ReposGetAdminBranchProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposSetAdminBranchProtection200ResponseBody = ProtectedBranchAdminEnforced;

export type ReposSetAdminBranchProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposDeleteAdminBranchProtection404ResponseBody = BasicError;

export type ReposDeleteAdminBranchProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetPullRequestReviewProtection200ResponseBody = ProtectedBranchPullRequestReview;

export type ReposGetPullRequestReviewProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposUpdatePullRequestReviewProtection200ResponseBody = ProtectedBranchPullRequestReview;

export type ReposUpdatePullRequestReviewProtection422ResponseBody = ValidationError;

export type ReposUpdatePullRequestReviewProtectionRequestBody = {
  readonly dismissal_restrictions?: {
    readonly users?: ReadonlyArray<string>;
    readonly teams?: ReadonlyArray<string>;
    readonly apps?: ReadonlyArray<string>;
  };
  readonly dismiss_stale_reviews?: boolean;
  readonly require_code_owner_reviews?: boolean;
  readonly required_approving_review_count?: number;
  readonly require_last_push_approval?: boolean;
  readonly bypass_pull_request_allowances?: {
    readonly users?: ReadonlyArray<string>;
    readonly teams?: ReadonlyArray<string>;
    readonly apps?: ReadonlyArray<string>;
  };
};

export type ReposUpdatePullRequestReviewProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposDeletePullRequestReviewProtection404ResponseBody = BasicError;

export type ReposDeletePullRequestReviewProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetCommitSignatureProtection200ResponseBody = ProtectedBranchAdminEnforced;

export type ReposGetCommitSignatureProtection404ResponseBody = BasicError;

export type ReposGetCommitSignatureProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposCreateCommitSignatureProtection200ResponseBody = ProtectedBranchAdminEnforced;

export type ReposCreateCommitSignatureProtection404ResponseBody = BasicError;

export type ReposCreateCommitSignatureProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposDeleteCommitSignatureProtection404ResponseBody = BasicError;

export type ReposDeleteCommitSignatureProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetStatusChecksProtection200ResponseBody = StatusCheckPolicy;

export type ReposGetStatusChecksProtection404ResponseBody = BasicError;

export type ReposGetStatusChecksProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposUpdateStatusCheckProtection200ResponseBody = StatusCheckPolicy;

export type ReposUpdateStatusCheckProtection404ResponseBody = BasicError;

export type ReposUpdateStatusCheckProtection422ResponseBody = ValidationError;

export type ReposUpdateStatusCheckProtectionRequestBody = {
  readonly strict?: boolean;
  readonly contexts?: ReadonlyArray<string>;
  readonly checks?: ReadonlyArray<{
    readonly context: string;
    readonly app_id?: number;
  }>;
};

export type ReposUpdateStatusCheckProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposRemoveStatusCheckProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetAllStatusCheckContexts200ResponseBody = ReadonlyArray<string>;

export type ReposGetAllStatusCheckContexts404ResponseBody = BasicError;

export type ReposGetAllStatusCheckContextsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposAddStatusCheckContexts200ResponseBody = ReadonlyArray<string>;

export type ReposAddStatusCheckContexts403ResponseBody = BasicError;

export type ReposAddStatusCheckContexts404ResponseBody = BasicError;

export type ReposAddStatusCheckContexts422ResponseBody = ValidationError;

export type ReposAddStatusCheckContextsRequestBody =
  | { readonly contexts: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposAddStatusCheckContextsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposSetStatusCheckContexts200ResponseBody = ReadonlyArray<string>;

export type ReposSetStatusCheckContexts404ResponseBody = BasicError;

export type ReposSetStatusCheckContexts422ResponseBody = ValidationError;

export type ReposSetStatusCheckContextsRequestBody =
  | { readonly contexts: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposSetStatusCheckContextsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposRemoveStatusCheckContexts200ResponseBody = ReadonlyArray<string>;

export type ReposRemoveStatusCheckContexts404ResponseBody = BasicError;

export type ReposRemoveStatusCheckContexts422ResponseBody = ValidationError;

export type ReposRemoveStatusCheckContextsRequestBody =
  | { readonly contexts: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposRemoveStatusCheckContextsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetAccessRestrictions200ResponseBody = BranchRestrictionPolicy;

export type ReposGetAccessRestrictions404ResponseBody = BasicError;

export type ReposGetAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposDeleteAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetAppsWithAccessToProtectedBranch200ResponseBody = ReadonlyArray<GitHubApp>;

export type ReposGetAppsWithAccessToProtectedBranch404ResponseBody = BasicError;

export type ReposGetAppsWithAccessToProtectedBranchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposAddAppAccessRestrictions200ResponseBody = ReadonlyArray<GitHubApp>;

export type ReposAddAppAccessRestrictions422ResponseBody = ValidationError;

export type ReposAddAppAccessRestrictionsRequestBody =
  | { readonly apps: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposAddAppAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposSetAppAccessRestrictions200ResponseBody = ReadonlyArray<GitHubApp>;

export type ReposSetAppAccessRestrictions422ResponseBody = ValidationError;

export type ReposSetAppAccessRestrictionsRequestBody =
  | { readonly apps: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposSetAppAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposRemoveAppAccessRestrictions200ResponseBody = ReadonlyArray<GitHubApp>;

export type ReposRemoveAppAccessRestrictions422ResponseBody = ValidationError;

export type ReposRemoveAppAccessRestrictionsRequestBody =
  | { readonly apps: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposRemoveAppAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetTeamsWithAccessToProtectedBranch200ResponseBody = ReadonlyArray<Team>;

export type ReposGetTeamsWithAccessToProtectedBranch404ResponseBody = BasicError;

export type ReposGetTeamsWithAccessToProtectedBranchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposAddTeamAccessRestrictions200ResponseBody = ReadonlyArray<Team>;

export type ReposAddTeamAccessRestrictions422ResponseBody = ValidationError;

export type ReposAddTeamAccessRestrictionsRequestBody =
  | { readonly teams: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposAddTeamAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposSetTeamAccessRestrictions200ResponseBody = ReadonlyArray<Team>;

export type ReposSetTeamAccessRestrictions422ResponseBody = ValidationError;

export type ReposSetTeamAccessRestrictionsRequestBody =
  | { readonly teams: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposSetTeamAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposRemoveTeamAccessRestrictions200ResponseBody = ReadonlyArray<Team>;

export type ReposRemoveTeamAccessRestrictions422ResponseBody = ValidationError;

export type ReposRemoveTeamAccessRestrictionsRequestBody =
  | { readonly teams: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposRemoveTeamAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetUsersWithAccessToProtectedBranch200ResponseBody = ReadonlyArray<SimpleUser>;

export type ReposGetUsersWithAccessToProtectedBranch404ResponseBody = BasicError;

export type ReposGetUsersWithAccessToProtectedBranchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposAddUserAccessRestrictions200ResponseBody = ReadonlyArray<SimpleUser>;

export type ReposAddUserAccessRestrictions422ResponseBody = ValidationError;

export type ReposAddUserAccessRestrictionsRequestBody =
  | { readonly users: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposAddUserAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposSetUserAccessRestrictions200ResponseBody = ReadonlyArray<SimpleUser>;

export type ReposSetUserAccessRestrictions422ResponseBody = ValidationError;

export type ReposSetUserAccessRestrictionsRequestBody =
  | { readonly users: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposSetUserAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposRemoveUserAccessRestrictions200ResponseBody = ReadonlyArray<SimpleUser>;

export type ReposRemoveUserAccessRestrictions422ResponseBody = ValidationError;

export type ReposRemoveUserAccessRestrictionsRequestBody =
  | { readonly users: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposRemoveUserAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposRenameBranch201ResponseBody = BranchWithProtection;

export type ReposRenameBranch403ResponseBody = BasicError;

export type ReposRenameBranch404ResponseBody = BasicError;

export type ReposRenameBranch422ResponseBody = ValidationError;

export type ReposRenameBranchRequestBody = { readonly new_name: string };

export type ReposRenameBranchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type CheckRun = {
  readonly id: number;
  readonly head_sha: string;
  readonly node_id: string;
  readonly external_id: string | null;
  readonly url: string;
  readonly html_url: string | null;
  readonly details_url: string | null;
  readonly status: 'queued' | 'in_progress' | 'completed';
  readonly conclusion:
    | 'success'
    | 'failure'
    | 'neutral'
    | 'cancelled'
    | 'skipped'
    | 'timed_out'
    | 'action_required'
    | null;
  readonly started_at: string | null;
  readonly completed_at: string | null;
  readonly output: {
    readonly title: string | null;
    readonly summary: string | null;
    readonly text: string | null;
    readonly annotations_count: number;
    readonly annotations_url: string;
  };
  readonly name: string;
  readonly check_suite: { readonly id: number } | null;
  readonly app: GitHubApp;
  readonly pull_requests: ReadonlyArray<PullRequestMinimal>;
  readonly deployment?: Deployment;
};

export type ChecksCreate201ResponseBody = CheckRun;

export type ChecksCreateRequestBody = {
  readonly name: string;
  readonly head_sha: string;
  readonly details_url?: string;
  readonly external_id?: string;
  readonly status?: 'queued' | 'in_progress' | 'completed';
  readonly started_at?: string;
  readonly conclusion?:
    | 'action_required'
    | 'cancelled'
    | 'failure'
    | 'neutral'
    | 'success'
    | 'skipped'
    | 'stale'
    | 'timed_out';
  readonly completed_at?: string;
  readonly output?: {
    readonly title: string;
    readonly summary: string;
    readonly text?: string;
    readonly annotations?: ReadonlyArray<{
      readonly path: string;
      readonly start_line: number;
      readonly end_line: number;
      readonly start_column?: number;
      readonly end_column?: number;
      readonly annotation_level: 'notice' | 'warning' | 'failure';
      readonly message: string;
      readonly title?: string;
      readonly raw_details?: string;
    }>;
    readonly images?: ReadonlyArray<{
      readonly alt: string;
      readonly image_url: string;
      readonly caption?: string;
    }>;
  };
  readonly actions?: ReadonlyArray<{
    readonly label: string;
    readonly description: string;
    readonly identifier: string;
  }>;
} & (
  | { readonly status: 'completed' }
  | { readonly status?: 'queued' | 'in_progress' }
);

export type ChecksCreateRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ChecksGet200ResponseBody = CheckRun;

export type ChecksGetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_run_id: number;
};

export type ChecksUpdate200ResponseBody = CheckRun;

export type ChecksUpdateRequestBody = {
  readonly name?: string;
  readonly details_url?: string;
  readonly external_id?: string;
  readonly started_at?: string;
  readonly status?: 'queued' | 'in_progress' | 'completed';
  readonly conclusion?:
    | 'action_required'
    | 'cancelled'
    | 'failure'
    | 'neutral'
    | 'success'
    | 'skipped'
    | 'stale'
    | 'timed_out';
  readonly completed_at?: string;
  readonly output?: {
    readonly title?: string;
    readonly summary: string;
    readonly text?: string;
    readonly annotations?: ReadonlyArray<{
      readonly path: string;
      readonly start_line: number;
      readonly end_line: number;
      readonly start_column?: number;
      readonly end_column?: number;
      readonly annotation_level: 'notice' | 'warning' | 'failure';
      readonly message: string;
      readonly title?: string;
      readonly raw_details?: string;
    }>;
    readonly images?: ReadonlyArray<{
      readonly alt: string;
      readonly image_url: string;
      readonly caption?: string;
    }>;
  };
  readonly actions?: ReadonlyArray<{
    readonly label: string;
    readonly description: string;
    readonly identifier: string;
  }>;
} & (
  | { readonly status?: 'completed' }
  | { readonly status?: 'queued' | 'in_progress' }
);

export type ChecksUpdateRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_run_id: number;
};

export type CheckAnnotation = {
  readonly path: string;
  readonly start_line: number;
  readonly end_line: number;
  readonly start_column: number | null;
  readonly end_column: number | null;
  readonly annotation_level: string | null;
  readonly title: string | null;
  readonly message: string | null;
  readonly raw_details: string | null;
  readonly blob_href: string;
};

export type ChecksListAnnotations200ResponseBody = ReadonlyArray<CheckAnnotation>;

export type ChecksListAnnotationsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ChecksListAnnotationsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_run_id: number;
};

export type ChecksRerequestRun201ResponseBody = EmptyObject;

export type ChecksRerequestRun403ResponseBody = BasicError;

export type ChecksRerequestRun404ResponseBody = BasicError;

export type ChecksRerequestRun422ResponseBody = BasicError;

export type ChecksRerequestRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_run_id: number;
};

export type CheckSuite = {
  readonly id: number;
  readonly node_id: string;
  readonly head_branch: string | null;
  readonly head_sha: string;
  readonly status: 'queued' | 'in_progress' | 'completed' | null;
  readonly conclusion:
    | 'success'
    | 'failure'
    | 'neutral'
    | 'cancelled'
    | 'skipped'
    | 'timed_out'
    | 'action_required'
    | null;
  readonly url: string | null;
  readonly before: string | null;
  readonly after: string | null;
  readonly pull_requests: ReadonlyArray<PullRequestMinimal> | null;
  readonly app: GitHubApp;
  readonly repository: MinimalRepository;
  readonly created_at: string | null;
  readonly updated_at: string | null;
  readonly head_commit: SimpleCommit;
  readonly latest_check_runs_count: number;
  readonly check_runs_url: string;
  readonly rerequestable?: boolean;
  readonly runs_rerequestable?: boolean;
};

export type ChecksCreateSuite200ResponseBody = CheckSuite;

export type ChecksCreateSuite201ResponseBody = CheckSuite;

export type ChecksCreateSuiteRequestBody = { readonly head_sha: string };

export type ChecksCreateSuiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CheckSuitePreference = {
  readonly preferences: {
    readonly auto_trigger_checks?: ReadonlyArray<{
      readonly app_id: number;
      readonly setting: boolean;
    }>;
  };
  readonly repository: MinimalRepository;
};

export type ChecksSetSuitesPreferences200ResponseBody = CheckSuitePreference;

export type ChecksSetSuitesPreferencesRequestBody = {
  readonly auto_trigger_checks?: ReadonlyArray<{
    readonly app_id: number;
    readonly setting: boolean;
  }>;
};

export type ChecksSetSuitesPreferencesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ChecksGetSuite200ResponseBody = CheckSuite;

export type ChecksGetSuiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_suite_id: number;
};

export type ChecksListForSuite200ResponseBody = {
  readonly total_count: number;
  readonly check_runs: ReadonlyArray<CheckRun>;
};

export type ChecksListForSuiteRequestQuery = {
  readonly check_name?: string;
  readonly status?: 'queued' | 'in_progress' | 'completed';
  readonly filter?: 'latest' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type ChecksListForSuiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_suite_id: number;
};

export type ChecksRerequestSuite201ResponseBody = EmptyObject;

export type ChecksRerequestSuiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_suite_id: number;
};

export type CodeScanningAlertRuleSummary = {
  readonly id?: string | null;
  readonly name?: string;
  readonly tags?: ReadonlyArray<string> | null;
  readonly severity?: 'none' | 'note' | 'warning' | 'error' | null;
  readonly description?: string;
};

export type CodeScanningAlertItems = {
  readonly number: AlertNumber;
  readonly created_at: AlertCreatedAt;
  readonly updated_at?: AlertUpdatedAt;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly instances_url: AlertInstancesUrl;
  readonly state: CodeScanningAlertState;
  readonly fixed_at?: AlertFixedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_reason: CodeScanningAlertDismissedReason;
  readonly dismissed_comment?: CodeScanningAlertDismissedComment;
  readonly rule: CodeScanningAlertRuleSummary;
  readonly tool: CodeScanningAnalysisTool;
  readonly most_recent_instance: CodeScanningAlertInstance;
};

export type CodeScanningListAlertsForRepo200ResponseBody = ReadonlyArray<CodeScanningAlertItems>;

export type CodeScanningListAlertsForRepo403ResponseBody = BasicError;

export type CodeScanningListAlertsForRepo404ResponseBody = BasicError;

export type CodeScanningListAlertsForRepo503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningListAlertsForRepoRequestQuery = {
  readonly tool_name?: CodeScanningAnalysisToolName;
  readonly tool_guid?: CodeScanningAnalysisToolGuid;
  readonly page?: number;
  readonly per_page?: number;
  readonly ref?: CodeScanningRef;
  readonly direction?: 'asc' | 'desc';
  readonly sort?: 'created' | 'updated';
  readonly state?: CodeScanningAlertState;
};

export type CodeScanningListAlertsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodeScanningAlert = {
  readonly number: AlertNumber;
  readonly created_at: AlertCreatedAt;
  readonly updated_at?: AlertUpdatedAt;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly instances_url: AlertInstancesUrl;
  readonly state: CodeScanningAlertState;
  readonly fixed_at?: AlertFixedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_reason: CodeScanningAlertDismissedReason;
  readonly dismissed_comment?: CodeScanningAlertDismissedComment;
  readonly rule: CodeScanningAlertRule;
  readonly tool: CodeScanningAnalysisTool;
  readonly most_recent_instance: CodeScanningAlertInstance;
};

export type CodeScanningGetAlert200ResponseBody = CodeScanningAlert;

export type CodeScanningGetAlert403ResponseBody = BasicError;

export type CodeScanningGetAlert404ResponseBody = BasicError;

export type CodeScanningGetAlert503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningGetAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type CodeScanningUpdateAlert200ResponseBody = CodeScanningAlert;

export type CodeScanningUpdateAlert403ResponseBody = BasicError;

export type CodeScanningUpdateAlert404ResponseBody = BasicError;

export type CodeScanningUpdateAlert503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningAlertSetState = 'open' | 'dismissed';

export type CodeScanningUpdateAlertRequestBody = {
  readonly state: CodeScanningAlertSetState;
  readonly dismissed_reason?: CodeScanningAlertDismissedReason;
  readonly dismissed_comment?: CodeScanningAlertDismissedComment;
};

export type CodeScanningUpdateAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type CodeScanningListAlertInstances200ResponseBody = ReadonlyArray<CodeScanningAlertInstance>;

export type CodeScanningListAlertInstances403ResponseBody = BasicError;

export type CodeScanningListAlertInstances404ResponseBody = BasicError;

export type CodeScanningListAlertInstances503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningListAlertInstancesRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
  readonly ref?: CodeScanningRef;
};

export type CodeScanningListAlertInstancesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type CodeScanningAnalysisCommitSha = string;

export type CodeScanningAnalysisEnvironment = string;

export type CodeScanningAnalysisCreatedAt = string;

export type CodeScanningAnalysisUrl = string;

export type CodeScanningAnalysisSarifId = string;

export type CodeScanningAnalysis = {
  readonly ref: CodeScanningRef;
  readonly commit_sha: CodeScanningAnalysisCommitSha;
  readonly analysis_key: CodeScanningAnalysisAnalysisKey;
  readonly environment: CodeScanningAnalysisEnvironment;
  readonly category?: CodeScanningAnalysisCategory;
  readonly error: string;
  readonly created_at: CodeScanningAnalysisCreatedAt;
  readonly results_count: number;
  readonly rules_count: number;
  readonly id: number;
  readonly url: CodeScanningAnalysisUrl;
  readonly sarif_id: CodeScanningAnalysisSarifId;
  readonly tool: CodeScanningAnalysisTool;
  readonly deletable: boolean;
  readonly warning: string;
};

export type CodeScanningListRecentAnalyses200ResponseBody = ReadonlyArray<CodeScanningAnalysis>;

export type CodeScanningListRecentAnalyses403ResponseBody = BasicError;

export type CodeScanningListRecentAnalyses404ResponseBody = BasicError;

export type CodeScanningListRecentAnalyses503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningListRecentAnalysesRequestQuery = {
  readonly tool_name?: CodeScanningAnalysisToolName;
  readonly tool_guid?: CodeScanningAnalysisToolGuid;
  readonly page?: number;
  readonly per_page?: number;
  readonly ref?: CodeScanningRef;
  readonly sarif_id?: CodeScanningAnalysisSarifId;
  readonly direction?: 'asc' | 'desc';
  readonly sort?: 'created';
};

export type CodeScanningListRecentAnalysesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodeScanningGetAnalysis200ResponseBody = CodeScanningAnalysis;

export type CodeScanningGetAnalysis403ResponseBody = BasicError;

export type CodeScanningGetAnalysis404ResponseBody = BasicError;

export type CodeScanningGetAnalysis503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningGetAnalysisRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly analysis_id: number;
};

export type AnalysisDeletion = {
  readonly next_analysis_url: string | null;
  readonly confirm_delete_url: string | null;
};

export type CodeScanningDeleteAnalysis200ResponseBody = AnalysisDeletion;

export type CodeScanningDeleteAnalysis400ResponseBody = BasicError;

export type CodeScanningDeleteAnalysis403ResponseBody = BasicError;

export type CodeScanningDeleteAnalysis404ResponseBody = BasicError;

export type CodeScanningDeleteAnalysis503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningDeleteAnalysisRequestQuery = {
  readonly confirm_delete?: string | null;
};

export type CodeScanningDeleteAnalysisRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly analysis_id: number;
};

export type CodeQlDatabase = {
  readonly id: number;
  readonly name: string;
  readonly language: string;
  readonly uploader: SimpleUser;
  readonly content_type: string;
  readonly size: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly url: string;
};

export type CodeScanningListCodeqlDatabases200ResponseBody = ReadonlyArray<CodeQlDatabase>;

export type CodeScanningListCodeqlDatabases403ResponseBody = BasicError;

export type CodeScanningListCodeqlDatabases404ResponseBody = BasicError;

export type CodeScanningListCodeqlDatabases503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningListCodeqlDatabasesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodeScanningGetCodeqlDatabase200ResponseBody = CodeQlDatabase;

export type CodeScanningGetCodeqlDatabase403ResponseBody = BasicError;

export type CodeScanningGetCodeqlDatabase404ResponseBody = BasicError;

export type CodeScanningGetCodeqlDatabase503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningGetCodeqlDatabaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly language: string;
};

export type CodeScanningSarifsReceipt = {
  readonly id?: CodeScanningAnalysisSarifId;
  readonly url?: string;
};

export type CodeScanningUploadSarif202ResponseBody = CodeScanningSarifsReceipt;

export type CodeScanningUploadSarif403ResponseBody = BasicError;

export type CodeScanningUploadSarif404ResponseBody = BasicError;

export type CodeScanningUploadSarif503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningAnalysisSarifFile = string;

export type CodeScanningUploadSarifRequestBody = {
  readonly commit_sha: CodeScanningAnalysisCommitSha;
  readonly ref: CodeScanningRef;
  readonly sarif: CodeScanningAnalysisSarifFile;
  readonly checkout_uri?: string;
  readonly started_at?: string;
  readonly tool_name?: string;
  readonly validate?: boolean;
};

export type CodeScanningUploadSarifRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodeScanningSarifsStatus = {
  readonly processing_status?: 'pending' | 'complete' | 'failed';
  readonly analyses_url?: string | null;
  readonly errors?: ReadonlyArray<string> | null;
};

export type CodeScanningGetSarif200ResponseBody = CodeScanningSarifsStatus;

export type CodeScanningGetSarif403ResponseBody = BasicError;

export type CodeScanningGetSarif503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningGetSarifRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly sarif_id: string;
};

export type CodeownersErrors = {
  readonly errors: ReadonlyArray<{
    readonly line: number;
    readonly column: number;
    readonly source?: string;
    readonly kind: string;
    readonly suggestion?: string | null;
    readonly message: string;
    readonly path: string;
  }>;
};

export type ReposCodeownersErrors200ResponseBody = CodeownersErrors;

export type ReposCodeownersErrorsRequestQuery = { readonly ref?: string };

export type ReposCodeownersErrorsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesListInRepositoryForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly codespaces: ReadonlyArray<Codespace>;
};

export type CodespacesListInRepositoryForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesListInRepositoryForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesListInRepositoryForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesListInRepositoryForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesListInRepositoryForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesListInRepositoryForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesCreateWithRepoForAuthenticatedUser201ResponseBody = Codespace;

export type CodespacesCreateWithRepoForAuthenticatedUser202ResponseBody = Codespace;

export type CodespacesCreateWithRepoForAuthenticatedUser400ResponseBody = BasicError;

export type CodespacesCreateWithRepoForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesCreateWithRepoForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesCreateWithRepoForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesCreateWithRepoForAuthenticatedUser503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodespacesCreateWithRepoForAuthenticatedUserRequestBody = {
  readonly ref?: string;
  readonly location?: string;
  readonly client_ip?: string;
  readonly machine?: string;
  readonly devcontainer_path?: string;
  readonly multi_repo_permissions_opt_out?: boolean;
  readonly working_directory?: string;
  readonly idle_timeout_minutes?: number;
  readonly display_name?: string;
  readonly retention_period_minutes?: number;
} | null;

export type CodespacesCreateWithRepoForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly devcontainers: ReadonlyArray<{
    readonly path: string;
    readonly name?: string;
  }>;
};

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser400ResponseBody = BasicError;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesRepoMachinesForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly machines: ReadonlyArray<CodespaceMachine>;
};

export type CodespacesRepoMachinesForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesRepoMachinesForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesRepoMachinesForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesRepoMachinesForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesRepoMachinesForAuthenticatedUserRequestQuery = {
  readonly location?: string;
  readonly client_ip?: string;
};

export type CodespacesRepoMachinesForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesPreFlightWithRepoForAuthenticatedUser200ResponseBody = {
  readonly billable_owner?: SimpleUser;
  readonly defaults?: {
    readonly location: string;
    readonly devcontainer_path: string | null;
  };
};

export type CodespacesPreFlightWithRepoForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesPreFlightWithRepoForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesPreFlightWithRepoForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesPreFlightWithRepoForAuthenticatedUserRequestQuery = {
  readonly ref?: string;
  readonly client_ip?: string;
};

export type CodespacesPreFlightWithRepoForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesListRepoSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<CodespacesSecret>;
};

export type CodespacesListRepoSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesListRepoSecretsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesGetRepoPublicKey200ResponseBody = CodespacesPublicKey;

export type CodespacesGetRepoPublicKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesGetRepoSecret200ResponseBody = CodespacesSecret;

export type CodespacesGetRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type CodespacesCreateOrUpdateRepoSecret201ResponseBody = EmptyObject;

export type CodespacesCreateOrUpdateRepoSecretRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id?: string;
};

export type CodespacesCreateOrUpdateRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type CodespacesDeleteRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type Collaborator = {
  readonly login: string;
  readonly id: number;
  readonly email?: string | null;
  readonly name?: string | null;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly site_admin: boolean;
  readonly permissions?: {
    readonly pull: boolean;
    readonly triage?: boolean;
    readonly push: boolean;
    readonly maintain?: boolean;
    readonly admin: boolean;
  };
  readonly role_name: string;
};

export type ReposListCollaborators200ResponseBody = ReadonlyArray<Collaborator>;

export type ReposListCollaborators404ResponseBody = BasicError;

export type ReposListCollaboratorsRequestQuery = {
  readonly affiliation?: 'outside' | 'direct' | 'all';
  readonly permission?: 'pull' | 'triage' | 'push' | 'maintain' | 'admin';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListCollaboratorsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCheckCollaboratorRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly username: string;
};

export type RepositoryInvitation = {
  readonly id: number;
  readonly repository: MinimalRepository;
  readonly invitee: SimpleUser;
  readonly inviter: SimpleUser;
  readonly permissions: 'read' | 'write' | 'admin' | 'triage' | 'maintain';
  readonly created_at: string;
  readonly expired?: boolean;
  readonly url: string;
  readonly html_url: string;
  readonly node_id: string;
};

export type ReposAddCollaborator201ResponseBody = RepositoryInvitation;

export type ReposAddCollaborator403ResponseBody = BasicError;

export type ReposAddCollaborator422ResponseBody = ValidationError;

export type ReposAddCollaboratorRequestBody = { readonly permission?: string };

export type ReposAddCollaboratorRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly username: string;
};

export type ReposRemoveCollaboratorRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly username: string;
};

export type RepositoryCollaboratorPermission = {
  readonly permission: string;
  readonly role_name: string;
  readonly user: Collaborator;
};

export type ReposGetCollaboratorPermissionLevel200ResponseBody = RepositoryCollaboratorPermission;

export type ReposGetCollaboratorPermissionLevel404ResponseBody = BasicError;

export type ReposGetCollaboratorPermissionLevelRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly username: string;
};

export type CommitComment = {
  readonly html_url: string;
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly body: string;
  readonly path: string | null;
  readonly position: number | null;
  readonly line: number | null;
  readonly commit_id: string;
  readonly user: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly author_association: AuthorAssociation;
  readonly reactions?: ReactionRollup;
};

export type ReposListCommitCommentsForRepo200ResponseBody = ReadonlyArray<CommitComment>;

export type ReposListCommitCommentsForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListCommitCommentsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetCommitComment200ResponseBody = CommitComment;

export type ReposGetCommitComment404ResponseBody = BasicError;

export type ReposGetCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReposUpdateCommitComment200ResponseBody = CommitComment;

export type ReposUpdateCommitComment404ResponseBody = BasicError;

export type ReposUpdateCommitCommentRequestBody = { readonly body: string };

export type ReposUpdateCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReposDeleteCommitComment404ResponseBody = BasicError;

export type ReposDeleteCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsListForCommitComment200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForCommitComment404ResponseBody = BasicError;

export type ReactionsListForCommitCommentRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsCreateForCommitComment200ResponseBody = Reaction;

export type ReactionsCreateForCommitComment201ResponseBody = Reaction;

export type ReactionsCreateForCommitComment422ResponseBody = ValidationError;

export type ReactionsCreateForCommitCommentRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsDeleteForCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
  readonly reaction_id: number;
};

export type ReposListCommits200ResponseBody = ReadonlyArray<Commit>;

export type ReposListCommits400ResponseBody = BasicError;

export type ReposListCommits404ResponseBody = BasicError;

export type ReposListCommits409ResponseBody = BasicError;

export type ReposListCommits500ResponseBody = BasicError;

export type ReposListCommitsRequestQuery = {
  readonly sha?: string;
  readonly path?: string;
  readonly author?: string;
  readonly since?: string;
  readonly until?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListCommitsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type BranchShort = {
  readonly name: string;
  readonly commit: { readonly sha: string; readonly url: string };
  readonly protected: boolean;
};

export type ReposListBranchesForHeadCommit200ResponseBody = ReadonlyArray<BranchShort>;

export type ReposListBranchesForHeadCommit422ResponseBody = ValidationError;

export type ReposListBranchesForHeadCommitRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly commit_sha: string;
};

export type ReposListCommentsForCommit200ResponseBody = ReadonlyArray<CommitComment>;

export type ReposListCommentsForCommitRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListCommentsForCommitRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly commit_sha: string;
};

export type ReposCreateCommitComment201ResponseBody = CommitComment;

export type ReposCreateCommitComment403ResponseBody = BasicError;

export type ReposCreateCommitComment422ResponseBody = ValidationError;

export type ReposCreateCommitCommentRequestBody = {
  readonly body: string;
  readonly path?: string;
  readonly position?: number;
  readonly line?: number;
};

export type ReposCreateCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly commit_sha: string;
};

export type Link = { readonly href: string };

export type AutoMerge = {
  readonly enabled_by: SimpleUser;
  readonly merge_method: 'merge' | 'squash' | 'rebase';
  readonly commit_title: string;
  readonly commit_message: string;
} | null;

export type PullRequestSimple = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly html_url: string;
  readonly diff_url: string;
  readonly patch_url: string;
  readonly issue_url: string;
  readonly commits_url: string;
  readonly review_comments_url: string;
  readonly review_comment_url: string;
  readonly comments_url: string;
  readonly statuses_url: string;
  readonly number: number;
  readonly state: string;
  readonly locked: boolean;
  readonly title: string;
  readonly user: SimpleUser;
  readonly body: string | null;
  readonly labels: ReadonlyArray<{
    readonly id: number;
    readonly node_id: string;
    readonly url: string;
    readonly name: string;
    readonly description: string;
    readonly color: string;
    readonly default: boolean;
  }>;
  readonly milestone: Milestone;
  readonly active_lock_reason?: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly closed_at: string | null;
  readonly merged_at: string | null;
  readonly merge_commit_sha: string | null;
  readonly assignee: SimpleUser;
  readonly assignees?: ReadonlyArray<SimpleUser> | null;
  readonly requested_reviewers?: ReadonlyArray<SimpleUser> | null;
  readonly requested_teams?: ReadonlyArray<Team> | null;
  readonly head: {
    readonly label: string;
    readonly ref: string;
    readonly repo: Repository;
    readonly sha: string;
    readonly user: SimpleUser;
  };
  readonly base: {
    readonly label: string;
    readonly ref: string;
    readonly repo: Repository;
    readonly sha: string;
    readonly user: SimpleUser;
  };
  readonly _links: {
    readonly comments: Link;
    readonly commits: Link;
    readonly statuses: Link;
    readonly html: Link;
    readonly issue: Link;
    readonly review_comments: Link;
    readonly review_comment: Link;
    readonly self: Link;
  };
  readonly author_association: AuthorAssociation;
  readonly auto_merge: AutoMerge;
  readonly draft?: boolean;
};

export type ReposListPullRequestsAssociatedWithCommit200ResponseBody = ReadonlyArray<PullRequestSimple>;

export type ReposListPullRequestsAssociatedWithCommitRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListPullRequestsAssociatedWithCommitRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly commit_sha: string;
};

export type ReposGetCommit200ResponseBody = Commit;

export type ReposGetCommit404ResponseBody = BasicError;

export type ReposGetCommit422ResponseBody = ValidationError;

export type ReposGetCommit500ResponseBody = BasicError;

export type ReposGetCommit503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type ReposGetCommitRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type ReposGetCommitRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type ChecksListForRef200ResponseBody = {
  readonly total_count: number;
  readonly check_runs: ReadonlyArray<CheckRun>;
};

export type ChecksListForRefRequestQuery = {
  readonly check_name?: string;
  readonly status?: 'queued' | 'in_progress' | 'completed';
  readonly filter?: 'latest' | 'all';
  readonly per_page?: number;
  readonly page?: number;
  readonly app_id?: number;
};

export type ChecksListForRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type ChecksListSuitesForRef200ResponseBody = {
  readonly total_count: number;
  readonly check_suites: ReadonlyArray<CheckSuite>;
};

export type ChecksListSuitesForRefRequestQuery = {
  readonly app_id?: number;
  readonly check_name?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type ChecksListSuitesForRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type SimpleCommitStatus = {
  readonly description: string | null;
  readonly id: number;
  readonly node_id: string;
  readonly state: string;
  readonly context: string;
  readonly target_url: string | null;
  readonly required?: boolean | null;
  readonly avatar_url: string | null;
  readonly url: string;
  readonly created_at: string;
  readonly updated_at: string;
};

export type CombinedCommitStatus = {
  readonly state: string;
  readonly statuses: ReadonlyArray<SimpleCommitStatus>;
  readonly sha: string;
  readonly total_count: number;
  readonly repository: MinimalRepository;
  readonly commit_url: string;
  readonly url: string;
};

export type ReposGetCombinedStatusForRef200ResponseBody = CombinedCommitStatus;

export type ReposGetCombinedStatusForRef404ResponseBody = BasicError;

export type ReposGetCombinedStatusForRefRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposGetCombinedStatusForRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type Status = {
  readonly url: string;
  readonly avatar_url: string | null;
  readonly id: number;
  readonly node_id: string;
  readonly state: string;
  readonly description: string | null;
  readonly target_url: string | null;
  readonly context: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly creator: SimpleUser;
};

export type ReposListCommitStatusesForRef200ResponseBody = ReadonlyArray<Status>;

export type ReposListCommitStatusesForRef301ResponseBody = BasicError;

export type ReposListCommitStatusesForRefRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListCommitStatusesForRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type CommunityHealthFile = {
  readonly url: string;
  readonly html_url: string;
} | null;

export type CommunityProfile = {
  readonly health_percentage: number;
  readonly description: string | null;
  readonly documentation: string | null;
  readonly files: {
    readonly code_of_conduct: CodeOfConductSimple;
    readonly code_of_conduct_file: CommunityHealthFile;
    readonly license: LicenseSimple;
    readonly contributing: CommunityHealthFile;
    readonly readme: CommunityHealthFile;
    readonly issue_template: CommunityHealthFile;
    readonly pull_request_template: CommunityHealthFile;
  };
  readonly updated_at: string | null;
  readonly content_reports_enabled?: boolean;
};

export type ReposGetCommunityProfileMetrics200ResponseBody = CommunityProfile;

export type ReposGetCommunityProfileMetricsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CommitComparison = {
  readonly url: string;
  readonly html_url: string;
  readonly permalink_url: string;
  readonly diff_url: string;
  readonly patch_url: string;
  readonly base_commit: Commit;
  readonly merge_base_commit: Commit;
  readonly status: 'diverged' | 'ahead' | 'behind' | 'identical';
  readonly ahead_by: number;
  readonly behind_by: number;
  readonly total_commits: number;
  readonly commits: ReadonlyArray<Commit>;
  readonly files?: ReadonlyArray<DiffEntry>;
};

export type ReposCompareCommits200ResponseBody = CommitComparison;

export type ReposCompareCommits404ResponseBody = BasicError;

export type ReposCompareCommits500ResponseBody = BasicError;

export type ReposCompareCommits503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type ReposCompareCommitsRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type ReposCompareCommitsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly basehead: string;
};

export type ContentDirectory = ReadonlyArray<{
  readonly type: 'dir' | 'file' | 'submodule' | 'symlink';
  readonly size: number;
  readonly name: string;
  readonly path: string;
  readonly content?: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string | null;
  readonly html_url: string | null;
  readonly download_url: string | null;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
}>;

export type ContentFile = {
  readonly type: 'file';
  readonly encoding: string;
  readonly size: number;
  readonly name: string;
  readonly path: string;
  readonly content: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string | null;
  readonly html_url: string | null;
  readonly download_url: string | null;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
  readonly target?: string;
  readonly submodule_git_url?: string;
};

export type SymlinkContent = {
  readonly type: 'symlink';
  readonly target: string;
  readonly size: number;
  readonly name: string;
  readonly path: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string | null;
  readonly html_url: string | null;
  readonly download_url: string | null;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
};

export type SubmoduleContent = {
  readonly type: 'submodule';
  readonly submodule_git_url: string;
  readonly size: number;
  readonly name: string;
  readonly path: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string | null;
  readonly html_url: string | null;
  readonly download_url: string | null;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
};

export type ReposGetContent200ResponseBody =
  | ContentDirectory
  | ContentFile
  | SymlinkContent
  | SubmoduleContent;

export type ReposGetContent403ResponseBody = BasicError;

export type ReposGetContent404ResponseBody = BasicError;

export type ReposGetContentRequestQuery = { readonly ref?: string };

export type ReposGetContentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly path: string;
};

export type FileCommit = {
  readonly content: {
    readonly name?: string;
    readonly path?: string;
    readonly sha?: string;
    readonly size?: number;
    readonly url?: string;
    readonly html_url?: string;
    readonly git_url?: string;
    readonly download_url?: string;
    readonly type?: string;
    readonly _links?: {
      readonly self?: string;
      readonly git?: string;
      readonly html?: string;
    };
  } | null;
  readonly commit: {
    readonly sha?: string;
    readonly node_id?: string;
    readonly url?: string;
    readonly html_url?: string;
    readonly author?: {
      readonly date?: string;
      readonly name?: string;
      readonly email?: string;
    };
    readonly committer?: {
      readonly date?: string;
      readonly name?: string;
      readonly email?: string;
    };
    readonly message?: string;
    readonly tree?: { readonly url?: string; readonly sha?: string };
    readonly parents?: ReadonlyArray<{
      readonly url?: string;
      readonly html_url?: string;
      readonly sha?: string;
    }>;
    readonly verification?: {
      readonly verified?: boolean;
      readonly reason?: string;
      readonly signature?: string | null;
      readonly payload?: string | null;
    };
  };
};

export type ReposCreateOrUpdateFileContents200ResponseBody = FileCommit;

export type ReposCreateOrUpdateFileContents201ResponseBody = FileCommit;

export type ReposCreateOrUpdateFileContents404ResponseBody = BasicError;

export type ReposCreateOrUpdateFileContents409ResponseBody = BasicError;

export type ReposCreateOrUpdateFileContents422ResponseBody = ValidationError;

export type ReposCreateOrUpdateFileContentsRequestBody = {
  readonly message: string;
  readonly content: string;
  readonly sha?: string;
  readonly branch?: string;
  readonly committer?: {
    readonly name: string;
    readonly email: string;
    readonly date?: string;
  };
  readonly author?: {
    readonly name: string;
    readonly email: string;
    readonly date?: string;
  };
};

export type ReposCreateOrUpdateFileContentsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly path: string;
};

export type ReposDeleteFile200ResponseBody = FileCommit;

export type ReposDeleteFile404ResponseBody = BasicError;

export type ReposDeleteFile409ResponseBody = BasicError;

export type ReposDeleteFile422ResponseBody = ValidationError;

export type ReposDeleteFile503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type ReposDeleteFileRequestBody = {
  readonly message: string;
  readonly sha: string;
  readonly branch?: string;
  readonly committer?: { readonly name?: string; readonly email?: string };
  readonly author?: { readonly name?: string; readonly email?: string };
};

export type ReposDeleteFileRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly path: string;
};

export type Contributor = {
  readonly login?: string;
  readonly id?: number;
  readonly node_id?: string;
  readonly avatar_url?: string;
  readonly gravatar_id?: string | null;
  readonly url?: string;
  readonly html_url?: string;
  readonly followers_url?: string;
  readonly following_url?: string;
  readonly gists_url?: string;
  readonly starred_url?: string;
  readonly subscriptions_url?: string;
  readonly organizations_url?: string;
  readonly repos_url?: string;
  readonly events_url?: string;
  readonly received_events_url?: string;
  readonly type: string;
  readonly site_admin?: boolean;
  readonly contributions: number;
  readonly email?: string;
  readonly name?: string;
};

export type ReposListContributors200ResponseBody = ReadonlyArray<Contributor>;

export type ReposListContributors403ResponseBody = BasicError;

export type ReposListContributors404ResponseBody = BasicError;

export type ReposListContributorsRequestQuery = {
  readonly anon?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListContributorsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type DependabotAlert = {
  readonly number: AlertNumber;
  readonly state: 'dismissed' | 'fixed' | 'open';
  readonly dependency: {
    readonly package?: DependabotAlertPackage;
    readonly manifest_path?: string;
    readonly scope?: 'development' | 'runtime' | null;
  };
  readonly security_advisory: DependabotAlertSecurityAdvisory;
  readonly security_vulnerability: DependabotAlertSecurityVulnerability;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly created_at: AlertCreatedAt;
  readonly updated_at: AlertUpdatedAt;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_reason:
    | 'fix_started'
    | 'inaccurate'
    | 'no_bandwidth'
    | 'not_used'
    | 'tolerable_risk'
    | null;
  readonly dismissed_comment: string | null;
  readonly fixed_at: AlertFixedAt;
};

export type DependabotListAlertsForRepo200ResponseBody = ReadonlyArray<DependabotAlert>;

export type DependabotListAlertsForRepo400ResponseBody = BasicError;

export type DependabotListAlertsForRepo403ResponseBody = BasicError;

export type DependabotListAlertsForRepo404ResponseBody = BasicError;

export type DependabotListAlertsForRepo422ResponseBody = ValidationErrorSimple;

export type DependabotListAlertsForRepoRequestQuery = {
  readonly state?: string;
  readonly severity?: string;
  readonly ecosystem?: string;
  readonly package?: string;
  readonly manifest?: string;
  readonly scope?: 'development' | 'runtime';
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly page?: number;
  readonly per_page?: number;
  readonly before?: string;
  readonly after?: string;
  readonly first?: number;
  readonly last?: number;
};

export type DependabotListAlertsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type DependabotGetAlert200ResponseBody = DependabotAlert;

export type DependabotGetAlert403ResponseBody = BasicError;

export type DependabotGetAlert404ResponseBody = BasicError;

export type DependabotGetAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type DependabotUpdateAlert200ResponseBody = DependabotAlert;

export type DependabotUpdateAlert400ResponseBody = BasicError;

export type DependabotUpdateAlert403ResponseBody = BasicError;

export type DependabotUpdateAlert404ResponseBody = BasicError;

export type DependabotUpdateAlert409ResponseBody = BasicError;

export type DependabotUpdateAlert422ResponseBody = ValidationErrorSimple;

export type DependabotUpdateAlertRequestBody = {
  readonly state: 'dismissed' | 'open';
  readonly dismissed_reason?:
    | 'fix_started'
    | 'inaccurate'
    | 'no_bandwidth'
    | 'not_used'
    | 'tolerable_risk';
  readonly dismissed_comment?: string;
};

export type DependabotUpdateAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type DependabotSecret = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
};

export type DependabotListRepoSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<DependabotSecret>;
};

export type DependabotListRepoSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type DependabotListRepoSecretsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type DependabotGetRepoPublicKey200ResponseBody = DependabotPublicKey;

export type DependabotGetRepoPublicKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type DependabotGetRepoSecret200ResponseBody = DependabotSecret;

export type DependabotGetRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type DependabotCreateOrUpdateRepoSecret201ResponseBody = EmptyObject;

export type DependabotCreateOrUpdateRepoSecretRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id?: string;
};

export type DependabotCreateOrUpdateRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type DependabotDeleteRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type DependencyGraphDiff = ReadonlyArray<{
  readonly change_type: 'added' | 'removed';
  readonly manifest: string;
  readonly ecosystem: string;
  readonly name: string;
  readonly version: string;
  readonly package_url: string | null;
  readonly license: string | null;
  readonly source_repository_url: string | null;
  readonly vulnerabilities: ReadonlyArray<{
    readonly severity: string;
    readonly advisory_ghsa_id: string;
    readonly advisory_summary: string;
    readonly advisory_url: string;
  }>;
  readonly scope: 'unknown' | 'runtime' | 'development';
}>;

export type DependencyGraphDiffRange200ResponseBody = DependencyGraphDiff;

export type DependencyGraphDiffRange403ResponseBody = BasicError;

export type DependencyGraphDiffRange404ResponseBody = BasicError;

export type DependencyGraphDiffRangeRequestQuery = { readonly name?: string };

export type DependencyGraphDiffRangeRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly basehead: string;
};

export type DependencyGraphCreateRepositorySnapshot201ResponseBody = {
  readonly id: number;
  readonly created_at: string;
  readonly result: string;
  readonly message: string;
};

export type Metadata = unknown;

export type Snapshot = {
  readonly version: number;
  readonly job: {
    readonly id: string;
    readonly correlator: string;
    readonly html_url?: string;
  };
  readonly sha: string;
  readonly ref: string;
  readonly detector: {
    readonly name: string;
    readonly version: string;
    readonly url: string;
  };
  readonly metadata?: Metadata;
  readonly manifests?: unknown;
  readonly scanned: string;
};

export type DependencyGraphCreateRepositorySnapshotRequestBody = Snapshot;

export type DependencyGraphCreateRepositorySnapshotRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposListDeployments200ResponseBody = ReadonlyArray<Deployment>;

export type ReposListDeploymentsRequestQuery = {
  readonly sha?: string;
  readonly ref?: string;
  readonly task?: string;
  readonly environment?: string | null;
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListDeploymentsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateDeployment201ResponseBody = Deployment;

export type ReposCreateDeployment202ResponseBody = {
  readonly message?: string;
};

export type ReposCreateDeployment422ResponseBody = ValidationError;

export type ReposCreateDeploymentRequestBody = {
  readonly ref: string;
  readonly task?: string;
  readonly auto_merge?: boolean;
  readonly required_contexts?: ReadonlyArray<string>;
  readonly payload?: unknown | string;
  readonly environment?: string;
  readonly description?: string | null;
  readonly transient_environment?: boolean;
  readonly production_environment?: boolean;
};

export type ReposCreateDeploymentRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetDeployment200ResponseBody = Deployment;

export type ReposGetDeployment404ResponseBody = BasicError;

export type ReposGetDeploymentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly deployment_id: number;
};

export type ReposDeleteDeployment404ResponseBody = BasicError;

export type ReposDeleteDeployment422ResponseBody = ValidationErrorSimple;

export type ReposDeleteDeploymentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly deployment_id: number;
};

export type DeploymentStatus = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly state:
    | 'error'
    | 'failure'
    | 'inactive'
    | 'pending'
    | 'success'
    | 'queued'
    | 'in_progress';
  readonly creator: SimpleUser;
  readonly description: string;
  readonly environment?: string;
  readonly target_url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly deployment_url: string;
  readonly repository_url: string;
  readonly environment_url?: string;
  readonly log_url?: string;
  readonly performed_via_github_app?: GitHubApp;
};

export type ReposListDeploymentStatuses200ResponseBody = ReadonlyArray<DeploymentStatus>;

export type ReposListDeploymentStatuses404ResponseBody = BasicError;

export type ReposListDeploymentStatusesRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListDeploymentStatusesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly deployment_id: number;
};

export type ReposCreateDeploymentStatus201ResponseBody = DeploymentStatus;

export type ReposCreateDeploymentStatus422ResponseBody = ValidationError;

export type ReposCreateDeploymentStatusRequestBody = {
  readonly state:
    | 'error'
    | 'failure'
    | 'inactive'
    | 'in_progress'
    | 'queued'
    | 'pending'
    | 'success';
  readonly target_url?: string;
  readonly log_url?: string;
  readonly description?: string;
  readonly environment?: 'production' | 'staging' | 'qa';
  readonly environment_url?: string;
  readonly auto_inactive?: boolean;
};

export type ReposCreateDeploymentStatusRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly deployment_id: number;
};

export type ReposGetDeploymentStatus200ResponseBody = DeploymentStatus;

export type ReposGetDeploymentStatus404ResponseBody = BasicError;

export type ReposGetDeploymentStatusRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly deployment_id: number;
  readonly status_id: number;
};

export type ReposCreateDispatchEvent422ResponseBody = ValidationError;

export type ReposCreateDispatchEventRequestBody = {
  readonly event_type: string;
  readonly client_payload?: unknown;
};

export type ReposCreateDispatchEventRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type WaitTimer = number;

export type DeploymentBranchPolicySettings = {
  readonly protected_branches: boolean;
  readonly custom_branch_policies: boolean;
} | null;

export type Environment = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly url: string;
  readonly html_url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly protection_rules?: ReadonlyArray<
    | {
        readonly id: number;
        readonly node_id: string;
        readonly type: string;
        readonly wait_timer?: WaitTimer;
      }
    | {
        readonly id: number;
        readonly node_id: string;
        readonly type: string;
        readonly reviewers?: ReadonlyArray<{
          readonly type?: DeploymentReviewerType;
          readonly reviewer?: SimpleUser | Team;
        }>;
      }
    | { readonly id: number; readonly node_id: string; readonly type: string }
  >;
  readonly deployment_branch_policy?: DeploymentBranchPolicySettings;
};

export type ReposGetAllEnvironments200ResponseBody = {
  readonly total_count?: number;
  readonly environments?: ReadonlyArray<Environment>;
};

export type ReposGetAllEnvironmentsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposGetAllEnvironmentsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetEnvironment200ResponseBody = Environment;

export type ReposGetEnvironmentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
};

export type ReposCreateOrUpdateEnvironment200ResponseBody = Environment;

export type ReposCreateOrUpdateEnvironment422ResponseBody = BasicError;

export type ReposCreateOrUpdateEnvironmentRequestBody = {
  readonly wait_timer?: WaitTimer;
  readonly reviewers?: ReadonlyArray<{
    readonly type?: DeploymentReviewerType;
    readonly id?: number;
  }> | null;
  readonly deployment_branch_policy?: DeploymentBranchPolicySettings;
} | null;

export type ReposCreateOrUpdateEnvironmentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
};

export type ReposDeleteAnEnvironmentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
};

export type DeploymentBranchPolicy = {
  readonly id?: number;
  readonly node_id?: string;
  readonly name?: string;
};

export type ReposListDeploymentBranchPolicies200ResponseBody = {
  readonly total_count: number;
  readonly branch_policies: ReadonlyArray<DeploymentBranchPolicy>;
};

export type ReposListDeploymentBranchPoliciesRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListDeploymentBranchPoliciesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
};

export type ReposCreateDeploymentBranchPolicy200ResponseBody = DeploymentBranchPolicy;

export type DeploymentBranchPolicyNamePattern = { readonly name: string };

export type ReposCreateDeploymentBranchPolicyRequestBody = DeploymentBranchPolicyNamePattern;

export type ReposCreateDeploymentBranchPolicyRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
};

export type ReposGetDeploymentBranchPolicy200ResponseBody = DeploymentBranchPolicy;

export type ReposGetDeploymentBranchPolicyRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
  readonly branch_policy_id: number;
};

export type ReposUpdateDeploymentBranchPolicy200ResponseBody = DeploymentBranchPolicy;

export type ReposUpdateDeploymentBranchPolicyRequestBody = DeploymentBranchPolicyNamePattern;

export type ReposUpdateDeploymentBranchPolicyRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
  readonly branch_policy_id: number;
};

export type ReposDeleteDeploymentBranchPolicyRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
  readonly branch_policy_id: number;
};

export type ActivityListRepoEvents200ResponseBody = ReadonlyArray<Event>;

export type ActivityListRepoEventsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListRepoEventsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposListForks200ResponseBody = ReadonlyArray<MinimalRepository>;

export type ReposListForks400ResponseBody = BasicError;

export type ReposListForksRequestQuery = {
  readonly sort?: 'newest' | 'oldest' | 'stargazers' | 'watchers';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListForksRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateFork202ResponseBody = FullRepository;

export type ReposCreateFork400ResponseBody = BasicError;

export type ReposCreateFork403ResponseBody = BasicError;

export type ReposCreateFork404ResponseBody = BasicError;

export type ReposCreateFork422ResponseBody = ValidationError;

export type ReposCreateForkRequestBody = {
  readonly organization?: string;
  readonly name?: string;
  readonly default_branch_only?: boolean;
} | null;

export type ReposCreateForkRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ShortBlob = { readonly url: string; readonly sha: string };

export type GitCreateBlob201ResponseBody = ShortBlob;

export type GitCreateBlob403ResponseBody = BasicError;

export type GitCreateBlob404ResponseBody = BasicError;

export type GitCreateBlob409ResponseBody = BasicError;

export type GitCreateBlob422ResponseBody = ValidationError;

export type GitCreateBlobRequestBody = {
  readonly content: string;
  readonly encoding?: string;
};

export type GitCreateBlobRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type Blob = {
  readonly content: string;
  readonly encoding: string;
  readonly url: string;
  readonly sha: string;
  readonly size: number | null;
  readonly node_id: string;
  readonly highlighted_content?: string;
};

export type GitGetBlob200ResponseBody = Blob;

export type GitGetBlob403ResponseBody = BasicError;

export type GitGetBlob404ResponseBody = BasicError;

export type GitGetBlob422ResponseBody = ValidationError;

export type GitGetBlobRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly file_sha: string;
};

export type GitCommit = {
  readonly sha: string;
  readonly node_id: string;
  readonly url: string;
  readonly author: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly committer: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly message: string;
  readonly tree: { readonly sha: string; readonly url: string };
  readonly parents: ReadonlyArray<{
    readonly sha: string;
    readonly url: string;
    readonly html_url: string;
  }>;
  readonly verification: {
    readonly verified: boolean;
    readonly reason: string;
    readonly signature: string | null;
    readonly payload: string | null;
  };
  readonly html_url: string;
};

export type GitCreateCommit201ResponseBody = GitCommit;

export type GitCreateCommit404ResponseBody = BasicError;

export type GitCreateCommit422ResponseBody = ValidationError;

export type GitCreateCommitRequestBody = {
  readonly message: string;
  readonly tree: string;
  readonly parents?: ReadonlyArray<string>;
  readonly author?: {
    readonly name: string;
    readonly email: string;
    readonly date?: string;
  };
  readonly committer?: {
    readonly name?: string;
    readonly email?: string;
    readonly date?: string;
  };
  readonly signature?: string;
};

export type GitCreateCommitRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type GitGetCommit200ResponseBody = GitCommit;

export type GitGetCommit404ResponseBody = BasicError;

export type GitGetCommitRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly commit_sha: string;
};

export type GitReference = {
  readonly ref: string;
  readonly node_id: string;
  readonly url: string;
  readonly object: {
    readonly type: string;
    readonly sha: string;
    readonly url: string;
  };
};

export type GitListMatchingRefs200ResponseBody = ReadonlyArray<GitReference>;

export type GitListMatchingRefsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type GitGetRef200ResponseBody = GitReference;

export type GitGetRef404ResponseBody = BasicError;

export type GitGetRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type GitCreateRef201ResponseBody = GitReference;

export type GitCreateRef422ResponseBody = ValidationError;

export type GitCreateRefRequestBody = {
  readonly ref: string;
  readonly sha: string;
  readonly key?: string;
};

export type GitCreateRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type GitUpdateRef200ResponseBody = GitReference;

export type GitUpdateRef422ResponseBody = ValidationError;

export type GitUpdateRefRequestBody = {
  readonly sha: string;
  readonly force?: boolean;
};

export type GitUpdateRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type GitDeleteRef422ResponseBody = ValidationError;

export type GitDeleteRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type GitTag = {
  readonly node_id: string;
  readonly tag: string;
  readonly sha: string;
  readonly url: string;
  readonly message: string;
  readonly tagger: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly object: {
    readonly sha: string;
    readonly type: string;
    readonly url: string;
  };
  readonly verification?: Verification;
};

export type GitCreateTag201ResponseBody = GitTag;

export type GitCreateTag422ResponseBody = ValidationError;

export type GitCreateTagRequestBody = {
  readonly tag: string;
  readonly message: string;
  readonly object: string;
  readonly type: 'commit' | 'tree' | 'blob';
  readonly tagger?: {
    readonly name: string;
    readonly email: string;
    readonly date?: string;
  };
};

export type GitCreateTagRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type GitGetTag200ResponseBody = GitTag;

export type GitGetTag404ResponseBody = BasicError;

export type GitGetTagRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly tag_sha: string;
};

export type GitTree = {
  readonly sha: string;
  readonly url: string;
  readonly truncated: boolean;
  readonly tree: ReadonlyArray<{
    readonly path?: string;
    readonly mode?: string;
    readonly type?: string;
    readonly sha?: string;
    readonly size?: number;
    readonly url?: string;
  }>;
};

export type GitCreateTree201ResponseBody = GitTree;

export type GitCreateTree403ResponseBody = BasicError;

export type GitCreateTree404ResponseBody = BasicError;

export type GitCreateTree422ResponseBody = ValidationError;

export type GitCreateTreeRequestBody = {
  readonly tree: ReadonlyArray<{
    readonly path?: string;
    readonly mode?: '100644' | '100755' | '040000' | '160000' | '120000';
    readonly type?: 'blob' | 'tree' | 'commit';
    readonly sha?: string | null;
    readonly content?: string;
  }>;
  readonly base_tree?: string;
};

export type GitCreateTreeRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type GitGetTree200ResponseBody = GitTree;

export type GitGetTree404ResponseBody = BasicError;

export type GitGetTree422ResponseBody = ValidationError;

export type GitGetTreeRequestQuery = { readonly recursive?: string };

export type GitGetTreeRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly tree_sha: string;
};

export type HookResponse = {
  readonly code: number | null;
  readonly status: string | null;
  readonly message: string | null;
};

export type Webhook = {
  readonly type: string;
  readonly id: number;
  readonly name: string;
  readonly active: boolean;
  readonly events: ReadonlyArray<string>;
  readonly config: {
    readonly email?: string;
    readonly password?: string;
    readonly room?: string;
    readonly subdomain?: string;
    readonly url?: WebhookConfigUrl;
    readonly insecure_ssl?: WebhookConfigInsecureSsl;
    readonly content_type?: WebhookConfigContentType;
    readonly digest?: string;
    readonly secret?: WebhookConfigSecret;
    readonly token?: string;
  };
  readonly updated_at: string;
  readonly created_at: string;
  readonly url: string;
  readonly test_url: string;
  readonly ping_url: string;
  readonly deliveries_url?: string;
  readonly last_response: HookResponse;
};

export type ReposListWebhooks200ResponseBody = ReadonlyArray<Webhook>;

export type ReposListWebhooks404ResponseBody = BasicError;

export type ReposListWebhooksRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListWebhooksRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateWebhook201ResponseBody = Webhook;

export type ReposCreateWebhook403ResponseBody = BasicError;

export type ReposCreateWebhook404ResponseBody = BasicError;

export type ReposCreateWebhook422ResponseBody = ValidationError;

export type ReposCreateWebhookRequestBody = {
  readonly name?: string;
  readonly config?: {
    readonly url?: WebhookConfigUrl;
    readonly content_type?: WebhookConfigContentType;
    readonly secret?: WebhookConfigSecret;
    readonly insecure_ssl?: WebhookConfigInsecureSsl;
    readonly token?: string;
    readonly digest?: string;
  };
  readonly events?: ReadonlyArray<string>;
  readonly active?: boolean;
} | null;

export type ReposCreateWebhookRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetWebhook200ResponseBody = Webhook;

export type ReposGetWebhook404ResponseBody = BasicError;

export type ReposGetWebhookRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposUpdateWebhook200ResponseBody = Webhook;

export type ReposUpdateWebhook404ResponseBody = BasicError;

export type ReposUpdateWebhook422ResponseBody = ValidationError;

export type ReposUpdateWebhookRequestBody = {
  readonly config?: {
    readonly url: WebhookConfigUrl;
    readonly content_type?: WebhookConfigContentType;
    readonly secret?: WebhookConfigSecret;
    readonly insecure_ssl?: WebhookConfigInsecureSsl;
    readonly address?: string;
    readonly room?: string;
  };
  readonly events?: ReadonlyArray<string>;
  readonly add_events?: ReadonlyArray<string>;
  readonly remove_events?: ReadonlyArray<string>;
  readonly active?: boolean;
};

export type ReposUpdateWebhookRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposDeleteWebhook404ResponseBody = BasicError;

export type ReposDeleteWebhookRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposGetWebhookConfigForRepo200ResponseBody = WebhookConfiguration;

export type ReposGetWebhookConfigForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposUpdateWebhookConfigForRepo200ResponseBody = WebhookConfiguration;

export type ReposUpdateWebhookConfigForRepoRequestBody = {
  readonly url?: WebhookConfigUrl;
  readonly content_type?: WebhookConfigContentType;
  readonly secret?: WebhookConfigSecret;
  readonly insecure_ssl?: WebhookConfigInsecureSsl;
};

export type ReposUpdateWebhookConfigForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposListWebhookDeliveries200ResponseBody = ReadonlyArray<SimpleWebhookDelivery>;

export type ReposListWebhookDeliveries400ResponseBody = BasicError;

export type ReposListWebhookDeliveries422ResponseBody = ValidationError;

export type ReposListWebhookDeliveriesRequestQuery = {
  readonly per_page?: number;
  readonly cursor?: string;
};

export type ReposListWebhookDeliveriesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposGetWebhookDelivery200ResponseBody = WebhookDelivery;

export type ReposGetWebhookDelivery400ResponseBody = BasicError;

export type ReposGetWebhookDelivery422ResponseBody = ValidationError;

export type ReposGetWebhookDeliveryRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
  readonly delivery_id: number;
};

export type ReposRedeliverWebhookDelivery202ResponseBody = unknown;

export type ReposRedeliverWebhookDelivery400ResponseBody = BasicError;

export type ReposRedeliverWebhookDelivery422ResponseBody = ValidationError;

export type ReposRedeliverWebhookDeliveryRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
  readonly delivery_id: number;
};

export type ReposPingWebhook404ResponseBody = BasicError;

export type ReposPingWebhookRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposTestPushWebhook404ResponseBody = BasicError;

export type ReposTestPushWebhookRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type Import = {
  readonly vcs: string | null;
  readonly use_lfs?: boolean;
  readonly vcs_url: string;
  readonly svc_root?: string;
  readonly tfvc_project?: string;
  readonly status:
    | 'auth'
    | 'error'
    | 'none'
    | 'detecting'
    | 'choose'
    | 'auth_failed'
    | 'importing'
    | 'mapping'
    | 'waiting_to_push'
    | 'pushing'
    | 'complete'
    | 'setup'
    | 'unknown'
    | 'detection_found_multiple'
    | 'detection_found_nothing'
    | 'detection_needs_auth';
  readonly status_text?: string | null;
  readonly failed_step?: string | null;
  readonly error_message?: string | null;
  readonly import_percent?: number | null;
  readonly commit_count?: number | null;
  readonly push_percent?: number | null;
  readonly has_large_files?: boolean;
  readonly large_files_size?: number;
  readonly large_files_count?: number;
  readonly project_choices?: ReadonlyArray<{
    readonly vcs?: string;
    readonly tfvc_project?: string;
    readonly human_name?: string;
  }>;
  readonly message?: string;
  readonly authors_count?: number | null;
  readonly url: string;
  readonly html_url: string;
  readonly authors_url: string;
  readonly repository_url: string;
  readonly svn_root?: string;
};

export type MigrationsGetImportStatus200ResponseBody = Import;

export type MigrationsGetImportStatus404ResponseBody = BasicError;

export type MigrationsGetImportStatusRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MigrationsStartImport201ResponseBody = Import;

export type MigrationsStartImport404ResponseBody = BasicError;

export type MigrationsStartImport422ResponseBody = ValidationError;

export type MigrationsStartImportRequestBody = {
  readonly vcs_url: string;
  readonly vcs?: 'subversion' | 'git' | 'mercurial' | 'tfvc';
  readonly vcs_username?: string;
  readonly vcs_password?: string;
  readonly tfvc_project?: string;
};

export type MigrationsStartImportRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MigrationsUpdateImport200ResponseBody = Import;

export type MigrationsUpdateImportRequestBody = {
  readonly vcs_username?: string;
  readonly vcs_password?: string;
  readonly vcs?: 'subversion' | 'tfvc' | 'git' | 'mercurial';
  readonly tfvc_project?: string;
} | null;

export type MigrationsUpdateImportRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MigrationsCancelImportRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PorterAuthor = {
  readonly id: number;
  readonly remote_id: string;
  readonly remote_name: string;
  readonly email: string;
  readonly name: string;
  readonly url: string;
  readonly import_url: string;
};

export type MigrationsGetCommitAuthors200ResponseBody = ReadonlyArray<PorterAuthor>;

export type MigrationsGetCommitAuthors404ResponseBody = BasicError;

export type MigrationsGetCommitAuthorsRequestQuery = {
  readonly since?: number;
};

export type MigrationsGetCommitAuthorsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MigrationsMapCommitAuthor200ResponseBody = PorterAuthor;

export type MigrationsMapCommitAuthor404ResponseBody = BasicError;

export type MigrationsMapCommitAuthor422ResponseBody = ValidationError;

export type MigrationsMapCommitAuthorRequestBody = {
  readonly email?: string;
  readonly name?: string;
};

export type MigrationsMapCommitAuthorRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly author_id: number;
};

export type PorterLargeFile = {
  readonly ref_name: string;
  readonly path: string;
  readonly oid: string;
  readonly size: number;
};

export type MigrationsGetLargeFiles200ResponseBody = ReadonlyArray<PorterLargeFile>;

export type MigrationsGetLargeFilesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MigrationsSetLfsPreference200ResponseBody = Import;

export type MigrationsSetLfsPreference422ResponseBody = ValidationError;

export type MigrationsSetLfsPreferenceRequestBody = {
  readonly use_lfs: 'opt_in' | 'opt_out';
};

export type MigrationsSetLfsPreferenceRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type AppsGetRepoInstallation200ResponseBody = Installation;

export type AppsGetRepoInstallation301ResponseBody = BasicError;

export type AppsGetRepoInstallation404ResponseBody = BasicError;

export type AppsGetRepoInstallationRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type InteractionsGetRestrictionsForRepo200ResponseBody =
  | InteractionLimits
  | {};

export type InteractionsGetRestrictionsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type InteractionsSetRestrictionsForRepo200ResponseBody = InteractionLimits;

export type InteractionsSetRestrictionsForRepoRequestBody = InteractionRestrictions;

export type InteractionsSetRestrictionsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type InteractionsRemoveRestrictionsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposListInvitations200ResponseBody = ReadonlyArray<RepositoryInvitation>;

export type ReposListInvitationsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListInvitationsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposUpdateInvitation200ResponseBody = RepositoryInvitation;

export type ReposUpdateInvitationRequestBody = {
  readonly permissions?: 'read' | 'write' | 'maintain' | 'triage' | 'admin';
};

export type ReposUpdateInvitationRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly invitation_id: number;
};

export type ReposDeleteInvitationRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly invitation_id: number;
};

export type IssuesListForRepo200ResponseBody = ReadonlyArray<Issue>;

export type IssuesListForRepo301ResponseBody = BasicError;

export type IssuesListForRepo404ResponseBody = BasicError;

export type IssuesListForRepo422ResponseBody = ValidationError;

export type IssuesListForRepoRequestQuery = {
  readonly milestone?: string;
  readonly state?: 'open' | 'closed' | 'all';
  readonly assignee?: string;
  readonly creator?: string;
  readonly mentioned?: string;
  readonly labels?: string;
  readonly sort?: 'created' | 'updated' | 'comments';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesCreate201ResponseBody = Issue;

export type IssuesCreate403ResponseBody = BasicError;

export type IssuesCreate404ResponseBody = BasicError;

export type IssuesCreate410ResponseBody = BasicError;

export type IssuesCreate422ResponseBody = ValidationError;

export type IssuesCreate503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type IssuesCreateRequestBody = {
  readonly title: string | number;
  readonly body?: string;
  readonly assignee?: string | null;
  readonly milestone?: string | number | null;
  readonly labels?: ReadonlyArray<
    | string
    | {
        readonly id?: number;
        readonly name?: string;
        readonly description?: string | null;
        readonly color?: string | null;
      }
  >;
  readonly assignees?: ReadonlyArray<string>;
};

export type IssuesCreateRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesListCommentsForRepo200ResponseBody = ReadonlyArray<IssueComment>;

export type IssuesListCommentsForRepo404ResponseBody = BasicError;

export type IssuesListCommentsForRepo422ResponseBody = ValidationError;

export type IssuesListCommentsForRepoRequestQuery = {
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListCommentsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesGetComment200ResponseBody = IssueComment;

export type IssuesGetComment404ResponseBody = BasicError;

export type IssuesGetCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type IssuesUpdateComment200ResponseBody = IssueComment;

export type IssuesUpdateComment422ResponseBody = ValidationError;

export type IssuesUpdateCommentRequestBody = { readonly body: string };

export type IssuesUpdateCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type IssuesDeleteCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsListForIssueComment200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForIssueComment404ResponseBody = BasicError;

export type ReactionsListForIssueCommentRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForIssueCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsCreateForIssueComment200ResponseBody = Reaction;

export type ReactionsCreateForIssueComment201ResponseBody = Reaction;

export type ReactionsCreateForIssueComment422ResponseBody = ValidationError;

export type ReactionsCreateForIssueCommentRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForIssueCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsDeleteForIssueCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
  readonly reaction_id: number;
};

export type IssueEventLabel = {
  readonly name: string | null;
  readonly color: string | null;
};

export type IssueEventDismissedReview = {
  readonly state: string;
  readonly review_id: number;
  readonly dismissal_message: string | null;
  readonly dismissal_commit_id?: string | null;
};

export type IssueEventMilestone = { readonly title: string };

export type IssueEventProjectCard = {
  readonly url: string;
  readonly id: number;
  readonly project_url: string;
  readonly project_id: number;
  readonly column_name: string;
  readonly previous_column_name?: string;
};

export type IssueEventRename = { readonly from: string; readonly to: string };

export type IssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly issue?: Issue;
  readonly label?: IssueEventLabel;
  readonly assignee?: SimpleUser;
  readonly assigner?: SimpleUser;
  readonly review_requester?: SimpleUser;
  readonly requested_reviewer?: SimpleUser;
  readonly requested_team?: Team;
  readonly dismissed_review?: IssueEventDismissedReview;
  readonly milestone?: IssueEventMilestone;
  readonly project_card?: IssueEventProjectCard;
  readonly rename?: IssueEventRename;
  readonly author_association?: AuthorAssociation;
  readonly lock_reason?: string | null;
  readonly performed_via_github_app?: GitHubApp;
};

export type IssuesListEventsForRepo200ResponseBody = ReadonlyArray<IssueEvent>;

export type IssuesListEventsForRepo422ResponseBody = ValidationError;

export type IssuesListEventsForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListEventsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesGetEvent200ResponseBody = IssueEvent;

export type IssuesGetEvent403ResponseBody = BasicError;

export type IssuesGetEvent404ResponseBody = BasicError;

export type IssuesGetEvent410ResponseBody = BasicError;

export type IssuesGetEventRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly event_id: number;
};

export type IssuesGet200ResponseBody = Issue;

export type IssuesGet301ResponseBody = BasicError;

export type IssuesGet404ResponseBody = BasicError;

export type IssuesGet410ResponseBody = BasicError;

export type IssuesGetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesUpdate200ResponseBody = Issue;

export type IssuesUpdate301ResponseBody = BasicError;

export type IssuesUpdate403ResponseBody = BasicError;

export type IssuesUpdate404ResponseBody = BasicError;

export type IssuesUpdate410ResponseBody = BasicError;

export type IssuesUpdate422ResponseBody = ValidationError;

export type IssuesUpdate503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type IssuesUpdateRequestBody = {
  readonly title?: string | number | null;
  readonly body?: string | null;
  readonly assignee?: string | null;
  readonly state?: 'open' | 'closed';
  readonly state_reason?: 'completed' | 'not_planned' | 'reopened' | null;
  readonly milestone?: string | number | null;
  readonly labels?: ReadonlyArray<
    | string
    | {
        readonly id?: number;
        readonly name?: string;
        readonly description?: string | null;
        readonly color?: string | null;
      }
  >;
  readonly assignees?: ReadonlyArray<string>;
};

export type IssuesUpdateRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesAddAssignees201ResponseBody = Issue;

export type IssuesAddAssigneesRequestBody = {
  readonly assignees?: ReadonlyArray<string>;
};

export type IssuesAddAssigneesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesRemoveAssignees200ResponseBody = Issue;

export type IssuesRemoveAssigneesRequestBody = {
  readonly assignees?: ReadonlyArray<string>;
};

export type IssuesRemoveAssigneesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesListComments200ResponseBody = ReadonlyArray<IssueComment>;

export type IssuesListComments404ResponseBody = BasicError;

export type IssuesListComments410ResponseBody = BasicError;

export type IssuesListCommentsRequestQuery = {
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListCommentsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesCreateComment201ResponseBody = IssueComment;

export type IssuesCreateComment403ResponseBody = BasicError;

export type IssuesCreateComment404ResponseBody = BasicError;

export type IssuesCreateComment410ResponseBody = BasicError;

export type IssuesCreateComment422ResponseBody = ValidationError;

export type IssuesCreateCommentRequestBody = { readonly body: string };

export type IssuesCreateCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type LabeledIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly label: { readonly name: string; readonly color: string };
};

export type UnlabeledIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly label: { readonly name: string; readonly color: string };
};

export type AssignedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly assignee: SimpleUser;
  readonly assigner: SimpleUser;
};

export type UnassignedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly assignee: SimpleUser;
  readonly assigner: SimpleUser;
};

export type MilestonedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly milestone: { readonly title: string };
};

export type DemilestonedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly milestone: { readonly title: string };
};

export type RenamedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly rename: { readonly from: string; readonly to: string };
};

export type ReviewRequestedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly review_requester: SimpleUser;
  readonly requested_team?: Team;
  readonly requested_reviewer?: SimpleUser;
};

export type ReviewRequestRemovedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly review_requester: SimpleUser;
  readonly requested_team?: Team;
  readonly requested_reviewer?: SimpleUser;
};

export type ReviewDismissedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly dismissed_review: {
    readonly state: string;
    readonly review_id: number;
    readonly dismissal_message: string | null;
    readonly dismissal_commit_id?: string;
  };
};

export type LockedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly lock_reason: string | null;
};

export type AddedToProjectIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly project_card?: {
    readonly id: number;
    readonly url: string;
    readonly project_id: number;
    readonly project_url: string;
    readonly column_name: string;
    readonly previous_column_name?: string;
  };
};

export type MovedColumnInProjectIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly project_card?: {
    readonly id: number;
    readonly url: string;
    readonly project_id: number;
    readonly project_url: string;
    readonly column_name: string;
    readonly previous_column_name?: string;
  };
};

export type RemovedFromProjectIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly project_card?: {
    readonly id: number;
    readonly url: string;
    readonly project_id: number;
    readonly project_url: string;
    readonly column_name: string;
    readonly previous_column_name?: string;
  };
};

export type ConvertedNoteToIssueIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly project_card?: {
    readonly id: number;
    readonly url: string;
    readonly project_id: number;
    readonly project_url: string;
    readonly column_name: string;
    readonly previous_column_name?: string;
  };
};

export type IssueEventForIssue =
  | LabeledIssueEvent
  | UnlabeledIssueEvent
  | AssignedIssueEvent
  | UnassignedIssueEvent
  | MilestonedIssueEvent
  | DemilestonedIssueEvent
  | RenamedIssueEvent
  | ReviewRequestedIssueEvent
  | ReviewRequestRemovedIssueEvent
  | ReviewDismissedIssueEvent
  | LockedIssueEvent
  | AddedToProjectIssueEvent
  | MovedColumnInProjectIssueEvent
  | RemovedFromProjectIssueEvent
  | ConvertedNoteToIssueIssueEvent;

export type IssuesListEvents200ResponseBody = ReadonlyArray<IssueEventForIssue>;

export type IssuesListEvents410ResponseBody = BasicError;

export type IssuesListEventsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListEventsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type Label = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly name: string;
  readonly description: string | null;
  readonly color: string;
  readonly default: boolean;
};

export type IssuesListLabelsOnIssue200ResponseBody = ReadonlyArray<Label>;

export type IssuesListLabelsOnIssue301ResponseBody = BasicError;

export type IssuesListLabelsOnIssue404ResponseBody = BasicError;

export type IssuesListLabelsOnIssue410ResponseBody = BasicError;

export type IssuesListLabelsOnIssueRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListLabelsOnIssueRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesAddLabels200ResponseBody = ReadonlyArray<Label>;

export type IssuesAddLabels301ResponseBody = BasicError;

export type IssuesAddLabels404ResponseBody = BasicError;

export type IssuesAddLabels410ResponseBody = BasicError;

export type IssuesAddLabels422ResponseBody = ValidationError;

export type IssuesAddLabelsRequestBody =
  | { readonly labels?: ReadonlyArray<string> }
  | ReadonlyArray<string>
  | { readonly labels?: ReadonlyArray<{ readonly name: string }> }
  | ReadonlyArray<{ readonly name: string }>
  | string;

export type IssuesAddLabelsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesSetLabels200ResponseBody = ReadonlyArray<Label>;

export type IssuesSetLabels301ResponseBody = BasicError;

export type IssuesSetLabels404ResponseBody = BasicError;

export type IssuesSetLabels410ResponseBody = BasicError;

export type IssuesSetLabels422ResponseBody = ValidationError;

export type IssuesSetLabelsRequestBody =
  | { readonly labels?: ReadonlyArray<string> }
  | ReadonlyArray<string>
  | { readonly labels?: ReadonlyArray<{ readonly name: string }> }
  | ReadonlyArray<{ readonly name: string }>
  | string;

export type IssuesSetLabelsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesRemoveAllLabels301ResponseBody = BasicError;

export type IssuesRemoveAllLabels404ResponseBody = BasicError;

export type IssuesRemoveAllLabels410ResponseBody = BasicError;

export type IssuesRemoveAllLabelsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesRemoveLabel200ResponseBody = ReadonlyArray<Label>;

export type IssuesRemoveLabel301ResponseBody = BasicError;

export type IssuesRemoveLabel404ResponseBody = BasicError;

export type IssuesRemoveLabel410ResponseBody = BasicError;

export type IssuesRemoveLabelRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
  readonly name: string;
};

export type IssuesLock403ResponseBody = BasicError;

export type IssuesLock404ResponseBody = BasicError;

export type IssuesLock410ResponseBody = BasicError;

export type IssuesLock422ResponseBody = ValidationError;

export type IssuesLockRequestBody = {
  readonly lock_reason?: 'off-topic' | 'too heated' | 'resolved' | 'spam';
} | null;

export type IssuesLockRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesUnlock403ResponseBody = BasicError;

export type IssuesUnlock404ResponseBody = BasicError;

export type IssuesUnlockRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type ReactionsListForIssue200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForIssue404ResponseBody = BasicError;

export type ReactionsListForIssue410ResponseBody = BasicError;

export type ReactionsListForIssueRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForIssueRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type ReactionsCreateForIssue200ResponseBody = Reaction;

export type ReactionsCreateForIssue201ResponseBody = Reaction;

export type ReactionsCreateForIssue422ResponseBody = ValidationError;

export type ReactionsCreateForIssueRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForIssueRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type ReactionsDeleteForIssueRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
  readonly reaction_id: number;
};

export type TimelineCommentEvent = {
  readonly event: string;
  readonly actor: SimpleUser;
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly body?: string;
  readonly body_text?: string;
  readonly body_html?: string;
  readonly html_url: string;
  readonly user: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly issue_url: string;
  readonly author_association: AuthorAssociation;
  readonly performed_via_github_app?: GitHubApp;
  readonly reactions?: ReactionRollup;
};

export type TimelineCrossReferencedEvent = {
  readonly event: string;
  readonly actor?: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly source: { readonly type?: string; readonly issue?: Issue };
};

export type TimelineCommittedEvent = {
  readonly event?: string;
  readonly sha: string;
  readonly node_id: string;
  readonly url: string;
  readonly author: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly committer: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly message: string;
  readonly tree: { readonly sha: string; readonly url: string };
  readonly parents: ReadonlyArray<{
    readonly sha: string;
    readonly url: string;
    readonly html_url: string;
  }>;
  readonly verification: {
    readonly verified: boolean;
    readonly reason: string;
    readonly signature: string | null;
    readonly payload: string | null;
  };
  readonly html_url: string;
};

export type TimelineReviewedEvent = {
  readonly event: string;
  readonly id: number;
  readonly node_id: string;
  readonly user: SimpleUser;
  readonly body: string | null;
  readonly state: string;
  readonly html_url: string;
  readonly pull_request_url: string;
  readonly _links: {
    readonly html: { readonly href: string };
    readonly pull_request: { readonly href: string };
  };
  readonly submitted_at?: string;
  readonly commit_id: string;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly author_association: AuthorAssociation;
};

export type PullRequestReviewComment = {
  readonly url: string;
  readonly pull_request_review_id: number | null;
  readonly id: number;
  readonly node_id: string;
  readonly diff_hunk: string;
  readonly path: string;
  readonly position: number;
  readonly original_position: number;
  readonly commit_id: string;
  readonly original_commit_id: string;
  readonly in_reply_to_id?: number;
  readonly user: SimpleUser;
  readonly body: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly html_url: string;
  readonly pull_request_url: string;
  readonly author_association: AuthorAssociation;
  readonly _links: {
    readonly self: { readonly href: string };
    readonly html: { readonly href: string };
    readonly pull_request: { readonly href: string };
  };
  readonly start_line?: number | null;
  readonly original_start_line?: number | null;
  readonly start_side?: 'LEFT' | 'RIGHT' | null;
  readonly line?: number;
  readonly original_line?: number;
  readonly side?: 'LEFT' | 'RIGHT';
  readonly reactions?: ReactionRollup;
  readonly body_html?: string;
  readonly body_text?: string;
};

export type TimelineLineCommentedEvent = {
  readonly event?: string;
  readonly node_id?: string;
  readonly comments?: ReadonlyArray<PullRequestReviewComment>;
};

export type TimelineCommitCommentedEvent = {
  readonly event?: string;
  readonly node_id?: string;
  readonly commit_id?: string;
  readonly comments?: ReadonlyArray<CommitComment>;
};

export type TimelineAssignedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly assignee: SimpleUser;
};

export type TimelineUnassignedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly assignee: SimpleUser;
};

export type StateChangeIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly state_reason?: string | null;
};

export type TimelineEvent = unknown &
  (
    | LabeledIssueEvent
    | UnlabeledIssueEvent
    | MilestonedIssueEvent
    | DemilestonedIssueEvent
    | RenamedIssueEvent
    | ReviewRequestedIssueEvent
    | ReviewRequestRemovedIssueEvent
    | ReviewDismissedIssueEvent
    | LockedIssueEvent
    | AddedToProjectIssueEvent
    | MovedColumnInProjectIssueEvent
    | RemovedFromProjectIssueEvent
    | ConvertedNoteToIssueIssueEvent
    | TimelineCommentEvent
    | TimelineCrossReferencedEvent
    | TimelineCommittedEvent
    | TimelineReviewedEvent
    | TimelineLineCommentedEvent
    | TimelineCommitCommentedEvent
    | TimelineAssignedIssueEvent
    | TimelineUnassignedIssueEvent
    | StateChangeIssueEvent
  );

export type IssuesListEventsForTimeline200ResponseBody = ReadonlyArray<TimelineEvent>;

export type IssuesListEventsForTimeline404ResponseBody = BasicError;

export type IssuesListEventsForTimeline410ResponseBody = BasicError;

export type IssuesListEventsForTimelineRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListEventsForTimelineRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type DeployKey = {
  readonly id: number;
  readonly key: string;
  readonly url: string;
  readonly title: string;
  readonly verified: boolean;
  readonly created_at: string;
  readonly read_only: boolean;
  readonly added_by?: string | null;
  readonly last_used?: string | null;
};

export type ReposListDeployKeys200ResponseBody = ReadonlyArray<DeployKey>;

export type ReposListDeployKeysRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListDeployKeysRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateDeployKey201ResponseBody = DeployKey;

export type ReposCreateDeployKey422ResponseBody = ValidationError;

export type ReposCreateDeployKeyRequestBody = {
  readonly title?: string;
  readonly key: string;
  readonly read_only?: boolean;
};

export type ReposCreateDeployKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetDeployKey200ResponseBody = DeployKey;

export type ReposGetDeployKey404ResponseBody = BasicError;

export type ReposGetDeployKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly key_id: number;
};

export type ReposDeleteDeployKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly key_id: number;
};

export type IssuesListLabelsForRepo200ResponseBody = ReadonlyArray<Label>;

export type IssuesListLabelsForRepo404ResponseBody = BasicError;

export type IssuesListLabelsForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListLabelsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesCreateLabel201ResponseBody = Label;

export type IssuesCreateLabel404ResponseBody = BasicError;

export type IssuesCreateLabel422ResponseBody = ValidationError;

export type IssuesCreateLabelRequestBody = {
  readonly name: string;
  readonly color?: string;
  readonly description?: string;
};

export type IssuesCreateLabelRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesGetLabel200ResponseBody = Label;

export type IssuesGetLabel404ResponseBody = BasicError;

export type IssuesGetLabelRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly name: string;
};

export type IssuesUpdateLabel200ResponseBody = Label;

export type IssuesUpdateLabelRequestBody = {
  readonly new_name?: string;
  readonly color?: string;
  readonly description?: string;
};

export type IssuesUpdateLabelRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly name: string;
};

export type IssuesDeleteLabelRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly name: string;
};

export type Language = unknown;

export type ReposListLanguages200ResponseBody = Language;

export type ReposListLanguagesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposEnableLfsForRepo202ResponseBody = unknown;

export type ReposEnableLfsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDisableLfsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type LicenseContent = {
  readonly name: string;
  readonly path: string;
  readonly sha: string;
  readonly size: number;
  readonly url: string;
  readonly html_url: string | null;
  readonly git_url: string | null;
  readonly download_url: string | null;
  readonly type: string;
  readonly content: string;
  readonly encoding: string;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
  readonly license: LicenseSimple;
};

export type LicensesGetForRepo200ResponseBody = LicenseContent;

export type LicensesGetForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MergedUpstream = {
  readonly message?: string;
  readonly merge_type?: 'merge' | 'fast-forward' | 'none';
  readonly base_branch?: string;
};

export type ReposMergeUpstream200ResponseBody = MergedUpstream;

export type ReposMergeUpstreamRequestBody = { readonly branch: string };

export type ReposMergeUpstreamRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposMerge201ResponseBody = Commit;

export type ReposMerge403ResponseBody = BasicError;

export type ReposMerge422ResponseBody = ValidationError;

export type ReposMergeRequestBody = {
  readonly base: string;
  readonly head: string;
  readonly commit_message?: string;
};

export type ReposMergeRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesListMilestones200ResponseBody = ReadonlyArray<Milestone>;

export type IssuesListMilestones404ResponseBody = BasicError;

export type IssuesListMilestonesRequestQuery = {
  readonly state?: 'open' | 'closed' | 'all';
  readonly sort?: 'due_on' | 'completeness';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListMilestonesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesCreateMilestone201ResponseBody = Milestone;

export type IssuesCreateMilestone404ResponseBody = BasicError;

export type IssuesCreateMilestone422ResponseBody = ValidationError;

export type IssuesCreateMilestoneRequestBody = {
  readonly title: string;
  readonly state?: 'open' | 'closed';
  readonly description?: string;
  readonly due_on?: string;
};

export type IssuesCreateMilestoneRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesGetMilestone200ResponseBody = Milestone;

export type IssuesGetMilestone404ResponseBody = BasicError;

export type IssuesGetMilestoneRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly milestone_number: number;
};

export type IssuesUpdateMilestone200ResponseBody = Milestone;

export type IssuesUpdateMilestoneRequestBody = {
  readonly title?: string;
  readonly state?: 'open' | 'closed';
  readonly description?: string;
  readonly due_on?: string;
};

export type IssuesUpdateMilestoneRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly milestone_number: number;
};

export type IssuesDeleteMilestone404ResponseBody = BasicError;

export type IssuesDeleteMilestoneRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly milestone_number: number;
};

export type IssuesListLabelsForMilestone200ResponseBody = ReadonlyArray<Label>;

export type IssuesListLabelsForMilestoneRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListLabelsForMilestoneRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly milestone_number: number;
};

export type ActivityListRepoNotificationsForAuthenticatedUser200ResponseBody = ReadonlyArray<Thread>;

export type ActivityListRepoNotificationsForAuthenticatedUserRequestQuery = {
  readonly all?: boolean;
  readonly participating?: boolean;
  readonly since?: string;
  readonly before?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListRepoNotificationsForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivityMarkRepoNotificationsAsRead202ResponseBody = {
  readonly message?: string;
  readonly url?: string;
};

export type ActivityMarkRepoNotificationsAsReadRequestBody = {
  readonly last_read_at?: string;
};

export type ActivityMarkRepoNotificationsAsReadRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PagesSourceHash = {
  readonly branch: string;
  readonly path: string;
};

export type PagesHttpsCertificate = {
  readonly state:
    | 'new'
    | 'authorization_created'
    | 'authorization_pending'
    | 'authorized'
    | 'authorization_revoked'
    | 'issued'
    | 'uploaded'
    | 'approved'
    | 'errored'
    | 'bad_authz'
    | 'destroy_pending'
    | 'dns_changed';
  readonly description: string;
  readonly domains: ReadonlyArray<string>;
  readonly expires_at?: string;
};

export type GitHubPages = {
  readonly url: string;
  readonly status: 'built' | 'building' | 'errored' | null;
  readonly cname: string | null;
  readonly protected_domain_state?:
    | 'pending'
    | 'verified'
    | 'unverified'
    | null;
  readonly pending_domain_unverified_at?: string | null;
  readonly custom_404: boolean;
  readonly html_url?: string;
  readonly build_type?: 'legacy' | 'workflow' | null;
  readonly source?: PagesSourceHash;
  readonly public: boolean;
  readonly https_certificate?: PagesHttpsCertificate;
  readonly https_enforced?: boolean;
};

export type ReposGetPages200ResponseBody = GitHubPages;

export type ReposGetPages404ResponseBody = BasicError;

export type ReposGetPagesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreatePagesSite201ResponseBody = GitHubPages;

export type ReposCreatePagesSite409ResponseBody = BasicError;

export type ReposCreatePagesSite422ResponseBody = ValidationError;

export type ReposCreatePagesSiteRequestBody =
  | ({
      readonly build_type?: 'legacy' | 'workflow';
      readonly source?: {
        readonly branch: string;
        readonly path?: '/' | '/docs';
      };
    } & unknown)
  | null;

export type ReposCreatePagesSiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposUpdateInformationAboutPagesSite400ResponseBody = BasicError;

export type ReposUpdateInformationAboutPagesSite409ResponseBody = BasicError;

export type ReposUpdateInformationAboutPagesSite422ResponseBody = ValidationError;

export type ReposUpdateInformationAboutPagesSiteRequestBody = {
  readonly cname?: string | null;
  readonly https_enforced?: boolean;
  readonly public?: boolean;
  readonly build_type?: 'legacy' | 'workflow';
  readonly source?:
    | 'gh-pages'
    | 'master'
    | 'master /docs'
    | { readonly branch: string; readonly path: '/' | '/docs' };
} & unknown;

export type ReposUpdateInformationAboutPagesSiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDeletePagesSite404ResponseBody = BasicError;

export type ReposDeletePagesSite409ResponseBody = BasicError;

export type ReposDeletePagesSite422ResponseBody = ValidationError;

export type ReposDeletePagesSiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PageBuild = {
  readonly url: string;
  readonly status: string;
  readonly error: { readonly message: string | null };
  readonly pusher: SimpleUser;
  readonly commit: string;
  readonly duration: number;
  readonly created_at: string;
  readonly updated_at: string;
};

export type ReposListPagesBuilds200ResponseBody = ReadonlyArray<PageBuild>;

export type ReposListPagesBuildsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListPagesBuildsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PageBuildStatus = { readonly url: string; readonly status: string };

export type ReposRequestPagesBuild201ResponseBody = PageBuildStatus;

export type ReposRequestPagesBuildRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetLatestPagesBuild200ResponseBody = PageBuild;

export type ReposGetLatestPagesBuildRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetPagesBuild200ResponseBody = PageBuild;

export type ReposGetPagesBuildRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly build_id: number;
};

export type ReposCreatePagesDeployment200ResponseBody = GitHubPages;

export type ReposCreatePagesDeployment400ResponseBody = BasicError;

export type ReposCreatePagesDeployment404ResponseBody = BasicError;

export type ReposCreatePagesDeployment422ResponseBody = ValidationError;

export type ReposCreatePagesDeploymentRequestBody = {
  readonly artifact_url: string;
  readonly environment?: string;
  readonly pages_build_version: string;
  readonly oidc_token: string;
};

export type ReposCreatePagesDeploymentRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PagesHealthCheckStatus = {
  readonly domain?: {
    readonly host?: string;
    readonly uri?: string;
    readonly nameservers?: string;
    readonly dns_resolves?: boolean;
    readonly is_proxied?: boolean | null;
    readonly is_cloudflare_ip?: boolean | null;
    readonly is_fastly_ip?: boolean | null;
    readonly is_old_ip_address?: boolean | null;
    readonly is_a_record?: boolean | null;
    readonly has_cname_record?: boolean | null;
    readonly has_mx_records_present?: boolean | null;
    readonly is_valid_domain?: boolean;
    readonly is_apex_domain?: boolean;
    readonly should_be_a_record?: boolean | null;
    readonly is_cname_to_github_user_domain?: boolean | null;
    readonly is_cname_to_pages_dot_github_dot_com?: boolean | null;
    readonly is_cname_to_fastly?: boolean | null;
    readonly is_pointed_to_github_pages_ip?: boolean | null;
    readonly is_non_github_pages_ip_present?: boolean | null;
    readonly is_pages_domain?: boolean;
    readonly is_served_by_pages?: boolean | null;
    readonly is_valid?: boolean;
    readonly reason?: string | null;
    readonly responds_to_https?: boolean;
    readonly enforces_https?: boolean;
    readonly https_error?: string | null;
    readonly is_https_eligible?: boolean | null;
    readonly caa_error?: string | null;
  };
  readonly alt_domain?: {
    readonly host?: string;
    readonly uri?: string;
    readonly nameservers?: string;
    readonly dns_resolves?: boolean;
    readonly is_proxied?: boolean | null;
    readonly is_cloudflare_ip?: boolean | null;
    readonly is_fastly_ip?: boolean | null;
    readonly is_old_ip_address?: boolean | null;
    readonly is_a_record?: boolean | null;
    readonly has_cname_record?: boolean | null;
    readonly has_mx_records_present?: boolean | null;
    readonly is_valid_domain?: boolean;
    readonly is_apex_domain?: boolean;
    readonly should_be_a_record?: boolean | null;
    readonly is_cname_to_github_user_domain?: boolean | null;
    readonly is_cname_to_pages_dot_github_dot_com?: boolean | null;
    readonly is_cname_to_fastly?: boolean | null;
    readonly is_pointed_to_github_pages_ip?: boolean | null;
    readonly is_non_github_pages_ip_present?: boolean | null;
    readonly is_pages_domain?: boolean;
    readonly is_served_by_pages?: boolean | null;
    readonly is_valid?: boolean;
    readonly reason?: string | null;
    readonly responds_to_https?: boolean;
    readonly enforces_https?: boolean;
    readonly https_error?: string | null;
    readonly is_https_eligible?: boolean | null;
    readonly caa_error?: string | null;
  } | null;
};

export type ReposGetPagesHealthCheck200ResponseBody = PagesHealthCheckStatus;

export type ReposGetPagesHealthCheck202ResponseBody = EmptyObject;

export type ReposGetPagesHealthCheck404ResponseBody = BasicError;

export type ReposGetPagesHealthCheckRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ProjectsListForRepo200ResponseBody = ReadonlyArray<Project>;

export type ProjectsListForRepo401ResponseBody = BasicError;

export type ProjectsListForRepo403ResponseBody = BasicError;

export type ProjectsListForRepo404ResponseBody = BasicError;

export type ProjectsListForRepo410ResponseBody = BasicError;

export type ProjectsListForRepo422ResponseBody = ValidationErrorSimple;

export type ProjectsListForRepoRequestQuery = {
  readonly state?: 'open' | 'closed' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type ProjectsListForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ProjectsCreateForRepo201ResponseBody = Project;

export type ProjectsCreateForRepo401ResponseBody = BasicError;

export type ProjectsCreateForRepo403ResponseBody = BasicError;

export type ProjectsCreateForRepo404ResponseBody = BasicError;

export type ProjectsCreateForRepo410ResponseBody = BasicError;

export type ProjectsCreateForRepo422ResponseBody = ValidationErrorSimple;

export type ProjectsCreateForRepoRequestBody = {
  readonly name: string;
  readonly body?: string;
};

export type ProjectsCreateForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PullsList200ResponseBody = ReadonlyArray<PullRequestSimple>;

export type PullsList422ResponseBody = ValidationError;

export type PullsListRequestQuery = {
  readonly state?: 'open' | 'closed' | 'all';
  readonly head?: string;
  readonly base?: string;
  readonly sort?: 'created' | 'updated' | 'popularity' | 'long-running';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PullRequest = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly html_url: string;
  readonly diff_url: string;
  readonly patch_url: string;
  readonly issue_url: string;
  readonly commits_url: string;
  readonly review_comments_url: string;
  readonly review_comment_url: string;
  readonly comments_url: string;
  readonly statuses_url: string;
  readonly number: number;
  readonly state: 'open' | 'closed';
  readonly locked: boolean;
  readonly title: string;
  readonly user: SimpleUser;
  readonly body: string | null;
  readonly labels: ReadonlyArray<{
    readonly id: number;
    readonly node_id: string;
    readonly url: string;
    readonly name: string;
    readonly description: string | null;
    readonly color: string;
    readonly default: boolean;
  }>;
  readonly milestone: Milestone;
  readonly active_lock_reason?: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly closed_at: string | null;
  readonly merged_at: string | null;
  readonly merge_commit_sha: string | null;
  readonly assignee: SimpleUser;
  readonly assignees?: ReadonlyArray<SimpleUser> | null;
  readonly requested_reviewers?: ReadonlyArray<SimpleUser> | null;
  readonly requested_teams?: ReadonlyArray<TeamSimple> | null;
  readonly head: {
    readonly label: string;
    readonly ref: string;
    readonly repo: {
      readonly archive_url: string;
      readonly assignees_url: string;
      readonly blobs_url: string;
      readonly branches_url: string;
      readonly collaborators_url: string;
      readonly comments_url: string;
      readonly commits_url: string;
      readonly compare_url: string;
      readonly contents_url: string;
      readonly contributors_url: string;
      readonly deployments_url: string;
      readonly description: string | null;
      readonly downloads_url: string;
      readonly events_url: string;
      readonly fork: boolean;
      readonly forks_url: string;
      readonly full_name: string;
      readonly git_commits_url: string;
      readonly git_refs_url: string;
      readonly git_tags_url: string;
      readonly hooks_url: string;
      readonly html_url: string;
      readonly id: number;
      readonly node_id: string;
      readonly issue_comment_url: string;
      readonly issue_events_url: string;
      readonly issues_url: string;
      readonly keys_url: string;
      readonly labels_url: string;
      readonly languages_url: string;
      readonly merges_url: string;
      readonly milestones_url: string;
      readonly name: string;
      readonly notifications_url: string;
      readonly owner: {
        readonly avatar_url: string;
        readonly events_url: string;
        readonly followers_url: string;
        readonly following_url: string;
        readonly gists_url: string;
        readonly gravatar_id: string | null;
        readonly html_url: string;
        readonly id: number;
        readonly node_id: string;
        readonly login: string;
        readonly organizations_url: string;
        readonly received_events_url: string;
        readonly repos_url: string;
        readonly site_admin: boolean;
        readonly starred_url: string;
        readonly subscriptions_url: string;
        readonly type: string;
        readonly url: string;
      };
      readonly private: boolean;
      readonly pulls_url: string;
      readonly releases_url: string;
      readonly stargazers_url: string;
      readonly statuses_url: string;
      readonly subscribers_url: string;
      readonly subscription_url: string;
      readonly tags_url: string;
      readonly teams_url: string;
      readonly trees_url: string;
      readonly url: string;
      readonly clone_url: string;
      readonly default_branch: string;
      readonly forks: number;
      readonly forks_count: number;
      readonly git_url: string;
      readonly has_downloads: boolean;
      readonly has_issues: boolean;
      readonly has_projects: boolean;
      readonly has_wiki: boolean;
      readonly has_pages: boolean;
      readonly homepage: string | null;
      readonly language: string | null;
      readonly master_branch?: string;
      readonly archived: boolean;
      readonly disabled: boolean;
      readonly visibility?: string;
      readonly mirror_url: string | null;
      readonly open_issues: number;
      readonly open_issues_count: number;
      readonly permissions?: {
        readonly admin: boolean;
        readonly maintain?: boolean;
        readonly push: boolean;
        readonly triage?: boolean;
        readonly pull: boolean;
      };
      readonly temp_clone_token?: string;
      readonly allow_merge_commit?: boolean;
      readonly allow_squash_merge?: boolean;
      readonly allow_rebase_merge?: boolean;
      readonly license: {
        readonly key: string;
        readonly name: string;
        readonly url: string | null;
        readonly spdx_id: string | null;
        readonly node_id: string;
      } | null;
      readonly pushed_at: string;
      readonly size: number;
      readonly ssh_url: string;
      readonly stargazers_count: number;
      readonly svn_url: string;
      readonly topics?: ReadonlyArray<string>;
      readonly watchers: number;
      readonly watchers_count: number;
      readonly created_at: string;
      readonly updated_at: string;
      readonly allow_forking?: boolean;
      readonly is_template?: boolean;
      readonly web_commit_signoff_required?: boolean;
    } | null;
    readonly sha: string;
    readonly user: {
      readonly avatar_url: string;
      readonly events_url: string;
      readonly followers_url: string;
      readonly following_url: string;
      readonly gists_url: string;
      readonly gravatar_id: string | null;
      readonly html_url: string;
      readonly id: number;
      readonly node_id: string;
      readonly login: string;
      readonly organizations_url: string;
      readonly received_events_url: string;
      readonly repos_url: string;
      readonly site_admin: boolean;
      readonly starred_url: string;
      readonly subscriptions_url: string;
      readonly type: string;
      readonly url: string;
    };
  };
  readonly base: {
    readonly label: string;
    readonly ref: string;
    readonly repo: {
      readonly archive_url: string;
      readonly assignees_url: string;
      readonly blobs_url: string;
      readonly branches_url: string;
      readonly collaborators_url: string;
      readonly comments_url: string;
      readonly commits_url: string;
      readonly compare_url: string;
      readonly contents_url: string;
      readonly contributors_url: string;
      readonly deployments_url: string;
      readonly description: string | null;
      readonly downloads_url: string;
      readonly events_url: string;
      readonly fork: boolean;
      readonly forks_url: string;
      readonly full_name: string;
      readonly git_commits_url: string;
      readonly git_refs_url: string;
      readonly git_tags_url: string;
      readonly hooks_url: string;
      readonly html_url: string;
      readonly id: number;
      readonly is_template?: boolean;
      readonly node_id: string;
      readonly issue_comment_url: string;
      readonly issue_events_url: string;
      readonly issues_url: string;
      readonly keys_url: string;
      readonly labels_url: string;
      readonly languages_url: string;
      readonly merges_url: string;
      readonly milestones_url: string;
      readonly name: string;
      readonly notifications_url: string;
      readonly owner: {
        readonly avatar_url: string;
        readonly events_url: string;
        readonly followers_url: string;
        readonly following_url: string;
        readonly gists_url: string;
        readonly gravatar_id: string | null;
        readonly html_url: string;
        readonly id: number;
        readonly node_id: string;
        readonly login: string;
        readonly organizations_url: string;
        readonly received_events_url: string;
        readonly repos_url: string;
        readonly site_admin: boolean;
        readonly starred_url: string;
        readonly subscriptions_url: string;
        readonly type: string;
        readonly url: string;
      };
      readonly private: boolean;
      readonly pulls_url: string;
      readonly releases_url: string;
      readonly stargazers_url: string;
      readonly statuses_url: string;
      readonly subscribers_url: string;
      readonly subscription_url: string;
      readonly tags_url: string;
      readonly teams_url: string;
      readonly trees_url: string;
      readonly url: string;
      readonly clone_url: string;
      readonly default_branch: string;
      readonly forks: number;
      readonly forks_count: number;
      readonly git_url: string;
      readonly has_downloads: boolean;
      readonly has_issues: boolean;
      readonly has_projects: boolean;
      readonly has_wiki: boolean;
      readonly has_pages: boolean;
      readonly homepage: string | null;
      readonly language: string | null;
      readonly master_branch?: string;
      readonly archived: boolean;
      readonly disabled: boolean;
      readonly visibility?: string;
      readonly mirror_url: string | null;
      readonly open_issues: number;
      readonly open_issues_count: number;
      readonly permissions?: {
        readonly admin: boolean;
        readonly maintain?: boolean;
        readonly push: boolean;
        readonly triage?: boolean;
        readonly pull: boolean;
      };
      readonly temp_clone_token?: string;
      readonly allow_merge_commit?: boolean;
      readonly allow_squash_merge?: boolean;
      readonly allow_rebase_merge?: boolean;
      readonly license: LicenseSimple;
      readonly pushed_at: string;
      readonly size: number;
      readonly ssh_url: string;
      readonly stargazers_count: number;
      readonly svn_url: string;
      readonly topics?: ReadonlyArray<string>;
      readonly watchers: number;
      readonly watchers_count: number;
      readonly created_at: string;
      readonly updated_at: string;
      readonly allow_forking?: boolean;
      readonly web_commit_signoff_required?: boolean;
    };
    readonly sha: string;
    readonly user: {
      readonly avatar_url: string;
      readonly events_url: string;
      readonly followers_url: string;
      readonly following_url: string;
      readonly gists_url: string;
      readonly gravatar_id: string | null;
      readonly html_url: string;
      readonly id: number;
      readonly node_id: string;
      readonly login: string;
      readonly organizations_url: string;
      readonly received_events_url: string;
      readonly repos_url: string;
      readonly site_admin: boolean;
      readonly starred_url: string;
      readonly subscriptions_url: string;
      readonly type: string;
      readonly url: string;
    };
  };
  readonly _links: {
    readonly comments: Link;
    readonly commits: Link;
    readonly statuses: Link;
    readonly html: Link;
    readonly issue: Link;
    readonly review_comments: Link;
    readonly review_comment: Link;
    readonly self: Link;
  };
  readonly author_association: AuthorAssociation;
  readonly auto_merge: AutoMerge;
  readonly draft?: boolean;
  readonly merged: boolean;
  readonly mergeable: boolean | null;
  readonly rebaseable?: boolean | null;
  readonly mergeable_state: string;
  readonly merged_by: SimpleUser;
  readonly comments: number;
  readonly review_comments: number;
  readonly maintainer_can_modify: boolean;
  readonly commits: number;
  readonly additions: number;
  readonly deletions: number;
  readonly changed_files: number;
};

export type PullsCreate201ResponseBody = PullRequest;

export type PullsCreate403ResponseBody = BasicError;

export type PullsCreate422ResponseBody = ValidationError;

export type PullsCreateRequestBody = {
  readonly title?: string;
  readonly head: string;
  readonly base: string;
  readonly body?: string;
  readonly maintainer_can_modify?: boolean;
  readonly draft?: boolean;
  readonly issue?: number;
};

export type PullsCreateRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PullsListReviewCommentsForRepo200ResponseBody = ReadonlyArray<PullRequestReviewComment>;

export type PullsListReviewCommentsForRepoRequestQuery = {
  readonly sort?: 'created' | 'updated' | 'created_at';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListReviewCommentsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PullsGetReviewComment200ResponseBody = PullRequestReviewComment;

export type PullsGetReviewComment404ResponseBody = BasicError;

export type PullsGetReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type PullsUpdateReviewComment200ResponseBody = PullRequestReviewComment;

export type PullsUpdateReviewCommentRequestBody = { readonly body: string };

export type PullsUpdateReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type PullsDeleteReviewComment404ResponseBody = BasicError;

export type PullsDeleteReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsListForPullRequestReviewComment200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForPullRequestReviewComment404ResponseBody = BasicError;

export type ReactionsListForPullRequestReviewCommentRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForPullRequestReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsCreateForPullRequestReviewComment200ResponseBody = Reaction;

export type ReactionsCreateForPullRequestReviewComment201ResponseBody = Reaction;

export type ReactionsCreateForPullRequestReviewComment422ResponseBody = ValidationError;

export type ReactionsCreateForPullRequestReviewCommentRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForPullRequestReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsDeleteForPullRequestCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
  readonly reaction_id: number;
};

export type PullsGet200ResponseBody = PullRequest;

export type PullsGet404ResponseBody = BasicError;

export type PullsGet500ResponseBody = BasicError;

export type PullsGet503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type PullsGetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsUpdate200ResponseBody = PullRequest;

export type PullsUpdate403ResponseBody = BasicError;

export type PullsUpdate422ResponseBody = ValidationError;

export type PullsUpdateRequestBody = {
  readonly title?: string;
  readonly body?: string;
  readonly state?: 'open' | 'closed';
  readonly base?: string;
  readonly maintainer_can_modify?: boolean;
};

export type PullsUpdateRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type CodespacesCreateWithPrForAuthenticatedUser201ResponseBody = Codespace;

export type CodespacesCreateWithPrForAuthenticatedUser202ResponseBody = Codespace;

export type CodespacesCreateWithPrForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesCreateWithPrForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesCreateWithPrForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesCreateWithPrForAuthenticatedUser503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodespacesCreateWithPrForAuthenticatedUserRequestBody = {
  readonly location?: string;
  readonly client_ip?: string;
  readonly machine?: string;
  readonly devcontainer_path?: string;
  readonly multi_repo_permissions_opt_out?: boolean;
  readonly working_directory?: string;
  readonly idle_timeout_minutes?: number;
  readonly display_name?: string;
  readonly retention_period_minutes?: number;
} | null;

export type CodespacesCreateWithPrForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsListReviewComments200ResponseBody = ReadonlyArray<PullRequestReviewComment>;

export type PullsListReviewCommentsRequestQuery = {
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListReviewCommentsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsCreateReviewComment201ResponseBody = PullRequestReviewComment;

export type PullsCreateReviewComment403ResponseBody = BasicError;

export type PullsCreateReviewComment422ResponseBody = ValidationError;

export type PullsCreateReviewCommentRequestBody = {
  readonly body: string;
  readonly commit_id: string;
  readonly path: string;
  readonly position?: number;
  readonly side?: 'LEFT' | 'RIGHT';
  readonly line: number;
  readonly start_line?: number;
  readonly start_side?: 'LEFT' | 'RIGHT' | 'side';
  readonly in_reply_to?: number;
};

export type PullsCreateReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsCreateReplyForReviewComment201ResponseBody = PullRequestReviewComment;

export type PullsCreateReplyForReviewComment404ResponseBody = BasicError;

export type PullsCreateReplyForReviewCommentRequestBody = {
  readonly body: string;
};

export type PullsCreateReplyForReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly comment_id: number;
};

export type PullsListCommits200ResponseBody = ReadonlyArray<Commit>;

export type PullsListCommitsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListCommitsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsListFiles200ResponseBody = ReadonlyArray<DiffEntry>;

export type PullsListFiles422ResponseBody = ValidationError;

export type PullsListFiles500ResponseBody = BasicError;

export type PullsListFiles503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type PullsListFilesRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListFilesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsCheckIfMergedRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullRequestMergeResult = {
  readonly sha: string;
  readonly merged: boolean;
  readonly message: string;
};

export type PullsMerge200ResponseBody = PullRequestMergeResult;

export type PullsMerge403ResponseBody = BasicError;

export type PullsMerge404ResponseBody = BasicError;

export type PullsMerge405ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
};

export type PullsMerge409ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
};

export type PullsMerge422ResponseBody = ValidationError;

export type PullsMergeRequestBody = {
  readonly commit_title?: string;
  readonly commit_message?: string;
  readonly sha?: string;
  readonly merge_method?: 'merge' | 'squash' | 'rebase';
} | null;

export type PullsMergeRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullRequestReviewRequest = {
  readonly users: ReadonlyArray<SimpleUser>;
  readonly teams: ReadonlyArray<Team>;
};

export type PullsListRequestedReviewers200ResponseBody = PullRequestReviewRequest;

export type PullsListRequestedReviewersRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsRequestReviewers201ResponseBody = PullRequestSimple;

export type PullsRequestReviewers403ResponseBody = BasicError;

export type PullsRequestReviewersRequestBody = {
  readonly reviewers?: ReadonlyArray<string>;
  readonly team_reviewers?: ReadonlyArray<string>;
} & unknown;

export type PullsRequestReviewersRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsRemoveRequestedReviewers200ResponseBody = PullRequestSimple;

export type PullsRemoveRequestedReviewers422ResponseBody = ValidationError;

export type PullsRemoveRequestedReviewersRequestBody = {
  readonly reviewers: ReadonlyArray<string>;
  readonly team_reviewers?: ReadonlyArray<string>;
};

export type PullsRemoveRequestedReviewersRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullRequestReview = {
  readonly id: number;
  readonly node_id: string;
  readonly user: SimpleUser;
  readonly body: string;
  readonly state: string;
  readonly html_url: string;
  readonly pull_request_url: string;
  readonly _links: {
    readonly html: { readonly href: string };
    readonly pull_request: { readonly href: string };
  };
  readonly submitted_at?: string;
  readonly commit_id: string;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly author_association: AuthorAssociation;
};

export type PullsListReviews200ResponseBody = ReadonlyArray<PullRequestReview>;

export type PullsListReviewsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListReviewsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsCreateReview200ResponseBody = PullRequestReview;

export type PullsCreateReview403ResponseBody = BasicError;

export type PullsCreateReview422ResponseBody = ValidationErrorSimple;

export type PullsCreateReviewRequestBody = {
  readonly commit_id?: string;
  readonly body?: string;
  readonly event?: 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT';
  readonly comments?: ReadonlyArray<{
    readonly path: string;
    readonly position?: number;
    readonly body: string;
    readonly line?: number;
    readonly side?: string;
    readonly start_line?: number;
    readonly start_side?: string;
  }>;
};

export type PullsCreateReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsGetReview200ResponseBody = PullRequestReview;

export type PullsGetReview404ResponseBody = BasicError;

export type PullsGetReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly review_id: number;
};

export type PullsUpdateReview200ResponseBody = PullRequestReview;

export type PullsUpdateReview422ResponseBody = ValidationErrorSimple;

export type PullsUpdateReviewRequestBody = { readonly body: string };

export type PullsUpdateReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly review_id: number;
};

export type PullsDeletePendingReview200ResponseBody = PullRequestReview;

export type PullsDeletePendingReview404ResponseBody = BasicError;

export type PullsDeletePendingReview422ResponseBody = ValidationErrorSimple;

export type PullsDeletePendingReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly review_id: number;
};

export type LegacyReviewComment = {
  readonly url: string;
  readonly pull_request_review_id: number | null;
  readonly id: number;
  readonly node_id: string;
  readonly diff_hunk: string;
  readonly path: string;
  readonly position: number | null;
  readonly original_position: number;
  readonly commit_id: string;
  readonly original_commit_id: string;
  readonly in_reply_to_id?: number;
  readonly user: SimpleUser;
  readonly body: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly html_url: string;
  readonly pull_request_url: string;
  readonly author_association: AuthorAssociation;
  readonly _links: {
    readonly self: Link;
    readonly html: Link;
    readonly pull_request: Link;
  };
  readonly body_text?: string;
  readonly body_html?: string;
  readonly reactions?: ReactionRollup;
  readonly side?: 'LEFT' | 'RIGHT';
  readonly start_side?: 'LEFT' | 'RIGHT' | null;
  readonly line?: number;
  readonly original_line?: number;
  readonly start_line?: number | null;
  readonly original_start_line?: number | null;
};

export type PullsListCommentsForReview200ResponseBody = ReadonlyArray<LegacyReviewComment>;

export type PullsListCommentsForReview404ResponseBody = BasicError;

export type PullsListCommentsForReviewRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListCommentsForReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly review_id: number;
};

export type PullsDismissReview200ResponseBody = PullRequestReview;

export type PullsDismissReview404ResponseBody = BasicError;

export type PullsDismissReview422ResponseBody = ValidationErrorSimple;

export type PullsDismissReviewRequestBody = {
  readonly message: string;
  readonly event?: 'DISMISS';
};

export type PullsDismissReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly review_id: number;
};

export type PullsSubmitReview200ResponseBody = PullRequestReview;

export type PullsSubmitReview403ResponseBody = BasicError;

export type PullsSubmitReview404ResponseBody = BasicError;

export type PullsSubmitReview422ResponseBody = ValidationErrorSimple;

export type PullsSubmitReviewRequestBody = {
  readonly body?: string;
  readonly event: 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT';
};

export type PullsSubmitReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly review_id: number;
};

export type PullsUpdateBranch202ResponseBody = {
  readonly message?: string;
  readonly url?: string;
};

export type PullsUpdateBranch403ResponseBody = BasicError;

export type PullsUpdateBranch422ResponseBody = ValidationError;

export type PullsUpdateBranchRequestBody = {
  readonly expected_head_sha?: string;
} | null;

export type PullsUpdateBranchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type ReposGetReadme200ResponseBody = ContentFile;

export type ReposGetReadme404ResponseBody = BasicError;

export type ReposGetReadme422ResponseBody = ValidationError;

export type ReposGetReadmeRequestQuery = { readonly ref?: string };

export type ReposGetReadmeRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetReadmeInDirectory200ResponseBody = ContentFile;

export type ReposGetReadmeInDirectory404ResponseBody = BasicError;

export type ReposGetReadmeInDirectory422ResponseBody = ValidationError;

export type ReposGetReadmeInDirectoryRequestQuery = { readonly ref?: string };

export type ReposGetReadmeInDirectoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly dir: string;
};

export type ReleaseAsset = {
  readonly url: string;
  readonly browser_download_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly label: string | null;
  readonly state: 'uploaded' | 'open';
  readonly content_type: string;
  readonly size: number;
  readonly download_count: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly uploader: SimpleUser;
};

export type Release = {
  readonly url: string;
  readonly html_url: string;
  readonly assets_url: string;
  readonly upload_url: string;
  readonly tarball_url: string | null;
  readonly zipball_url: string | null;
  readonly id: number;
  readonly node_id: string;
  readonly tag_name: string;
  readonly target_commitish: string;
  readonly name: string | null;
  readonly body?: string | null;
  readonly draft: boolean;
  readonly prerelease: boolean;
  readonly created_at: string;
  readonly published_at: string | null;
  readonly author: SimpleUser;
  readonly assets: ReadonlyArray<ReleaseAsset>;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly mentions_count?: number;
  readonly discussion_url?: string;
  readonly reactions?: ReactionRollup;
};

export type ReposListReleases200ResponseBody = ReadonlyArray<Release>;

export type ReposListReleases404ResponseBody = BasicError;

export type ReposListReleasesRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListReleasesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateRelease201ResponseBody = Release;

export type ReposCreateRelease404ResponseBody = BasicError;

export type ReposCreateRelease422ResponseBody = ValidationError;

export type ReposCreateReleaseRequestBody = {
  readonly tag_name: string;
  readonly target_commitish?: string;
  readonly name?: string;
  readonly body?: string;
  readonly draft?: boolean;
  readonly prerelease?: boolean;
  readonly discussion_category_name?: string;
  readonly generate_release_notes?: boolean;
};

export type ReposCreateReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetReleaseAsset200ResponseBody = ReleaseAsset;

export type ReposGetReleaseAsset404ResponseBody = BasicError;

export type ReposGetReleaseAssetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly asset_id: number;
};

export type ReposUpdateReleaseAsset200ResponseBody = ReleaseAsset;

export type ReposUpdateReleaseAssetRequestBody = {
  readonly name?: string;
  readonly label?: string;
  readonly state?: string;
};

export type ReposUpdateReleaseAssetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly asset_id: number;
};

export type ReposDeleteReleaseAssetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly asset_id: number;
};

export type GeneratedReleaseNotesContent = {
  readonly name: string;
  readonly body: string;
};

export type ReposGenerateReleaseNotes200ResponseBody = GeneratedReleaseNotesContent;

export type ReposGenerateReleaseNotes404ResponseBody = BasicError;

export type ReposGenerateReleaseNotesRequestBody = {
  readonly tag_name: string;
  readonly target_commitish?: string;
  readonly previous_tag_name?: string;
  readonly configuration_file_path?: string;
};

export type ReposGenerateReleaseNotesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetLatestRelease200ResponseBody = Release;

export type ReposGetLatestReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetReleaseByTag200ResponseBody = Release;

export type ReposGetReleaseByTag404ResponseBody = BasicError;

export type ReposGetReleaseByTagRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly tag: string;
};

export type ReposGetRelease200ResponseBody = Release;

export type ReposGetRelease404ResponseBody = BasicError;

export type ReposGetReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReposUpdateRelease200ResponseBody = Release;

export type ReposUpdateRelease404ResponseBody = BasicError;

export type ReposUpdateReleaseRequestBody = {
  readonly tag_name?: string;
  readonly target_commitish?: string;
  readonly name?: string;
  readonly body?: string;
  readonly draft?: boolean;
  readonly prerelease?: boolean;
  readonly discussion_category_name?: string;
};

export type ReposUpdateReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReposDeleteReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReposListReleaseAssets200ResponseBody = ReadonlyArray<ReleaseAsset>;

export type ReposListReleaseAssetsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListReleaseAssetsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReposUploadReleaseAsset201ResponseBody = ReleaseAsset;

export type ReposUploadReleaseAssetRequestQuery = {
  readonly name: string;
  readonly label?: string;
};

export type ReposUploadReleaseAssetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReactionsListForRelease200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForRelease404ResponseBody = BasicError;

export type ReactionsListForReleaseRequestQuery = {
  readonly content?: '+1' | 'laugh' | 'heart' | 'hooray' | 'rocket' | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReactionsCreateForRelease200ResponseBody = Reaction;

export type ReactionsCreateForRelease201ResponseBody = Reaction;

export type ReactionsCreateForRelease422ResponseBody = ValidationError;

export type ReactionsCreateForReleaseRequestBody = {
  readonly content: '+1' | 'laugh' | 'heart' | 'hooray' | 'rocket' | 'eyes';
};

export type ReactionsCreateForReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReactionsDeleteForReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
  readonly reaction_id: number;
};

export type SecretScanningAlert = {
  readonly number?: AlertNumber;
  readonly created_at?: AlertCreatedAt;
  readonly updated_at?: AlertUpdatedAt;
  readonly url?: AlertUrl;
  readonly html_url?: AlertHtmlUrl;
  readonly locations_url?: string;
  readonly state?: SecretScanningAlertState;
  readonly resolution?: SecretScanningAlertResolution;
  readonly resolved_at?: string | null;
  readonly resolved_by?: SimpleUser;
  readonly resolution_comment?: string | null;
  readonly secret_type?: string;
  readonly secret_type_display_name?: string;
  readonly secret?: string;
  readonly push_protection_bypassed?: boolean | null;
  readonly push_protection_bypassed_by?: SimpleUser;
  readonly push_protection_bypassed_at?: string | null;
};

export type SecretScanningListAlertsForRepo200ResponseBody = ReadonlyArray<SecretScanningAlert>;

export type SecretScanningListAlertsForRepo503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SecretScanningListAlertsForRepoRequestQuery = {
  readonly state?: 'open' | 'resolved';
  readonly secret_type?: string;
  readonly resolution?: string;
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly page?: number;
  readonly per_page?: number;
  readonly before?: string;
  readonly after?: string;
};

export type SecretScanningListAlertsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type SecretScanningGetAlert200ResponseBody = SecretScanningAlert;

export type SecretScanningGetAlert503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SecretScanningGetAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type SecretScanningUpdateAlert200ResponseBody = SecretScanningAlert;

export type SecretScanningUpdateAlert503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SecretScanningAlertResolutionComment = string | null;

export type SecretScanningUpdateAlertRequestBody = {
  readonly state: SecretScanningAlertState;
  readonly resolution?: SecretScanningAlertResolution;
  readonly resolution_comment?: SecretScanningAlertResolutionComment;
};

export type SecretScanningUpdateAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type SecretScanningLocationCommit = {
  readonly path: string;
  readonly start_line: number;
  readonly end_line: number;
  readonly start_column: number;
  readonly end_column: number;
  readonly blob_sha: string;
  readonly blob_url: string;
  readonly commit_sha: string;
  readonly commit_url: string;
};

export type SecretScanningLocation = {
  readonly type: 'commit';
  readonly details: SecretScanningLocationCommit;
};

export type SecretScanningListLocationsForAlert200ResponseBody = ReadonlyArray<SecretScanningLocation>;

export type SecretScanningListLocationsForAlert503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SecretScanningListLocationsForAlertRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type SecretScanningListLocationsForAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type Stargazer = {
  readonly starred_at: string;
  readonly user: SimpleUser;
};

export type ActivityListStargazersForRepo200ResponseBody =
  | ReadonlyArray<SimpleUser>
  | ReadonlyArray<Stargazer>;

export type ActivityListStargazersForRepo422ResponseBody = ValidationError;

export type ActivityListStargazersForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListStargazersForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodeFrequencyStat = ReadonlyArray<number>;

export type ReposGetCodeFrequencyStats200ResponseBody = ReadonlyArray<CodeFrequencyStat>;

export type ReposGetCodeFrequencyStats202ResponseBody = unknown;

export type ReposGetCodeFrequencyStatsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CommitActivity = {
  readonly days: ReadonlyArray<number>;
  readonly total: number;
  readonly week: number;
};

export type ReposGetCommitActivityStats200ResponseBody = ReadonlyArray<CommitActivity>;

export type ReposGetCommitActivityStats202ResponseBody = unknown;

export type ReposGetCommitActivityStatsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ContributorActivity = {
  readonly author: SimpleUser;
  readonly total: number;
  readonly weeks: ReadonlyArray<{
    readonly w?: number;
    readonly a?: number;
    readonly d?: number;
    readonly c?: number;
  }>;
};

export type ReposGetContributorsStats200ResponseBody = ReadonlyArray<ContributorActivity>;

export type ReposGetContributorsStats202ResponseBody = unknown;

export type ReposGetContributorsStatsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ParticipationStats = {
  readonly all: ReadonlyArray<number>;
  readonly owner: ReadonlyArray<number>;
};

export type ReposGetParticipationStats200ResponseBody = ParticipationStats;

export type ReposGetParticipationStats404ResponseBody = BasicError;

export type ReposGetParticipationStatsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetPunchCardStats200ResponseBody = ReadonlyArray<CodeFrequencyStat>;

export type ReposGetPunchCardStatsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateCommitStatus201ResponseBody = Status;

export type ReposCreateCommitStatusRequestBody = {
  readonly state: 'error' | 'failure' | 'pending' | 'success';
  readonly target_url?: string | null;
  readonly description?: string | null;
  readonly context?: string;
};

export type ReposCreateCommitStatusRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly sha: string;
};

export type ActivityListWatchersForRepo200ResponseBody = ReadonlyArray<SimpleUser>;

export type ActivityListWatchersForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListWatchersForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivityGetRepoSubscription200ResponseBody = RepositoryInvitation;

export type ActivityGetRepoSubscription403ResponseBody = BasicError;

export type ActivityGetRepoSubscriptionRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivitySetRepoSubscription200ResponseBody = RepositoryInvitation;

export type ActivitySetRepoSubscriptionRequestBody = {
  readonly subscribed?: boolean;
  readonly ignored?: boolean;
};

export type ActivitySetRepoSubscriptionRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivityDeleteRepoSubscriptionRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type Tag = {
  readonly name: string;
  readonly commit: { readonly sha: string; readonly url: string };
  readonly zipball_url: string;
  readonly tarball_url: string;
  readonly node_id: string;
};

export type ReposListTags200ResponseBody = ReadonlyArray<Tag>;

export type ReposListTagsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListTagsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type TagProtection = {
  readonly id?: number;
  readonly created_at?: string;
  readonly updated_at?: string;
  readonly enabled?: boolean;
  readonly pattern: string;
};

export type ReposListTagProtection200ResponseBody = ReadonlyArray<TagProtection>;

export type ReposListTagProtection403ResponseBody = BasicError;

export type ReposListTagProtection404ResponseBody = BasicError;

export type ReposListTagProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateTagProtection201ResponseBody = TagProtection;

export type ReposCreateTagProtection403ResponseBody = BasicError;

export type ReposCreateTagProtection404ResponseBody = BasicError;

export type ReposCreateTagProtectionRequestBody = { readonly pattern: string };

export type ReposCreateTagProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDeleteTagProtection403ResponseBody = BasicError;

export type ReposDeleteTagProtection404ResponseBody = BasicError;

export type ReposDeleteTagProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly tag_protection_id: number;
};

export type ReposDownloadTarballArchiveRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type ReposListTeams200ResponseBody = ReadonlyArray<Team>;

export type ReposListTeamsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListTeamsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type Topic = { readonly names: ReadonlyArray<string> };

export type ReposGetAllTopics200ResponseBody = Topic;

export type ReposGetAllTopics404ResponseBody = BasicError;

export type ReposGetAllTopicsRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type ReposGetAllTopicsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposReplaceAllTopics200ResponseBody = Topic;

export type ReposReplaceAllTopics404ResponseBody = BasicError;

export type ReposReplaceAllTopics422ResponseBody = ValidationErrorSimple;

export type ReposReplaceAllTopicsRequestBody = {
  readonly names: ReadonlyArray<string>;
};

export type ReposReplaceAllTopicsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type Traffic = {
  readonly timestamp: string;
  readonly uniques: number;
  readonly count: number;
};

export type CloneTraffic = {
  readonly count: number;
  readonly uniques: number;
  readonly clones: ReadonlyArray<Traffic>;
};

export type ReposGetClones200ResponseBody = CloneTraffic;

export type ReposGetClones403ResponseBody = BasicError;

export type ReposGetClonesRequestQuery = { readonly per?: '' | 'day' | 'week' };

export type ReposGetClonesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ContentTraffic = {
  readonly path: string;
  readonly title: string;
  readonly count: number;
  readonly uniques: number;
};

export type ReposGetTopPaths200ResponseBody = ReadonlyArray<ContentTraffic>;

export type ReposGetTopPaths403ResponseBody = BasicError;

export type ReposGetTopPathsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReferrerTraffic = {
  readonly referrer: string;
  readonly count: number;
  readonly uniques: number;
};

export type ReposGetTopReferrers200ResponseBody = ReadonlyArray<ReferrerTraffic>;

export type ReposGetTopReferrers403ResponseBody = BasicError;

export type ReposGetTopReferrersRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ViewTraffic = {
  readonly count: number;
  readonly uniques: number;
  readonly views: ReadonlyArray<Traffic>;
};

export type ReposGetViews200ResponseBody = ViewTraffic;

export type ReposGetViews403ResponseBody = BasicError;

export type ReposGetViewsRequestQuery = { readonly per?: '' | 'day' | 'week' };

export type ReposGetViewsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposTransfer202ResponseBody = MinimalRepository;

export type ReposTransferRequestBody = {
  readonly new_owner: string;
  readonly team_ids?: ReadonlyArray<number>;
};

export type ReposTransferRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCheckVulnerabilityAlertsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposEnableVulnerabilityAlertsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDisableVulnerabilityAlertsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDownloadZipballArchiveRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type ReposCreateUsingTemplate201ResponseBody = Repository;

export type ReposCreateUsingTemplateRequestBody = {
  readonly owner?: string;
  readonly name: string;
  readonly description?: string;
  readonly include_all_branches?: boolean;
  readonly private?: boolean;
};

export type ReposCreateUsingTemplateRequestPath = {
  readonly template_owner: string;
  readonly template_repo: string;
};

export type ReposListPublic200ResponseBody = ReadonlyArray<MinimalRepository>;

export type ReposListPublic422ResponseBody = ValidationError;

export type ReposListPublicRequestQuery = { readonly since?: number };

export type ActionsListEnvironmentSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<ActionsSecret>;
};

export type ActionsListEnvironmentSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListEnvironmentSecretsRequestPath = {
  readonly repository_id: number;
  readonly environment_name: string;
};

export type ActionsGetEnvironmentPublicKey200ResponseBody = ActionsPublicKey;

export type ActionsGetEnvironmentPublicKeyRequestPath = {
  readonly repository_id: number;
  readonly environment_name: string;
};

export type ActionsGetEnvironmentSecret200ResponseBody = ActionsSecret;

export type ActionsGetEnvironmentSecretRequestPath = {
  readonly repository_id: number;
  readonly environment_name: string;
  readonly secret_name: string;
};

export type ActionsCreateOrUpdateEnvironmentSecret201ResponseBody = EmptyObject;

export type ActionsCreateOrUpdateEnvironmentSecretRequestBody = {
  readonly encrypted_value: string;
  readonly key_id: string;
};

export type ActionsCreateOrUpdateEnvironmentSecretRequestPath = {
  readonly repository_id: number;
  readonly environment_name: string;
  readonly secret_name: string;
};

export type ActionsDeleteEnvironmentSecretRequestPath = {
  readonly repository_id: number;
  readonly environment_name: string;
  readonly secret_name: string;
};

export type SearchResultTextMatches = ReadonlyArray<{
  readonly object_url?: string;
  readonly object_type?: string | null;
  readonly property?: string;
  readonly fragment?: string;
  readonly matches?: ReadonlyArray<{
    readonly text?: string;
    readonly indices?: ReadonlyArray<number>;
  }>;
}>;

export type CodeSearchResultItem = {
  readonly name: string;
  readonly path: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string;
  readonly html_url: string;
  readonly repository: MinimalRepository;
  readonly score: number;
  readonly file_size?: number;
  readonly language?: string | null;
  readonly last_modified_at?: string;
  readonly line_numbers?: ReadonlyArray<string>;
  readonly text_matches?: SearchResultTextMatches;
};

export type SearchCode200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<CodeSearchResultItem>;
};

export type SearchCode403ResponseBody = BasicError;

export type SearchCode422ResponseBody = ValidationError;

export type SearchCode503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SearchCodeRequestQuery = {
  readonly q: string;
  readonly sort?: 'indexed';
  readonly order?: 'desc' | 'asc';
  readonly per_page?: number;
  readonly page?: number;
};

export type CommitSearchResultItem = {
  readonly url: string;
  readonly sha: string;
  readonly html_url: string;
  readonly comments_url: string;
  readonly commit: {
    readonly author: {
      readonly name: string;
      readonly email: string;
      readonly date: string;
    };
    readonly committer: GitUser;
    readonly comment_count: number;
    readonly message: string;
    readonly tree: { readonly sha: string; readonly url: string };
    readonly url: string;
    readonly verification?: Verification;
  };
  readonly author: SimpleUser;
  readonly committer: GitUser;
  readonly parents: ReadonlyArray<{
    readonly url?: string;
    readonly html_url?: string;
    readonly sha?: string;
  }>;
  readonly repository: MinimalRepository;
  readonly score: number;
  readonly node_id: string;
  readonly text_matches?: SearchResultTextMatches;
};

export type SearchCommits200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<CommitSearchResultItem>;
};

export type SearchCommitsRequestQuery = {
  readonly q: string;
  readonly sort?: 'author-date' | 'committer-date';
  readonly order?: 'desc' | 'asc';
  readonly per_page?: number;
  readonly page?: number;
};

export type IssueSearchResultItem = {
  readonly url: string;
  readonly repository_url: string;
  readonly labels_url: string;
  readonly comments_url: string;
  readonly events_url: string;
  readonly html_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly number: number;
  readonly title: string;
  readonly locked: boolean;
  readonly active_lock_reason?: string | null;
  readonly assignees?: ReadonlyArray<SimpleUser> | null;
  readonly user: SimpleUser;
  readonly labels: ReadonlyArray<{
    readonly id?: number;
    readonly node_id?: string;
    readonly url?: string;
    readonly name?: string;
    readonly color?: string;
    readonly default?: boolean;
    readonly description?: string | null;
  }>;
  readonly state: string;
  readonly state_reason?: string | null;
  readonly assignee: SimpleUser;
  readonly milestone: Milestone;
  readonly comments: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly closed_at: string | null;
  readonly text_matches?: SearchResultTextMatches;
  readonly pull_request?: {
    readonly merged_at?: string | null;
    readonly diff_url: string | null;
    readonly html_url: string | null;
    readonly patch_url: string | null;
    readonly url: string | null;
  };
  readonly body?: string;
  readonly score: number;
  readonly author_association: AuthorAssociation;
  readonly draft?: boolean;
  readonly repository?: Repository;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly timeline_url?: string;
  readonly performed_via_github_app?: GitHubApp;
  readonly reactions?: ReactionRollup;
};

export type SearchIssuesAndPullRequests200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<IssueSearchResultItem>;
};

export type SearchIssuesAndPullRequests403ResponseBody = BasicError;

export type SearchIssuesAndPullRequests422ResponseBody = ValidationError;

export type SearchIssuesAndPullRequests503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SearchIssuesAndPullRequestsRequestQuery = {
  readonly q: string;
  readonly sort?:
    | 'comments'
    | 'reactions'
    | 'reactions-+1'
    | 'reactions--1'
    | 'reactions-smile'
    | 'reactions-thinking_face'
    | 'reactions-heart'
    | 'reactions-tada'
    | 'interactions'
    | 'created'
    | 'updated';
  readonly order?: 'desc' | 'asc';
  readonly per_page?: number;
  readonly page?: number;
};

export type LabelSearchResultItem = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly name: string;
  readonly color: string;
  readonly default: boolean;
  readonly description: string | null;
  readonly score: number;
  readonly text_matches?: SearchResultTextMatches;
};

export type SearchLabels200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<LabelSearchResultItem>;
};

export type SearchLabels403ResponseBody = BasicError;

export type SearchLabels404ResponseBody = BasicError;

export type SearchLabels422ResponseBody = ValidationError;

export type SearchLabelsRequestQuery = {
  readonly repository_id: number;
  readonly q: string;
  readonly sort?: 'created' | 'updated';
  readonly order?: 'desc' | 'asc';
  readonly per_page?: number;
  readonly page?: number;
};

export type RepoSearchResultItem = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly pushed_at: string;
  readonly homepage: string | null;
  readonly size: number;
  readonly stargazers_count: number;
  readonly watchers_count: number;
  readonly language: string | null;
  readonly forks_count: number;
  readonly open_issues_count: number;
  readonly master_branch?: string;
  readonly default_branch: string;
  readonly score: number;
  readonly forks_url: string;
  readonly keys_url: string;
  readonly collaborators_url: string;
  readonly teams_url: string;
  readonly hooks_url: string;
  readonly issue_events_url: string;
  readonly events_url: string;
  readonly assignees_url: string;
  readonly branches_url: string;
  readonly tags_url: string;
  readonly blobs_url: string;
  readonly git_tags_url: string;
  readonly git_refs_url: string;
  readonly trees_url: string;
  readonly statuses_url: string;
  readonly languages_url: string;
  readonly stargazers_url: string;
  readonly contributors_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly commits_url: string;
  readonly git_commits_url: string;
  readonly comments_url: string;
  readonly issue_comment_url: string;
  readonly contents_url: string;
  readonly compare_url: string;
  readonly merges_url: string;
  readonly archive_url: string;
  readonly downloads_url: string;
  readonly issues_url: string;
  readonly pulls_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly labels_url: string;
  readonly releases_url: string;
  readonly deployments_url: string;
  readonly git_url: string;
  readonly ssh_url: string;
  readonly clone_url: string;
  readonly svn_url: string;
  readonly forks: number;
  readonly open_issues: number;
  readonly watchers: number;
  readonly topics?: ReadonlyArray<string>;
  readonly mirror_url: string | null;
  readonly has_issues: boolean;
  readonly has_projects: boolean;
  readonly has_pages: boolean;
  readonly has_wiki: boolean;
  readonly has_downloads: boolean;
  readonly archived: boolean;
  readonly disabled: boolean;
  readonly visibility?: string;
  readonly license: LicenseSimple;
  readonly permissions?: {
    readonly admin: boolean;
    readonly maintain?: boolean;
    readonly push: boolean;
    readonly triage?: boolean;
    readonly pull: boolean;
  };
  readonly text_matches?: SearchResultTextMatches;
  readonly temp_clone_token?: string;
  readonly allow_merge_commit?: boolean;
  readonly allow_squash_merge?: boolean;
  readonly allow_rebase_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_forking?: boolean;
  readonly is_template?: boolean;
  readonly web_commit_signoff_required?: boolean;
};

export type SearchRepos200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<RepoSearchResultItem>;
};

export type SearchRepos422ResponseBody = ValidationError;

export type SearchRepos503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SearchReposRequestQuery = {
  readonly q: string;
  readonly sort?: 'stars' | 'forks' | 'help-wanted-issues' | 'updated';
  readonly order?: 'desc' | 'asc';
  readonly per_page?: number;
  readonly page?: number;
};

export type TopicSearchResultItem = {
  readonly name: string;
  readonly display_name: string | null;
  readonly short_description: string | null;
  readonly description: string | null;
  readonly created_by: string | null;
  readonly released: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly featured: boolean;
  readonly curated: boolean;
  readonly score: number;
  readonly repository_count?: number | null;
  readonly logo_url?: string | null;
  readonly text_matches?: SearchResultTextMatches;
  readonly related?: ReadonlyArray<{
    readonly topic_relation?: {
      readonly id?: number;
      readonly name?: string;
      readonly topic_id?: number;
      readonly relation_type?: string;
    };
  }> | null;
  readonly aliases?: ReadonlyArray<{
    readonly topic_relation?: {
      readonly id?: number;
      readonly name?: string;
      readonly topic_id?: number;
      readonly relation_type?: string;
    };
  }> | null;
};

export type SearchTopics200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<TopicSearchResultItem>;
};

export type SearchTopicsRequestQuery = {
  readonly q: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type UserSearchResultItem = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly score: number;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly events_url: string;
  readonly public_repos?: number;
  readonly public_gists?: number;
  readonly followers?: number;
  readonly following?: number;
  readonly created_at?: string;
  readonly updated_at?: string;
  readonly name?: string | null;
  readonly bio?: string | null;
  readonly email?: string | null;
  readonly location?: string | null;
  readonly site_admin: boolean;
  readonly hireable?: boolean | null;
  readonly text_matches?: SearchResultTextMatches;
  readonly blog?: string | null;
  readonly company?: string | null;
  readonly suspended_at?: string | null;
};

export type SearchUsers200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<UserSearchResultItem>;
};

export type SearchUsers422ResponseBody = ValidationError;

export type SearchUsers503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SearchUsersRequestQuery = {
  readonly q: string;
  readonly sort?: 'followers' | 'repositories' | 'joined';
  readonly order?: 'desc' | 'asc';
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsGetLegacy200ResponseBody = FullTeam;

export type TeamsGetLegacy404ResponseBody = BasicError;

export type TeamsGetLegacyRequestPath = { readonly team_id: number };

export type TeamsUpdateLegacy200ResponseBody = FullTeam;

export type TeamsUpdateLegacy201ResponseBody = FullTeam;

export type TeamsUpdateLegacy403ResponseBody = BasicError;

export type TeamsUpdateLegacy404ResponseBody = BasicError;

export type TeamsUpdateLegacy422ResponseBody = ValidationError;

export type TeamsUpdateLegacyRequestBody = {
  readonly name: string;
  readonly description?: string;
  readonly privacy?: 'secret' | 'closed';
  readonly permission?: 'pull' | 'push' | 'admin';
  readonly parent_team_id?: number | null;
};

export type TeamsUpdateLegacyRequestPath = { readonly team_id: number };

export type TeamsDeleteLegacy404ResponseBody = BasicError;

export type TeamsDeleteLegacy422ResponseBody = ValidationError;

export type TeamsDeleteLegacyRequestPath = { readonly team_id: number };

export type TeamsListDiscussionsLegacy200ResponseBody = ReadonlyArray<TeamDiscussion>;

export type TeamsListDiscussionsLegacyRequestQuery = {
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListDiscussionsLegacyRequestPath = {
  readonly team_id: number;
};

export type TeamsCreateDiscussionLegacy201ResponseBody = TeamDiscussion;

export type TeamsCreateDiscussionLegacyRequestBody = {
  readonly title: string;
  readonly body: string;
  readonly private?: boolean;
};

export type TeamsCreateDiscussionLegacyRequestPath = {
  readonly team_id: number;
};

export type TeamsGetDiscussionLegacy200ResponseBody = TeamDiscussion;

export type TeamsGetDiscussionLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type TeamsUpdateDiscussionLegacy200ResponseBody = TeamDiscussion;

export type TeamsUpdateDiscussionLegacyRequestBody = {
  readonly title?: string;
  readonly body?: string;
};

export type TeamsUpdateDiscussionLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type TeamsDeleteDiscussionLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type TeamsListDiscussionCommentsLegacy200ResponseBody = ReadonlyArray<TeamDiscussionComment>;

export type TeamsListDiscussionCommentsLegacyRequestQuery = {
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListDiscussionCommentsLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type TeamsCreateDiscussionCommentLegacy201ResponseBody = TeamDiscussionComment;

export type TeamsCreateDiscussionCommentLegacyRequestBody = {
  readonly body: string;
};

export type TeamsCreateDiscussionCommentLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type TeamsGetDiscussionCommentLegacy200ResponseBody = TeamDiscussionComment;

export type TeamsGetDiscussionCommentLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type TeamsUpdateDiscussionCommentLegacy200ResponseBody = TeamDiscussionComment;

export type TeamsUpdateDiscussionCommentLegacyRequestBody = {
  readonly body: string;
};

export type TeamsUpdateDiscussionCommentLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type TeamsDeleteDiscussionCommentLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type ReactionsListForTeamDiscussionCommentLegacy200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForTeamDiscussionCommentLegacyRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForTeamDiscussionCommentLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type ReactionsCreateForTeamDiscussionCommentLegacy201ResponseBody = Reaction;

export type ReactionsCreateForTeamDiscussionCommentLegacyRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForTeamDiscussionCommentLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type ReactionsListForTeamDiscussionLegacy200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForTeamDiscussionLegacyRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForTeamDiscussionLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type ReactionsCreateForTeamDiscussionLegacy201ResponseBody = Reaction;

export type ReactionsCreateForTeamDiscussionLegacyRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForTeamDiscussionLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type TeamsListPendingInvitationsLegacy200ResponseBody = ReadonlyArray<OrganizationInvitation>;

export type TeamsListPendingInvitationsLegacyRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListPendingInvitationsLegacyRequestPath = {
  readonly team_id: number;
};

export type TeamsListMembersLegacy200ResponseBody = ReadonlyArray<SimpleUser>;

export type TeamsListMembersLegacy404ResponseBody = BasicError;

export type TeamsListMembersLegacyRequestQuery = {
  readonly role?: 'member' | 'maintainer' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListMembersLegacyRequestPath = { readonly team_id: number };

export type TeamsGetMemberLegacyRequestPath = {
  readonly team_id: number;
  readonly username: string;
};

export type TeamsAddMemberLegacy403ResponseBody = BasicError;

export type TeamsAddMemberLegacyRequestPath = {
  readonly team_id: number;
  readonly username: string;
};

export type TeamsRemoveMemberLegacyRequestPath = {
  readonly team_id: number;
  readonly username: string;
};

export type TeamsGetMembershipForUserLegacy200ResponseBody = TeamMembership;

export type TeamsGetMembershipForUserLegacy404ResponseBody = BasicError;

export type TeamsGetMembershipForUserLegacyRequestPath = {
  readonly team_id: number;
  readonly username: string;
};

export type TeamsAddOrUpdateMembershipForUserLegacy200ResponseBody = TeamMembership;

export type TeamsAddOrUpdateMembershipForUserLegacy404ResponseBody = BasicError;

export type TeamsAddOrUpdateMembershipForUserLegacyRequestBody = {
  readonly role?: 'member' | 'maintainer';
};

export type TeamsAddOrUpdateMembershipForUserLegacyRequestPath = {
  readonly team_id: number;
  readonly username: string;
};

export type TeamsRemoveMembershipForUserLegacyRequestPath = {
  readonly team_id: number;
  readonly username: string;
};

export type TeamsListProjectsLegacy200ResponseBody = ReadonlyArray<TeamProject>;

export type TeamsListProjectsLegacy404ResponseBody = BasicError;

export type TeamsListProjectsLegacyRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListProjectsLegacyRequestPath = { readonly team_id: number };

export type TeamsCheckPermissionsForProjectLegacy200ResponseBody = TeamProject;

export type TeamsCheckPermissionsForProjectLegacyRequestPath = {
  readonly team_id: number;
  readonly project_id: number;
};

export type TeamsAddOrUpdateProjectPermissionsLegacy403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
};

export type TeamsAddOrUpdateProjectPermissionsLegacy404ResponseBody = BasicError;

export type TeamsAddOrUpdateProjectPermissionsLegacy422ResponseBody = ValidationError;

export type TeamsAddOrUpdateProjectPermissionsLegacyRequestBody = {
  readonly permission?: 'read' | 'write' | 'admin';
};

export type TeamsAddOrUpdateProjectPermissionsLegacyRequestPath = {
  readonly team_id: number;
  readonly project_id: number;
};

export type TeamsRemoveProjectLegacy404ResponseBody = BasicError;

export type TeamsRemoveProjectLegacy422ResponseBody = ValidationError;

export type TeamsRemoveProjectLegacyRequestPath = {
  readonly team_id: number;
  readonly project_id: number;
};

export type TeamsListReposLegacy200ResponseBody = ReadonlyArray<MinimalRepository>;

export type TeamsListReposLegacy404ResponseBody = BasicError;

export type TeamsListReposLegacyRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListReposLegacyRequestPath = { readonly team_id: number };

export type TeamsCheckPermissionsForRepoLegacy200ResponseBody = TeamRepository;

export type TeamsCheckPermissionsForRepoLegacyRequestPath = {
  readonly team_id: number;
  readonly owner: string;
  readonly repo: string;
};

export type TeamsAddOrUpdateRepoPermissionsLegacy403ResponseBody = BasicError;

export type TeamsAddOrUpdateRepoPermissionsLegacy422ResponseBody = ValidationError;

export type TeamsAddOrUpdateRepoPermissionsLegacyRequestBody = {
  readonly permission?: 'pull' | 'push' | 'admin';
};

export type TeamsAddOrUpdateRepoPermissionsLegacyRequestPath = {
  readonly team_id: number;
  readonly owner: string;
  readonly repo: string;
};

export type TeamsRemoveRepoLegacyRequestPath = {
  readonly team_id: number;
  readonly owner: string;
  readonly repo: string;
};

export type TeamsListChildLegacy200ResponseBody = ReadonlyArray<Team>;

export type TeamsListChildLegacy403ResponseBody = BasicError;

export type TeamsListChildLegacy404ResponseBody = BasicError;

export type TeamsListChildLegacy422ResponseBody = ValidationError;

export type TeamsListChildLegacyRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListChildLegacyRequestPath = { readonly team_id: number };

export type PrivateUser = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly site_admin: boolean;
  readonly name: string | null;
  readonly company: string | null;
  readonly blog: string | null;
  readonly location: string | null;
  readonly email: string | null;
  readonly hireable: boolean | null;
  readonly bio: string | null;
  readonly twitter_username?: string | null;
  readonly public_repos: number;
  readonly public_gists: number;
  readonly followers: number;
  readonly following: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly private_gists: number;
  readonly total_private_repos: number;
  readonly owned_private_repos: number;
  readonly disk_usage: number;
  readonly collaborators: number;
  readonly two_factor_authentication: boolean;
  readonly plan?: {
    readonly collaborators: number;
    readonly name: string;
    readonly space: number;
    readonly private_repos: number;
  };
  readonly suspended_at?: string | null;
  readonly business_plus?: boolean;
  readonly ldap_dn?: string;
};

export type UsersGetAuthenticated200ResponseBody = PrivateUser | PublicUser;

export type UsersGetAuthenticated401ResponseBody = BasicError;

export type UsersGetAuthenticated403ResponseBody = BasicError;

export type UsersUpdateAuthenticated200ResponseBody = PrivateUser;

export type UsersUpdateAuthenticated401ResponseBody = BasicError;

export type UsersUpdateAuthenticated403ResponseBody = BasicError;

export type UsersUpdateAuthenticated404ResponseBody = BasicError;

export type UsersUpdateAuthenticated422ResponseBody = ValidationError;

export type UsersUpdateAuthenticatedRequestBody = {
  readonly name?: string;
  readonly email?: string;
  readonly blog?: string;
  readonly twitter_username?: string | null;
  readonly company?: string;
  readonly location?: string;
  readonly hireable?: boolean;
  readonly bio?: string;
};

export type UsersListBlockedByAuthenticatedUser200ResponseBody = ReadonlyArray<SimpleUser>;

export type UsersListBlockedByAuthenticatedUser401ResponseBody = BasicError;

export type UsersListBlockedByAuthenticatedUser403ResponseBody = BasicError;

export type UsersListBlockedByAuthenticatedUser404ResponseBody = BasicError;

export type UsersListBlockedByAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersCheckBlocked401ResponseBody = BasicError;

export type UsersCheckBlocked403ResponseBody = BasicError;

export type UsersCheckBlocked404ResponseBody = BasicError;

export type UsersCheckBlockedRequestPath = { readonly username: string };

export type UsersBlock401ResponseBody = BasicError;

export type UsersBlock403ResponseBody = BasicError;

export type UsersBlock404ResponseBody = BasicError;

export type UsersBlock422ResponseBody = ValidationError;

export type UsersBlockRequestPath = { readonly username: string };

export type UsersUnblock401ResponseBody = BasicError;

export type UsersUnblock403ResponseBody = BasicError;

export type UsersUnblock404ResponseBody = BasicError;

export type UsersUnblockRequestPath = { readonly username: string };

export type CodespacesListForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly codespaces: ReadonlyArray<Codespace>;
};

export type CodespacesListForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesListForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesListForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesListForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesListForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly repository_id?: number;
};

export type CodespacesCreateForAuthenticatedUser201ResponseBody = Codespace;

export type CodespacesCreateForAuthenticatedUser202ResponseBody = Codespace;

export type CodespacesCreateForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesCreateForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesCreateForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesCreateForAuthenticatedUser503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodespacesCreateForAuthenticatedUserRequestBody =
  | {
      readonly repository_id: number;
      readonly ref?: string;
      readonly location?: string;
      readonly client_ip?: string;
      readonly machine?: string;
      readonly devcontainer_path?: string;
      readonly multi_repo_permissions_opt_out?: boolean;
      readonly working_directory?: string;
      readonly idle_timeout_minutes?: number;
      readonly display_name?: string;
      readonly retention_period_minutes?: number;
    }
  | {
      readonly pull_request: {
        readonly pull_request_number: number;
        readonly repository_id: number;
      };
      readonly location?: string;
      readonly machine?: string;
      readonly devcontainer_path?: string;
      readonly working_directory?: string;
      readonly idle_timeout_minutes?: number;
    };

export type CodespacesListSecretsForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<CodespacesSecret>;
};

export type CodespacesListSecretsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesUserPublicKey = {
  readonly key_id: string;
  readonly key: string;
};

export type CodespacesGetPublicKeyForAuthenticatedUser200ResponseBody = CodespacesUserPublicKey;

export type CodespacesGetSecretForAuthenticatedUser200ResponseBody = CodespacesSecret;

export type CodespacesGetSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
};

export type CodespacesCreateOrUpdateSecretForAuthenticatedUser201ResponseBody = EmptyObject;

export type CodespacesCreateOrUpdateSecretForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesCreateOrUpdateSecretForAuthenticatedUser422ResponseBody = ValidationError;

export type CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id: string;
  readonly selected_repository_ids?: ReadonlyArray<string>;
};

export type CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
};

export type CodespacesDeleteSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
};

export type CodespacesListRepositoriesForSecretForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<MinimalRepository>;
};

export type CodespacesListRepositoriesForSecretForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesListRepositoriesForSecretForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesListRepositoriesForSecretForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesListRepositoriesForSecretForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesListRepositoriesForSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
};

export type CodespacesSetRepositoriesForSecretForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesSetRepositoriesForSecretForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesSetRepositoriesForSecretForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesSetRepositoriesForSecretForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestBody = {
  readonly selected_repository_ids: ReadonlyArray<number>;
};

export type CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
};

export type CodespacesAddRepositoryForSecretForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesAddRepositoryForSecretForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesAddRepositoryForSecretForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesAddRepositoryForSecretForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesAddRepositoryForSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
  readonly repository_id: number;
};

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
  readonly repository_id: number;
};

export type CodespacesGetForAuthenticatedUser200ResponseBody = Codespace;

export type CodespacesGetForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesGetForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesGetForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesGetForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesGetForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type CodespacesUpdateForAuthenticatedUser200ResponseBody = Codespace;

export type CodespacesUpdateForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesUpdateForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesUpdateForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesUpdateForAuthenticatedUserRequestBody = {
  readonly machine?: string;
  readonly display_name?: string;
  readonly recent_folders?: ReadonlyArray<string>;
};

export type CodespacesUpdateForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type CodespacesDeleteForAuthenticatedUser202ResponseBody = unknown;

export type CodespacesDeleteForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesDeleteForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesDeleteForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesDeleteForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesDeleteForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type FetchesInformationAboutAnExportOfACodespace = {
  readonly state?: string | null;
  readonly completed_at?: string | null;
  readonly branch?: string | null;
  readonly sha?: string | null;
  readonly id?: string;
  readonly export_url?: string;
  readonly html_url?: string | null;
};

export type CodespacesExportForAuthenticatedUser202ResponseBody = FetchesInformationAboutAnExportOfACodespace;

export type CodespacesExportForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesExportForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesExportForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesExportForAuthenticatedUser422ResponseBody = ValidationError;

export type CodespacesExportForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesExportForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type CodespacesGetExportDetailsForAuthenticatedUser200ResponseBody = FetchesInformationAboutAnExportOfACodespace;

export type CodespacesGetExportDetailsForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesGetExportDetailsForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
  readonly export_id: string;
};

export type CodespacesCodespaceMachinesForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly machines: ReadonlyArray<CodespaceMachine>;
};

export type CodespacesCodespaceMachinesForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesCodespaceMachinesForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesCodespaceMachinesForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesCodespaceMachinesForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesCodespaceMachinesForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type CodespacesStartForAuthenticatedUser200ResponseBody = Codespace;

export type CodespacesStartForAuthenticatedUser400ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUser402ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUser409ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type CodespacesStopForAuthenticatedUser200ResponseBody = Codespace;

export type CodespacesStopForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesStopForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesStopForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesStopForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesStopForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type Email = {
  readonly email: string;
  readonly primary: boolean;
  readonly verified: boolean;
  readonly visibility: string | null;
};

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUser200ResponseBody = ReadonlyArray<Email>;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUser401ResponseBody = BasicError;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUser403ResponseBody = BasicError;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUser404ResponseBody = BasicError;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestBody = {
  readonly visibility: 'public' | 'private';
};

export type UsersListEmailsForAuthenticatedUser200ResponseBody = ReadonlyArray<Email>;

export type UsersListEmailsForAuthenticatedUser401ResponseBody = BasicError;

export type UsersListEmailsForAuthenticatedUser403ResponseBody = BasicError;

export type UsersListEmailsForAuthenticatedUser404ResponseBody = BasicError;

export type UsersListEmailsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersAddEmailForAuthenticatedUser201ResponseBody = ReadonlyArray<Email>;

export type UsersAddEmailForAuthenticatedUser401ResponseBody = BasicError;

export type UsersAddEmailForAuthenticatedUser403ResponseBody = BasicError;

export type UsersAddEmailForAuthenticatedUser404ResponseBody = BasicError;

export type UsersAddEmailForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersAddEmailForAuthenticatedUserRequestBody =
  | { readonly emails: ReadonlyArray<string> }
  | ReadonlyArray<string>
  | string;

export type UsersDeleteEmailForAuthenticatedUser401ResponseBody = BasicError;

export type UsersDeleteEmailForAuthenticatedUser403ResponseBody = BasicError;

export type UsersDeleteEmailForAuthenticatedUser404ResponseBody = BasicError;

export type UsersDeleteEmailForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersDeleteEmailForAuthenticatedUserRequestBody =
  | { readonly emails: ReadonlyArray<string> }
  | ReadonlyArray<string>
  | string;

export type UsersListFollowersForAuthenticatedUser200ResponseBody = ReadonlyArray<SimpleUser>;

export type UsersListFollowersForAuthenticatedUser401ResponseBody = BasicError;

export type UsersListFollowersForAuthenticatedUser403ResponseBody = BasicError;

export type UsersListFollowersForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersListFollowedByAuthenticatedUser200ResponseBody = ReadonlyArray<SimpleUser>;

export type UsersListFollowedByAuthenticatedUser401ResponseBody = BasicError;

export type UsersListFollowedByAuthenticatedUser403ResponseBody = BasicError;

export type UsersListFollowedByAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersCheckPersonIsFollowedByAuthenticated401ResponseBody = BasicError;

export type UsersCheckPersonIsFollowedByAuthenticated403ResponseBody = BasicError;

export type UsersCheckPersonIsFollowedByAuthenticated404ResponseBody = BasicError;

export type UsersCheckPersonIsFollowedByAuthenticatedRequestPath = {
  readonly username: string;
};

export type UsersFollow401ResponseBody = BasicError;

export type UsersFollow403ResponseBody = BasicError;

export type UsersFollow404ResponseBody = BasicError;

export type UsersFollowRequestPath = { readonly username: string };

export type UsersUnfollow401ResponseBody = BasicError;

export type UsersUnfollow403ResponseBody = BasicError;

export type UsersUnfollow404ResponseBody = BasicError;

export type UsersUnfollowRequestPath = { readonly username: string };

export type GpgKey = {
  readonly id: number;
  readonly name?: string | null;
  readonly primary_key_id: number | null;
  readonly key_id: string;
  readonly public_key: string;
  readonly emails: ReadonlyArray<{
    readonly email?: string;
    readonly verified?: boolean;
  }>;
  readonly subkeys: ReadonlyArray<{
    readonly id?: number;
    readonly primary_key_id?: number;
    readonly key_id?: string;
    readonly public_key?: string;
    readonly emails?: ReadonlyArray<unknown>;
    readonly subkeys?: ReadonlyArray<unknown>;
    readonly can_sign?: boolean;
    readonly can_encrypt_comms?: boolean;
    readonly can_encrypt_storage?: boolean;
    readonly can_certify?: boolean;
    readonly created_at?: string;
    readonly expires_at?: string | null;
    readonly raw_key?: string | null;
    readonly revoked?: boolean;
  }>;
  readonly can_sign: boolean;
  readonly can_encrypt_comms: boolean;
  readonly can_encrypt_storage: boolean;
  readonly can_certify: boolean;
  readonly created_at: string;
  readonly expires_at: string | null;
  readonly revoked: boolean;
  readonly raw_key: string | null;
};

export type UsersListGpgKeysForAuthenticatedUser200ResponseBody = ReadonlyArray<GpgKey>;

export type UsersListGpgKeysForAuthenticatedUser401ResponseBody = BasicError;

export type UsersListGpgKeysForAuthenticatedUser403ResponseBody = BasicError;

export type UsersListGpgKeysForAuthenticatedUser404ResponseBody = BasicError;

export type UsersListGpgKeysForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersCreateGpgKeyForAuthenticatedUser201ResponseBody = GpgKey;

export type UsersCreateGpgKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersCreateGpgKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersCreateGpgKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersCreateGpgKeyForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersCreateGpgKeyForAuthenticatedUserRequestBody = {
  readonly name?: string;
  readonly armored_public_key: string;
};

export type UsersGetGpgKeyForAuthenticatedUser200ResponseBody = GpgKey;

export type UsersGetGpgKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersGetGpgKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersGetGpgKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersGetGpgKeyForAuthenticatedUserRequestPath = {
  readonly gpg_key_id: number;
};

export type UsersDeleteGpgKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersDeleteGpgKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersDeleteGpgKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersDeleteGpgKeyForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersDeleteGpgKeyForAuthenticatedUserRequestPath = {
  readonly gpg_key_id: number;
};

export type AppsListInstallationsForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly installations: ReadonlyArray<Installation>;
};

export type AppsListInstallationsForAuthenticatedUser401ResponseBody = BasicError;

export type AppsListInstallationsForAuthenticatedUser403ResponseBody = BasicError;

export type AppsListInstallationsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListInstallationReposForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly repository_selection?: string;
  readonly repositories: ReadonlyArray<Repository>;
};

export type AppsListInstallationReposForAuthenticatedUser403ResponseBody = BasicError;

export type AppsListInstallationReposForAuthenticatedUser404ResponseBody = BasicError;

export type AppsListInstallationReposForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListInstallationReposForAuthenticatedUserRequestPath = {
  readonly installation_id: number;
};

export type AppsAddRepoToInstallationForAuthenticatedUser403ResponseBody = BasicError;

export type AppsAddRepoToInstallationForAuthenticatedUser404ResponseBody = BasicError;

export type AppsAddRepoToInstallationForAuthenticatedUserRequestPath = {
  readonly installation_id: number;
  readonly repository_id: number;
};

export type AppsRemoveRepoFromInstallationForAuthenticatedUser403ResponseBody = BasicError;

export type AppsRemoveRepoFromInstallationForAuthenticatedUser404ResponseBody = BasicError;

export type AppsRemoveRepoFromInstallationForAuthenticatedUserRequestPath = {
  readonly installation_id: number;
  readonly repository_id: number;
};

export type InteractionsGetRestrictionsForAuthenticatedUser200ResponseBody =
  | InteractionLimits
  | {};

export type InteractionsSetRestrictionsForAuthenticatedUser200ResponseBody = InteractionLimits;

export type InteractionsSetRestrictionsForAuthenticatedUser422ResponseBody = ValidationError;

export type InteractionsSetRestrictionsForAuthenticatedUserRequestBody = InteractionRestrictions;

export type IssuesListForAuthenticatedUser200ResponseBody = ReadonlyArray<Issue>;

export type IssuesListForAuthenticatedUser404ResponseBody = BasicError;

export type IssuesListForAuthenticatedUserRequestQuery = {
  readonly filter?:
    | 'assigned'
    | 'created'
    | 'mentioned'
    | 'subscribed'
    | 'repos'
    | 'all';
  readonly state?: 'open' | 'closed' | 'all';
  readonly labels?: string;
  readonly sort?: 'created' | 'updated' | 'comments';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type Key = {
  readonly key: string;
  readonly id: number;
  readonly url: string;
  readonly title: string;
  readonly created_at: string;
  readonly verified: boolean;
  readonly read_only: boolean;
};

export type UsersListPublicSshKeysForAuthenticatedUser200ResponseBody = ReadonlyArray<Key>;

export type UsersListPublicSshKeysForAuthenticatedUser401ResponseBody = BasicError;

export type UsersListPublicSshKeysForAuthenticatedUser403ResponseBody = BasicError;

export type UsersListPublicSshKeysForAuthenticatedUser404ResponseBody = BasicError;

export type UsersListPublicSshKeysForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersCreatePublicSshKeyForAuthenticatedUser201ResponseBody = Key;

export type UsersCreatePublicSshKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersCreatePublicSshKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersCreatePublicSshKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersCreatePublicSshKeyForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersCreatePublicSshKeyForAuthenticatedUserRequestBody = {
  readonly title?: string;
  readonly key: string;
};

export type UsersGetPublicSshKeyForAuthenticatedUser200ResponseBody = Key;

export type UsersGetPublicSshKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersGetPublicSshKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersGetPublicSshKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersGetPublicSshKeyForAuthenticatedUserRequestPath = {
  readonly key_id: number;
};

export type UsersDeletePublicSshKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersDeletePublicSshKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersDeletePublicSshKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersDeletePublicSshKeyForAuthenticatedUserRequestPath = {
  readonly key_id: number;
};

export type MarketplaceAccount = {
  readonly url: string;
  readonly id: number;
  readonly type: string;
  readonly node_id?: string;
  readonly login: string;
  readonly email?: string | null;
  readonly organization_billing_email?: string | null;
};

export type UserMarketplacePurchase = {
  readonly billing_cycle: string;
  readonly next_billing_date: string | null;
  readonly unit_count: number | null;
  readonly on_free_trial: boolean;
  readonly free_trial_ends_on: string | null;
  readonly updated_at: string | null;
  readonly account: MarketplaceAccount;
  readonly plan: MarketplaceListingPlan;
};

export type AppsListSubscriptionsForAuthenticatedUser200ResponseBody = ReadonlyArray<UserMarketplacePurchase>;

export type AppsListSubscriptionsForAuthenticatedUser401ResponseBody = BasicError;

export type AppsListSubscriptionsForAuthenticatedUser404ResponseBody = BasicError;

export type AppsListSubscriptionsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListSubscriptionsForAuthenticatedUserStubbed200ResponseBody = ReadonlyArray<UserMarketplacePurchase>;

export type AppsListSubscriptionsForAuthenticatedUserStubbed401ResponseBody = BasicError;

export type AppsListSubscriptionsForAuthenticatedUserStubbedRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListMembershipsForAuthenticatedUser200ResponseBody = ReadonlyArray<OrgMembership>;

export type OrgsListMembershipsForAuthenticatedUser401ResponseBody = BasicError;

export type OrgsListMembershipsForAuthenticatedUser403ResponseBody = BasicError;

export type OrgsListMembershipsForAuthenticatedUser422ResponseBody = ValidationError;

export type OrgsListMembershipsForAuthenticatedUserRequestQuery = {
  readonly state?: 'active' | 'pending';
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsGetMembershipForAuthenticatedUser200ResponseBody = OrgMembership;

export type OrgsGetMembershipForAuthenticatedUser403ResponseBody = BasicError;

export type OrgsGetMembershipForAuthenticatedUser404ResponseBody = BasicError;

export type OrgsGetMembershipForAuthenticatedUserRequestPath = {
  readonly org: string;
};

export type OrgsUpdateMembershipForAuthenticatedUser200ResponseBody = OrgMembership;

export type OrgsUpdateMembershipForAuthenticatedUser403ResponseBody = BasicError;

export type OrgsUpdateMembershipForAuthenticatedUser404ResponseBody = BasicError;

export type OrgsUpdateMembershipForAuthenticatedUser422ResponseBody = ValidationError;

export type OrgsUpdateMembershipForAuthenticatedUserRequestBody = {
  readonly state: 'active';
};

export type OrgsUpdateMembershipForAuthenticatedUserRequestPath = {
  readonly org: string;
};

export type MigrationsListForAuthenticatedUser200ResponseBody = ReadonlyArray<Migration>;

export type MigrationsListForAuthenticatedUser401ResponseBody = BasicError;

export type MigrationsListForAuthenticatedUser403ResponseBody = BasicError;

export type MigrationsListForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type MigrationsStartForAuthenticatedUser201ResponseBody = Migration;

export type MigrationsStartForAuthenticatedUser401ResponseBody = BasicError;

export type MigrationsStartForAuthenticatedUser403ResponseBody = BasicError;

export type MigrationsStartForAuthenticatedUser422ResponseBody = ValidationError;

export type MigrationsStartForAuthenticatedUserRequestBody = {
  readonly lock_repositories?: boolean;
  readonly exclude_metadata?: boolean;
  readonly exclude_git_data?: boolean;
  readonly exclude_attachments?: boolean;
  readonly exclude_releases?: boolean;
  readonly exclude_owner_projects?: boolean;
  readonly org_metadata_only?: boolean;
  readonly exclude?: ReadonlyArray<'repositories'>;
  readonly repositories: ReadonlyArray<string>;
};

export type MigrationsGetStatusForAuthenticatedUser200ResponseBody = Migration;

export type MigrationsGetStatusForAuthenticatedUser401ResponseBody = BasicError;

export type MigrationsGetStatusForAuthenticatedUser403ResponseBody = BasicError;

export type MigrationsGetStatusForAuthenticatedUser404ResponseBody = BasicError;

export type MigrationsGetStatusForAuthenticatedUserRequestQuery = {
  readonly exclude?: ReadonlyArray<string> | string;
};

export type MigrationsGetStatusForAuthenticatedUserRequestPath = {
  readonly migration_id: number;
};

export type MigrationsGetArchiveForAuthenticatedUser401ResponseBody = BasicError;

export type MigrationsGetArchiveForAuthenticatedUser403ResponseBody = BasicError;

export type MigrationsGetArchiveForAuthenticatedUserRequestPath = {
  readonly migration_id: number;
};

export type MigrationsDeleteArchiveForAuthenticatedUser401ResponseBody = BasicError;

export type MigrationsDeleteArchiveForAuthenticatedUser403ResponseBody = BasicError;

export type MigrationsDeleteArchiveForAuthenticatedUser404ResponseBody = BasicError;

export type MigrationsDeleteArchiveForAuthenticatedUserRequestPath = {
  readonly migration_id: number;
};

export type MigrationsUnlockRepoForAuthenticatedUser401ResponseBody = BasicError;

export type MigrationsUnlockRepoForAuthenticatedUser403ResponseBody = BasicError;

export type MigrationsUnlockRepoForAuthenticatedUser404ResponseBody = BasicError;

export type MigrationsUnlockRepoForAuthenticatedUserRequestPath = {
  readonly migration_id: number;
  readonly repo_name: string;
};

export type MigrationsListReposForAuthenticatedUser200ResponseBody = ReadonlyArray<MinimalRepository>;

export type MigrationsListReposForAuthenticatedUser404ResponseBody = BasicError;

export type MigrationsListReposForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type MigrationsListReposForAuthenticatedUserRequestPath = {
  readonly migration_id: number;
};

export type OrgsListForAuthenticatedUser200ResponseBody = ReadonlyArray<OrganizationSimple>;

export type OrgsListForAuthenticatedUser401ResponseBody = BasicError;

export type OrgsListForAuthenticatedUser403ResponseBody = BasicError;

export type OrgsListForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type PackagesListPackagesForAuthenticatedUser200ResponseBody = ReadonlyArray<Package>;

export type PackagesListPackagesForAuthenticatedUserRequestQuery = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly visibility?: 'public' | 'private' | 'internal';
};

export type PackagesGetPackageForAuthenticatedUser200ResponseBody = Package;

export type PackagesGetPackageForAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
};

export type PackagesDeletePackageForAuthenticatedUser401ResponseBody = BasicError;

export type PackagesDeletePackageForAuthenticatedUser403ResponseBody = BasicError;

export type PackagesDeletePackageForAuthenticatedUser404ResponseBody = BasicError;

export type PackagesDeletePackageForAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
};

export type PackagesRestorePackageForAuthenticatedUser401ResponseBody = BasicError;

export type PackagesRestorePackageForAuthenticatedUser403ResponseBody = BasicError;

export type PackagesRestorePackageForAuthenticatedUser404ResponseBody = BasicError;

export type PackagesRestorePackageForAuthenticatedUserRequestQuery = {
  readonly token?: string;
};

export type PackagesRestorePackageForAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
};

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser200ResponseBody = ReadonlyArray<PackageVersion>;

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser401ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser403ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser404ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
  readonly state?: 'active' | 'deleted';
};

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
};

export type PackagesGetPackageVersionForAuthenticatedUser200ResponseBody = PackageVersion;

export type PackagesGetPackageVersionForAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly package_version_id: number;
};

export type PackagesDeletePackageVersionForAuthenticatedUser401ResponseBody = BasicError;

export type PackagesDeletePackageVersionForAuthenticatedUser403ResponseBody = BasicError;

export type PackagesDeletePackageVersionForAuthenticatedUser404ResponseBody = BasicError;

export type PackagesDeletePackageVersionForAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly package_version_id: number;
};

export type PackagesRestorePackageVersionForAuthenticatedUser401ResponseBody = BasicError;

export type PackagesRestorePackageVersionForAuthenticatedUser403ResponseBody = BasicError;

export type PackagesRestorePackageVersionForAuthenticatedUser404ResponseBody = BasicError;

export type PackagesRestorePackageVersionForAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly package_version_id: number;
};

export type ProjectsCreateForAuthenticatedUser201ResponseBody = Project;

export type ProjectsCreateForAuthenticatedUser401ResponseBody = BasicError;

export type ProjectsCreateForAuthenticatedUser403ResponseBody = BasicError;

export type ProjectsCreateForAuthenticatedUser422ResponseBody = ValidationErrorSimple;

export type ProjectsCreateForAuthenticatedUserRequestBody = {
  readonly name: string;
  readonly body?: string | null;
};

export type UsersListPublicEmailsForAuthenticatedUser200ResponseBody = ReadonlyArray<Email>;

export type UsersListPublicEmailsForAuthenticatedUser401ResponseBody = BasicError;

export type UsersListPublicEmailsForAuthenticatedUser403ResponseBody = BasicError;

export type UsersListPublicEmailsForAuthenticatedUser404ResponseBody = BasicError;

export type UsersListPublicEmailsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListForAuthenticatedUser200ResponseBody = ReadonlyArray<Repository>;

export type ReposListForAuthenticatedUser401ResponseBody = BasicError;

export type ReposListForAuthenticatedUser403ResponseBody = BasicError;

export type ReposListForAuthenticatedUser422ResponseBody = ValidationError;

export type ReposListForAuthenticatedUserRequestQuery = {
  readonly visibility?: 'all' | 'public' | 'private';
  readonly affiliation?: string;
  readonly type?: 'all' | 'owner' | 'public' | 'private' | 'member';
  readonly sort?: 'created' | 'updated' | 'pushed' | 'full_name';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
  readonly since?: string;
  readonly before?: string;
};

export type ReposCreateForAuthenticatedUser201ResponseBody = Repository;

export type ReposCreateForAuthenticatedUser400ResponseBody = BasicError;

export type ReposCreateForAuthenticatedUser401ResponseBody = BasicError;

export type ReposCreateForAuthenticatedUser403ResponseBody = BasicError;

export type ReposCreateForAuthenticatedUser404ResponseBody = BasicError;

export type ReposCreateForAuthenticatedUser422ResponseBody = ValidationError;

export type ReposCreateForAuthenticatedUserRequestBody = {
  readonly name: string;
  readonly description?: string;
  readonly homepage?: string;
  readonly private?: boolean;
  readonly has_issues?: boolean;
  readonly has_projects?: boolean;
  readonly has_wiki?: boolean;
  readonly team_id?: number;
  readonly auto_init?: boolean;
  readonly gitignore_template?: string;
  readonly license_template?: string;
  readonly allow_squash_merge?: boolean;
  readonly allow_merge_commit?: boolean;
  readonly allow_rebase_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
  readonly squash_merge_commit_message?:
    | 'PR_BODY'
    | 'COMMIT_MESSAGES'
    | 'BLANK';
  readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
  readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
  readonly has_downloads?: boolean;
  readonly is_template?: boolean;
};

export type ReposListInvitationsForAuthenticatedUser200ResponseBody = ReadonlyArray<RepositoryInvitation>;

export type ReposListInvitationsForAuthenticatedUser401ResponseBody = BasicError;

export type ReposListInvitationsForAuthenticatedUser403ResponseBody = BasicError;

export type ReposListInvitationsForAuthenticatedUser404ResponseBody = BasicError;

export type ReposListInvitationsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposAcceptInvitationForAuthenticatedUser403ResponseBody = BasicError;

export type ReposAcceptInvitationForAuthenticatedUser404ResponseBody = BasicError;

export type ReposAcceptInvitationForAuthenticatedUser409ResponseBody = BasicError;

export type ReposAcceptInvitationForAuthenticatedUserRequestPath = {
  readonly invitation_id: number;
};

export type ReposDeclineInvitationForAuthenticatedUser403ResponseBody = BasicError;

export type ReposDeclineInvitationForAuthenticatedUser404ResponseBody = BasicError;

export type ReposDeclineInvitationForAuthenticatedUser409ResponseBody = BasicError;

export type ReposDeclineInvitationForAuthenticatedUserRequestPath = {
  readonly invitation_id: number;
};

export type SshSigningKey = {
  readonly key: string;
  readonly id: number;
  readonly title: string;
  readonly created_at: string;
};

export type UsersListSshSigningKeysForAuthenticatedUser200ResponseBody = ReadonlyArray<SshSigningKey>;

export type UsersListSshSigningKeysForAuthenticatedUser401ResponseBody = BasicError;

export type UsersListSshSigningKeysForAuthenticatedUser403ResponseBody = BasicError;

export type UsersListSshSigningKeysForAuthenticatedUser404ResponseBody = BasicError;

export type UsersListSshSigningKeysForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersCreateSshSigningKeyForAuthenticatedUser201ResponseBody = SshSigningKey;

export type UsersCreateSshSigningKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersCreateSshSigningKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersCreateSshSigningKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersCreateSshSigningKeyForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersCreateSshSigningKeyForAuthenticatedUserRequestBody = {
  readonly title?: string;
  readonly key: string;
};

export type UsersGetSshSigningKeyForAuthenticatedUser200ResponseBody = SshSigningKey;

export type UsersGetSshSigningKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersGetSshSigningKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersGetSshSigningKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersGetSshSigningKeyForAuthenticatedUserRequestPath = {
  readonly ssh_signing_key_id: number;
};

export type UsersDeleteSshSigningKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersDeleteSshSigningKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersDeleteSshSigningKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersDeleteSshSigningKeyForAuthenticatedUserRequestPath = {
  readonly ssh_signing_key_id: number;
};

export type ActivityListReposStarredByAuthenticatedUser200ResponseBody = ReadonlyArray<Repository>;

export type ActivityListReposStarredByAuthenticatedUser401ResponseBody = BasicError;

export type ActivityListReposStarredByAuthenticatedUser403ResponseBody = BasicError;

export type ActivityListReposStarredByAuthenticatedUserRequestQuery = {
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityCheckRepoIsStarredByAuthenticatedUser401ResponseBody = BasicError;

export type ActivityCheckRepoIsStarredByAuthenticatedUser403ResponseBody = BasicError;

export type ActivityCheckRepoIsStarredByAuthenticatedUser404ResponseBody = BasicError;

export type ActivityCheckRepoIsStarredByAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivityStarRepoForAuthenticatedUser401ResponseBody = BasicError;

export type ActivityStarRepoForAuthenticatedUser403ResponseBody = BasicError;

export type ActivityStarRepoForAuthenticatedUser404ResponseBody = BasicError;

export type ActivityStarRepoForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivityUnstarRepoForAuthenticatedUser401ResponseBody = BasicError;

export type ActivityUnstarRepoForAuthenticatedUser403ResponseBody = BasicError;

export type ActivityUnstarRepoForAuthenticatedUser404ResponseBody = BasicError;

export type ActivityUnstarRepoForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivityListWatchedReposForAuthenticatedUser200ResponseBody = ReadonlyArray<MinimalRepository>;

export type ActivityListWatchedReposForAuthenticatedUser401ResponseBody = BasicError;

export type ActivityListWatchedReposForAuthenticatedUser403ResponseBody = BasicError;

export type ActivityListWatchedReposForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListForAuthenticatedUser200ResponseBody = ReadonlyArray<FullTeam>;

export type TeamsListForAuthenticatedUser403ResponseBody = BasicError;

export type TeamsListForAuthenticatedUser404ResponseBody = BasicError;

export type TeamsListForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersList200ResponseBody = ReadonlyArray<SimpleUser>;

export type UsersListRequestQuery = {
  readonly since?: number;
  readonly per_page?: number;
};

export type UsersGetByUsername200ResponseBody = PrivateUser | PublicUser;

export type UsersGetByUsername404ResponseBody = BasicError;

export type UsersGetByUsernameRequestPath = { readonly username: string };

export type ActivityListEventsForAuthenticatedUser200ResponseBody = ReadonlyArray<Event>;

export type ActivityListEventsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListEventsForAuthenticatedUserRequestPath = {
  readonly username: string;
};

export type ActivityListOrgEventsForAuthenticatedUser200ResponseBody = ReadonlyArray<Event>;

export type ActivityListOrgEventsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListOrgEventsForAuthenticatedUserRequestPath = {
  readonly username: string;
  readonly org: string;
};

export type ActivityListPublicEventsForUser200ResponseBody = ReadonlyArray<Event>;

export type ActivityListPublicEventsForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListPublicEventsForUserRequestPath = {
  readonly username: string;
};

export type UsersListFollowersForUser200ResponseBody = ReadonlyArray<SimpleUser>;

export type UsersListFollowersForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersListFollowersForUserRequestPath = {
  readonly username: string;
};

export type UsersListFollowingForUser200ResponseBody = ReadonlyArray<SimpleUser>;

export type UsersListFollowingForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersListFollowingForUserRequestPath = {
  readonly username: string;
};

export type UsersCheckFollowingForUserRequestPath = {
  readonly username: string;
  readonly target_user: string;
};

export type GistsListForUser200ResponseBody = ReadonlyArray<BaseGist>;

export type GistsListForUser422ResponseBody = ValidationError;

export type GistsListForUserRequestQuery = {
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type GistsListForUserRequestPath = { readonly username: string };

export type UsersListGpgKeysForUser200ResponseBody = ReadonlyArray<GpgKey>;

export type UsersListGpgKeysForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersListGpgKeysForUserRequestPath = { readonly username: string };

export type Hovercard = {
  readonly contexts: ReadonlyArray<{
    readonly message: string;
    readonly octicon: string;
  }>;
};

export type UsersGetContextForUser200ResponseBody = Hovercard;

export type UsersGetContextForUser404ResponseBody = BasicError;

export type UsersGetContextForUser422ResponseBody = ValidationError;

export type UsersGetContextForUserRequestQuery = {
  readonly subject_type?:
    | 'organization'
    | 'repository'
    | 'issue'
    | 'pull_request';
  readonly subject_id?: string;
};

export type UsersGetContextForUserRequestPath = { readonly username: string };

export type AppsGetUserInstallation200ResponseBody = Installation;

export type AppsGetUserInstallationRequestPath = { readonly username: string };

export type KeySimple = { readonly id: number; readonly key: string };

export type UsersListPublicKeysForUser200ResponseBody = ReadonlyArray<KeySimple>;

export type UsersListPublicKeysForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersListPublicKeysForUserRequestPath = {
  readonly username: string;
};

export type OrgsListForUser200ResponseBody = ReadonlyArray<OrganizationSimple>;

export type OrgsListForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListForUserRequestPath = { readonly username: string };

export type PackagesListPackagesForUser200ResponseBody = ReadonlyArray<Package>;

export type PackagesListPackagesForUser401ResponseBody = BasicError;

export type PackagesListPackagesForUser403ResponseBody = BasicError;

export type PackagesListPackagesForUserRequestQuery = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly visibility?: 'public' | 'private' | 'internal';
};

export type PackagesListPackagesForUserRequestPath = {
  readonly username: string;
};

export type PackagesGetPackageForUser200ResponseBody = Package;

export type PackagesGetPackageForUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly username: string;
};

export type PackagesDeletePackageForUser401ResponseBody = BasicError;

export type PackagesDeletePackageForUser403ResponseBody = BasicError;

export type PackagesDeletePackageForUser404ResponseBody = BasicError;

export type PackagesDeletePackageForUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly username: string;
};

export type PackagesRestorePackageForUser401ResponseBody = BasicError;

export type PackagesRestorePackageForUser403ResponseBody = BasicError;

export type PackagesRestorePackageForUser404ResponseBody = BasicError;

export type PackagesRestorePackageForUserRequestQuery = {
  readonly token?: string;
};

export type PackagesRestorePackageForUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly username: string;
};

export type PackagesGetAllPackageVersionsForPackageOwnedByUser200ResponseBody = ReadonlyArray<PackageVersion>;

export type PackagesGetAllPackageVersionsForPackageOwnedByUser401ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByUser403ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByUser404ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly username: string;
};

export type PackagesGetPackageVersionForUser200ResponseBody = PackageVersion;

export type PackagesGetPackageVersionForUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly package_version_id: number;
  readonly username: string;
};

export type PackagesDeletePackageVersionForUser401ResponseBody = BasicError;

export type PackagesDeletePackageVersionForUser403ResponseBody = BasicError;

export type PackagesDeletePackageVersionForUser404ResponseBody = BasicError;

export type PackagesDeletePackageVersionForUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly username: string;
  readonly package_version_id: number;
};

export type PackagesRestorePackageVersionForUser401ResponseBody = BasicError;

export type PackagesRestorePackageVersionForUser403ResponseBody = BasicError;

export type PackagesRestorePackageVersionForUser404ResponseBody = BasicError;

export type PackagesRestorePackageVersionForUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly username: string;
  readonly package_version_id: number;
};

export type ProjectsListForUser200ResponseBody = ReadonlyArray<Project>;

export type ProjectsListForUser422ResponseBody = ValidationError;

export type ProjectsListForUserRequestQuery = {
  readonly state?: 'open' | 'closed' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type ProjectsListForUserRequestPath = { readonly username: string };

export type ActivityListReceivedEventsForUser200ResponseBody = ReadonlyArray<Event>;

export type ActivityListReceivedEventsForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListReceivedEventsForUserRequestPath = {
  readonly username: string;
};

export type ActivityListReceivedPublicEventsForUser200ResponseBody = ReadonlyArray<Event>;

export type ActivityListReceivedPublicEventsForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListReceivedPublicEventsForUserRequestPath = {
  readonly username: string;
};

export type ReposListForUser200ResponseBody = ReadonlyArray<MinimalRepository>;

export type ReposListForUserRequestQuery = {
  readonly type?: 'all' | 'owner' | 'member';
  readonly sort?: 'created' | 'updated' | 'pushed' | 'full_name';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListForUserRequestPath = { readonly username: string };

export type BillingGetGithubActionsBillingUser200ResponseBody = ActionsBillingUsage;

export type BillingGetGithubActionsBillingUserRequestPath = {
  readonly username: string;
};

export type BillingGetGithubPackagesBillingUser200ResponseBody = PackagesBillingUsage;

export type BillingGetGithubPackagesBillingUserRequestPath = {
  readonly username: string;
};

export type BillingGetSharedStorageBillingUser200ResponseBody = CombinedBillingUsage;

export type BillingGetSharedStorageBillingUserRequestPath = {
  readonly username: string;
};

export type UsersListSshSigningKeysForUser200ResponseBody = ReadonlyArray<SshSigningKey>;

export type UsersListSshSigningKeysForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersListSshSigningKeysForUserRequestPath = {
  readonly username: string;
};

export type StarredRepository = {
  readonly starred_at: string;
  readonly repo: Repository;
};

export type ActivityListReposStarredByUser200ResponseBody =
  | ReadonlyArray<StarredRepository>
  | ReadonlyArray<Repository>;

export type ActivityListReposStarredByUserRequestQuery = {
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListReposStarredByUserRequestPath = {
  readonly username: string;
};

export type ActivityListReposWatchedByUser200ResponseBody = ReadonlyArray<MinimalRepository>;

export type ActivityListReposWatchedByUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListReposWatchedByUserRequestPath = {
  readonly username: string;
};

export type MetaRootRequest = Request<
  ParamsDictionary,
  MetaRoot200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MetaRootResponse = Response<
  MetaRoot200ResponseBody,
  Record<string, any>,
  200
>;

export type MetaRootHandler = (
  req: MetaRootRequest,
  res: MetaRootResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsGetAuthenticatedRequest = Request<
  ParamsDictionary,
  AppsGetAuthenticated200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetAuthenticatedResponse = Response<
  AppsGetAuthenticated200ResponseBody,
  Record<string, any>,
  200
>;

export type AppsGetAuthenticatedHandler = (
  req: AppsGetAuthenticatedRequest,
  res: AppsGetAuthenticatedResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsCreateFromManifestRequest = Request<
  AppsCreateFromManifestRequestPath,
  | AppsCreateFromManifest201ResponseBody
  | AppsCreateFromManifest404ResponseBody
  | AppsCreateFromManifest422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsCreateFromManifestResponse = Response<
  | AppsCreateFromManifest201ResponseBody
  | AppsCreateFromManifest404ResponseBody
  | AppsCreateFromManifest422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export type AppsCreateFromManifestHandler = (
  req: AppsCreateFromManifestRequest,
  res: AppsCreateFromManifestResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsGetWebhookConfigForAppRequest = Request<
  ParamsDictionary,
  AppsGetWebhookConfigForApp200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetWebhookConfigForAppResponse = Response<
  AppsGetWebhookConfigForApp200ResponseBody,
  Record<string, any>,
  200
>;

export type AppsGetWebhookConfigForAppHandler = (
  req: AppsGetWebhookConfigForAppRequest,
  res: AppsGetWebhookConfigForAppResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsUpdateWebhookConfigForAppRequest = Request<
  ParamsDictionary,
  AppsUpdateWebhookConfigForApp200ResponseBody,
  AppsUpdateWebhookConfigForAppRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsUpdateWebhookConfigForAppResponse = Response<
  AppsUpdateWebhookConfigForApp200ResponseBody,
  Record<string, any>,
  200
>;

export type AppsUpdateWebhookConfigForAppHandler = (
  req: AppsUpdateWebhookConfigForAppRequest,
  res: AppsUpdateWebhookConfigForAppResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsListWebhookDeliveriesRequest = Request<
  ParamsDictionary,
  | AppsListWebhookDeliveries200ResponseBody
  | AppsListWebhookDeliveries400ResponseBody
  | AppsListWebhookDeliveries422ResponseBody,
  unknown,
  AppsListWebhookDeliveriesRequestQuery,
  Record<string, any>
>;

export type AppsListWebhookDeliveriesResponse = Response<
  | AppsListWebhookDeliveries200ResponseBody
  | AppsListWebhookDeliveries400ResponseBody
  | AppsListWebhookDeliveries422ResponseBody,
  Record<string, any>,
  200 | 400 | 422
>;

export type AppsListWebhookDeliveriesHandler = (
  req: AppsListWebhookDeliveriesRequest,
  res: AppsListWebhookDeliveriesResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsGetWebhookDeliveryRequest = Request<
  AppsGetWebhookDeliveryRequestPath,
  | AppsGetWebhookDelivery200ResponseBody
  | AppsGetWebhookDelivery400ResponseBody
  | AppsGetWebhookDelivery422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetWebhookDeliveryResponse = Response<
  | AppsGetWebhookDelivery200ResponseBody
  | AppsGetWebhookDelivery400ResponseBody
  | AppsGetWebhookDelivery422ResponseBody,
  Record<string, any>,
  200 | 400 | 422
>;

export type AppsGetWebhookDeliveryHandler = (
  req: AppsGetWebhookDeliveryRequest,
  res: AppsGetWebhookDeliveryResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsRedeliverWebhookDeliveryRequest = Request<
  AppsRedeliverWebhookDeliveryRequestPath,
  | AppsRedeliverWebhookDelivery202ResponseBody
  | AppsRedeliverWebhookDelivery400ResponseBody
  | AppsRedeliverWebhookDelivery422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsRedeliverWebhookDeliveryResponse = Response<
  | AppsRedeliverWebhookDelivery202ResponseBody
  | AppsRedeliverWebhookDelivery400ResponseBody
  | AppsRedeliverWebhookDelivery422ResponseBody,
  Record<string, any>,
  202 | 400 | 422
>;

export type AppsRedeliverWebhookDeliveryHandler = (
  req: AppsRedeliverWebhookDeliveryRequest,
  res: AppsRedeliverWebhookDeliveryResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsListInstallationsRequest = Request<
  ParamsDictionary,
  AppsListInstallations200ResponseBody,
  unknown,
  AppsListInstallationsRequestQuery,
  Record<string, any>
>;

export type AppsListInstallationsResponse = Response<
  AppsListInstallations200ResponseBody,
  Record<string, any>,
  200
>;

export type AppsListInstallationsHandler = (
  req: AppsListInstallationsRequest,
  res: AppsListInstallationsResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsGetInstallationRequest = Request<
  AppsGetInstallationRequestPath,
  AppsGetInstallation200ResponseBody | AppsGetInstallation404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetInstallationResponse = Response<
  AppsGetInstallation200ResponseBody | AppsGetInstallation404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type AppsGetInstallationHandler = (
  req: AppsGetInstallationRequest,
  res: AppsGetInstallationResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsDeleteInstallationRequest = Request<
  AppsDeleteInstallationRequestPath,
  AppsDeleteInstallation404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsDeleteInstallationResponse = Response<
  AppsDeleteInstallation404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type AppsDeleteInstallationHandler = (
  req: AppsDeleteInstallationRequest,
  res: AppsDeleteInstallationResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsCreateInstallationAccessTokenRequest = Request<
  AppsCreateInstallationAccessTokenRequestPath,
  | AppsCreateInstallationAccessToken201ResponseBody
  | AppsCreateInstallationAccessToken401ResponseBody
  | AppsCreateInstallationAccessToken403ResponseBody
  | AppsCreateInstallationAccessToken404ResponseBody
  | AppsCreateInstallationAccessToken422ResponseBody,
  AppsCreateInstallationAccessTokenRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsCreateInstallationAccessTokenResponse = Response<
  | AppsCreateInstallationAccessToken201ResponseBody
  | AppsCreateInstallationAccessToken401ResponseBody
  | AppsCreateInstallationAccessToken403ResponseBody
  | AppsCreateInstallationAccessToken404ResponseBody
  | AppsCreateInstallationAccessToken422ResponseBody,
  Record<string, any>,
  201 | 401 | 403 | 404 | 422
>;

export type AppsCreateInstallationAccessTokenHandler = (
  req: AppsCreateInstallationAccessTokenRequest,
  res: AppsCreateInstallationAccessTokenResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsSuspendInstallationRequest = Request<
  AppsSuspendInstallationRequestPath,
  AppsSuspendInstallation404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsSuspendInstallationResponse = Response<
  AppsSuspendInstallation404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type AppsSuspendInstallationHandler = (
  req: AppsSuspendInstallationRequest,
  res: AppsSuspendInstallationResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsUnsuspendInstallationRequest = Request<
  AppsUnsuspendInstallationRequestPath,
  AppsUnsuspendInstallation404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsUnsuspendInstallationResponse = Response<
  AppsUnsuspendInstallation404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type AppsUnsuspendInstallationHandler = (
  req: AppsUnsuspendInstallationRequest,
  res: AppsUnsuspendInstallationResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsDeleteAuthorizationRequest = Request<
  AppsDeleteAuthorizationRequestPath,
  AppsDeleteAuthorization422ResponseBody,
  AppsDeleteAuthorizationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsDeleteAuthorizationResponse = Response<
  AppsDeleteAuthorization422ResponseBody,
  Record<string, any>,
  204 | 422
>;

export type AppsDeleteAuthorizationHandler = (
  req: AppsDeleteAuthorizationRequest,
  res: AppsDeleteAuthorizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsCheckTokenRequest = Request<
  AppsCheckTokenRequestPath,
  | AppsCheckToken200ResponseBody
  | AppsCheckToken404ResponseBody
  | AppsCheckToken422ResponseBody,
  AppsCheckTokenRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsCheckTokenResponse = Response<
  | AppsCheckToken200ResponseBody
  | AppsCheckToken404ResponseBody
  | AppsCheckToken422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type AppsCheckTokenHandler = (
  req: AppsCheckTokenRequest,
  res: AppsCheckTokenResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsResetTokenRequest = Request<
  AppsResetTokenRequestPath,
  AppsResetToken200ResponseBody | AppsResetToken422ResponseBody,
  AppsResetTokenRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsResetTokenResponse = Response<
  AppsResetToken200ResponseBody | AppsResetToken422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type AppsResetTokenHandler = (
  req: AppsResetTokenRequest,
  res: AppsResetTokenResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsDeleteTokenRequest = Request<
  AppsDeleteTokenRequestPath,
  AppsDeleteToken422ResponseBody,
  AppsDeleteTokenRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsDeleteTokenResponse = Response<
  AppsDeleteToken422ResponseBody,
  Record<string, any>,
  204 | 422
>;

export type AppsDeleteTokenHandler = (
  req: AppsDeleteTokenRequest,
  res: AppsDeleteTokenResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsScopeTokenRequest = Request<
  AppsScopeTokenRequestPath,
  | AppsScopeToken200ResponseBody
  | AppsScopeToken401ResponseBody
  | AppsScopeToken403ResponseBody
  | AppsScopeToken404ResponseBody
  | AppsScopeToken422ResponseBody,
  AppsScopeTokenRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsScopeTokenResponse = Response<
  | AppsScopeToken200ResponseBody
  | AppsScopeToken401ResponseBody
  | AppsScopeToken403ResponseBody
  | AppsScopeToken404ResponseBody
  | AppsScopeToken422ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404 | 422
>;

export type AppsScopeTokenHandler = (
  req: AppsScopeTokenRequest,
  res: AppsScopeTokenResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsGetBySlugRequest = Request<
  AppsGetBySlugRequestPath,
  | AppsGetBySlug200ResponseBody
  | AppsGetBySlug403ResponseBody
  | AppsGetBySlug404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetBySlugResponse = Response<
  | AppsGetBySlug200ResponseBody
  | AppsGetBySlug403ResponseBody
  | AppsGetBySlug404ResponseBody,
  Record<string, any>,
  200 | 403 | 404
>;

export type AppsGetBySlugHandler = (
  req: AppsGetBySlugRequest,
  res: AppsGetBySlugResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodesOfConductGetAllCodesOfConductRequest = Request<
  ParamsDictionary,
  CodesOfConductGetAllCodesOfConduct200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodesOfConductGetAllCodesOfConductResponse = Response<
  CodesOfConductGetAllCodesOfConduct200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export type CodesOfConductGetAllCodesOfConductHandler = (
  req: CodesOfConductGetAllCodesOfConductRequest,
  res: CodesOfConductGetAllCodesOfConductResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodesOfConductGetConductCodeRequest = Request<
  CodesOfConductGetConductCodeRequestPath,
  | CodesOfConductGetConductCode200ResponseBody
  | CodesOfConductGetConductCode404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodesOfConductGetConductCodeResponse = Response<
  | CodesOfConductGetConductCode200ResponseBody
  | CodesOfConductGetConductCode404ResponseBody,
  Record<string, any>,
  200 | 304 | 404
>;

export type CodesOfConductGetConductCodeHandler = (
  req: CodesOfConductGetConductCodeRequest,
  res: CodesOfConductGetConductCodeResponse,
  next: NextFunction
) => Promise<void> | void;

export type EmojisGetRequest = Request<
  ParamsDictionary,
  EmojisGet200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EmojisGetResponse = Response<
  EmojisGet200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export type EmojisGetHandler = (
  req: EmojisGetRequest,
  res: EmojisGetResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminGetServerStatisticsRequest = Request<
  EnterpriseAdminGetServerStatisticsRequestPath,
  EnterpriseAdminGetServerStatistics200ResponseBody,
  unknown,
  EnterpriseAdminGetServerStatisticsRequestQuery,
  Record<string, any>
>;

export type EnterpriseAdminGetServerStatisticsResponse = Response<
  EnterpriseAdminGetServerStatistics200ResponseBody,
  Record<string, any>,
  200
>;

export type EnterpriseAdminGetServerStatisticsHandler = (
  req: EnterpriseAdminGetServerStatisticsRequest,
  res: EnterpriseAdminGetServerStatisticsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetActionsCacheUsageForEnterpriseRequest = Request<
  ActionsGetActionsCacheUsageForEnterpriseRequestPath,
  ActionsGetActionsCacheUsageForEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetActionsCacheUsageForEnterpriseResponse = Response<
  ActionsGetActionsCacheUsageForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetActionsCacheUsageForEnterpriseHandler = (
  req: ActionsGetActionsCacheUsageForEnterpriseRequest,
  res: ActionsGetActionsCacheUsageForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest = Request<
  EnterpriseAdminGetGithubActionsPermissionsEnterpriseRequestPath,
  EnterpriseAdminGetGithubActionsPermissionsEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse = Response<
  EnterpriseAdminGetGithubActionsPermissionsEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export type EnterpriseAdminGetGithubActionsPermissionsEnterpriseHandler = (
  req: EnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest,
  res: EnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest = Request<
  EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequestPath,
  unknown,
  EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type EnterpriseAdminSetGithubActionsPermissionsEnterpriseHandler = (
  req: EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest,
  res: EnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest = Request<
  EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequestPath,
  EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200ResponseBody,
  unknown,
  EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequestQuery,
  Record<string, any>
>;

export type EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse = Response<
  EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export type EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseHandler = (
  req: EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest,
  res: EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest = Request<
  EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequestPath,
  unknown,
  EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseHandler = (
  req: EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest,
  res: EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest = Request<
  EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseHandler = (
  req: EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest,
  res: EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest = Request<
  EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseHandler = (
  req: EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest,
  res: EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminGetAllowedActionsEnterpriseRequest = Request<
  EnterpriseAdminGetAllowedActionsEnterpriseRequestPath,
  EnterpriseAdminGetAllowedActionsEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminGetAllowedActionsEnterpriseResponse = Response<
  EnterpriseAdminGetAllowedActionsEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export type EnterpriseAdminGetAllowedActionsEnterpriseHandler = (
  req: EnterpriseAdminGetAllowedActionsEnterpriseRequest,
  res: EnterpriseAdminGetAllowedActionsEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminSetAllowedActionsEnterpriseRequest = Request<
  EnterpriseAdminSetAllowedActionsEnterpriseRequestPath,
  unknown,
  EnterpriseAdminSetAllowedActionsEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminSetAllowedActionsEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type EnterpriseAdminSetAllowedActionsEnterpriseHandler = (
  req: EnterpriseAdminSetAllowedActionsEnterpriseRequest,
  res: EnterpriseAdminSetAllowedActionsEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest = Request<
  ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestPath,
  ActionsGetGithubActionsDefaultWorkflowPermissionsEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse = Response<
  ActionsGetGithubActionsDefaultWorkflowPermissionsEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler = (
  req: ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest,
  res: ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest = Request<
  ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestPath,
  unknown,
  ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler = (
  req: ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest,
  res: ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest = Request<
  EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequestPath,
  EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200ResponseBody,
  unknown,
  EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequestQuery,
  Record<string, any>
>;

export type EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse = Response<
  EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export type EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseHandler = (
  req: EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest,
  res: EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest = Request<
  EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequestPath,
  EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise201ResponseBody,
  EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse = Response<
  EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise201ResponseBody,
  Record<string, any>,
  201
>;

export type EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseHandler = (
  req: EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest,
  res: EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest = Request<
  EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequestPath,
  EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse = Response<
  EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export type EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseHandler = (
  req: EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest,
  res: EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest = Request<
  EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequestPath,
  EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise200ResponseBody,
  EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse = Response<
  EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export type EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseHandler = (
  req: EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest,
  res: EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest = Request<
  EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseHandler = (
  req: EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest,
  res: EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest = Request<
  EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath,
  EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise200ResponseBody,
  unknown,
  EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestQuery,
  Record<string, any>
>;

export type EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse = Response<
  EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export type EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler = (
  req: EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
  res: EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest = Request<
  EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath,
  unknown,
  EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler = (
  req: EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
  res: EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest = Request<
  EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler = (
  req: EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
  res: EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest = Request<
  EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler = (
  req: EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
  res: EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest = Request<
  EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequestPath,
  EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200ResponseBody,
  unknown,
  EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequestQuery,
  Record<string, any>
>;

export type EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse = Response<
  EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export type EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseHandler = (
  req: EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest,
  res: EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest = Request<
  EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequestPath,
  unknown,
  EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseHandler = (
  req: EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest,
  res: EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest = Request<
  EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseHandler = (
  req: EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest,
  res: EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest = Request<
  EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseHandler = (
  req: EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest,
  res: EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminListSelfHostedRunnersForEnterpriseRequest = Request<
  EnterpriseAdminListSelfHostedRunnersForEnterpriseRequestPath,
  EnterpriseAdminListSelfHostedRunnersForEnterprise200ResponseBody,
  unknown,
  EnterpriseAdminListSelfHostedRunnersForEnterpriseRequestQuery,
  Record<string, any>
>;

export type EnterpriseAdminListSelfHostedRunnersForEnterpriseResponse = Response<
  EnterpriseAdminListSelfHostedRunnersForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export type EnterpriseAdminListSelfHostedRunnersForEnterpriseHandler = (
  req: EnterpriseAdminListSelfHostedRunnersForEnterpriseRequest,
  res: EnterpriseAdminListSelfHostedRunnersForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminListRunnerApplicationsForEnterpriseRequest = Request<
  EnterpriseAdminListRunnerApplicationsForEnterpriseRequestPath,
  EnterpriseAdminListRunnerApplicationsForEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminListRunnerApplicationsForEnterpriseResponse = Response<
  EnterpriseAdminListRunnerApplicationsForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export type EnterpriseAdminListRunnerApplicationsForEnterpriseHandler = (
  req: EnterpriseAdminListRunnerApplicationsForEnterpriseRequest,
  res: EnterpriseAdminListRunnerApplicationsForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminCreateRegistrationTokenForEnterpriseRequest = Request<
  EnterpriseAdminCreateRegistrationTokenForEnterpriseRequestPath,
  EnterpriseAdminCreateRegistrationTokenForEnterprise201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminCreateRegistrationTokenForEnterpriseResponse = Response<
  EnterpriseAdminCreateRegistrationTokenForEnterprise201ResponseBody,
  Record<string, any>,
  201
>;

export type EnterpriseAdminCreateRegistrationTokenForEnterpriseHandler = (
  req: EnterpriseAdminCreateRegistrationTokenForEnterpriseRequest,
  res: EnterpriseAdminCreateRegistrationTokenForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminCreateRemoveTokenForEnterpriseRequest = Request<
  EnterpriseAdminCreateRemoveTokenForEnterpriseRequestPath,
  EnterpriseAdminCreateRemoveTokenForEnterprise201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminCreateRemoveTokenForEnterpriseResponse = Response<
  EnterpriseAdminCreateRemoveTokenForEnterprise201ResponseBody,
  Record<string, any>,
  201
>;

export type EnterpriseAdminCreateRemoveTokenForEnterpriseHandler = (
  req: EnterpriseAdminCreateRemoveTokenForEnterpriseRequest,
  res: EnterpriseAdminCreateRemoveTokenForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest = Request<
  EnterpriseAdminGetSelfHostedRunnerForEnterpriseRequestPath,
  EnterpriseAdminGetSelfHostedRunnerForEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse = Response<
  EnterpriseAdminGetSelfHostedRunnerForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export type EnterpriseAdminGetSelfHostedRunnerForEnterpriseHandler = (
  req: EnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest,
  res: EnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest = Request<
  EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseHandler = (
  req: EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest,
  res: EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseRequest = Request<
  EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseRequestPath,
  | EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseResponse = Response<
  | EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseHandler = (
  req: EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseRequest,
  res: EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest = Request<
  EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequestPath,
  | EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise422ResponseBody,
  EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseResponse = Response<
  | EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseHandler = (
  req: EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest,
  res: EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest = Request<
  EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequestPath,
  | EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise422ResponseBody,
  EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseResponse = Response<
  | EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseHandler = (
  req: EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest,
  res: EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequest = Request<
  EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequestPath,
  | EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse = Response<
  | EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseHandler = (
  req: EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequest,
  res: EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseRequest = Request<
  EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseRequestPath,
  | EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse = Response<
  | EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseHandler = (
  req: EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseRequest,
  res: EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodeScanningListAlertsForEnterpriseRequest = Request<
  CodeScanningListAlertsForEnterpriseRequestPath,
  | CodeScanningListAlertsForEnterprise200ResponseBody
  | CodeScanningListAlertsForEnterprise404ResponseBody
  | CodeScanningListAlertsForEnterprise503ResponseBody,
  unknown,
  CodeScanningListAlertsForEnterpriseRequestQuery,
  Record<string, any>
>;

export type CodeScanningListAlertsForEnterpriseResponse = Response<
  | CodeScanningListAlertsForEnterprise200ResponseBody
  | CodeScanningListAlertsForEnterprise404ResponseBody
  | CodeScanningListAlertsForEnterprise503ResponseBody,
  Record<string, any>,
  200 | 404 | 503
>;

export type CodeScanningListAlertsForEnterpriseHandler = (
  req: CodeScanningListAlertsForEnterpriseRequest,
  res: CodeScanningListAlertsForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type SecretScanningListAlertsForEnterpriseRequest = Request<
  SecretScanningListAlertsForEnterpriseRequestPath,
  | SecretScanningListAlertsForEnterprise200ResponseBody
  | SecretScanningListAlertsForEnterprise404ResponseBody
  | SecretScanningListAlertsForEnterprise503ResponseBody,
  unknown,
  SecretScanningListAlertsForEnterpriseRequestQuery,
  Record<string, any>
>;

export type SecretScanningListAlertsForEnterpriseResponse = Response<
  | SecretScanningListAlertsForEnterprise200ResponseBody
  | SecretScanningListAlertsForEnterprise404ResponseBody
  | SecretScanningListAlertsForEnterprise503ResponseBody,
  Record<string, any>,
  200 | 404 | 503
>;

export type SecretScanningListAlertsForEnterpriseHandler = (
  req: SecretScanningListAlertsForEnterpriseRequest,
  res: SecretScanningListAlertsForEnterpriseResponse,
  next: NextFunction
) => Promise<void> | void;

export type BillingGetGithubAdvancedSecurityBillingGheRequest = Request<
  BillingGetGithubAdvancedSecurityBillingGheRequestPath,
  | BillingGetGithubAdvancedSecurityBillingGhe200ResponseBody
  | BillingGetGithubAdvancedSecurityBillingGhe403ResponseBody,
  unknown,
  BillingGetGithubAdvancedSecurityBillingGheRequestQuery,
  Record<string, any>
>;

export type BillingGetGithubAdvancedSecurityBillingGheResponse = Response<
  | BillingGetGithubAdvancedSecurityBillingGhe200ResponseBody
  | BillingGetGithubAdvancedSecurityBillingGhe403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export type BillingGetGithubAdvancedSecurityBillingGheHandler = (
  req: BillingGetGithubAdvancedSecurityBillingGheRequest,
  res: BillingGetGithubAdvancedSecurityBillingGheResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListPublicEventsRequest = Request<
  ParamsDictionary,
  | ActivityListPublicEvents200ResponseBody
  | ActivityListPublicEvents403ResponseBody
  | ActivityListPublicEvents503ResponseBody,
  unknown,
  ActivityListPublicEventsRequestQuery,
  Record<string, any>
>;

export type ActivityListPublicEventsResponse = Response<
  | ActivityListPublicEvents200ResponseBody
  | ActivityListPublicEvents403ResponseBody
  | ActivityListPublicEvents503ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 503
>;

export type ActivityListPublicEventsHandler = (
  req: ActivityListPublicEventsRequest,
  res: ActivityListPublicEventsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityGetFeedsRequest = Request<
  ParamsDictionary,
  ActivityGetFeeds200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityGetFeedsResponse = Response<
  ActivityGetFeeds200ResponseBody,
  Record<string, any>,
  200
>;

export type ActivityGetFeedsHandler = (
  req: ActivityGetFeedsRequest,
  res: ActivityGetFeedsResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsListRequest = Request<
  ParamsDictionary,
  GistsList200ResponseBody | GistsList403ResponseBody,
  unknown,
  GistsListRequestQuery,
  Record<string, any>
>;

export type GistsListResponse = Response<
  GistsList200ResponseBody | GistsList403ResponseBody,
  Record<string, any>,
  200 | 304 | 403
>;

export type GistsListHandler = (
  req: GistsListRequest,
  res: GistsListResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsCreateRequest = Request<
  ParamsDictionary,
  | GistsCreate201ResponseBody
  | GistsCreate403ResponseBody
  | GistsCreate404ResponseBody
  | GistsCreate422ResponseBody,
  GistsCreateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GistsCreateResponse = Response<
  | GistsCreate201ResponseBody
  | GistsCreate403ResponseBody
  | GistsCreate404ResponseBody
  | GistsCreate422ResponseBody,
  Record<string, any>,
  201 | 304 | 403 | 404 | 422
>;

export type GistsCreateHandler = (
  req: GistsCreateRequest,
  res: GistsCreateResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsListPublicRequest = Request<
  ParamsDictionary,
  | GistsListPublic200ResponseBody
  | GistsListPublic403ResponseBody
  | GistsListPublic422ResponseBody,
  unknown,
  GistsListPublicRequestQuery,
  Record<string, any>
>;

export type GistsListPublicResponse = Response<
  | GistsListPublic200ResponseBody
  | GistsListPublic403ResponseBody
  | GistsListPublic422ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 422
>;

export type GistsListPublicHandler = (
  req: GistsListPublicRequest,
  res: GistsListPublicResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsListStarredRequest = Request<
  ParamsDictionary,
  | GistsListStarred200ResponseBody
  | GistsListStarred401ResponseBody
  | GistsListStarred403ResponseBody,
  unknown,
  GistsListStarredRequestQuery,
  Record<string, any>
>;

export type GistsListStarredResponse = Response<
  | GistsListStarred200ResponseBody
  | GistsListStarred401ResponseBody
  | GistsListStarred403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type GistsListStarredHandler = (
  req: GistsListStarredRequest,
  res: GistsListStarredResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsGetRequest = Request<
  GistsGetRequestPath,
  GistsGet200ResponseBody | GistsGet403ResponseBody | GistsGet404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsGetResponse = Response<
  GistsGet200ResponseBody | GistsGet403ResponseBody | GistsGet404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export type GistsGetHandler = (
  req: GistsGetRequest,
  res: GistsGetResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsUpdateRequest = Request<
  GistsUpdateRequestPath,
  | GistsUpdate200ResponseBody
  | GistsUpdate404ResponseBody
  | GistsUpdate422ResponseBody,
  GistsUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GistsUpdateResponse = Response<
  | GistsUpdate200ResponseBody
  | GistsUpdate404ResponseBody
  | GistsUpdate422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type GistsUpdateHandler = (
  req: GistsUpdateRequest,
  res: GistsUpdateResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsDeleteRequest = Request<
  GistsDeleteRequestPath,
  GistsDelete403ResponseBody | GistsDelete404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsDeleteResponse = Response<
  GistsDelete403ResponseBody | GistsDelete404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export type GistsDeleteHandler = (
  req: GistsDeleteRequest,
  res: GistsDeleteResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsListCommentsRequest = Request<
  GistsListCommentsRequestPath,
  | GistsListComments200ResponseBody
  | GistsListComments403ResponseBody
  | GistsListComments404ResponseBody,
  unknown,
  GistsListCommentsRequestQuery,
  Record<string, any>
>;

export type GistsListCommentsResponse = Response<
  | GistsListComments200ResponseBody
  | GistsListComments403ResponseBody
  | GistsListComments404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export type GistsListCommentsHandler = (
  req: GistsListCommentsRequest,
  res: GistsListCommentsResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsCreateCommentRequest = Request<
  GistsCreateCommentRequestPath,
  | GistsCreateComment201ResponseBody
  | GistsCreateComment403ResponseBody
  | GistsCreateComment404ResponseBody,
  GistsCreateCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GistsCreateCommentResponse = Response<
  | GistsCreateComment201ResponseBody
  | GistsCreateComment403ResponseBody
  | GistsCreateComment404ResponseBody,
  Record<string, any>,
  201 | 304 | 403 | 404
>;

export type GistsCreateCommentHandler = (
  req: GistsCreateCommentRequest,
  res: GistsCreateCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsGetCommentRequest = Request<
  GistsGetCommentRequestPath,
  | GistsGetComment200ResponseBody
  | GistsGetComment403ResponseBody
  | GistsGetComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsGetCommentResponse = Response<
  | GistsGetComment200ResponseBody
  | GistsGetComment403ResponseBody
  | GistsGetComment404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export type GistsGetCommentHandler = (
  req: GistsGetCommentRequest,
  res: GistsGetCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsUpdateCommentRequest = Request<
  GistsUpdateCommentRequestPath,
  GistsUpdateComment200ResponseBody | GistsUpdateComment404ResponseBody,
  GistsUpdateCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GistsUpdateCommentResponse = Response<
  GistsUpdateComment200ResponseBody | GistsUpdateComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type GistsUpdateCommentHandler = (
  req: GistsUpdateCommentRequest,
  res: GistsUpdateCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsDeleteCommentRequest = Request<
  GistsDeleteCommentRequestPath,
  GistsDeleteComment403ResponseBody | GistsDeleteComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsDeleteCommentResponse = Response<
  GistsDeleteComment403ResponseBody | GistsDeleteComment404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export type GistsDeleteCommentHandler = (
  req: GistsDeleteCommentRequest,
  res: GistsDeleteCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsListCommitsRequest = Request<
  GistsListCommitsRequestPath,
  | GistsListCommits200ResponseBody
  | GistsListCommits403ResponseBody
  | GistsListCommits404ResponseBody,
  unknown,
  GistsListCommitsRequestQuery,
  Record<string, any>
>;

export type GistsListCommitsResponse = Response<
  | GistsListCommits200ResponseBody
  | GistsListCommits403ResponseBody
  | GistsListCommits404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export type GistsListCommitsHandler = (
  req: GistsListCommitsRequest,
  res: GistsListCommitsResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsListForksRequest = Request<
  GistsListForksRequestPath,
  | GistsListForks200ResponseBody
  | GistsListForks403ResponseBody
  | GistsListForks404ResponseBody,
  unknown,
  GistsListForksRequestQuery,
  Record<string, any>
>;

export type GistsListForksResponse = Response<
  | GistsListForks200ResponseBody
  | GistsListForks403ResponseBody
  | GistsListForks404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export type GistsListForksHandler = (
  req: GistsListForksRequest,
  res: GistsListForksResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsForkRequest = Request<
  GistsForkRequestPath,
  | GistsFork201ResponseBody
  | GistsFork403ResponseBody
  | GistsFork404ResponseBody
  | GistsFork422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsForkResponse = Response<
  | GistsFork201ResponseBody
  | GistsFork403ResponseBody
  | GistsFork404ResponseBody
  | GistsFork422ResponseBody,
  Record<string, any>,
  201 | 304 | 403 | 404 | 422
>;

export type GistsForkHandler = (
  req: GistsForkRequest,
  res: GistsForkResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsCheckIsStarredRequest = Request<
  GistsCheckIsStarredRequestPath,
  GistsCheckIsStarred403ResponseBody | GistsCheckIsStarred404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsCheckIsStarredResponse = Response<
  GistsCheckIsStarred403ResponseBody | GistsCheckIsStarred404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export type GistsCheckIsStarredHandler = (
  req: GistsCheckIsStarredRequest,
  res: GistsCheckIsStarredResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsStarRequest = Request<
  GistsStarRequestPath,
  GistsStar403ResponseBody | GistsStar404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsStarResponse = Response<
  GistsStar403ResponseBody | GistsStar404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export type GistsStarHandler = (
  req: GistsStarRequest,
  res: GistsStarResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsUnstarRequest = Request<
  GistsUnstarRequestPath,
  GistsUnstar403ResponseBody | GistsUnstar404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsUnstarResponse = Response<
  GistsUnstar403ResponseBody | GistsUnstar404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export type GistsUnstarHandler = (
  req: GistsUnstarRequest,
  res: GistsUnstarResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsGetRevisionRequest = Request<
  GistsGetRevisionRequestPath,
  | GistsGetRevision200ResponseBody
  | GistsGetRevision403ResponseBody
  | GistsGetRevision404ResponseBody
  | GistsGetRevision422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsGetRevisionResponse = Response<
  | GistsGetRevision200ResponseBody
  | GistsGetRevision403ResponseBody
  | GistsGetRevision404ResponseBody
  | GistsGetRevision422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export type GistsGetRevisionHandler = (
  req: GistsGetRevisionRequest,
  res: GistsGetRevisionResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitignoreGetAllTemplatesRequest = Request<
  ParamsDictionary,
  GitignoreGetAllTemplates200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitignoreGetAllTemplatesResponse = Response<
  GitignoreGetAllTemplates200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export type GitignoreGetAllTemplatesHandler = (
  req: GitignoreGetAllTemplatesRequest,
  res: GitignoreGetAllTemplatesResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitignoreGetTemplateRequest = Request<
  GitignoreGetTemplateRequestPath,
  GitignoreGetTemplate200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitignoreGetTemplateResponse = Response<
  GitignoreGetTemplate200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export type GitignoreGetTemplateHandler = (
  req: GitignoreGetTemplateRequest,
  res: GitignoreGetTemplateResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsListReposAccessibleToInstallationRequest = Request<
  ParamsDictionary,
  | AppsListReposAccessibleToInstallation200ResponseBody
  | AppsListReposAccessibleToInstallation401ResponseBody
  | AppsListReposAccessibleToInstallation403ResponseBody,
  unknown,
  AppsListReposAccessibleToInstallationRequestQuery,
  Record<string, any>
>;

export type AppsListReposAccessibleToInstallationResponse = Response<
  | AppsListReposAccessibleToInstallation200ResponseBody
  | AppsListReposAccessibleToInstallation401ResponseBody
  | AppsListReposAccessibleToInstallation403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type AppsListReposAccessibleToInstallationHandler = (
  req: AppsListReposAccessibleToInstallationRequest,
  res: AppsListReposAccessibleToInstallationResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsRevokeInstallationAccessTokenRequest = Request<
  ParamsDictionary,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsRevokeInstallationAccessTokenResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type AppsRevokeInstallationAccessTokenHandler = (
  req: AppsRevokeInstallationAccessTokenRequest,
  res: AppsRevokeInstallationAccessTokenResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListRequest = Request<
  ParamsDictionary,
  | IssuesList200ResponseBody
  | IssuesList404ResponseBody
  | IssuesList422ResponseBody,
  unknown,
  IssuesListRequestQuery,
  Record<string, any>
>;

export type IssuesListResponse = Response<
  | IssuesList200ResponseBody
  | IssuesList404ResponseBody
  | IssuesList422ResponseBody,
  Record<string, any>,
  200 | 304 | 404 | 422
>;

export type IssuesListHandler = (
  req: IssuesListRequest,
  res: IssuesListResponse,
  next: NextFunction
) => Promise<void> | void;

export type LicensesGetAllCommonlyUsedRequest = Request<
  ParamsDictionary,
  LicensesGetAllCommonlyUsed200ResponseBody,
  unknown,
  LicensesGetAllCommonlyUsedRequestQuery,
  Record<string, any>
>;

export type LicensesGetAllCommonlyUsedResponse = Response<
  LicensesGetAllCommonlyUsed200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export type LicensesGetAllCommonlyUsedHandler = (
  req: LicensesGetAllCommonlyUsedRequest,
  res: LicensesGetAllCommonlyUsedResponse,
  next: NextFunction
) => Promise<void> | void;

export type LicensesGetRequest = Request<
  LicensesGetRequestPath,
  | LicensesGet200ResponseBody
  | LicensesGet403ResponseBody
  | LicensesGet404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type LicensesGetResponse = Response<
  | LicensesGet200ResponseBody
  | LicensesGet403ResponseBody
  | LicensesGet404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export type LicensesGetHandler = (
  req: LicensesGetRequest,
  res: LicensesGetResponse,
  next: NextFunction
) => Promise<void> | void;

export type MarkdownRenderRequest = Request<
  ParamsDictionary,
  unknown,
  MarkdownRenderRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MarkdownRenderResponse = Response<
  unknown,
  Record<string, any>,
  200 | 304
>;

export type MarkdownRenderHandler = (
  req: MarkdownRenderRequest,
  res: MarkdownRenderResponse,
  next: NextFunction
) => Promise<void> | void;

export type MarkdownRenderRawRequest = Request<
  ParamsDictionary,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MarkdownRenderRawResponse = Response<
  unknown,
  Record<string, any>,
  200 | 304
>;

export type MarkdownRenderRawHandler = (
  req: MarkdownRenderRawRequest,
  res: MarkdownRenderRawResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsGetSubscriptionPlanForAccountRequest = Request<
  AppsGetSubscriptionPlanForAccountRequestPath,
  | AppsGetSubscriptionPlanForAccount200ResponseBody
  | AppsGetSubscriptionPlanForAccount401ResponseBody
  | AppsGetSubscriptionPlanForAccount404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetSubscriptionPlanForAccountResponse = Response<
  | AppsGetSubscriptionPlanForAccount200ResponseBody
  | AppsGetSubscriptionPlanForAccount401ResponseBody
  | AppsGetSubscriptionPlanForAccount404ResponseBody,
  Record<string, any>,
  200 | 401 | 404
>;

export type AppsGetSubscriptionPlanForAccountHandler = (
  req: AppsGetSubscriptionPlanForAccountRequest,
  res: AppsGetSubscriptionPlanForAccountResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsListPlansRequest = Request<
  ParamsDictionary,
  | AppsListPlans200ResponseBody
  | AppsListPlans401ResponseBody
  | AppsListPlans404ResponseBody,
  unknown,
  AppsListPlansRequestQuery,
  Record<string, any>
>;

export type AppsListPlansResponse = Response<
  | AppsListPlans200ResponseBody
  | AppsListPlans401ResponseBody
  | AppsListPlans404ResponseBody,
  Record<string, any>,
  200 | 401 | 404
>;

export type AppsListPlansHandler = (
  req: AppsListPlansRequest,
  res: AppsListPlansResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsListAccountsForPlanRequest = Request<
  AppsListAccountsForPlanRequestPath,
  | AppsListAccountsForPlan200ResponseBody
  | AppsListAccountsForPlan401ResponseBody
  | AppsListAccountsForPlan404ResponseBody
  | AppsListAccountsForPlan422ResponseBody,
  unknown,
  AppsListAccountsForPlanRequestQuery,
  Record<string, any>
>;

export type AppsListAccountsForPlanResponse = Response<
  | AppsListAccountsForPlan200ResponseBody
  | AppsListAccountsForPlan401ResponseBody
  | AppsListAccountsForPlan404ResponseBody
  | AppsListAccountsForPlan422ResponseBody,
  Record<string, any>,
  200 | 401 | 404 | 422
>;

export type AppsListAccountsForPlanHandler = (
  req: AppsListAccountsForPlanRequest,
  res: AppsListAccountsForPlanResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsGetSubscriptionPlanForAccountStubbedRequest = Request<
  AppsGetSubscriptionPlanForAccountStubbedRequestPath,
  | AppsGetSubscriptionPlanForAccountStubbed200ResponseBody
  | AppsGetSubscriptionPlanForAccountStubbed401ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetSubscriptionPlanForAccountStubbedResponse = Response<
  | AppsGetSubscriptionPlanForAccountStubbed200ResponseBody
  | AppsGetSubscriptionPlanForAccountStubbed401ResponseBody,
  Record<string, any>,
  200 | 401 | 404
>;

export type AppsGetSubscriptionPlanForAccountStubbedHandler = (
  req: AppsGetSubscriptionPlanForAccountStubbedRequest,
  res: AppsGetSubscriptionPlanForAccountStubbedResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsListPlansStubbedRequest = Request<
  ParamsDictionary,
  AppsListPlansStubbed200ResponseBody | AppsListPlansStubbed401ResponseBody,
  unknown,
  AppsListPlansStubbedRequestQuery,
  Record<string, any>
>;

export type AppsListPlansStubbedResponse = Response<
  AppsListPlansStubbed200ResponseBody | AppsListPlansStubbed401ResponseBody,
  Record<string, any>,
  200 | 401
>;

export type AppsListPlansStubbedHandler = (
  req: AppsListPlansStubbedRequest,
  res: AppsListPlansStubbedResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsListAccountsForPlanStubbedRequest = Request<
  AppsListAccountsForPlanStubbedRequestPath,
  | AppsListAccountsForPlanStubbed200ResponseBody
  | AppsListAccountsForPlanStubbed401ResponseBody,
  unknown,
  AppsListAccountsForPlanStubbedRequestQuery,
  Record<string, any>
>;

export type AppsListAccountsForPlanStubbedResponse = Response<
  | AppsListAccountsForPlanStubbed200ResponseBody
  | AppsListAccountsForPlanStubbed401ResponseBody,
  Record<string, any>,
  200 | 401
>;

export type AppsListAccountsForPlanStubbedHandler = (
  req: AppsListAccountsForPlanStubbedRequest,
  res: AppsListAccountsForPlanStubbedResponse,
  next: NextFunction
) => Promise<void> | void;

export type MetaGetRequest = Request<
  ParamsDictionary,
  MetaGet200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MetaGetResponse = Response<
  MetaGet200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export type MetaGetHandler = (
  req: MetaGetRequest,
  res: MetaGetResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListPublicEventsForRepoNetworkRequest = Request<
  ActivityListPublicEventsForRepoNetworkRequestPath,
  | ActivityListPublicEventsForRepoNetwork200ResponseBody
  | ActivityListPublicEventsForRepoNetwork301ResponseBody
  | ActivityListPublicEventsForRepoNetwork403ResponseBody
  | ActivityListPublicEventsForRepoNetwork404ResponseBody,
  unknown,
  ActivityListPublicEventsForRepoNetworkRequestQuery,
  Record<string, any>
>;

export type ActivityListPublicEventsForRepoNetworkResponse = Response<
  | ActivityListPublicEventsForRepoNetwork200ResponseBody
  | ActivityListPublicEventsForRepoNetwork301ResponseBody
  | ActivityListPublicEventsForRepoNetwork403ResponseBody
  | ActivityListPublicEventsForRepoNetwork404ResponseBody,
  Record<string, any>,
  200 | 301 | 304 | 403 | 404
>;

export type ActivityListPublicEventsForRepoNetworkHandler = (
  req: ActivityListPublicEventsForRepoNetworkRequest,
  res: ActivityListPublicEventsForRepoNetworkResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListNotificationsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ActivityListNotificationsForAuthenticatedUser200ResponseBody
  | ActivityListNotificationsForAuthenticatedUser401ResponseBody
  | ActivityListNotificationsForAuthenticatedUser403ResponseBody
  | ActivityListNotificationsForAuthenticatedUser422ResponseBody,
  unknown,
  ActivityListNotificationsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ActivityListNotificationsForAuthenticatedUserResponse = Response<
  | ActivityListNotificationsForAuthenticatedUser200ResponseBody
  | ActivityListNotificationsForAuthenticatedUser401ResponseBody
  | ActivityListNotificationsForAuthenticatedUser403ResponseBody
  | ActivityListNotificationsForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 422
>;

export type ActivityListNotificationsForAuthenticatedUserHandler = (
  req: ActivityListNotificationsForAuthenticatedUserRequest,
  res: ActivityListNotificationsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityMarkNotificationsAsReadRequest = Request<
  ParamsDictionary,
  | ActivityMarkNotificationsAsRead202ResponseBody
  | ActivityMarkNotificationsAsRead401ResponseBody
  | ActivityMarkNotificationsAsRead403ResponseBody,
  ActivityMarkNotificationsAsReadRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActivityMarkNotificationsAsReadResponse = Response<
  | ActivityMarkNotificationsAsRead202ResponseBody
  | ActivityMarkNotificationsAsRead401ResponseBody
  | ActivityMarkNotificationsAsRead403ResponseBody,
  Record<string, any>,
  202 | 205 | 304 | 401 | 403
>;

export type ActivityMarkNotificationsAsReadHandler = (
  req: ActivityMarkNotificationsAsReadRequest,
  res: ActivityMarkNotificationsAsReadResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityGetThreadRequest = Request<
  ActivityGetThreadRequestPath,
  | ActivityGetThread200ResponseBody
  | ActivityGetThread401ResponseBody
  | ActivityGetThread403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityGetThreadResponse = Response<
  | ActivityGetThread200ResponseBody
  | ActivityGetThread401ResponseBody
  | ActivityGetThread403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type ActivityGetThreadHandler = (
  req: ActivityGetThreadRequest,
  res: ActivityGetThreadResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityMarkThreadAsReadRequest = Request<
  ActivityMarkThreadAsReadRequestPath,
  ActivityMarkThreadAsRead403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityMarkThreadAsReadResponse = Response<
  ActivityMarkThreadAsRead403ResponseBody,
  Record<string, any>,
  205 | 304 | 403
>;

export type ActivityMarkThreadAsReadHandler = (
  req: ActivityMarkThreadAsReadRequest,
  res: ActivityMarkThreadAsReadResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityGetThreadSubscriptionForAuthenticatedUserRequest = Request<
  ActivityGetThreadSubscriptionForAuthenticatedUserRequestPath,
  | ActivityGetThreadSubscriptionForAuthenticatedUser200ResponseBody
  | ActivityGetThreadSubscriptionForAuthenticatedUser401ResponseBody
  | ActivityGetThreadSubscriptionForAuthenticatedUser403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityGetThreadSubscriptionForAuthenticatedUserResponse = Response<
  | ActivityGetThreadSubscriptionForAuthenticatedUser200ResponseBody
  | ActivityGetThreadSubscriptionForAuthenticatedUser401ResponseBody
  | ActivityGetThreadSubscriptionForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type ActivityGetThreadSubscriptionForAuthenticatedUserHandler = (
  req: ActivityGetThreadSubscriptionForAuthenticatedUserRequest,
  res: ActivityGetThreadSubscriptionForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivitySetThreadSubscriptionRequest = Request<
  ActivitySetThreadSubscriptionRequestPath,
  | ActivitySetThreadSubscription200ResponseBody
  | ActivitySetThreadSubscription401ResponseBody
  | ActivitySetThreadSubscription403ResponseBody,
  ActivitySetThreadSubscriptionRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActivitySetThreadSubscriptionResponse = Response<
  | ActivitySetThreadSubscription200ResponseBody
  | ActivitySetThreadSubscription401ResponseBody
  | ActivitySetThreadSubscription403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type ActivitySetThreadSubscriptionHandler = (
  req: ActivitySetThreadSubscriptionRequest,
  res: ActivitySetThreadSubscriptionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityDeleteThreadSubscriptionRequest = Request<
  ActivityDeleteThreadSubscriptionRequestPath,
  | ActivityDeleteThreadSubscription401ResponseBody
  | ActivityDeleteThreadSubscription403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityDeleteThreadSubscriptionResponse = Response<
  | ActivityDeleteThreadSubscription401ResponseBody
  | ActivityDeleteThreadSubscription403ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403
>;

export type ActivityDeleteThreadSubscriptionHandler = (
  req: ActivityDeleteThreadSubscriptionRequest,
  res: ActivityDeleteThreadSubscriptionResponse,
  next: NextFunction
) => Promise<void> | void;

export type MetaGetOctocatRequest = Request<
  ParamsDictionary,
  unknown,
  unknown,
  MetaGetOctocatRequestQuery,
  Record<string, any>
>;

export type MetaGetOctocatResponse = Response<
  unknown,
  Record<string, any>,
  200
>;

export type MetaGetOctocatHandler = (
  req: MetaGetOctocatRequest,
  res: MetaGetOctocatResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListRequest = Request<
  ParamsDictionary,
  OrgsList200ResponseBody,
  unknown,
  OrgsListRequestQuery,
  Record<string, any>
>;

export type OrgsListResponse = Response<
  OrgsList200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export type OrgsListHandler = (
  req: OrgsListRequest,
  res: OrgsListResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListCustomRolesRequest = Request<
  OrgsListCustomRolesRequestPath,
  OrgsListCustomRoles200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsListCustomRolesResponse = Response<
  OrgsListCustomRoles200ResponseBody,
  Record<string, any>,
  200
>;

export type OrgsListCustomRolesHandler = (
  req: OrgsListCustomRolesRequest,
  res: OrgsListCustomRolesResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsGetRequest = Request<
  OrgsGetRequestPath,
  OrgsGet200ResponseBody | OrgsGet404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetResponse = Response<
  OrgsGet200ResponseBody | OrgsGet404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type OrgsGetHandler = (
  req: OrgsGetRequest,
  res: OrgsGetResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsUpdateRequest = Request<
  OrgsUpdateRequestPath,
  | OrgsUpdate200ResponseBody
  | OrgsUpdate409ResponseBody
  | OrgsUpdate422ResponseBody,
  OrgsUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsUpdateResponse = Response<
  | OrgsUpdate200ResponseBody
  | OrgsUpdate409ResponseBody
  | OrgsUpdate422ResponseBody,
  Record<string, any>,
  200 | 409 | 422
>;

export type OrgsUpdateHandler = (
  req: OrgsUpdateRequest,
  res: OrgsUpdateResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetActionsCacheUsageForOrgRequest = Request<
  ActionsGetActionsCacheUsageForOrgRequestPath,
  ActionsGetActionsCacheUsageForOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetActionsCacheUsageForOrgResponse = Response<
  ActionsGetActionsCacheUsageForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetActionsCacheUsageForOrgHandler = (
  req: ActionsGetActionsCacheUsageForOrgRequest,
  res: ActionsGetActionsCacheUsageForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetActionsCacheUsageByRepoForOrgRequest = Request<
  ActionsGetActionsCacheUsageByRepoForOrgRequestPath,
  ActionsGetActionsCacheUsageByRepoForOrg200ResponseBody,
  unknown,
  ActionsGetActionsCacheUsageByRepoForOrgRequestQuery,
  Record<string, any>
>;

export type ActionsGetActionsCacheUsageByRepoForOrgResponse = Response<
  ActionsGetActionsCacheUsageByRepoForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetActionsCacheUsageByRepoForOrgHandler = (
  req: ActionsGetActionsCacheUsageByRepoForOrgRequest,
  res: ActionsGetActionsCacheUsageByRepoForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetGithubActionsPermissionsOrganizationRequest = Request<
  ActionsGetGithubActionsPermissionsOrganizationRequestPath,
  ActionsGetGithubActionsPermissionsOrganization200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetGithubActionsPermissionsOrganizationResponse = Response<
  ActionsGetGithubActionsPermissionsOrganization200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetGithubActionsPermissionsOrganizationHandler = (
  req: ActionsGetGithubActionsPermissionsOrganizationRequest,
  res: ActionsGetGithubActionsPermissionsOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetGithubActionsPermissionsOrganizationRequest = Request<
  ActionsSetGithubActionsPermissionsOrganizationRequestPath,
  unknown,
  ActionsSetGithubActionsPermissionsOrganizationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetGithubActionsPermissionsOrganizationResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsSetGithubActionsPermissionsOrganizationHandler = (
  req: ActionsSetGithubActionsPermissionsOrganizationRequest,
  res: ActionsSetGithubActionsPermissionsOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest = Request<
  ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequestPath,
  ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200ResponseBody,
  unknown,
  ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequestQuery,
  Record<string, any>
>;

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse = Response<
  ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationHandler = (
  req: ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest,
  res: ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest = Request<
  ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestPath,
  unknown,
  ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationHandler = (
  req: ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest,
  res: ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsEnableSelectedRepositoryGithubActionsOrganizationRequest = Request<
  ActionsEnableSelectedRepositoryGithubActionsOrganizationRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsEnableSelectedRepositoryGithubActionsOrganizationResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsEnableSelectedRepositoryGithubActionsOrganizationHandler = (
  req: ActionsEnableSelectedRepositoryGithubActionsOrganizationRequest,
  res: ActionsEnableSelectedRepositoryGithubActionsOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDisableSelectedRepositoryGithubActionsOrganizationRequest = Request<
  ActionsDisableSelectedRepositoryGithubActionsOrganizationRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDisableSelectedRepositoryGithubActionsOrganizationResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsDisableSelectedRepositoryGithubActionsOrganizationHandler = (
  req: ActionsDisableSelectedRepositoryGithubActionsOrganizationRequest,
  res: ActionsDisableSelectedRepositoryGithubActionsOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetAllowedActionsOrganizationRequest = Request<
  ActionsGetAllowedActionsOrganizationRequestPath,
  ActionsGetAllowedActionsOrganization200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetAllowedActionsOrganizationResponse = Response<
  ActionsGetAllowedActionsOrganization200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetAllowedActionsOrganizationHandler = (
  req: ActionsGetAllowedActionsOrganizationRequest,
  res: ActionsGetAllowedActionsOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetAllowedActionsOrganizationRequest = Request<
  ActionsSetAllowedActionsOrganizationRequestPath,
  unknown,
  ActionsSetAllowedActionsOrganizationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetAllowedActionsOrganizationResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsSetAllowedActionsOrganizationHandler = (
  req: ActionsSetAllowedActionsOrganizationRequest,
  res: ActionsSetAllowedActionsOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest = Request<
  ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequestPath,
  ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse = Response<
  ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationHandler = (
  req: ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest,
  res: ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest = Request<
  ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequestPath,
  unknown,
  ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationHandler = (
  req: ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest,
  res: ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListSelfHostedRunnerGroupsForOrgRequest = Request<
  ActionsListSelfHostedRunnerGroupsForOrgRequestPath,
  ActionsListSelfHostedRunnerGroupsForOrg200ResponseBody,
  unknown,
  ActionsListSelfHostedRunnerGroupsForOrgRequestQuery,
  Record<string, any>
>;

export type ActionsListSelfHostedRunnerGroupsForOrgResponse = Response<
  ActionsListSelfHostedRunnerGroupsForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListSelfHostedRunnerGroupsForOrgHandler = (
  req: ActionsListSelfHostedRunnerGroupsForOrgRequest,
  res: ActionsListSelfHostedRunnerGroupsForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsCreateSelfHostedRunnerGroupForOrgRequest = Request<
  ActionsCreateSelfHostedRunnerGroupForOrgRequestPath,
  ActionsCreateSelfHostedRunnerGroupForOrg201ResponseBody,
  ActionsCreateSelfHostedRunnerGroupForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateSelfHostedRunnerGroupForOrgResponse = Response<
  ActionsCreateSelfHostedRunnerGroupForOrg201ResponseBody,
  Record<string, any>,
  201
>;

export type ActionsCreateSelfHostedRunnerGroupForOrgHandler = (
  req: ActionsCreateSelfHostedRunnerGroupForOrgRequest,
  res: ActionsCreateSelfHostedRunnerGroupForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetSelfHostedRunnerGroupForOrgRequest = Request<
  ActionsGetSelfHostedRunnerGroupForOrgRequestPath,
  ActionsGetSelfHostedRunnerGroupForOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetSelfHostedRunnerGroupForOrgResponse = Response<
  ActionsGetSelfHostedRunnerGroupForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetSelfHostedRunnerGroupForOrgHandler = (
  req: ActionsGetSelfHostedRunnerGroupForOrgRequest,
  res: ActionsGetSelfHostedRunnerGroupForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsUpdateSelfHostedRunnerGroupForOrgRequest = Request<
  ActionsUpdateSelfHostedRunnerGroupForOrgRequestPath,
  ActionsUpdateSelfHostedRunnerGroupForOrg200ResponseBody,
  ActionsUpdateSelfHostedRunnerGroupForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsUpdateSelfHostedRunnerGroupForOrgResponse = Response<
  ActionsUpdateSelfHostedRunnerGroupForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsUpdateSelfHostedRunnerGroupForOrgHandler = (
  req: ActionsUpdateSelfHostedRunnerGroupForOrgRequest,
  res: ActionsUpdateSelfHostedRunnerGroupForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDeleteSelfHostedRunnerGroupFromOrgRequest = Request<
  ActionsDeleteSelfHostedRunnerGroupFromOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteSelfHostedRunnerGroupFromOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsDeleteSelfHostedRunnerGroupFromOrgHandler = (
  req: ActionsDeleteSelfHostedRunnerGroupFromOrgRequest,
  res: ActionsDeleteSelfHostedRunnerGroupFromOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest = Request<
  ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequestPath,
  ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200ResponseBody,
  unknown,
  ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequestQuery,
  Record<string, any>
>;

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse = Response<
  ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgHandler = (
  req: ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest,
  res: ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest = Request<
  ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestPath,
  unknown,
  ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgHandler = (
  req: ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest,
  res: ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest = Request<
  ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgHandler = (
  req: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest,
  res: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListSelfHostedRunnersInGroupForOrgRequest = Request<
  ActionsListSelfHostedRunnersInGroupForOrgRequestPath,
  ActionsListSelfHostedRunnersInGroupForOrg200ResponseBody,
  unknown,
  ActionsListSelfHostedRunnersInGroupForOrgRequestQuery,
  Record<string, any>
>;

export type ActionsListSelfHostedRunnersInGroupForOrgResponse = Response<
  ActionsListSelfHostedRunnersInGroupForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListSelfHostedRunnersInGroupForOrgHandler = (
  req: ActionsListSelfHostedRunnersInGroupForOrgRequest,
  res: ActionsListSelfHostedRunnersInGroupForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetSelfHostedRunnersInGroupForOrgRequest = Request<
  ActionsSetSelfHostedRunnersInGroupForOrgRequestPath,
  unknown,
  ActionsSetSelfHostedRunnersInGroupForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetSelfHostedRunnersInGroupForOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsSetSelfHostedRunnersInGroupForOrgHandler = (
  req: ActionsSetSelfHostedRunnersInGroupForOrgRequest,
  res: ActionsSetSelfHostedRunnersInGroupForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsAddSelfHostedRunnerToGroupForOrgRequest = Request<
  ActionsAddSelfHostedRunnerToGroupForOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsAddSelfHostedRunnerToGroupForOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsAddSelfHostedRunnerToGroupForOrgHandler = (
  req: ActionsAddSelfHostedRunnerToGroupForOrgRequest,
  res: ActionsAddSelfHostedRunnerToGroupForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsRemoveSelfHostedRunnerFromGroupForOrgRequest = Request<
  ActionsRemoveSelfHostedRunnerFromGroupForOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveSelfHostedRunnerFromGroupForOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsRemoveSelfHostedRunnerFromGroupForOrgHandler = (
  req: ActionsRemoveSelfHostedRunnerFromGroupForOrgRequest,
  res: ActionsRemoveSelfHostedRunnerFromGroupForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListSelfHostedRunnersForOrgRequest = Request<
  ActionsListSelfHostedRunnersForOrgRequestPath,
  ActionsListSelfHostedRunnersForOrg200ResponseBody,
  unknown,
  ActionsListSelfHostedRunnersForOrgRequestQuery,
  Record<string, any>
>;

export type ActionsListSelfHostedRunnersForOrgResponse = Response<
  ActionsListSelfHostedRunnersForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListSelfHostedRunnersForOrgHandler = (
  req: ActionsListSelfHostedRunnersForOrgRequest,
  res: ActionsListSelfHostedRunnersForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListRunnerApplicationsForOrgRequest = Request<
  ActionsListRunnerApplicationsForOrgRequestPath,
  ActionsListRunnerApplicationsForOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsListRunnerApplicationsForOrgResponse = Response<
  ActionsListRunnerApplicationsForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListRunnerApplicationsForOrgHandler = (
  req: ActionsListRunnerApplicationsForOrgRequest,
  res: ActionsListRunnerApplicationsForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsCreateRegistrationTokenForOrgRequest = Request<
  ActionsCreateRegistrationTokenForOrgRequestPath,
  ActionsCreateRegistrationTokenForOrg201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateRegistrationTokenForOrgResponse = Response<
  ActionsCreateRegistrationTokenForOrg201ResponseBody,
  Record<string, any>,
  201
>;

export type ActionsCreateRegistrationTokenForOrgHandler = (
  req: ActionsCreateRegistrationTokenForOrgRequest,
  res: ActionsCreateRegistrationTokenForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsCreateRemoveTokenForOrgRequest = Request<
  ActionsCreateRemoveTokenForOrgRequestPath,
  ActionsCreateRemoveTokenForOrg201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateRemoveTokenForOrgResponse = Response<
  ActionsCreateRemoveTokenForOrg201ResponseBody,
  Record<string, any>,
  201
>;

export type ActionsCreateRemoveTokenForOrgHandler = (
  req: ActionsCreateRemoveTokenForOrgRequest,
  res: ActionsCreateRemoveTokenForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetSelfHostedRunnerForOrgRequest = Request<
  ActionsGetSelfHostedRunnerForOrgRequestPath,
  ActionsGetSelfHostedRunnerForOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetSelfHostedRunnerForOrgResponse = Response<
  ActionsGetSelfHostedRunnerForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetSelfHostedRunnerForOrgHandler = (
  req: ActionsGetSelfHostedRunnerForOrgRequest,
  res: ActionsGetSelfHostedRunnerForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDeleteSelfHostedRunnerFromOrgRequest = Request<
  ActionsDeleteSelfHostedRunnerFromOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteSelfHostedRunnerFromOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsDeleteSelfHostedRunnerFromOrgHandler = (
  req: ActionsDeleteSelfHostedRunnerFromOrgRequest,
  res: ActionsDeleteSelfHostedRunnerFromOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListLabelsForSelfHostedRunnerForOrgRequest = Request<
  ActionsListLabelsForSelfHostedRunnerForOrgRequestPath,
  | ActionsListLabelsForSelfHostedRunnerForOrg200ResponseBody
  | ActionsListLabelsForSelfHostedRunnerForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsListLabelsForSelfHostedRunnerForOrgResponse = Response<
  | ActionsListLabelsForSelfHostedRunnerForOrg200ResponseBody
  | ActionsListLabelsForSelfHostedRunnerForOrg404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ActionsListLabelsForSelfHostedRunnerForOrgHandler = (
  req: ActionsListLabelsForSelfHostedRunnerForOrgRequest,
  res: ActionsListLabelsForSelfHostedRunnerForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest = Request<
  ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestPath,
  | ActionsAddCustomLabelsToSelfHostedRunnerForOrg200ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForOrg404ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForOrg422ResponseBody,
  ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse = Response<
  | ActionsAddCustomLabelsToSelfHostedRunnerForOrg200ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForOrg404ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForOrg422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgHandler = (
  req: ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest,
  res: ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest = Request<
  ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestPath,
  | ActionsSetCustomLabelsForSelfHostedRunnerForOrg200ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForOrg404ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForOrg422ResponseBody,
  ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse = Response<
  | ActionsSetCustomLabelsForSelfHostedRunnerForOrg200ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForOrg404ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForOrg422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgHandler = (
  req: ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest,
  res: ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest = Request<
  ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequestPath,
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg200ResponseBody
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse = Response<
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg200ResponseBody
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgHandler = (
  req: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest,
  res: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest = Request<
  ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequestPath,
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg200ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg404ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse = Response<
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg200ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg404ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgHandler = (
  req: ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest,
  res: ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListOrgSecretsRequest = Request<
  ActionsListOrgSecretsRequestPath,
  ActionsListOrgSecrets200ResponseBody,
  unknown,
  ActionsListOrgSecretsRequestQuery,
  Record<string, any>
>;

export type ActionsListOrgSecretsResponse = Response<
  ActionsListOrgSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListOrgSecretsHandler = (
  req: ActionsListOrgSecretsRequest,
  res: ActionsListOrgSecretsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetOrgPublicKeyRequest = Request<
  ActionsGetOrgPublicKeyRequestPath,
  ActionsGetOrgPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetOrgPublicKeyResponse = Response<
  ActionsGetOrgPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetOrgPublicKeyHandler = (
  req: ActionsGetOrgPublicKeyRequest,
  res: ActionsGetOrgPublicKeyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetOrgSecretRequest = Request<
  ActionsGetOrgSecretRequestPath,
  ActionsGetOrgSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetOrgSecretResponse = Response<
  ActionsGetOrgSecret200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetOrgSecretHandler = (
  req: ActionsGetOrgSecretRequest,
  res: ActionsGetOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsCreateOrUpdateOrgSecretRequest = Request<
  ActionsCreateOrUpdateOrgSecretRequestPath,
  ActionsCreateOrUpdateOrgSecret201ResponseBody,
  ActionsCreateOrUpdateOrgSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateOrUpdateOrgSecretResponse = Response<
  ActionsCreateOrUpdateOrgSecret201ResponseBody,
  Record<string, any>,
  201 | 204
>;

export type ActionsCreateOrUpdateOrgSecretHandler = (
  req: ActionsCreateOrUpdateOrgSecretRequest,
  res: ActionsCreateOrUpdateOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDeleteOrgSecretRequest = Request<
  ActionsDeleteOrgSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsDeleteOrgSecretHandler = (
  req: ActionsDeleteOrgSecretRequest,
  res: ActionsDeleteOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListSelectedReposForOrgSecretRequest = Request<
  ActionsListSelectedReposForOrgSecretRequestPath,
  ActionsListSelectedReposForOrgSecret200ResponseBody,
  unknown,
  ActionsListSelectedReposForOrgSecretRequestQuery,
  Record<string, any>
>;

export type ActionsListSelectedReposForOrgSecretResponse = Response<
  ActionsListSelectedReposForOrgSecret200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListSelectedReposForOrgSecretHandler = (
  req: ActionsListSelectedReposForOrgSecretRequest,
  res: ActionsListSelectedReposForOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetSelectedReposForOrgSecretRequest = Request<
  ActionsSetSelectedReposForOrgSecretRequestPath,
  unknown,
  ActionsSetSelectedReposForOrgSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetSelectedReposForOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsSetSelectedReposForOrgSecretHandler = (
  req: ActionsSetSelectedReposForOrgSecretRequest,
  res: ActionsSetSelectedReposForOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsAddSelectedRepoToOrgSecretRequest = Request<
  ActionsAddSelectedRepoToOrgSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsAddSelectedRepoToOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export type ActionsAddSelectedRepoToOrgSecretHandler = (
  req: ActionsAddSelectedRepoToOrgSecretRequest,
  res: ActionsAddSelectedRepoToOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsRemoveSelectedRepoFromOrgSecretRequest = Request<
  ActionsRemoveSelectedRepoFromOrgSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveSelectedRepoFromOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export type ActionsRemoveSelectedRepoFromOrgSecretHandler = (
  req: ActionsRemoveSelectedRepoFromOrgSecretRequest,
  res: ActionsRemoveSelectedRepoFromOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListBlockedUsersRequest = Request<
  OrgsListBlockedUsersRequestPath,
  OrgsListBlockedUsers200ResponseBody,
  unknown,
  OrgsListBlockedUsersRequestQuery,
  Record<string, any>
>;

export type OrgsListBlockedUsersResponse = Response<
  OrgsListBlockedUsers200ResponseBody,
  Record<string, any>,
  200
>;

export type OrgsListBlockedUsersHandler = (
  req: OrgsListBlockedUsersRequest,
  res: OrgsListBlockedUsersResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsCheckBlockedUserRequest = Request<
  OrgsCheckBlockedUserRequestPath,
  OrgsCheckBlockedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCheckBlockedUserResponse = Response<
  OrgsCheckBlockedUser404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type OrgsCheckBlockedUserHandler = (
  req: OrgsCheckBlockedUserRequest,
  res: OrgsCheckBlockedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsBlockUserRequest = Request<
  OrgsBlockUserRequestPath,
  OrgsBlockUser422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsBlockUserResponse = Response<
  OrgsBlockUser422ResponseBody,
  Record<string, any>,
  204 | 422
>;

export type OrgsBlockUserHandler = (
  req: OrgsBlockUserRequest,
  res: OrgsBlockUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsUnblockUserRequest = Request<
  OrgsUnblockUserRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsUnblockUserResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type OrgsUnblockUserHandler = (
  req: OrgsUnblockUserRequest,
  res: OrgsUnblockUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodeScanningListAlertsForOrgRequest = Request<
  CodeScanningListAlertsForOrgRequestPath,
  | CodeScanningListAlertsForOrg200ResponseBody
  | CodeScanningListAlertsForOrg404ResponseBody
  | CodeScanningListAlertsForOrg503ResponseBody,
  unknown,
  CodeScanningListAlertsForOrgRequestQuery,
  Record<string, any>
>;

export type CodeScanningListAlertsForOrgResponse = Response<
  | CodeScanningListAlertsForOrg200ResponseBody
  | CodeScanningListAlertsForOrg404ResponseBody
  | CodeScanningListAlertsForOrg503ResponseBody,
  Record<string, any>,
  200 | 404 | 503
>;

export type CodeScanningListAlertsForOrgHandler = (
  req: CodeScanningListAlertsForOrgRequest,
  res: CodeScanningListAlertsForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesListInOrganizationRequest = Request<
  CodespacesListInOrganizationRequestPath,
  | CodespacesListInOrganization200ResponseBody
  | CodespacesListInOrganization401ResponseBody
  | CodespacesListInOrganization403ResponseBody
  | CodespacesListInOrganization404ResponseBody
  | CodespacesListInOrganization500ResponseBody,
  unknown,
  CodespacesListInOrganizationRequestQuery,
  Record<string, any>
>;

export type CodespacesListInOrganizationResponse = Response<
  | CodespacesListInOrganization200ResponseBody
  | CodespacesListInOrganization401ResponseBody
  | CodespacesListInOrganization403ResponseBody
  | CodespacesListInOrganization404ResponseBody
  | CodespacesListInOrganization500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export type CodespacesListInOrganizationHandler = (
  req: CodespacesListInOrganizationRequest,
  res: CodespacesListInOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesSetCodespacesBillingRequest = Request<
  CodespacesSetCodespacesBillingRequestPath,
  | CodespacesSetCodespacesBilling404ResponseBody
  | CodespacesSetCodespacesBilling422ResponseBody
  | CodespacesSetCodespacesBilling500ResponseBody,
  CodespacesSetCodespacesBillingRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesSetCodespacesBillingResponse = Response<
  | CodespacesSetCodespacesBilling404ResponseBody
  | CodespacesSetCodespacesBilling422ResponseBody
  | CodespacesSetCodespacesBilling500ResponseBody,
  Record<string, any>,
  204 | 304 | 400 | 404 | 422 | 500
>;

export type CodespacesSetCodespacesBillingHandler = (
  req: CodespacesSetCodespacesBillingRequest,
  res: CodespacesSetCodespacesBillingResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesListOrgSecretsRequest = Request<
  CodespacesListOrgSecretsRequestPath,
  CodespacesListOrgSecrets200ResponseBody,
  unknown,
  CodespacesListOrgSecretsRequestQuery,
  Record<string, any>
>;

export type CodespacesListOrgSecretsResponse = Response<
  CodespacesListOrgSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export type CodespacesListOrgSecretsHandler = (
  req: CodespacesListOrgSecretsRequest,
  res: CodespacesListOrgSecretsResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesGetOrgPublicKeyRequest = Request<
  CodespacesGetOrgPublicKeyRequestPath,
  CodespacesGetOrgPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetOrgPublicKeyResponse = Response<
  CodespacesGetOrgPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export type CodespacesGetOrgPublicKeyHandler = (
  req: CodespacesGetOrgPublicKeyRequest,
  res: CodespacesGetOrgPublicKeyResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesGetOrgSecretRequest = Request<
  CodespacesGetOrgSecretRequestPath,
  CodespacesGetOrgSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetOrgSecretResponse = Response<
  CodespacesGetOrgSecret200ResponseBody,
  Record<string, any>,
  200
>;

export type CodespacesGetOrgSecretHandler = (
  req: CodespacesGetOrgSecretRequest,
  res: CodespacesGetOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesCreateOrUpdateOrgSecretRequest = Request<
  CodespacesCreateOrUpdateOrgSecretRequestPath,
  | CodespacesCreateOrUpdateOrgSecret201ResponseBody
  | CodespacesCreateOrUpdateOrgSecret404ResponseBody
  | CodespacesCreateOrUpdateOrgSecret422ResponseBody,
  CodespacesCreateOrUpdateOrgSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCreateOrUpdateOrgSecretResponse = Response<
  | CodespacesCreateOrUpdateOrgSecret201ResponseBody
  | CodespacesCreateOrUpdateOrgSecret404ResponseBody
  | CodespacesCreateOrUpdateOrgSecret422ResponseBody,
  Record<string, any>,
  201 | 204 | 404 | 422
>;

export type CodespacesCreateOrUpdateOrgSecretHandler = (
  req: CodespacesCreateOrUpdateOrgSecretRequest,
  res: CodespacesCreateOrUpdateOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesDeleteOrgSecretRequest = Request<
  CodespacesDeleteOrgSecretRequestPath,
  CodespacesDeleteOrgSecret404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesDeleteOrgSecretResponse = Response<
  CodespacesDeleteOrgSecret404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type CodespacesDeleteOrgSecretHandler = (
  req: CodespacesDeleteOrgSecretRequest,
  res: CodespacesDeleteOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesListSelectedReposForOrgSecretRequest = Request<
  CodespacesListSelectedReposForOrgSecretRequestPath,
  | CodespacesListSelectedReposForOrgSecret200ResponseBody
  | CodespacesListSelectedReposForOrgSecret404ResponseBody,
  unknown,
  CodespacesListSelectedReposForOrgSecretRequestQuery,
  Record<string, any>
>;

export type CodespacesListSelectedReposForOrgSecretResponse = Response<
  | CodespacesListSelectedReposForOrgSecret200ResponseBody
  | CodespacesListSelectedReposForOrgSecret404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type CodespacesListSelectedReposForOrgSecretHandler = (
  req: CodespacesListSelectedReposForOrgSecretRequest,
  res: CodespacesListSelectedReposForOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesSetSelectedReposForOrgSecretRequest = Request<
  CodespacesSetSelectedReposForOrgSecretRequestPath,
  CodespacesSetSelectedReposForOrgSecret404ResponseBody,
  CodespacesSetSelectedReposForOrgSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesSetSelectedReposForOrgSecretResponse = Response<
  CodespacesSetSelectedReposForOrgSecret404ResponseBody,
  Record<string, any>,
  204 | 404 | 409
>;

export type CodespacesSetSelectedReposForOrgSecretHandler = (
  req: CodespacesSetSelectedReposForOrgSecretRequest,
  res: CodespacesSetSelectedReposForOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesAddSelectedRepoToOrgSecretRequest = Request<
  CodespacesAddSelectedRepoToOrgSecretRequestPath,
  | CodespacesAddSelectedRepoToOrgSecret404ResponseBody
  | CodespacesAddSelectedRepoToOrgSecret422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesAddSelectedRepoToOrgSecretResponse = Response<
  | CodespacesAddSelectedRepoToOrgSecret404ResponseBody
  | CodespacesAddSelectedRepoToOrgSecret422ResponseBody,
  Record<string, any>,
  204 | 404 | 409 | 422
>;

export type CodespacesAddSelectedRepoToOrgSecretHandler = (
  req: CodespacesAddSelectedRepoToOrgSecretRequest,
  res: CodespacesAddSelectedRepoToOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesRemoveSelectedRepoFromOrgSecretRequest = Request<
  CodespacesRemoveSelectedRepoFromOrgSecretRequestPath,
  | CodespacesRemoveSelectedRepoFromOrgSecret404ResponseBody
  | CodespacesRemoveSelectedRepoFromOrgSecret422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesRemoveSelectedRepoFromOrgSecretResponse = Response<
  | CodespacesRemoveSelectedRepoFromOrgSecret404ResponseBody
  | CodespacesRemoveSelectedRepoFromOrgSecret422ResponseBody,
  Record<string, any>,
  204 | 404 | 409 | 422
>;

export type CodespacesRemoveSelectedRepoFromOrgSecretHandler = (
  req: CodespacesRemoveSelectedRepoFromOrgSecretRequest,
  res: CodespacesRemoveSelectedRepoFromOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsCreateCustomRoleRequest = Request<
  OrgsCreateCustomRoleRequestPath,
  | OrgsCreateCustomRole201ResponseBody
  | OrgsCreateCustomRole404ResponseBody
  | OrgsCreateCustomRole422ResponseBody,
  OrgsCreateCustomRoleRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCreateCustomRoleResponse = Response<
  | OrgsCreateCustomRole201ResponseBody
  | OrgsCreateCustomRole404ResponseBody
  | OrgsCreateCustomRole422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export type OrgsCreateCustomRoleHandler = (
  req: OrgsCreateCustomRoleRequest,
  res: OrgsCreateCustomRoleResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsGetCustomRoleRequest = Request<
  OrgsGetCustomRoleRequestPath,
  OrgsGetCustomRole200ResponseBody | OrgsGetCustomRole404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetCustomRoleResponse = Response<
  OrgsGetCustomRole200ResponseBody | OrgsGetCustomRole404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type OrgsGetCustomRoleHandler = (
  req: OrgsGetCustomRoleRequest,
  res: OrgsGetCustomRoleResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsUpdateCustomRoleRequest = Request<
  OrgsUpdateCustomRoleRequestPath,
  | OrgsUpdateCustomRole200ResponseBody
  | OrgsUpdateCustomRole404ResponseBody
  | OrgsUpdateCustomRole422ResponseBody,
  OrgsUpdateCustomRoleRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsUpdateCustomRoleResponse = Response<
  | OrgsUpdateCustomRole200ResponseBody
  | OrgsUpdateCustomRole404ResponseBody
  | OrgsUpdateCustomRole422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type OrgsUpdateCustomRoleHandler = (
  req: OrgsUpdateCustomRoleRequest,
  res: OrgsUpdateCustomRoleResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsDeleteCustomRoleRequest = Request<
  OrgsDeleteCustomRoleRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsDeleteCustomRoleResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type OrgsDeleteCustomRoleHandler = (
  req: OrgsDeleteCustomRoleRequest,
  res: OrgsDeleteCustomRoleResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotListAlertsForOrgRequest = Request<
  DependabotListAlertsForOrgRequestPath,
  | DependabotListAlertsForOrg200ResponseBody
  | DependabotListAlertsForOrg400ResponseBody
  | DependabotListAlertsForOrg403ResponseBody
  | DependabotListAlertsForOrg404ResponseBody
  | DependabotListAlertsForOrg422ResponseBody,
  unknown,
  DependabotListAlertsForOrgRequestQuery,
  Record<string, any>
>;

export type DependabotListAlertsForOrgResponse = Response<
  | DependabotListAlertsForOrg200ResponseBody
  | DependabotListAlertsForOrg400ResponseBody
  | DependabotListAlertsForOrg403ResponseBody
  | DependabotListAlertsForOrg404ResponseBody
  | DependabotListAlertsForOrg422ResponseBody,
  Record<string, any>,
  200 | 304 | 400 | 403 | 404 | 422
>;

export type DependabotListAlertsForOrgHandler = (
  req: DependabotListAlertsForOrgRequest,
  res: DependabotListAlertsForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotListOrgSecretsRequest = Request<
  DependabotListOrgSecretsRequestPath,
  DependabotListOrgSecrets200ResponseBody,
  unknown,
  DependabotListOrgSecretsRequestQuery,
  Record<string, any>
>;

export type DependabotListOrgSecretsResponse = Response<
  DependabotListOrgSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export type DependabotListOrgSecretsHandler = (
  req: DependabotListOrgSecretsRequest,
  res: DependabotListOrgSecretsResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotGetOrgPublicKeyRequest = Request<
  DependabotGetOrgPublicKeyRequestPath,
  DependabotGetOrgPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotGetOrgPublicKeyResponse = Response<
  DependabotGetOrgPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export type DependabotGetOrgPublicKeyHandler = (
  req: DependabotGetOrgPublicKeyRequest,
  res: DependabotGetOrgPublicKeyResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotGetOrgSecretRequest = Request<
  DependabotGetOrgSecretRequestPath,
  DependabotGetOrgSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotGetOrgSecretResponse = Response<
  DependabotGetOrgSecret200ResponseBody,
  Record<string, any>,
  200
>;

export type DependabotGetOrgSecretHandler = (
  req: DependabotGetOrgSecretRequest,
  res: DependabotGetOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotCreateOrUpdateOrgSecretRequest = Request<
  DependabotCreateOrUpdateOrgSecretRequestPath,
  DependabotCreateOrUpdateOrgSecret201ResponseBody,
  DependabotCreateOrUpdateOrgSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type DependabotCreateOrUpdateOrgSecretResponse = Response<
  DependabotCreateOrUpdateOrgSecret201ResponseBody,
  Record<string, any>,
  201 | 204
>;

export type DependabotCreateOrUpdateOrgSecretHandler = (
  req: DependabotCreateOrUpdateOrgSecretRequest,
  res: DependabotCreateOrUpdateOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotDeleteOrgSecretRequest = Request<
  DependabotDeleteOrgSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotDeleteOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type DependabotDeleteOrgSecretHandler = (
  req: DependabotDeleteOrgSecretRequest,
  res: DependabotDeleteOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotListSelectedReposForOrgSecretRequest = Request<
  DependabotListSelectedReposForOrgSecretRequestPath,
  DependabotListSelectedReposForOrgSecret200ResponseBody,
  unknown,
  DependabotListSelectedReposForOrgSecretRequestQuery,
  Record<string, any>
>;

export type DependabotListSelectedReposForOrgSecretResponse = Response<
  DependabotListSelectedReposForOrgSecret200ResponseBody,
  Record<string, any>,
  200
>;

export type DependabotListSelectedReposForOrgSecretHandler = (
  req: DependabotListSelectedReposForOrgSecretRequest,
  res: DependabotListSelectedReposForOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotSetSelectedReposForOrgSecretRequest = Request<
  DependabotSetSelectedReposForOrgSecretRequestPath,
  unknown,
  DependabotSetSelectedReposForOrgSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type DependabotSetSelectedReposForOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type DependabotSetSelectedReposForOrgSecretHandler = (
  req: DependabotSetSelectedReposForOrgSecretRequest,
  res: DependabotSetSelectedReposForOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotAddSelectedRepoToOrgSecretRequest = Request<
  DependabotAddSelectedRepoToOrgSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotAddSelectedRepoToOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export type DependabotAddSelectedRepoToOrgSecretHandler = (
  req: DependabotAddSelectedRepoToOrgSecretRequest,
  res: DependabotAddSelectedRepoToOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotRemoveSelectedRepoFromOrgSecretRequest = Request<
  DependabotRemoveSelectedRepoFromOrgSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotRemoveSelectedRepoFromOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export type DependabotRemoveSelectedRepoFromOrgSecretHandler = (
  req: DependabotRemoveSelectedRepoFromOrgSecretRequest,
  res: DependabotRemoveSelectedRepoFromOrgSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListPublicOrgEventsRequest = Request<
  ActivityListPublicOrgEventsRequestPath,
  ActivityListPublicOrgEvents200ResponseBody,
  unknown,
  ActivityListPublicOrgEventsRequestQuery,
  Record<string, any>
>;

export type ActivityListPublicOrgEventsResponse = Response<
  ActivityListPublicOrgEvents200ResponseBody,
  Record<string, any>,
  200
>;

export type ActivityListPublicOrgEventsHandler = (
  req: ActivityListPublicOrgEventsRequest,
  res: ActivityListPublicOrgEventsResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListFailedInvitationsRequest = Request<
  OrgsListFailedInvitationsRequestPath,
  | OrgsListFailedInvitations200ResponseBody
  | OrgsListFailedInvitations404ResponseBody,
  unknown,
  OrgsListFailedInvitationsRequestQuery,
  Record<string, any>
>;

export type OrgsListFailedInvitationsResponse = Response<
  | OrgsListFailedInvitations200ResponseBody
  | OrgsListFailedInvitations404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type OrgsListFailedInvitationsHandler = (
  req: OrgsListFailedInvitationsRequest,
  res: OrgsListFailedInvitationsResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListFineGrainedPermissionsRequest = Request<
  OrgsListFineGrainedPermissionsRequestPath,
  OrgsListFineGrainedPermissions200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsListFineGrainedPermissionsResponse = Response<
  OrgsListFineGrainedPermissions200ResponseBody,
  Record<string, any>,
  200
>;

export type OrgsListFineGrainedPermissionsHandler = (
  req: OrgsListFineGrainedPermissionsRequest,
  res: OrgsListFineGrainedPermissionsResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListWebhooksRequest = Request<
  OrgsListWebhooksRequestPath,
  OrgsListWebhooks200ResponseBody | OrgsListWebhooks404ResponseBody,
  unknown,
  OrgsListWebhooksRequestQuery,
  Record<string, any>
>;

export type OrgsListWebhooksResponse = Response<
  OrgsListWebhooks200ResponseBody | OrgsListWebhooks404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type OrgsListWebhooksHandler = (
  req: OrgsListWebhooksRequest,
  res: OrgsListWebhooksResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsCreateWebhookRequest = Request<
  OrgsCreateWebhookRequestPath,
  | OrgsCreateWebhook201ResponseBody
  | OrgsCreateWebhook404ResponseBody
  | OrgsCreateWebhook422ResponseBody,
  OrgsCreateWebhookRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCreateWebhookResponse = Response<
  | OrgsCreateWebhook201ResponseBody
  | OrgsCreateWebhook404ResponseBody
  | OrgsCreateWebhook422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export type OrgsCreateWebhookHandler = (
  req: OrgsCreateWebhookRequest,
  res: OrgsCreateWebhookResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsGetWebhookRequest = Request<
  OrgsGetWebhookRequestPath,
  OrgsGetWebhook200ResponseBody | OrgsGetWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetWebhookResponse = Response<
  OrgsGetWebhook200ResponseBody | OrgsGetWebhook404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type OrgsGetWebhookHandler = (
  req: OrgsGetWebhookRequest,
  res: OrgsGetWebhookResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsUpdateWebhookRequest = Request<
  OrgsUpdateWebhookRequestPath,
  | OrgsUpdateWebhook200ResponseBody
  | OrgsUpdateWebhook404ResponseBody
  | OrgsUpdateWebhook422ResponseBody,
  OrgsUpdateWebhookRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsUpdateWebhookResponse = Response<
  | OrgsUpdateWebhook200ResponseBody
  | OrgsUpdateWebhook404ResponseBody
  | OrgsUpdateWebhook422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type OrgsUpdateWebhookHandler = (
  req: OrgsUpdateWebhookRequest,
  res: OrgsUpdateWebhookResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsDeleteWebhookRequest = Request<
  OrgsDeleteWebhookRequestPath,
  OrgsDeleteWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsDeleteWebhookResponse = Response<
  OrgsDeleteWebhook404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type OrgsDeleteWebhookHandler = (
  req: OrgsDeleteWebhookRequest,
  res: OrgsDeleteWebhookResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsGetWebhookConfigForOrgRequest = Request<
  OrgsGetWebhookConfigForOrgRequestPath,
  OrgsGetWebhookConfigForOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetWebhookConfigForOrgResponse = Response<
  OrgsGetWebhookConfigForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type OrgsGetWebhookConfigForOrgHandler = (
  req: OrgsGetWebhookConfigForOrgRequest,
  res: OrgsGetWebhookConfigForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsUpdateWebhookConfigForOrgRequest = Request<
  OrgsUpdateWebhookConfigForOrgRequestPath,
  OrgsUpdateWebhookConfigForOrg200ResponseBody,
  OrgsUpdateWebhookConfigForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsUpdateWebhookConfigForOrgResponse = Response<
  OrgsUpdateWebhookConfigForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type OrgsUpdateWebhookConfigForOrgHandler = (
  req: OrgsUpdateWebhookConfigForOrgRequest,
  res: OrgsUpdateWebhookConfigForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListWebhookDeliveriesRequest = Request<
  OrgsListWebhookDeliveriesRequestPath,
  | OrgsListWebhookDeliveries200ResponseBody
  | OrgsListWebhookDeliveries400ResponseBody
  | OrgsListWebhookDeliveries422ResponseBody,
  unknown,
  OrgsListWebhookDeliveriesRequestQuery,
  Record<string, any>
>;

export type OrgsListWebhookDeliveriesResponse = Response<
  | OrgsListWebhookDeliveries200ResponseBody
  | OrgsListWebhookDeliveries400ResponseBody
  | OrgsListWebhookDeliveries422ResponseBody,
  Record<string, any>,
  200 | 400 | 422
>;

export type OrgsListWebhookDeliveriesHandler = (
  req: OrgsListWebhookDeliveriesRequest,
  res: OrgsListWebhookDeliveriesResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsGetWebhookDeliveryRequest = Request<
  OrgsGetWebhookDeliveryRequestPath,
  | OrgsGetWebhookDelivery200ResponseBody
  | OrgsGetWebhookDelivery400ResponseBody
  | OrgsGetWebhookDelivery422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetWebhookDeliveryResponse = Response<
  | OrgsGetWebhookDelivery200ResponseBody
  | OrgsGetWebhookDelivery400ResponseBody
  | OrgsGetWebhookDelivery422ResponseBody,
  Record<string, any>,
  200 | 400 | 422
>;

export type OrgsGetWebhookDeliveryHandler = (
  req: OrgsGetWebhookDeliveryRequest,
  res: OrgsGetWebhookDeliveryResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsRedeliverWebhookDeliveryRequest = Request<
  OrgsRedeliverWebhookDeliveryRequestPath,
  | OrgsRedeliverWebhookDelivery202ResponseBody
  | OrgsRedeliverWebhookDelivery400ResponseBody
  | OrgsRedeliverWebhookDelivery422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsRedeliverWebhookDeliveryResponse = Response<
  | OrgsRedeliverWebhookDelivery202ResponseBody
  | OrgsRedeliverWebhookDelivery400ResponseBody
  | OrgsRedeliverWebhookDelivery422ResponseBody,
  Record<string, any>,
  202 | 400 | 422
>;

export type OrgsRedeliverWebhookDeliveryHandler = (
  req: OrgsRedeliverWebhookDeliveryRequest,
  res: OrgsRedeliverWebhookDeliveryResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsPingWebhookRequest = Request<
  OrgsPingWebhookRequestPath,
  OrgsPingWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsPingWebhookResponse = Response<
  OrgsPingWebhook404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type OrgsPingWebhookHandler = (
  req: OrgsPingWebhookRequest,
  res: OrgsPingWebhookResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsGetOrgInstallationRequest = Request<
  AppsGetOrgInstallationRequestPath,
  AppsGetOrgInstallation200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetOrgInstallationResponse = Response<
  AppsGetOrgInstallation200ResponseBody,
  Record<string, any>,
  200
>;

export type AppsGetOrgInstallationHandler = (
  req: AppsGetOrgInstallationRequest,
  res: AppsGetOrgInstallationResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListAppInstallationsRequest = Request<
  OrgsListAppInstallationsRequestPath,
  OrgsListAppInstallations200ResponseBody,
  unknown,
  OrgsListAppInstallationsRequestQuery,
  Record<string, any>
>;

export type OrgsListAppInstallationsResponse = Response<
  OrgsListAppInstallations200ResponseBody,
  Record<string, any>,
  200
>;

export type OrgsListAppInstallationsHandler = (
  req: OrgsListAppInstallationsRequest,
  res: OrgsListAppInstallationsResponse,
  next: NextFunction
) => Promise<void> | void;

export type InteractionsGetRestrictionsForOrgRequest = Request<
  InteractionsGetRestrictionsForOrgRequestPath,
  InteractionsGetRestrictionsForOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsGetRestrictionsForOrgResponse = Response<
  InteractionsGetRestrictionsForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type InteractionsGetRestrictionsForOrgHandler = (
  req: InteractionsGetRestrictionsForOrgRequest,
  res: InteractionsGetRestrictionsForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type InteractionsSetRestrictionsForOrgRequest = Request<
  InteractionsSetRestrictionsForOrgRequestPath,
  | InteractionsSetRestrictionsForOrg200ResponseBody
  | InteractionsSetRestrictionsForOrg422ResponseBody,
  InteractionsSetRestrictionsForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsSetRestrictionsForOrgResponse = Response<
  | InteractionsSetRestrictionsForOrg200ResponseBody
  | InteractionsSetRestrictionsForOrg422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type InteractionsSetRestrictionsForOrgHandler = (
  req: InteractionsSetRestrictionsForOrgRequest,
  res: InteractionsSetRestrictionsForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type InteractionsRemoveRestrictionsForOrgRequest = Request<
  InteractionsRemoveRestrictionsForOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsRemoveRestrictionsForOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type InteractionsRemoveRestrictionsForOrgHandler = (
  req: InteractionsRemoveRestrictionsForOrgRequest,
  res: InteractionsRemoveRestrictionsForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListPendingInvitationsRequest = Request<
  OrgsListPendingInvitationsRequestPath,
  | OrgsListPendingInvitations200ResponseBody
  | OrgsListPendingInvitations404ResponseBody,
  unknown,
  OrgsListPendingInvitationsRequestQuery,
  Record<string, any>
>;

export type OrgsListPendingInvitationsResponse = Response<
  | OrgsListPendingInvitations200ResponseBody
  | OrgsListPendingInvitations404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type OrgsListPendingInvitationsHandler = (
  req: OrgsListPendingInvitationsRequest,
  res: OrgsListPendingInvitationsResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsCreateInvitationRequest = Request<
  OrgsCreateInvitationRequestPath,
  | OrgsCreateInvitation201ResponseBody
  | OrgsCreateInvitation404ResponseBody
  | OrgsCreateInvitation422ResponseBody,
  OrgsCreateInvitationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCreateInvitationResponse = Response<
  | OrgsCreateInvitation201ResponseBody
  | OrgsCreateInvitation404ResponseBody
  | OrgsCreateInvitation422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export type OrgsCreateInvitationHandler = (
  req: OrgsCreateInvitationRequest,
  res: OrgsCreateInvitationResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsCancelInvitationRequest = Request<
  OrgsCancelInvitationRequestPath,
  OrgsCancelInvitation404ResponseBody | OrgsCancelInvitation422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCancelInvitationResponse = Response<
  OrgsCancelInvitation404ResponseBody | OrgsCancelInvitation422ResponseBody,
  Record<string, any>,
  204 | 404 | 422
>;

export type OrgsCancelInvitationHandler = (
  req: OrgsCancelInvitationRequest,
  res: OrgsCancelInvitationResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListInvitationTeamsRequest = Request<
  OrgsListInvitationTeamsRequestPath,
  | OrgsListInvitationTeams200ResponseBody
  | OrgsListInvitationTeams404ResponseBody,
  unknown,
  OrgsListInvitationTeamsRequestQuery,
  Record<string, any>
>;

export type OrgsListInvitationTeamsResponse = Response<
  | OrgsListInvitationTeams200ResponseBody
  | OrgsListInvitationTeams404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type OrgsListInvitationTeamsHandler = (
  req: OrgsListInvitationTeamsRequest,
  res: OrgsListInvitationTeamsResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListForOrgRequest = Request<
  IssuesListForOrgRequestPath,
  IssuesListForOrg200ResponseBody | IssuesListForOrg404ResponseBody,
  unknown,
  IssuesListForOrgRequestQuery,
  Record<string, any>
>;

export type IssuesListForOrgResponse = Response<
  IssuesListForOrg200ResponseBody | IssuesListForOrg404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type IssuesListForOrgHandler = (
  req: IssuesListForOrgRequest,
  res: IssuesListForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListMembersRequest = Request<
  OrgsListMembersRequestPath,
  OrgsListMembers200ResponseBody | OrgsListMembers422ResponseBody,
  unknown,
  OrgsListMembersRequestQuery,
  Record<string, any>
>;

export type OrgsListMembersResponse = Response<
  OrgsListMembers200ResponseBody | OrgsListMembers422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type OrgsListMembersHandler = (
  req: OrgsListMembersRequest,
  res: OrgsListMembersResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsCheckMembershipForUserRequest = Request<
  OrgsCheckMembershipForUserRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCheckMembershipForUserResponse = Response<
  unknown,
  Record<string, any>,
  204 | 302 | 404
>;

export type OrgsCheckMembershipForUserHandler = (
  req: OrgsCheckMembershipForUserRequest,
  res: OrgsCheckMembershipForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsRemoveMemberRequest = Request<
  OrgsRemoveMemberRequestPath,
  OrgsRemoveMember403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsRemoveMemberResponse = Response<
  OrgsRemoveMember403ResponseBody,
  Record<string, any>,
  204 | 403
>;

export type OrgsRemoveMemberHandler = (
  req: OrgsRemoveMemberRequest,
  res: OrgsRemoveMemberResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesGetCodespacesForUserInOrgRequest = Request<
  CodespacesGetCodespacesForUserInOrgRequestPath,
  | CodespacesGetCodespacesForUserInOrg200ResponseBody
  | CodespacesGetCodespacesForUserInOrg401ResponseBody
  | CodespacesGetCodespacesForUserInOrg403ResponseBody
  | CodespacesGetCodespacesForUserInOrg404ResponseBody
  | CodespacesGetCodespacesForUserInOrg500ResponseBody,
  unknown,
  CodespacesGetCodespacesForUserInOrgRequestQuery,
  Record<string, any>
>;

export type CodespacesGetCodespacesForUserInOrgResponse = Response<
  | CodespacesGetCodespacesForUserInOrg200ResponseBody
  | CodespacesGetCodespacesForUserInOrg401ResponseBody
  | CodespacesGetCodespacesForUserInOrg403ResponseBody
  | CodespacesGetCodespacesForUserInOrg404ResponseBody
  | CodespacesGetCodespacesForUserInOrg500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export type CodespacesGetCodespacesForUserInOrgHandler = (
  req: CodespacesGetCodespacesForUserInOrgRequest,
  res: CodespacesGetCodespacesForUserInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesDeleteFromOrganizationRequest = Request<
  CodespacesDeleteFromOrganizationRequestPath,
  | CodespacesDeleteFromOrganization202ResponseBody
  | CodespacesDeleteFromOrganization401ResponseBody
  | CodespacesDeleteFromOrganization403ResponseBody
  | CodespacesDeleteFromOrganization404ResponseBody
  | CodespacesDeleteFromOrganization500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesDeleteFromOrganizationResponse = Response<
  | CodespacesDeleteFromOrganization202ResponseBody
  | CodespacesDeleteFromOrganization401ResponseBody
  | CodespacesDeleteFromOrganization403ResponseBody
  | CodespacesDeleteFromOrganization404ResponseBody
  | CodespacesDeleteFromOrganization500ResponseBody,
  Record<string, any>,
  202 | 304 | 401 | 403 | 404 | 500
>;

export type CodespacesDeleteFromOrganizationHandler = (
  req: CodespacesDeleteFromOrganizationRequest,
  res: CodespacesDeleteFromOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesStopInOrganizationRequest = Request<
  CodespacesStopInOrganizationRequestPath,
  | CodespacesStopInOrganization200ResponseBody
  | CodespacesStopInOrganization401ResponseBody
  | CodespacesStopInOrganization403ResponseBody
  | CodespacesStopInOrganization404ResponseBody
  | CodespacesStopInOrganization500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesStopInOrganizationResponse = Response<
  | CodespacesStopInOrganization200ResponseBody
  | CodespacesStopInOrganization401ResponseBody
  | CodespacesStopInOrganization403ResponseBody
  | CodespacesStopInOrganization404ResponseBody
  | CodespacesStopInOrganization500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export type CodespacesStopInOrganizationHandler = (
  req: CodespacesStopInOrganizationRequest,
  res: CodespacesStopInOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsGetMembershipForUserRequest = Request<
  OrgsGetMembershipForUserRequestPath,
  | OrgsGetMembershipForUser200ResponseBody
  | OrgsGetMembershipForUser403ResponseBody
  | OrgsGetMembershipForUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetMembershipForUserResponse = Response<
  | OrgsGetMembershipForUser200ResponseBody
  | OrgsGetMembershipForUser403ResponseBody
  | OrgsGetMembershipForUser404ResponseBody,
  Record<string, any>,
  200 | 403 | 404
>;

export type OrgsGetMembershipForUserHandler = (
  req: OrgsGetMembershipForUserRequest,
  res: OrgsGetMembershipForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsSetMembershipForUserRequest = Request<
  OrgsSetMembershipForUserRequestPath,
  | OrgsSetMembershipForUser200ResponseBody
  | OrgsSetMembershipForUser403ResponseBody
  | OrgsSetMembershipForUser422ResponseBody,
  OrgsSetMembershipForUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsSetMembershipForUserResponse = Response<
  | OrgsSetMembershipForUser200ResponseBody
  | OrgsSetMembershipForUser403ResponseBody
  | OrgsSetMembershipForUser422ResponseBody,
  Record<string, any>,
  200 | 403 | 422
>;

export type OrgsSetMembershipForUserHandler = (
  req: OrgsSetMembershipForUserRequest,
  res: OrgsSetMembershipForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsRemoveMembershipForUserRequest = Request<
  OrgsRemoveMembershipForUserRequestPath,
  | OrgsRemoveMembershipForUser403ResponseBody
  | OrgsRemoveMembershipForUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsRemoveMembershipForUserResponse = Response<
  | OrgsRemoveMembershipForUser403ResponseBody
  | OrgsRemoveMembershipForUser404ResponseBody,
  Record<string, any>,
  204 | 403 | 404
>;

export type OrgsRemoveMembershipForUserHandler = (
  req: OrgsRemoveMembershipForUserRequest,
  res: OrgsRemoveMembershipForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsListForOrgRequest = Request<
  MigrationsListForOrgRequestPath,
  MigrationsListForOrg200ResponseBody,
  unknown,
  MigrationsListForOrgRequestQuery,
  Record<string, any>
>;

export type MigrationsListForOrgResponse = Response<
  MigrationsListForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type MigrationsListForOrgHandler = (
  req: MigrationsListForOrgRequest,
  res: MigrationsListForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsStartForOrgRequest = Request<
  MigrationsStartForOrgRequestPath,
  | MigrationsStartForOrg201ResponseBody
  | MigrationsStartForOrg404ResponseBody
  | MigrationsStartForOrg422ResponseBody,
  MigrationsStartForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsStartForOrgResponse = Response<
  | MigrationsStartForOrg201ResponseBody
  | MigrationsStartForOrg404ResponseBody
  | MigrationsStartForOrg422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export type MigrationsStartForOrgHandler = (
  req: MigrationsStartForOrgRequest,
  res: MigrationsStartForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsGetStatusForOrgRequest = Request<
  MigrationsGetStatusForOrgRequestPath,
  | MigrationsGetStatusForOrg200ResponseBody
  | MigrationsGetStatusForOrg404ResponseBody,
  unknown,
  MigrationsGetStatusForOrgRequestQuery,
  Record<string, any>
>;

export type MigrationsGetStatusForOrgResponse = Response<
  | MigrationsGetStatusForOrg200ResponseBody
  | MigrationsGetStatusForOrg404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type MigrationsGetStatusForOrgHandler = (
  req: MigrationsGetStatusForOrgRequest,
  res: MigrationsGetStatusForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsDownloadArchiveForOrgRequest = Request<
  MigrationsDownloadArchiveForOrgRequestPath,
  MigrationsDownloadArchiveForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsDownloadArchiveForOrgResponse = Response<
  MigrationsDownloadArchiveForOrg404ResponseBody,
  Record<string, any>,
  302 | 404
>;

export type MigrationsDownloadArchiveForOrgHandler = (
  req: MigrationsDownloadArchiveForOrgRequest,
  res: MigrationsDownloadArchiveForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsDeleteArchiveForOrgRequest = Request<
  MigrationsDeleteArchiveForOrgRequestPath,
  MigrationsDeleteArchiveForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsDeleteArchiveForOrgResponse = Response<
  MigrationsDeleteArchiveForOrg404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type MigrationsDeleteArchiveForOrgHandler = (
  req: MigrationsDeleteArchiveForOrgRequest,
  res: MigrationsDeleteArchiveForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsUnlockRepoForOrgRequest = Request<
  MigrationsUnlockRepoForOrgRequestPath,
  MigrationsUnlockRepoForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsUnlockRepoForOrgResponse = Response<
  MigrationsUnlockRepoForOrg404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type MigrationsUnlockRepoForOrgHandler = (
  req: MigrationsUnlockRepoForOrgRequest,
  res: MigrationsUnlockRepoForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsListReposForOrgRequest = Request<
  MigrationsListReposForOrgRequestPath,
  | MigrationsListReposForOrg200ResponseBody
  | MigrationsListReposForOrg404ResponseBody,
  unknown,
  MigrationsListReposForOrgRequestQuery,
  Record<string, any>
>;

export type MigrationsListReposForOrgResponse = Response<
  | MigrationsListReposForOrg200ResponseBody
  | MigrationsListReposForOrg404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type MigrationsListReposForOrgHandler = (
  req: MigrationsListReposForOrgRequest,
  res: MigrationsListReposForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListOutsideCollaboratorsRequest = Request<
  OrgsListOutsideCollaboratorsRequestPath,
  OrgsListOutsideCollaborators200ResponseBody,
  unknown,
  OrgsListOutsideCollaboratorsRequestQuery,
  Record<string, any>
>;

export type OrgsListOutsideCollaboratorsResponse = Response<
  OrgsListOutsideCollaborators200ResponseBody,
  Record<string, any>,
  200
>;

export type OrgsListOutsideCollaboratorsHandler = (
  req: OrgsListOutsideCollaboratorsRequest,
  res: OrgsListOutsideCollaboratorsResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsConvertMemberToOutsideCollaboratorRequest = Request<
  OrgsConvertMemberToOutsideCollaboratorRequestPath,
  | OrgsConvertMemberToOutsideCollaborator202ResponseBody
  | OrgsConvertMemberToOutsideCollaborator404ResponseBody,
  OrgsConvertMemberToOutsideCollaboratorRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsConvertMemberToOutsideCollaboratorResponse = Response<
  | OrgsConvertMemberToOutsideCollaborator202ResponseBody
  | OrgsConvertMemberToOutsideCollaborator404ResponseBody,
  Record<string, any>,
  202 | 204 | 403 | 404
>;

export type OrgsConvertMemberToOutsideCollaboratorHandler = (
  req: OrgsConvertMemberToOutsideCollaboratorRequest,
  res: OrgsConvertMemberToOutsideCollaboratorResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsRemoveOutsideCollaboratorRequest = Request<
  OrgsRemoveOutsideCollaboratorRequestPath,
  OrgsRemoveOutsideCollaborator422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsRemoveOutsideCollaboratorResponse = Response<
  OrgsRemoveOutsideCollaborator422ResponseBody,
  Record<string, any>,
  204 | 422
>;

export type OrgsRemoveOutsideCollaboratorHandler = (
  req: OrgsRemoveOutsideCollaboratorRequest,
  res: OrgsRemoveOutsideCollaboratorResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesListPackagesForOrganizationRequest = Request<
  PackagesListPackagesForOrganizationRequestPath,
  | PackagesListPackagesForOrganization200ResponseBody
  | PackagesListPackagesForOrganization401ResponseBody
  | PackagesListPackagesForOrganization403ResponseBody,
  unknown,
  PackagesListPackagesForOrganizationRequestQuery,
  Record<string, any>
>;

export type PackagesListPackagesForOrganizationResponse = Response<
  | PackagesListPackagesForOrganization200ResponseBody
  | PackagesListPackagesForOrganization401ResponseBody
  | PackagesListPackagesForOrganization403ResponseBody,
  Record<string, any>,
  200 | 401 | 403
>;

export type PackagesListPackagesForOrganizationHandler = (
  req: PackagesListPackagesForOrganizationRequest,
  res: PackagesListPackagesForOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesGetPackageForOrganizationRequest = Request<
  PackagesGetPackageForOrganizationRequestPath,
  PackagesGetPackageForOrganization200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetPackageForOrganizationResponse = Response<
  PackagesGetPackageForOrganization200ResponseBody,
  Record<string, any>,
  200
>;

export type PackagesGetPackageForOrganizationHandler = (
  req: PackagesGetPackageForOrganizationRequest,
  res: PackagesGetPackageForOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesDeletePackageForOrgRequest = Request<
  PackagesDeletePackageForOrgRequestPath,
  | PackagesDeletePackageForOrg401ResponseBody
  | PackagesDeletePackageForOrg403ResponseBody
  | PackagesDeletePackageForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesDeletePackageForOrgResponse = Response<
  | PackagesDeletePackageForOrg401ResponseBody
  | PackagesDeletePackageForOrg403ResponseBody
  | PackagesDeletePackageForOrg404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export type PackagesDeletePackageForOrgHandler = (
  req: PackagesDeletePackageForOrgRequest,
  res: PackagesDeletePackageForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesRestorePackageForOrgRequest = Request<
  PackagesRestorePackageForOrgRequestPath,
  | PackagesRestorePackageForOrg401ResponseBody
  | PackagesRestorePackageForOrg403ResponseBody
  | PackagesRestorePackageForOrg404ResponseBody,
  unknown,
  PackagesRestorePackageForOrgRequestQuery,
  Record<string, any>
>;

export type PackagesRestorePackageForOrgResponse = Response<
  | PackagesRestorePackageForOrg401ResponseBody
  | PackagesRestorePackageForOrg403ResponseBody
  | PackagesRestorePackageForOrg404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export type PackagesRestorePackageForOrgHandler = (
  req: PackagesRestorePackageForOrgRequest,
  res: PackagesRestorePackageForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesGetAllPackageVersionsForPackageOwnedByOrgRequest = Request<
  PackagesGetAllPackageVersionsForPackageOwnedByOrgRequestPath,
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg200ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg401ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg403ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg404ResponseBody,
  unknown,
  PackagesGetAllPackageVersionsForPackageOwnedByOrgRequestQuery,
  Record<string, any>
>;

export type PackagesGetAllPackageVersionsForPackageOwnedByOrgResponse = Response<
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg200ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg401ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg403ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg404ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404
>;

export type PackagesGetAllPackageVersionsForPackageOwnedByOrgHandler = (
  req: PackagesGetAllPackageVersionsForPackageOwnedByOrgRequest,
  res: PackagesGetAllPackageVersionsForPackageOwnedByOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesGetPackageVersionForOrganizationRequest = Request<
  PackagesGetPackageVersionForOrganizationRequestPath,
  PackagesGetPackageVersionForOrganization200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetPackageVersionForOrganizationResponse = Response<
  PackagesGetPackageVersionForOrganization200ResponseBody,
  Record<string, any>,
  200
>;

export type PackagesGetPackageVersionForOrganizationHandler = (
  req: PackagesGetPackageVersionForOrganizationRequest,
  res: PackagesGetPackageVersionForOrganizationResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesDeletePackageVersionForOrgRequest = Request<
  PackagesDeletePackageVersionForOrgRequestPath,
  | PackagesDeletePackageVersionForOrg401ResponseBody
  | PackagesDeletePackageVersionForOrg403ResponseBody
  | PackagesDeletePackageVersionForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesDeletePackageVersionForOrgResponse = Response<
  | PackagesDeletePackageVersionForOrg401ResponseBody
  | PackagesDeletePackageVersionForOrg403ResponseBody
  | PackagesDeletePackageVersionForOrg404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export type PackagesDeletePackageVersionForOrgHandler = (
  req: PackagesDeletePackageVersionForOrgRequest,
  res: PackagesDeletePackageVersionForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesRestorePackageVersionForOrgRequest = Request<
  PackagesRestorePackageVersionForOrgRequestPath,
  | PackagesRestorePackageVersionForOrg401ResponseBody
  | PackagesRestorePackageVersionForOrg403ResponseBody
  | PackagesRestorePackageVersionForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesRestorePackageVersionForOrgResponse = Response<
  | PackagesRestorePackageVersionForOrg401ResponseBody
  | PackagesRestorePackageVersionForOrg403ResponseBody
  | PackagesRestorePackageVersionForOrg404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export type PackagesRestorePackageVersionForOrgHandler = (
  req: PackagesRestorePackageVersionForOrgRequest,
  res: PackagesRestorePackageVersionForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsListForOrgRequest = Request<
  ProjectsListForOrgRequestPath,
  ProjectsListForOrg200ResponseBody | ProjectsListForOrg422ResponseBody,
  unknown,
  ProjectsListForOrgRequestQuery,
  Record<string, any>
>;

export type ProjectsListForOrgResponse = Response<
  ProjectsListForOrg200ResponseBody | ProjectsListForOrg422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ProjectsListForOrgHandler = (
  req: ProjectsListForOrgRequest,
  res: ProjectsListForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsCreateForOrgRequest = Request<
  ProjectsCreateForOrgRequestPath,
  | ProjectsCreateForOrg201ResponseBody
  | ProjectsCreateForOrg401ResponseBody
  | ProjectsCreateForOrg403ResponseBody
  | ProjectsCreateForOrg404ResponseBody
  | ProjectsCreateForOrg410ResponseBody
  | ProjectsCreateForOrg422ResponseBody,
  ProjectsCreateForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsCreateForOrgResponse = Response<
  | ProjectsCreateForOrg201ResponseBody
  | ProjectsCreateForOrg401ResponseBody
  | ProjectsCreateForOrg403ResponseBody
  | ProjectsCreateForOrg404ResponseBody
  | ProjectsCreateForOrg410ResponseBody
  | ProjectsCreateForOrg422ResponseBody,
  Record<string, any>,
  201 | 401 | 403 | 404 | 410 | 422
>;

export type ProjectsCreateForOrgHandler = (
  req: ProjectsCreateForOrgRequest,
  res: ProjectsCreateForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListPublicMembersRequest = Request<
  OrgsListPublicMembersRequestPath,
  OrgsListPublicMembers200ResponseBody,
  unknown,
  OrgsListPublicMembersRequestQuery,
  Record<string, any>
>;

export type OrgsListPublicMembersResponse = Response<
  OrgsListPublicMembers200ResponseBody,
  Record<string, any>,
  200
>;

export type OrgsListPublicMembersHandler = (
  req: OrgsListPublicMembersRequest,
  res: OrgsListPublicMembersResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsCheckPublicMembershipForUserRequest = Request<
  OrgsCheckPublicMembershipForUserRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCheckPublicMembershipForUserResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export type OrgsCheckPublicMembershipForUserHandler = (
  req: OrgsCheckPublicMembershipForUserRequest,
  res: OrgsCheckPublicMembershipForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsSetPublicMembershipForAuthenticatedUserRequest = Request<
  OrgsSetPublicMembershipForAuthenticatedUserRequestPath,
  OrgsSetPublicMembershipForAuthenticatedUser403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsSetPublicMembershipForAuthenticatedUserResponse = Response<
  OrgsSetPublicMembershipForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  204 | 403
>;

export type OrgsSetPublicMembershipForAuthenticatedUserHandler = (
  req: OrgsSetPublicMembershipForAuthenticatedUserRequest,
  res: OrgsSetPublicMembershipForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsRemovePublicMembershipForAuthenticatedUserRequest = Request<
  OrgsRemovePublicMembershipForAuthenticatedUserRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsRemovePublicMembershipForAuthenticatedUserResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type OrgsRemovePublicMembershipForAuthenticatedUserHandler = (
  req: OrgsRemovePublicMembershipForAuthenticatedUserRequest,
  res: OrgsRemovePublicMembershipForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListForOrgRequest = Request<
  ReposListForOrgRequestPath,
  ReposListForOrg200ResponseBody,
  unknown,
  ReposListForOrgRequestQuery,
  Record<string, any>
>;

export type ReposListForOrgResponse = Response<
  ReposListForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListForOrgHandler = (
  req: ReposListForOrgRequest,
  res: ReposListForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateInOrgRequest = Request<
  ReposCreateInOrgRequestPath,
  | ReposCreateInOrg201ResponseBody
  | ReposCreateInOrg403ResponseBody
  | ReposCreateInOrg422ResponseBody,
  ReposCreateInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateInOrgResponse = Response<
  | ReposCreateInOrg201ResponseBody
  | ReposCreateInOrg403ResponseBody
  | ReposCreateInOrg422ResponseBody,
  Record<string, any>,
  201 | 403 | 422
>;

export type ReposCreateInOrgHandler = (
  req: ReposCreateInOrgRequest,
  res: ReposCreateInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type SecretScanningListAlertsForOrgRequest = Request<
  SecretScanningListAlertsForOrgRequestPath,
  | SecretScanningListAlertsForOrg200ResponseBody
  | SecretScanningListAlertsForOrg404ResponseBody
  | SecretScanningListAlertsForOrg503ResponseBody,
  unknown,
  SecretScanningListAlertsForOrgRequestQuery,
  Record<string, any>
>;

export type SecretScanningListAlertsForOrgResponse = Response<
  | SecretScanningListAlertsForOrg200ResponseBody
  | SecretScanningListAlertsForOrg404ResponseBody
  | SecretScanningListAlertsForOrg503ResponseBody,
  Record<string, any>,
  200 | 404 | 503
>;

export type SecretScanningListAlertsForOrgHandler = (
  req: SecretScanningListAlertsForOrgRequest,
  res: SecretScanningListAlertsForOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListSecurityManagerTeamsRequest = Request<
  OrgsListSecurityManagerTeamsRequestPath,
  OrgsListSecurityManagerTeams200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsListSecurityManagerTeamsResponse = Response<
  OrgsListSecurityManagerTeams200ResponseBody,
  Record<string, any>,
  200
>;

export type OrgsListSecurityManagerTeamsHandler = (
  req: OrgsListSecurityManagerTeamsRequest,
  res: OrgsListSecurityManagerTeamsResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsAddSecurityManagerTeamRequest = Request<
  OrgsAddSecurityManagerTeamRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsAddSecurityManagerTeamResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export type OrgsAddSecurityManagerTeamHandler = (
  req: OrgsAddSecurityManagerTeamRequest,
  res: OrgsAddSecurityManagerTeamResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsRemoveSecurityManagerTeamRequest = Request<
  OrgsRemoveSecurityManagerTeamRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsRemoveSecurityManagerTeamResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type OrgsRemoveSecurityManagerTeamHandler = (
  req: OrgsRemoveSecurityManagerTeamRequest,
  res: OrgsRemoveSecurityManagerTeamResponse,
  next: NextFunction
) => Promise<void> | void;

export type BillingGetGithubActionsBillingOrgRequest = Request<
  BillingGetGithubActionsBillingOrgRequestPath,
  BillingGetGithubActionsBillingOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type BillingGetGithubActionsBillingOrgResponse = Response<
  BillingGetGithubActionsBillingOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type BillingGetGithubActionsBillingOrgHandler = (
  req: BillingGetGithubActionsBillingOrgRequest,
  res: BillingGetGithubActionsBillingOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type BillingGetGithubAdvancedSecurityBillingOrgRequest = Request<
  BillingGetGithubAdvancedSecurityBillingOrgRequestPath,
  | BillingGetGithubAdvancedSecurityBillingOrg200ResponseBody
  | BillingGetGithubAdvancedSecurityBillingOrg403ResponseBody,
  unknown,
  BillingGetGithubAdvancedSecurityBillingOrgRequestQuery,
  Record<string, any>
>;

export type BillingGetGithubAdvancedSecurityBillingOrgResponse = Response<
  | BillingGetGithubAdvancedSecurityBillingOrg200ResponseBody
  | BillingGetGithubAdvancedSecurityBillingOrg403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export type BillingGetGithubAdvancedSecurityBillingOrgHandler = (
  req: BillingGetGithubAdvancedSecurityBillingOrgRequest,
  res: BillingGetGithubAdvancedSecurityBillingOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type BillingGetGithubPackagesBillingOrgRequest = Request<
  BillingGetGithubPackagesBillingOrgRequestPath,
  BillingGetGithubPackagesBillingOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type BillingGetGithubPackagesBillingOrgResponse = Response<
  BillingGetGithubPackagesBillingOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type BillingGetGithubPackagesBillingOrgHandler = (
  req: BillingGetGithubPackagesBillingOrgRequest,
  res: BillingGetGithubPackagesBillingOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type BillingGetSharedStorageBillingOrgRequest = Request<
  BillingGetSharedStorageBillingOrgRequestPath,
  BillingGetSharedStorageBillingOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type BillingGetSharedStorageBillingOrgResponse = Response<
  BillingGetSharedStorageBillingOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type BillingGetSharedStorageBillingOrgHandler = (
  req: BillingGetSharedStorageBillingOrgRequest,
  res: BillingGetSharedStorageBillingOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListRequest = Request<
  TeamsListRequestPath,
  TeamsList200ResponseBody | TeamsList403ResponseBody,
  unknown,
  TeamsListRequestQuery,
  Record<string, any>
>;

export type TeamsListResponse = Response<
  TeamsList200ResponseBody | TeamsList403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export type TeamsListHandler = (
  req: TeamsListRequest,
  res: TeamsListResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsCreateRequest = Request<
  TeamsCreateRequestPath,
  | TeamsCreate201ResponseBody
  | TeamsCreate403ResponseBody
  | TeamsCreate422ResponseBody,
  TeamsCreateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCreateResponse = Response<
  | TeamsCreate201ResponseBody
  | TeamsCreate403ResponseBody
  | TeamsCreate422ResponseBody,
  Record<string, any>,
  201 | 403 | 422
>;

export type TeamsCreateHandler = (
  req: TeamsCreateRequest,
  res: TeamsCreateResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsGetByNameRequest = Request<
  TeamsGetByNameRequestPath,
  TeamsGetByName200ResponseBody | TeamsGetByName404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetByNameResponse = Response<
  TeamsGetByName200ResponseBody | TeamsGetByName404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type TeamsGetByNameHandler = (
  req: TeamsGetByNameRequest,
  res: TeamsGetByNameResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsUpdateInOrgRequest = Request<
  TeamsUpdateInOrgRequestPath,
  | TeamsUpdateInOrg200ResponseBody
  | TeamsUpdateInOrg201ResponseBody
  | TeamsUpdateInOrg403ResponseBody
  | TeamsUpdateInOrg404ResponseBody
  | TeamsUpdateInOrg422ResponseBody,
  TeamsUpdateInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsUpdateInOrgResponse = Response<
  | TeamsUpdateInOrg200ResponseBody
  | TeamsUpdateInOrg201ResponseBody
  | TeamsUpdateInOrg403ResponseBody
  | TeamsUpdateInOrg404ResponseBody
  | TeamsUpdateInOrg422ResponseBody,
  Record<string, any>,
  200 | 201 | 403 | 404 | 422
>;

export type TeamsUpdateInOrgHandler = (
  req: TeamsUpdateInOrgRequest,
  res: TeamsUpdateInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsDeleteInOrgRequest = Request<
  TeamsDeleteInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsDeleteInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type TeamsDeleteInOrgHandler = (
  req: TeamsDeleteInOrgRequest,
  res: TeamsDeleteInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListDiscussionsInOrgRequest = Request<
  TeamsListDiscussionsInOrgRequestPath,
  TeamsListDiscussionsInOrg200ResponseBody,
  unknown,
  TeamsListDiscussionsInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListDiscussionsInOrgResponse = Response<
  TeamsListDiscussionsInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsListDiscussionsInOrgHandler = (
  req: TeamsListDiscussionsInOrgRequest,
  res: TeamsListDiscussionsInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsCreateDiscussionInOrgRequest = Request<
  TeamsCreateDiscussionInOrgRequestPath,
  TeamsCreateDiscussionInOrg201ResponseBody,
  TeamsCreateDiscussionInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCreateDiscussionInOrgResponse = Response<
  TeamsCreateDiscussionInOrg201ResponseBody,
  Record<string, any>,
  201
>;

export type TeamsCreateDiscussionInOrgHandler = (
  req: TeamsCreateDiscussionInOrgRequest,
  res: TeamsCreateDiscussionInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsGetDiscussionInOrgRequest = Request<
  TeamsGetDiscussionInOrgRequestPath,
  TeamsGetDiscussionInOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetDiscussionInOrgResponse = Response<
  TeamsGetDiscussionInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsGetDiscussionInOrgHandler = (
  req: TeamsGetDiscussionInOrgRequest,
  res: TeamsGetDiscussionInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsUpdateDiscussionInOrgRequest = Request<
  TeamsUpdateDiscussionInOrgRequestPath,
  TeamsUpdateDiscussionInOrg200ResponseBody,
  TeamsUpdateDiscussionInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsUpdateDiscussionInOrgResponse = Response<
  TeamsUpdateDiscussionInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsUpdateDiscussionInOrgHandler = (
  req: TeamsUpdateDiscussionInOrgRequest,
  res: TeamsUpdateDiscussionInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsDeleteDiscussionInOrgRequest = Request<
  TeamsDeleteDiscussionInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsDeleteDiscussionInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type TeamsDeleteDiscussionInOrgHandler = (
  req: TeamsDeleteDiscussionInOrgRequest,
  res: TeamsDeleteDiscussionInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListDiscussionCommentsInOrgRequest = Request<
  TeamsListDiscussionCommentsInOrgRequestPath,
  TeamsListDiscussionCommentsInOrg200ResponseBody,
  unknown,
  TeamsListDiscussionCommentsInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListDiscussionCommentsInOrgResponse = Response<
  TeamsListDiscussionCommentsInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsListDiscussionCommentsInOrgHandler = (
  req: TeamsListDiscussionCommentsInOrgRequest,
  res: TeamsListDiscussionCommentsInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsCreateDiscussionCommentInOrgRequest = Request<
  TeamsCreateDiscussionCommentInOrgRequestPath,
  TeamsCreateDiscussionCommentInOrg201ResponseBody,
  TeamsCreateDiscussionCommentInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCreateDiscussionCommentInOrgResponse = Response<
  TeamsCreateDiscussionCommentInOrg201ResponseBody,
  Record<string, any>,
  201
>;

export type TeamsCreateDiscussionCommentInOrgHandler = (
  req: TeamsCreateDiscussionCommentInOrgRequest,
  res: TeamsCreateDiscussionCommentInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsGetDiscussionCommentInOrgRequest = Request<
  TeamsGetDiscussionCommentInOrgRequestPath,
  TeamsGetDiscussionCommentInOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetDiscussionCommentInOrgResponse = Response<
  TeamsGetDiscussionCommentInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsGetDiscussionCommentInOrgHandler = (
  req: TeamsGetDiscussionCommentInOrgRequest,
  res: TeamsGetDiscussionCommentInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsUpdateDiscussionCommentInOrgRequest = Request<
  TeamsUpdateDiscussionCommentInOrgRequestPath,
  TeamsUpdateDiscussionCommentInOrg200ResponseBody,
  TeamsUpdateDiscussionCommentInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsUpdateDiscussionCommentInOrgResponse = Response<
  TeamsUpdateDiscussionCommentInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsUpdateDiscussionCommentInOrgHandler = (
  req: TeamsUpdateDiscussionCommentInOrgRequest,
  res: TeamsUpdateDiscussionCommentInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsDeleteDiscussionCommentInOrgRequest = Request<
  TeamsDeleteDiscussionCommentInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsDeleteDiscussionCommentInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type TeamsDeleteDiscussionCommentInOrgHandler = (
  req: TeamsDeleteDiscussionCommentInOrgRequest,
  res: TeamsDeleteDiscussionCommentInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsListForTeamDiscussionCommentInOrgRequest = Request<
  ReactionsListForTeamDiscussionCommentInOrgRequestPath,
  ReactionsListForTeamDiscussionCommentInOrg200ResponseBody,
  unknown,
  ReactionsListForTeamDiscussionCommentInOrgRequestQuery,
  Record<string, any>
>;

export type ReactionsListForTeamDiscussionCommentInOrgResponse = Response<
  ReactionsListForTeamDiscussionCommentInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type ReactionsListForTeamDiscussionCommentInOrgHandler = (
  req: ReactionsListForTeamDiscussionCommentInOrgRequest,
  res: ReactionsListForTeamDiscussionCommentInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsCreateForTeamDiscussionCommentInOrgRequest = Request<
  ReactionsCreateForTeamDiscussionCommentInOrgRequestPath,
  | ReactionsCreateForTeamDiscussionCommentInOrg200ResponseBody
  | ReactionsCreateForTeamDiscussionCommentInOrg201ResponseBody,
  ReactionsCreateForTeamDiscussionCommentInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForTeamDiscussionCommentInOrgResponse = Response<
  | ReactionsCreateForTeamDiscussionCommentInOrg200ResponseBody
  | ReactionsCreateForTeamDiscussionCommentInOrg201ResponseBody,
  Record<string, any>,
  200 | 201
>;

export type ReactionsCreateForTeamDiscussionCommentInOrgHandler = (
  req: ReactionsCreateForTeamDiscussionCommentInOrgRequest,
  res: ReactionsCreateForTeamDiscussionCommentInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsDeleteForTeamDiscussionCommentRequest = Request<
  ReactionsDeleteForTeamDiscussionCommentRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForTeamDiscussionCommentResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReactionsDeleteForTeamDiscussionCommentHandler = (
  req: ReactionsDeleteForTeamDiscussionCommentRequest,
  res: ReactionsDeleteForTeamDiscussionCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsListForTeamDiscussionInOrgRequest = Request<
  ReactionsListForTeamDiscussionInOrgRequestPath,
  ReactionsListForTeamDiscussionInOrg200ResponseBody,
  unknown,
  ReactionsListForTeamDiscussionInOrgRequestQuery,
  Record<string, any>
>;

export type ReactionsListForTeamDiscussionInOrgResponse = Response<
  ReactionsListForTeamDiscussionInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type ReactionsListForTeamDiscussionInOrgHandler = (
  req: ReactionsListForTeamDiscussionInOrgRequest,
  res: ReactionsListForTeamDiscussionInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsCreateForTeamDiscussionInOrgRequest = Request<
  ReactionsCreateForTeamDiscussionInOrgRequestPath,
  | ReactionsCreateForTeamDiscussionInOrg200ResponseBody
  | ReactionsCreateForTeamDiscussionInOrg201ResponseBody,
  ReactionsCreateForTeamDiscussionInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForTeamDiscussionInOrgResponse = Response<
  | ReactionsCreateForTeamDiscussionInOrg200ResponseBody
  | ReactionsCreateForTeamDiscussionInOrg201ResponseBody,
  Record<string, any>,
  200 | 201
>;

export type ReactionsCreateForTeamDiscussionInOrgHandler = (
  req: ReactionsCreateForTeamDiscussionInOrgRequest,
  res: ReactionsCreateForTeamDiscussionInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsDeleteForTeamDiscussionRequest = Request<
  ReactionsDeleteForTeamDiscussionRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForTeamDiscussionResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReactionsDeleteForTeamDiscussionHandler = (
  req: ReactionsDeleteForTeamDiscussionRequest,
  res: ReactionsDeleteForTeamDiscussionResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListPendingInvitationsInOrgRequest = Request<
  TeamsListPendingInvitationsInOrgRequestPath,
  TeamsListPendingInvitationsInOrg200ResponseBody,
  unknown,
  TeamsListPendingInvitationsInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListPendingInvitationsInOrgResponse = Response<
  TeamsListPendingInvitationsInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsListPendingInvitationsInOrgHandler = (
  req: TeamsListPendingInvitationsInOrgRequest,
  res: TeamsListPendingInvitationsInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListMembersInOrgRequest = Request<
  TeamsListMembersInOrgRequestPath,
  TeamsListMembersInOrg200ResponseBody,
  unknown,
  TeamsListMembersInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListMembersInOrgResponse = Response<
  TeamsListMembersInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsListMembersInOrgHandler = (
  req: TeamsListMembersInOrgRequest,
  res: TeamsListMembersInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsGetMembershipForUserInOrgRequest = Request<
  TeamsGetMembershipForUserInOrgRequestPath,
  TeamsGetMembershipForUserInOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetMembershipForUserInOrgResponse = Response<
  TeamsGetMembershipForUserInOrg200ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type TeamsGetMembershipForUserInOrgHandler = (
  req: TeamsGetMembershipForUserInOrgRequest,
  res: TeamsGetMembershipForUserInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsAddOrUpdateMembershipForUserInOrgRequest = Request<
  TeamsAddOrUpdateMembershipForUserInOrgRequestPath,
  TeamsAddOrUpdateMembershipForUserInOrg200ResponseBody,
  TeamsAddOrUpdateMembershipForUserInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddOrUpdateMembershipForUserInOrgResponse = Response<
  TeamsAddOrUpdateMembershipForUserInOrg200ResponseBody,
  Record<string, any>,
  200 | 403 | 422
>;

export type TeamsAddOrUpdateMembershipForUserInOrgHandler = (
  req: TeamsAddOrUpdateMembershipForUserInOrgRequest,
  res: TeamsAddOrUpdateMembershipForUserInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsRemoveMembershipForUserInOrgRequest = Request<
  TeamsRemoveMembershipForUserInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveMembershipForUserInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204 | 403
>;

export type TeamsRemoveMembershipForUserInOrgHandler = (
  req: TeamsRemoveMembershipForUserInOrgRequest,
  res: TeamsRemoveMembershipForUserInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListProjectsInOrgRequest = Request<
  TeamsListProjectsInOrgRequestPath,
  TeamsListProjectsInOrg200ResponseBody,
  unknown,
  TeamsListProjectsInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListProjectsInOrgResponse = Response<
  TeamsListProjectsInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsListProjectsInOrgHandler = (
  req: TeamsListProjectsInOrgRequest,
  res: TeamsListProjectsInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsCheckPermissionsForProjectInOrgRequest = Request<
  TeamsCheckPermissionsForProjectInOrgRequestPath,
  TeamsCheckPermissionsForProjectInOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCheckPermissionsForProjectInOrgResponse = Response<
  TeamsCheckPermissionsForProjectInOrg200ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type TeamsCheckPermissionsForProjectInOrgHandler = (
  req: TeamsCheckPermissionsForProjectInOrgRequest,
  res: TeamsCheckPermissionsForProjectInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsAddOrUpdateProjectPermissionsInOrgRequest = Request<
  TeamsAddOrUpdateProjectPermissionsInOrgRequestPath,
  TeamsAddOrUpdateProjectPermissionsInOrg403ResponseBody,
  TeamsAddOrUpdateProjectPermissionsInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddOrUpdateProjectPermissionsInOrgResponse = Response<
  TeamsAddOrUpdateProjectPermissionsInOrg403ResponseBody,
  Record<string, any>,
  204 | 403
>;

export type TeamsAddOrUpdateProjectPermissionsInOrgHandler = (
  req: TeamsAddOrUpdateProjectPermissionsInOrgRequest,
  res: TeamsAddOrUpdateProjectPermissionsInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsRemoveProjectInOrgRequest = Request<
  TeamsRemoveProjectInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveProjectInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type TeamsRemoveProjectInOrgHandler = (
  req: TeamsRemoveProjectInOrgRequest,
  res: TeamsRemoveProjectInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListReposInOrgRequest = Request<
  TeamsListReposInOrgRequestPath,
  TeamsListReposInOrg200ResponseBody,
  unknown,
  TeamsListReposInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListReposInOrgResponse = Response<
  TeamsListReposInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsListReposInOrgHandler = (
  req: TeamsListReposInOrgRequest,
  res: TeamsListReposInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsCheckPermissionsForRepoInOrgRequest = Request<
  TeamsCheckPermissionsForRepoInOrgRequestPath,
  TeamsCheckPermissionsForRepoInOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCheckPermissionsForRepoInOrgResponse = Response<
  TeamsCheckPermissionsForRepoInOrg200ResponseBody,
  Record<string, any>,
  200 | 204 | 404
>;

export type TeamsCheckPermissionsForRepoInOrgHandler = (
  req: TeamsCheckPermissionsForRepoInOrgRequest,
  res: TeamsCheckPermissionsForRepoInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsAddOrUpdateRepoPermissionsInOrgRequest = Request<
  TeamsAddOrUpdateRepoPermissionsInOrgRequestPath,
  unknown,
  TeamsAddOrUpdateRepoPermissionsInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddOrUpdateRepoPermissionsInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type TeamsAddOrUpdateRepoPermissionsInOrgHandler = (
  req: TeamsAddOrUpdateRepoPermissionsInOrgRequest,
  res: TeamsAddOrUpdateRepoPermissionsInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsRemoveRepoInOrgRequest = Request<
  TeamsRemoveRepoInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveRepoInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type TeamsRemoveRepoInOrgHandler = (
  req: TeamsRemoveRepoInOrgRequest,
  res: TeamsRemoveRepoInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListChildInOrgRequest = Request<
  TeamsListChildInOrgRequestPath,
  TeamsListChildInOrg200ResponseBody,
  unknown,
  TeamsListChildInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListChildInOrgResponse = Response<
  TeamsListChildInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsListChildInOrgHandler = (
  req: TeamsListChildInOrgRequest,
  res: TeamsListChildInOrgResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsEnableOrDisableSecurityProductOnAllOrgReposRequest = Request<
  OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsEnableOrDisableSecurityProductOnAllOrgReposResponse = Response<
  unknown,
  Record<string, any>,
  204 | 422
>;

export type OrgsEnableOrDisableSecurityProductOnAllOrgReposHandler = (
  req: OrgsEnableOrDisableSecurityProductOnAllOrgReposRequest,
  res: OrgsEnableOrDisableSecurityProductOnAllOrgReposResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsGetCardRequest = Request<
  ProjectsGetCardRequestPath,
  | ProjectsGetCard200ResponseBody
  | ProjectsGetCard401ResponseBody
  | ProjectsGetCard403ResponseBody
  | ProjectsGetCard404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsGetCardResponse = Response<
  | ProjectsGetCard200ResponseBody
  | ProjectsGetCard401ResponseBody
  | ProjectsGetCard403ResponseBody
  | ProjectsGetCard404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export type ProjectsGetCardHandler = (
  req: ProjectsGetCardRequest,
  res: ProjectsGetCardResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsUpdateCardRequest = Request<
  ProjectsUpdateCardRequestPath,
  | ProjectsUpdateCard200ResponseBody
  | ProjectsUpdateCard401ResponseBody
  | ProjectsUpdateCard403ResponseBody
  | ProjectsUpdateCard404ResponseBody
  | ProjectsUpdateCard422ResponseBody,
  ProjectsUpdateCardRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsUpdateCardResponse = Response<
  | ProjectsUpdateCard200ResponseBody
  | ProjectsUpdateCard401ResponseBody
  | ProjectsUpdateCard403ResponseBody
  | ProjectsUpdateCard404ResponseBody
  | ProjectsUpdateCard422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 422
>;

export type ProjectsUpdateCardHandler = (
  req: ProjectsUpdateCardRequest,
  res: ProjectsUpdateCardResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsDeleteCardRequest = Request<
  ProjectsDeleteCardRequestPath,
  | ProjectsDeleteCard401ResponseBody
  | ProjectsDeleteCard403ResponseBody
  | ProjectsDeleteCard404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsDeleteCardResponse = Response<
  | ProjectsDeleteCard401ResponseBody
  | ProjectsDeleteCard403ResponseBody
  | ProjectsDeleteCard404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export type ProjectsDeleteCardHandler = (
  req: ProjectsDeleteCardRequest,
  res: ProjectsDeleteCardResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsMoveCardRequest = Request<
  ProjectsMoveCardRequestPath,
  | ProjectsMoveCard201ResponseBody
  | ProjectsMoveCard401ResponseBody
  | ProjectsMoveCard403ResponseBody
  | ProjectsMoveCard422ResponseBody
  | ProjectsMoveCard503ResponseBody,
  ProjectsMoveCardRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsMoveCardResponse = Response<
  | ProjectsMoveCard201ResponseBody
  | ProjectsMoveCard401ResponseBody
  | ProjectsMoveCard403ResponseBody
  | ProjectsMoveCard422ResponseBody
  | ProjectsMoveCard503ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 422 | 503
>;

export type ProjectsMoveCardHandler = (
  req: ProjectsMoveCardRequest,
  res: ProjectsMoveCardResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsGetColumnRequest = Request<
  ProjectsGetColumnRequestPath,
  | ProjectsGetColumn200ResponseBody
  | ProjectsGetColumn401ResponseBody
  | ProjectsGetColumn403ResponseBody
  | ProjectsGetColumn404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsGetColumnResponse = Response<
  | ProjectsGetColumn200ResponseBody
  | ProjectsGetColumn401ResponseBody
  | ProjectsGetColumn403ResponseBody
  | ProjectsGetColumn404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export type ProjectsGetColumnHandler = (
  req: ProjectsGetColumnRequest,
  res: ProjectsGetColumnResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsUpdateColumnRequest = Request<
  ProjectsUpdateColumnRequestPath,
  | ProjectsUpdateColumn200ResponseBody
  | ProjectsUpdateColumn401ResponseBody
  | ProjectsUpdateColumn403ResponseBody,
  ProjectsUpdateColumnRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsUpdateColumnResponse = Response<
  | ProjectsUpdateColumn200ResponseBody
  | ProjectsUpdateColumn401ResponseBody
  | ProjectsUpdateColumn403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type ProjectsUpdateColumnHandler = (
  req: ProjectsUpdateColumnRequest,
  res: ProjectsUpdateColumnResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsDeleteColumnRequest = Request<
  ProjectsDeleteColumnRequestPath,
  ProjectsDeleteColumn401ResponseBody | ProjectsDeleteColumn403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsDeleteColumnResponse = Response<
  ProjectsDeleteColumn401ResponseBody | ProjectsDeleteColumn403ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403
>;

export type ProjectsDeleteColumnHandler = (
  req: ProjectsDeleteColumnRequest,
  res: ProjectsDeleteColumnResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsListCardsRequest = Request<
  ProjectsListCardsRequestPath,
  | ProjectsListCards200ResponseBody
  | ProjectsListCards401ResponseBody
  | ProjectsListCards403ResponseBody,
  unknown,
  ProjectsListCardsRequestQuery,
  Record<string, any>
>;

export type ProjectsListCardsResponse = Response<
  | ProjectsListCards200ResponseBody
  | ProjectsListCards401ResponseBody
  | ProjectsListCards403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type ProjectsListCardsHandler = (
  req: ProjectsListCardsRequest,
  res: ProjectsListCardsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsCreateCardRequest = Request<
  ProjectsCreateCardRequestPath,
  | ProjectsCreateCard201ResponseBody
  | ProjectsCreateCard401ResponseBody
  | ProjectsCreateCard403ResponseBody
  | ProjectsCreateCard422ResponseBody
  | ProjectsCreateCard503ResponseBody,
  ProjectsCreateCardRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsCreateCardResponse = Response<
  | ProjectsCreateCard201ResponseBody
  | ProjectsCreateCard401ResponseBody
  | ProjectsCreateCard403ResponseBody
  | ProjectsCreateCard422ResponseBody
  | ProjectsCreateCard503ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 422 | 503
>;

export type ProjectsCreateCardHandler = (
  req: ProjectsCreateCardRequest,
  res: ProjectsCreateCardResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsMoveColumnRequest = Request<
  ProjectsMoveColumnRequestPath,
  | ProjectsMoveColumn201ResponseBody
  | ProjectsMoveColumn401ResponseBody
  | ProjectsMoveColumn403ResponseBody
  | ProjectsMoveColumn422ResponseBody,
  ProjectsMoveColumnRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsMoveColumnResponse = Response<
  | ProjectsMoveColumn201ResponseBody
  | ProjectsMoveColumn401ResponseBody
  | ProjectsMoveColumn403ResponseBody
  | ProjectsMoveColumn422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 422
>;

export type ProjectsMoveColumnHandler = (
  req: ProjectsMoveColumnRequest,
  res: ProjectsMoveColumnResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsGetRequest = Request<
  ProjectsGetRequestPath,
  | ProjectsGet200ResponseBody
  | ProjectsGet401ResponseBody
  | ProjectsGet403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsGetResponse = Response<
  | ProjectsGet200ResponseBody
  | ProjectsGet401ResponseBody
  | ProjectsGet403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type ProjectsGetHandler = (
  req: ProjectsGetRequest,
  res: ProjectsGetResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsUpdateRequest = Request<
  ProjectsUpdateRequestPath,
  | ProjectsUpdate200ResponseBody
  | ProjectsUpdate401ResponseBody
  | ProjectsUpdate403ResponseBody
  | ProjectsUpdate410ResponseBody
  | ProjectsUpdate422ResponseBody,
  ProjectsUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsUpdateResponse = Response<
  | ProjectsUpdate200ResponseBody
  | ProjectsUpdate401ResponseBody
  | ProjectsUpdate403ResponseBody
  | ProjectsUpdate410ResponseBody
  | ProjectsUpdate422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 410 | 422
>;

export type ProjectsUpdateHandler = (
  req: ProjectsUpdateRequest,
  res: ProjectsUpdateResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsDeleteRequest = Request<
  ProjectsDeleteRequestPath,
  | ProjectsDelete401ResponseBody
  | ProjectsDelete403ResponseBody
  | ProjectsDelete404ResponseBody
  | ProjectsDelete410ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsDeleteResponse = Response<
  | ProjectsDelete401ResponseBody
  | ProjectsDelete403ResponseBody
  | ProjectsDelete404ResponseBody
  | ProjectsDelete410ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404 | 410
>;

export type ProjectsDeleteHandler = (
  req: ProjectsDeleteRequest,
  res: ProjectsDeleteResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsListCollaboratorsRequest = Request<
  ProjectsListCollaboratorsRequestPath,
  | ProjectsListCollaborators200ResponseBody
  | ProjectsListCollaborators401ResponseBody
  | ProjectsListCollaborators403ResponseBody
  | ProjectsListCollaborators404ResponseBody
  | ProjectsListCollaborators422ResponseBody,
  unknown,
  ProjectsListCollaboratorsRequestQuery,
  Record<string, any>
>;

export type ProjectsListCollaboratorsResponse = Response<
  | ProjectsListCollaborators200ResponseBody
  | ProjectsListCollaborators401ResponseBody
  | ProjectsListCollaborators403ResponseBody
  | ProjectsListCollaborators404ResponseBody
  | ProjectsListCollaborators422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 422
>;

export type ProjectsListCollaboratorsHandler = (
  req: ProjectsListCollaboratorsRequest,
  res: ProjectsListCollaboratorsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsAddCollaboratorRequest = Request<
  ProjectsAddCollaboratorRequestPath,
  | ProjectsAddCollaborator401ResponseBody
  | ProjectsAddCollaborator403ResponseBody
  | ProjectsAddCollaborator404ResponseBody
  | ProjectsAddCollaborator422ResponseBody,
  ProjectsAddCollaboratorRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsAddCollaboratorResponse = Response<
  | ProjectsAddCollaborator401ResponseBody
  | ProjectsAddCollaborator403ResponseBody
  | ProjectsAddCollaborator404ResponseBody
  | ProjectsAddCollaborator422ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404 | 422
>;

export type ProjectsAddCollaboratorHandler = (
  req: ProjectsAddCollaboratorRequest,
  res: ProjectsAddCollaboratorResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsRemoveCollaboratorRequest = Request<
  ProjectsRemoveCollaboratorRequestPath,
  | ProjectsRemoveCollaborator401ResponseBody
  | ProjectsRemoveCollaborator403ResponseBody
  | ProjectsRemoveCollaborator404ResponseBody
  | ProjectsRemoveCollaborator422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsRemoveCollaboratorResponse = Response<
  | ProjectsRemoveCollaborator401ResponseBody
  | ProjectsRemoveCollaborator403ResponseBody
  | ProjectsRemoveCollaborator404ResponseBody
  | ProjectsRemoveCollaborator422ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404 | 422
>;

export type ProjectsRemoveCollaboratorHandler = (
  req: ProjectsRemoveCollaboratorRequest,
  res: ProjectsRemoveCollaboratorResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsGetPermissionForUserRequest = Request<
  ProjectsGetPermissionForUserRequestPath,
  | ProjectsGetPermissionForUser200ResponseBody
  | ProjectsGetPermissionForUser401ResponseBody
  | ProjectsGetPermissionForUser403ResponseBody
  | ProjectsGetPermissionForUser404ResponseBody
  | ProjectsGetPermissionForUser422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsGetPermissionForUserResponse = Response<
  | ProjectsGetPermissionForUser200ResponseBody
  | ProjectsGetPermissionForUser401ResponseBody
  | ProjectsGetPermissionForUser403ResponseBody
  | ProjectsGetPermissionForUser404ResponseBody
  | ProjectsGetPermissionForUser422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 422
>;

export type ProjectsGetPermissionForUserHandler = (
  req: ProjectsGetPermissionForUserRequest,
  res: ProjectsGetPermissionForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsListColumnsRequest = Request<
  ProjectsListColumnsRequestPath,
  | ProjectsListColumns200ResponseBody
  | ProjectsListColumns401ResponseBody
  | ProjectsListColumns403ResponseBody,
  unknown,
  ProjectsListColumnsRequestQuery,
  Record<string, any>
>;

export type ProjectsListColumnsResponse = Response<
  | ProjectsListColumns200ResponseBody
  | ProjectsListColumns401ResponseBody
  | ProjectsListColumns403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type ProjectsListColumnsHandler = (
  req: ProjectsListColumnsRequest,
  res: ProjectsListColumnsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsCreateColumnRequest = Request<
  ProjectsCreateColumnRequestPath,
  | ProjectsCreateColumn201ResponseBody
  | ProjectsCreateColumn401ResponseBody
  | ProjectsCreateColumn403ResponseBody
  | ProjectsCreateColumn422ResponseBody,
  ProjectsCreateColumnRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsCreateColumnResponse = Response<
  | ProjectsCreateColumn201ResponseBody
  | ProjectsCreateColumn401ResponseBody
  | ProjectsCreateColumn403ResponseBody
  | ProjectsCreateColumn422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 422
>;

export type ProjectsCreateColumnHandler = (
  req: ProjectsCreateColumnRequest,
  res: ProjectsCreateColumnResponse,
  next: NextFunction
) => Promise<void> | void;

export type RateLimitGetRequest = Request<
  ParamsDictionary,
  RateLimitGet200ResponseBody | RateLimitGet404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type RateLimitGetResponse = Response<
  RateLimitGet200ResponseBody | RateLimitGet404ResponseBody,
  Record<string, any>,
  200 | 304 | 404
>;

export type RateLimitGetHandler = (
  req: RateLimitGetRequest,
  res: RateLimitGetResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetRequest = Request<
  ReposGetRequestPath,
  | ReposGet200ResponseBody
  | ReposGet301ResponseBody
  | ReposGet403ResponseBody
  | ReposGet404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetResponse = Response<
  | ReposGet200ResponseBody
  | ReposGet301ResponseBody
  | ReposGet403ResponseBody
  | ReposGet404ResponseBody,
  Record<string, any>,
  200 | 301 | 403 | 404
>;

export type ReposGetHandler = (
  req: ReposGetRequest,
  res: ReposGetResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposUpdateRequest = Request<
  ReposUpdateRequestPath,
  | ReposUpdate200ResponseBody
  | ReposUpdate307ResponseBody
  | ReposUpdate403ResponseBody
  | ReposUpdate404ResponseBody
  | ReposUpdate422ResponseBody,
  ReposUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateResponse = Response<
  | ReposUpdate200ResponseBody
  | ReposUpdate307ResponseBody
  | ReposUpdate403ResponseBody
  | ReposUpdate404ResponseBody
  | ReposUpdate422ResponseBody,
  Record<string, any>,
  200 | 307 | 403 | 404 | 422
>;

export type ReposUpdateHandler = (
  req: ReposUpdateRequest,
  res: ReposUpdateResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteRequest = Request<
  ReposDeleteRequestPath,
  | ReposDelete307ResponseBody
  | ReposDelete403ResponseBody
  | ReposDelete404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteResponse = Response<
  | ReposDelete307ResponseBody
  | ReposDelete403ResponseBody
  | ReposDelete404ResponseBody,
  Record<string, any>,
  204 | 307 | 403 | 404
>;

export type ReposDeleteHandler = (
  req: ReposDeleteRequest,
  res: ReposDeleteResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListArtifactsForRepoRequest = Request<
  ActionsListArtifactsForRepoRequestPath,
  ActionsListArtifactsForRepo200ResponseBody,
  unknown,
  ActionsListArtifactsForRepoRequestQuery,
  Record<string, any>
>;

export type ActionsListArtifactsForRepoResponse = Response<
  ActionsListArtifactsForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListArtifactsForRepoHandler = (
  req: ActionsListArtifactsForRepoRequest,
  res: ActionsListArtifactsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetArtifactRequest = Request<
  ActionsGetArtifactRequestPath,
  ActionsGetArtifact200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetArtifactResponse = Response<
  ActionsGetArtifact200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetArtifactHandler = (
  req: ActionsGetArtifactRequest,
  res: ActionsGetArtifactResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDeleteArtifactRequest = Request<
  ActionsDeleteArtifactRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteArtifactResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsDeleteArtifactHandler = (
  req: ActionsDeleteArtifactRequest,
  res: ActionsDeleteArtifactResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDownloadArtifactRequest = Request<
  ActionsDownloadArtifactRequestPath,
  ActionsDownloadArtifact410ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDownloadArtifactResponse = Response<
  ActionsDownloadArtifact410ResponseBody,
  Record<string, any>,
  302 | 410
>;

export type ActionsDownloadArtifactHandler = (
  req: ActionsDownloadArtifactRequest,
  res: ActionsDownloadArtifactResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetActionsCacheUsageRequest = Request<
  ActionsGetActionsCacheUsageRequestPath,
  ActionsGetActionsCacheUsage200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetActionsCacheUsageResponse = Response<
  ActionsGetActionsCacheUsage200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetActionsCacheUsageHandler = (
  req: ActionsGetActionsCacheUsageRequest,
  res: ActionsGetActionsCacheUsageResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetActionsCacheListRequest = Request<
  ActionsGetActionsCacheListRequestPath,
  ActionsGetActionsCacheList200ResponseBody,
  unknown,
  ActionsGetActionsCacheListRequestQuery,
  Record<string, any>
>;

export type ActionsGetActionsCacheListResponse = Response<
  ActionsGetActionsCacheList200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetActionsCacheListHandler = (
  req: ActionsGetActionsCacheListRequest,
  res: ActionsGetActionsCacheListResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDeleteActionsCacheByKeyRequest = Request<
  ActionsDeleteActionsCacheByKeyRequestPath,
  ActionsDeleteActionsCacheByKey200ResponseBody,
  unknown,
  ActionsDeleteActionsCacheByKeyRequestQuery,
  Record<string, any>
>;

export type ActionsDeleteActionsCacheByKeyResponse = Response<
  ActionsDeleteActionsCacheByKey200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsDeleteActionsCacheByKeyHandler = (
  req: ActionsDeleteActionsCacheByKeyRequest,
  res: ActionsDeleteActionsCacheByKeyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDeleteActionsCacheByIdRequest = Request<
  ActionsDeleteActionsCacheByIdRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteActionsCacheByIdResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsDeleteActionsCacheByIdHandler = (
  req: ActionsDeleteActionsCacheByIdRequest,
  res: ActionsDeleteActionsCacheByIdResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetJobForWorkflowRunRequest = Request<
  ActionsGetJobForWorkflowRunRequestPath,
  ActionsGetJobForWorkflowRun200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetJobForWorkflowRunResponse = Response<
  ActionsGetJobForWorkflowRun200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetJobForWorkflowRunHandler = (
  req: ActionsGetJobForWorkflowRunRequest,
  res: ActionsGetJobForWorkflowRunResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDownloadJobLogsForWorkflowRunRequest = Request<
  ActionsDownloadJobLogsForWorkflowRunRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDownloadJobLogsForWorkflowRunResponse = Response<
  unknown,
  Record<string, any>,
  302
>;

export type ActionsDownloadJobLogsForWorkflowRunHandler = (
  req: ActionsDownloadJobLogsForWorkflowRunRequest,
  res: ActionsDownloadJobLogsForWorkflowRunResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsReRunJobForWorkflowRunRequest = Request<
  ActionsReRunJobForWorkflowRunRequestPath,
  | ActionsReRunJobForWorkflowRun201ResponseBody
  | ActionsReRunJobForWorkflowRun403ResponseBody,
  ActionsReRunJobForWorkflowRunRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsReRunJobForWorkflowRunResponse = Response<
  | ActionsReRunJobForWorkflowRun201ResponseBody
  | ActionsReRunJobForWorkflowRun403ResponseBody,
  Record<string, any>,
  201 | 403
>;

export type ActionsReRunJobForWorkflowRunHandler = (
  req: ActionsReRunJobForWorkflowRunRequest,
  res: ActionsReRunJobForWorkflowRunResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetGithubActionsPermissionsRepositoryRequest = Request<
  ActionsGetGithubActionsPermissionsRepositoryRequestPath,
  ActionsGetGithubActionsPermissionsRepository200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetGithubActionsPermissionsRepositoryResponse = Response<
  ActionsGetGithubActionsPermissionsRepository200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetGithubActionsPermissionsRepositoryHandler = (
  req: ActionsGetGithubActionsPermissionsRepositoryRequest,
  res: ActionsGetGithubActionsPermissionsRepositoryResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetGithubActionsPermissionsRepositoryRequest = Request<
  ActionsSetGithubActionsPermissionsRepositoryRequestPath,
  unknown,
  ActionsSetGithubActionsPermissionsRepositoryRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetGithubActionsPermissionsRepositoryResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsSetGithubActionsPermissionsRepositoryHandler = (
  req: ActionsSetGithubActionsPermissionsRepositoryRequest,
  res: ActionsSetGithubActionsPermissionsRepositoryResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetWorkflowAccessToRepositoryRequest = Request<
  ActionsGetWorkflowAccessToRepositoryRequestPath,
  ActionsGetWorkflowAccessToRepository200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetWorkflowAccessToRepositoryResponse = Response<
  ActionsGetWorkflowAccessToRepository200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetWorkflowAccessToRepositoryHandler = (
  req: ActionsGetWorkflowAccessToRepositoryRequest,
  res: ActionsGetWorkflowAccessToRepositoryResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetWorkflowAccessToRepositoryRequest = Request<
  ActionsSetWorkflowAccessToRepositoryRequestPath,
  unknown,
  ActionsSetWorkflowAccessToRepositoryRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetWorkflowAccessToRepositoryResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsSetWorkflowAccessToRepositoryHandler = (
  req: ActionsSetWorkflowAccessToRepositoryRequest,
  res: ActionsSetWorkflowAccessToRepositoryResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetAllowedActionsRepositoryRequest = Request<
  ActionsGetAllowedActionsRepositoryRequestPath,
  ActionsGetAllowedActionsRepository200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetAllowedActionsRepositoryResponse = Response<
  ActionsGetAllowedActionsRepository200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetAllowedActionsRepositoryHandler = (
  req: ActionsGetAllowedActionsRepositoryRequest,
  res: ActionsGetAllowedActionsRepositoryResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetAllowedActionsRepositoryRequest = Request<
  ActionsSetAllowedActionsRepositoryRequestPath,
  unknown,
  ActionsSetAllowedActionsRepositoryRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetAllowedActionsRepositoryResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsSetAllowedActionsRepositoryHandler = (
  req: ActionsSetAllowedActionsRepositoryRequest,
  res: ActionsSetAllowedActionsRepositoryResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest = Request<
  ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequestPath,
  ActionsGetGithubActionsDefaultWorkflowPermissionsRepository200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse = Response<
  ActionsGetGithubActionsDefaultWorkflowPermissionsRepository200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryHandler = (
  req: ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest,
  res: ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest = Request<
  ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequestPath,
  unknown,
  ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryHandler = (
  req: ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest,
  res: ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListSelfHostedRunnersForRepoRequest = Request<
  ActionsListSelfHostedRunnersForRepoRequestPath,
  ActionsListSelfHostedRunnersForRepo200ResponseBody,
  unknown,
  ActionsListSelfHostedRunnersForRepoRequestQuery,
  Record<string, any>
>;

export type ActionsListSelfHostedRunnersForRepoResponse = Response<
  ActionsListSelfHostedRunnersForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListSelfHostedRunnersForRepoHandler = (
  req: ActionsListSelfHostedRunnersForRepoRequest,
  res: ActionsListSelfHostedRunnersForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListRunnerApplicationsForRepoRequest = Request<
  ActionsListRunnerApplicationsForRepoRequestPath,
  ActionsListRunnerApplicationsForRepo200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsListRunnerApplicationsForRepoResponse = Response<
  ActionsListRunnerApplicationsForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListRunnerApplicationsForRepoHandler = (
  req: ActionsListRunnerApplicationsForRepoRequest,
  res: ActionsListRunnerApplicationsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsCreateRegistrationTokenForRepoRequest = Request<
  ActionsCreateRegistrationTokenForRepoRequestPath,
  ActionsCreateRegistrationTokenForRepo201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateRegistrationTokenForRepoResponse = Response<
  ActionsCreateRegistrationTokenForRepo201ResponseBody,
  Record<string, any>,
  201
>;

export type ActionsCreateRegistrationTokenForRepoHandler = (
  req: ActionsCreateRegistrationTokenForRepoRequest,
  res: ActionsCreateRegistrationTokenForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsCreateRemoveTokenForRepoRequest = Request<
  ActionsCreateRemoveTokenForRepoRequestPath,
  ActionsCreateRemoveTokenForRepo201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateRemoveTokenForRepoResponse = Response<
  ActionsCreateRemoveTokenForRepo201ResponseBody,
  Record<string, any>,
  201
>;

export type ActionsCreateRemoveTokenForRepoHandler = (
  req: ActionsCreateRemoveTokenForRepoRequest,
  res: ActionsCreateRemoveTokenForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetSelfHostedRunnerForRepoRequest = Request<
  ActionsGetSelfHostedRunnerForRepoRequestPath,
  ActionsGetSelfHostedRunnerForRepo200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetSelfHostedRunnerForRepoResponse = Response<
  ActionsGetSelfHostedRunnerForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetSelfHostedRunnerForRepoHandler = (
  req: ActionsGetSelfHostedRunnerForRepoRequest,
  res: ActionsGetSelfHostedRunnerForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDeleteSelfHostedRunnerFromRepoRequest = Request<
  ActionsDeleteSelfHostedRunnerFromRepoRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteSelfHostedRunnerFromRepoResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsDeleteSelfHostedRunnerFromRepoHandler = (
  req: ActionsDeleteSelfHostedRunnerFromRepoRequest,
  res: ActionsDeleteSelfHostedRunnerFromRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListLabelsForSelfHostedRunnerForRepoRequest = Request<
  ActionsListLabelsForSelfHostedRunnerForRepoRequestPath,
  | ActionsListLabelsForSelfHostedRunnerForRepo200ResponseBody
  | ActionsListLabelsForSelfHostedRunnerForRepo404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsListLabelsForSelfHostedRunnerForRepoResponse = Response<
  | ActionsListLabelsForSelfHostedRunnerForRepo200ResponseBody
  | ActionsListLabelsForSelfHostedRunnerForRepo404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ActionsListLabelsForSelfHostedRunnerForRepoHandler = (
  req: ActionsListLabelsForSelfHostedRunnerForRepoRequest,
  res: ActionsListLabelsForSelfHostedRunnerForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest = Request<
  ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestPath,
  | ActionsAddCustomLabelsToSelfHostedRunnerForRepo200ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForRepo404ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForRepo422ResponseBody,
  ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse = Response<
  | ActionsAddCustomLabelsToSelfHostedRunnerForRepo200ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForRepo404ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForRepo422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoHandler = (
  req: ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest,
  res: ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest = Request<
  ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestPath,
  | ActionsSetCustomLabelsForSelfHostedRunnerForRepo200ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForRepo404ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForRepo422ResponseBody,
  ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse = Response<
  | ActionsSetCustomLabelsForSelfHostedRunnerForRepo200ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForRepo404ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForRepo422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoHandler = (
  req: ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest,
  res: ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest = Request<
  ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequestPath,
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo200ResponseBody
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse = Response<
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo200ResponseBody
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoHandler = (
  req: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest,
  res: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest = Request<
  ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequestPath,
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo200ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo404ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse = Response<
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo200ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo404ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoHandler = (
  req: ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest,
  res: ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListWorkflowRunsForRepoRequest = Request<
  ActionsListWorkflowRunsForRepoRequestPath,
  ActionsListWorkflowRunsForRepo200ResponseBody,
  unknown,
  ActionsListWorkflowRunsForRepoRequestQuery,
  Record<string, any>
>;

export type ActionsListWorkflowRunsForRepoResponse = Response<
  ActionsListWorkflowRunsForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListWorkflowRunsForRepoHandler = (
  req: ActionsListWorkflowRunsForRepoRequest,
  res: ActionsListWorkflowRunsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetWorkflowRunRequest = Request<
  ActionsGetWorkflowRunRequestPath,
  ActionsGetWorkflowRun200ResponseBody,
  unknown,
  ActionsGetWorkflowRunRequestQuery,
  Record<string, any>
>;

export type ActionsGetWorkflowRunResponse = Response<
  ActionsGetWorkflowRun200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetWorkflowRunHandler = (
  req: ActionsGetWorkflowRunRequest,
  res: ActionsGetWorkflowRunResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDeleteWorkflowRunRequest = Request<
  ActionsDeleteWorkflowRunRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteWorkflowRunResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsDeleteWorkflowRunHandler = (
  req: ActionsDeleteWorkflowRunRequest,
  res: ActionsDeleteWorkflowRunResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetReviewsForRunRequest = Request<
  ActionsGetReviewsForRunRequestPath,
  ActionsGetReviewsForRun200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetReviewsForRunResponse = Response<
  ActionsGetReviewsForRun200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetReviewsForRunHandler = (
  req: ActionsGetReviewsForRunRequest,
  res: ActionsGetReviewsForRunResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsApproveWorkflowRunRequest = Request<
  ActionsApproveWorkflowRunRequestPath,
  | ActionsApproveWorkflowRun201ResponseBody
  | ActionsApproveWorkflowRun403ResponseBody
  | ActionsApproveWorkflowRun404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsApproveWorkflowRunResponse = Response<
  | ActionsApproveWorkflowRun201ResponseBody
  | ActionsApproveWorkflowRun403ResponseBody
  | ActionsApproveWorkflowRun404ResponseBody,
  Record<string, any>,
  201 | 403 | 404
>;

export type ActionsApproveWorkflowRunHandler = (
  req: ActionsApproveWorkflowRunRequest,
  res: ActionsApproveWorkflowRunResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListWorkflowRunArtifactsRequest = Request<
  ActionsListWorkflowRunArtifactsRequestPath,
  ActionsListWorkflowRunArtifacts200ResponseBody,
  unknown,
  ActionsListWorkflowRunArtifactsRequestQuery,
  Record<string, any>
>;

export type ActionsListWorkflowRunArtifactsResponse = Response<
  ActionsListWorkflowRunArtifacts200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListWorkflowRunArtifactsHandler = (
  req: ActionsListWorkflowRunArtifactsRequest,
  res: ActionsListWorkflowRunArtifactsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetWorkflowRunAttemptRequest = Request<
  ActionsGetWorkflowRunAttemptRequestPath,
  ActionsGetWorkflowRunAttempt200ResponseBody,
  unknown,
  ActionsGetWorkflowRunAttemptRequestQuery,
  Record<string, any>
>;

export type ActionsGetWorkflowRunAttemptResponse = Response<
  ActionsGetWorkflowRunAttempt200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetWorkflowRunAttemptHandler = (
  req: ActionsGetWorkflowRunAttemptRequest,
  res: ActionsGetWorkflowRunAttemptResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListJobsForWorkflowRunAttemptRequest = Request<
  ActionsListJobsForWorkflowRunAttemptRequestPath,
  | ActionsListJobsForWorkflowRunAttempt200ResponseBody
  | ActionsListJobsForWorkflowRunAttempt404ResponseBody,
  unknown,
  ActionsListJobsForWorkflowRunAttemptRequestQuery,
  Record<string, any>
>;

export type ActionsListJobsForWorkflowRunAttemptResponse = Response<
  | ActionsListJobsForWorkflowRunAttempt200ResponseBody
  | ActionsListJobsForWorkflowRunAttempt404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ActionsListJobsForWorkflowRunAttemptHandler = (
  req: ActionsListJobsForWorkflowRunAttemptRequest,
  res: ActionsListJobsForWorkflowRunAttemptResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDownloadWorkflowRunAttemptLogsRequest = Request<
  ActionsDownloadWorkflowRunAttemptLogsRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDownloadWorkflowRunAttemptLogsResponse = Response<
  unknown,
  Record<string, any>,
  302
>;

export type ActionsDownloadWorkflowRunAttemptLogsHandler = (
  req: ActionsDownloadWorkflowRunAttemptLogsRequest,
  res: ActionsDownloadWorkflowRunAttemptLogsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsCancelWorkflowRunRequest = Request<
  ActionsCancelWorkflowRunRequestPath,
  | ActionsCancelWorkflowRun202ResponseBody
  | ActionsCancelWorkflowRun409ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCancelWorkflowRunResponse = Response<
  | ActionsCancelWorkflowRun202ResponseBody
  | ActionsCancelWorkflowRun409ResponseBody,
  Record<string, any>,
  202 | 409
>;

export type ActionsCancelWorkflowRunHandler = (
  req: ActionsCancelWorkflowRunRequest,
  res: ActionsCancelWorkflowRunResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListJobsForWorkflowRunRequest = Request<
  ActionsListJobsForWorkflowRunRequestPath,
  ActionsListJobsForWorkflowRun200ResponseBody,
  unknown,
  ActionsListJobsForWorkflowRunRequestQuery,
  Record<string, any>
>;

export type ActionsListJobsForWorkflowRunResponse = Response<
  ActionsListJobsForWorkflowRun200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListJobsForWorkflowRunHandler = (
  req: ActionsListJobsForWorkflowRunRequest,
  res: ActionsListJobsForWorkflowRunResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDownloadWorkflowRunLogsRequest = Request<
  ActionsDownloadWorkflowRunLogsRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDownloadWorkflowRunLogsResponse = Response<
  unknown,
  Record<string, any>,
  302
>;

export type ActionsDownloadWorkflowRunLogsHandler = (
  req: ActionsDownloadWorkflowRunLogsRequest,
  res: ActionsDownloadWorkflowRunLogsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDeleteWorkflowRunLogsRequest = Request<
  ActionsDeleteWorkflowRunLogsRequestPath,
  | ActionsDeleteWorkflowRunLogs403ResponseBody
  | ActionsDeleteWorkflowRunLogs500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteWorkflowRunLogsResponse = Response<
  | ActionsDeleteWorkflowRunLogs403ResponseBody
  | ActionsDeleteWorkflowRunLogs500ResponseBody,
  Record<string, any>,
  204 | 403 | 500
>;

export type ActionsDeleteWorkflowRunLogsHandler = (
  req: ActionsDeleteWorkflowRunLogsRequest,
  res: ActionsDeleteWorkflowRunLogsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetPendingDeploymentsForRunRequest = Request<
  ActionsGetPendingDeploymentsForRunRequestPath,
  ActionsGetPendingDeploymentsForRun200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetPendingDeploymentsForRunResponse = Response<
  ActionsGetPendingDeploymentsForRun200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetPendingDeploymentsForRunHandler = (
  req: ActionsGetPendingDeploymentsForRunRequest,
  res: ActionsGetPendingDeploymentsForRunResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsReviewPendingDeploymentsForRunRequest = Request<
  ActionsReviewPendingDeploymentsForRunRequestPath,
  ActionsReviewPendingDeploymentsForRun200ResponseBody,
  ActionsReviewPendingDeploymentsForRunRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsReviewPendingDeploymentsForRunResponse = Response<
  ActionsReviewPendingDeploymentsForRun200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsReviewPendingDeploymentsForRunHandler = (
  req: ActionsReviewPendingDeploymentsForRunRequest,
  res: ActionsReviewPendingDeploymentsForRunResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsReRunWorkflowRequest = Request<
  ActionsReRunWorkflowRequestPath,
  ActionsReRunWorkflow201ResponseBody,
  ActionsReRunWorkflowRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsReRunWorkflowResponse = Response<
  ActionsReRunWorkflow201ResponseBody,
  Record<string, any>,
  201
>;

export type ActionsReRunWorkflowHandler = (
  req: ActionsReRunWorkflowRequest,
  res: ActionsReRunWorkflowResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsReRunWorkflowFailedJobsRequest = Request<
  ActionsReRunWorkflowFailedJobsRequestPath,
  ActionsReRunWorkflowFailedJobs201ResponseBody,
  ActionsReRunWorkflowFailedJobsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsReRunWorkflowFailedJobsResponse = Response<
  ActionsReRunWorkflowFailedJobs201ResponseBody,
  Record<string, any>,
  201
>;

export type ActionsReRunWorkflowFailedJobsHandler = (
  req: ActionsReRunWorkflowFailedJobsRequest,
  res: ActionsReRunWorkflowFailedJobsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetWorkflowRunUsageRequest = Request<
  ActionsGetWorkflowRunUsageRequestPath,
  ActionsGetWorkflowRunUsage200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetWorkflowRunUsageResponse = Response<
  ActionsGetWorkflowRunUsage200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetWorkflowRunUsageHandler = (
  req: ActionsGetWorkflowRunUsageRequest,
  res: ActionsGetWorkflowRunUsageResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListRepoSecretsRequest = Request<
  ActionsListRepoSecretsRequestPath,
  ActionsListRepoSecrets200ResponseBody,
  unknown,
  ActionsListRepoSecretsRequestQuery,
  Record<string, any>
>;

export type ActionsListRepoSecretsResponse = Response<
  ActionsListRepoSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListRepoSecretsHandler = (
  req: ActionsListRepoSecretsRequest,
  res: ActionsListRepoSecretsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetRepoPublicKeyRequest = Request<
  ActionsGetRepoPublicKeyRequestPath,
  ActionsGetRepoPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetRepoPublicKeyResponse = Response<
  ActionsGetRepoPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetRepoPublicKeyHandler = (
  req: ActionsGetRepoPublicKeyRequest,
  res: ActionsGetRepoPublicKeyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetRepoSecretRequest = Request<
  ActionsGetRepoSecretRequestPath,
  ActionsGetRepoSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetRepoSecretResponse = Response<
  ActionsGetRepoSecret200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetRepoSecretHandler = (
  req: ActionsGetRepoSecretRequest,
  res: ActionsGetRepoSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsCreateOrUpdateRepoSecretRequest = Request<
  ActionsCreateOrUpdateRepoSecretRequestPath,
  ActionsCreateOrUpdateRepoSecret201ResponseBody,
  ActionsCreateOrUpdateRepoSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateOrUpdateRepoSecretResponse = Response<
  ActionsCreateOrUpdateRepoSecret201ResponseBody,
  Record<string, any>,
  201 | 204
>;

export type ActionsCreateOrUpdateRepoSecretHandler = (
  req: ActionsCreateOrUpdateRepoSecretRequest,
  res: ActionsCreateOrUpdateRepoSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDeleteRepoSecretRequest = Request<
  ActionsDeleteRepoSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteRepoSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsDeleteRepoSecretHandler = (
  req: ActionsDeleteRepoSecretRequest,
  res: ActionsDeleteRepoSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListRepoWorkflowsRequest = Request<
  ActionsListRepoWorkflowsRequestPath,
  ActionsListRepoWorkflows200ResponseBody,
  unknown,
  ActionsListRepoWorkflowsRequestQuery,
  Record<string, any>
>;

export type ActionsListRepoWorkflowsResponse = Response<
  ActionsListRepoWorkflows200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListRepoWorkflowsHandler = (
  req: ActionsListRepoWorkflowsRequest,
  res: ActionsListRepoWorkflowsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetWorkflowRequest = Request<
  ActionsGetWorkflowRequestPath,
  ActionsGetWorkflow200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetWorkflowResponse = Response<
  ActionsGetWorkflow200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetWorkflowHandler = (
  req: ActionsGetWorkflowRequest,
  res: ActionsGetWorkflowResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDisableWorkflowRequest = Request<
  ActionsDisableWorkflowRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDisableWorkflowResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsDisableWorkflowHandler = (
  req: ActionsDisableWorkflowRequest,
  res: ActionsDisableWorkflowResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsCreateWorkflowDispatchRequest = Request<
  ActionsCreateWorkflowDispatchRequestPath,
  unknown,
  ActionsCreateWorkflowDispatchRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateWorkflowDispatchResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsCreateWorkflowDispatchHandler = (
  req: ActionsCreateWorkflowDispatchRequest,
  res: ActionsCreateWorkflowDispatchResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsEnableWorkflowRequest = Request<
  ActionsEnableWorkflowRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsEnableWorkflowResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsEnableWorkflowHandler = (
  req: ActionsEnableWorkflowRequest,
  res: ActionsEnableWorkflowResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListWorkflowRunsRequest = Request<
  ActionsListWorkflowRunsRequestPath,
  ActionsListWorkflowRuns200ResponseBody,
  unknown,
  ActionsListWorkflowRunsRequestQuery,
  Record<string, any>
>;

export type ActionsListWorkflowRunsResponse = Response<
  ActionsListWorkflowRuns200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListWorkflowRunsHandler = (
  req: ActionsListWorkflowRunsRequest,
  res: ActionsListWorkflowRunsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetWorkflowUsageRequest = Request<
  ActionsGetWorkflowUsageRequestPath,
  ActionsGetWorkflowUsage200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetWorkflowUsageResponse = Response<
  ActionsGetWorkflowUsage200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetWorkflowUsageHandler = (
  req: ActionsGetWorkflowUsageRequest,
  res: ActionsGetWorkflowUsageResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListAssigneesRequest = Request<
  IssuesListAssigneesRequestPath,
  IssuesListAssignees200ResponseBody | IssuesListAssignees404ResponseBody,
  unknown,
  IssuesListAssigneesRequestQuery,
  Record<string, any>
>;

export type IssuesListAssigneesResponse = Response<
  IssuesListAssignees200ResponseBody | IssuesListAssignees404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type IssuesListAssigneesHandler = (
  req: IssuesListAssigneesRequest,
  res: IssuesListAssigneesResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesCheckUserCanBeAssignedRequest = Request<
  IssuesCheckUserCanBeAssignedRequestPath,
  IssuesCheckUserCanBeAssigned404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesCheckUserCanBeAssignedResponse = Response<
  IssuesCheckUserCanBeAssigned404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type IssuesCheckUserCanBeAssignedHandler = (
  req: IssuesCheckUserCanBeAssignedRequest,
  res: IssuesCheckUserCanBeAssignedResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListAutolinksRequest = Request<
  ReposListAutolinksRequestPath,
  ReposListAutolinks200ResponseBody,
  unknown,
  ReposListAutolinksRequestQuery,
  Record<string, any>
>;

export type ReposListAutolinksResponse = Response<
  ReposListAutolinks200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListAutolinksHandler = (
  req: ReposListAutolinksRequest,
  res: ReposListAutolinksResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateAutolinkRequest = Request<
  ReposCreateAutolinkRequestPath,
  ReposCreateAutolink201ResponseBody | ReposCreateAutolink422ResponseBody,
  ReposCreateAutolinkRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateAutolinkResponse = Response<
  ReposCreateAutolink201ResponseBody | ReposCreateAutolink422ResponseBody,
  Record<string, any>,
  201 | 422
>;

export type ReposCreateAutolinkHandler = (
  req: ReposCreateAutolinkRequest,
  res: ReposCreateAutolinkResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetAutolinkRequest = Request<
  ReposGetAutolinkRequestPath,
  ReposGetAutolink200ResponseBody | ReposGetAutolink404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetAutolinkResponse = Response<
  ReposGetAutolink200ResponseBody | ReposGetAutolink404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetAutolinkHandler = (
  req: ReposGetAutolinkRequest,
  res: ReposGetAutolinkResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteAutolinkRequest = Request<
  ReposDeleteAutolinkRequestPath,
  ReposDeleteAutolink404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteAutolinkResponse = Response<
  ReposDeleteAutolink404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type ReposDeleteAutolinkHandler = (
  req: ReposDeleteAutolinkRequest,
  res: ReposDeleteAutolinkResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposEnableAutomatedSecurityFixesRequest = Request<
  ReposEnableAutomatedSecurityFixesRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposEnableAutomatedSecurityFixesResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposEnableAutomatedSecurityFixesHandler = (
  req: ReposEnableAutomatedSecurityFixesRequest,
  res: ReposEnableAutomatedSecurityFixesResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDisableAutomatedSecurityFixesRequest = Request<
  ReposDisableAutomatedSecurityFixesRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDisableAutomatedSecurityFixesResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposDisableAutomatedSecurityFixesHandler = (
  req: ReposDisableAutomatedSecurityFixesRequest,
  res: ReposDisableAutomatedSecurityFixesResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListBranchesRequest = Request<
  ReposListBranchesRequestPath,
  ReposListBranches200ResponseBody | ReposListBranches404ResponseBody,
  unknown,
  ReposListBranchesRequestQuery,
  Record<string, any>
>;

export type ReposListBranchesResponse = Response<
  ReposListBranches200ResponseBody | ReposListBranches404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposListBranchesHandler = (
  req: ReposListBranchesRequest,
  res: ReposListBranchesResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetBranchRequest = Request<
  ReposGetBranchRequestPath,
  | ReposGetBranch200ResponseBody
  | ReposGetBranch301ResponseBody
  | ReposGetBranch404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetBranchResponse = Response<
  | ReposGetBranch200ResponseBody
  | ReposGetBranch301ResponseBody
  | ReposGetBranch404ResponseBody,
  Record<string, any>,
  200 | 301 | 404
>;

export type ReposGetBranchHandler = (
  req: ReposGetBranchRequest,
  res: ReposGetBranchResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetBranchProtectionRequest = Request<
  ReposGetBranchProtectionRequestPath,
  | ReposGetBranchProtection200ResponseBody
  | ReposGetBranchProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetBranchProtectionResponse = Response<
  | ReposGetBranchProtection200ResponseBody
  | ReposGetBranchProtection404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetBranchProtectionHandler = (
  req: ReposGetBranchProtectionRequest,
  res: ReposGetBranchProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposUpdateBranchProtectionRequest = Request<
  ReposUpdateBranchProtectionRequestPath,
  | ReposUpdateBranchProtection200ResponseBody
  | ReposUpdateBranchProtection403ResponseBody
  | ReposUpdateBranchProtection404ResponseBody
  | ReposUpdateBranchProtection422ResponseBody,
  ReposUpdateBranchProtectionRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateBranchProtectionResponse = Response<
  | ReposUpdateBranchProtection200ResponseBody
  | ReposUpdateBranchProtection403ResponseBody
  | ReposUpdateBranchProtection404ResponseBody
  | ReposUpdateBranchProtection422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export type ReposUpdateBranchProtectionHandler = (
  req: ReposUpdateBranchProtectionRequest,
  res: ReposUpdateBranchProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteBranchProtectionRequest = Request<
  ReposDeleteBranchProtectionRequestPath,
  ReposDeleteBranchProtection403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteBranchProtectionResponse = Response<
  ReposDeleteBranchProtection403ResponseBody,
  Record<string, any>,
  204 | 403
>;

export type ReposDeleteBranchProtectionHandler = (
  req: ReposDeleteBranchProtectionRequest,
  res: ReposDeleteBranchProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetAdminBranchProtectionRequest = Request<
  ReposGetAdminBranchProtectionRequestPath,
  ReposGetAdminBranchProtection200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetAdminBranchProtectionResponse = Response<
  ReposGetAdminBranchProtection200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposGetAdminBranchProtectionHandler = (
  req: ReposGetAdminBranchProtectionRequest,
  res: ReposGetAdminBranchProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposSetAdminBranchProtectionRequest = Request<
  ReposSetAdminBranchProtectionRequestPath,
  ReposSetAdminBranchProtection200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposSetAdminBranchProtectionResponse = Response<
  ReposSetAdminBranchProtection200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposSetAdminBranchProtectionHandler = (
  req: ReposSetAdminBranchProtectionRequest,
  res: ReposSetAdminBranchProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteAdminBranchProtectionRequest = Request<
  ReposDeleteAdminBranchProtectionRequestPath,
  ReposDeleteAdminBranchProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteAdminBranchProtectionResponse = Response<
  ReposDeleteAdminBranchProtection404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type ReposDeleteAdminBranchProtectionHandler = (
  req: ReposDeleteAdminBranchProtectionRequest,
  res: ReposDeleteAdminBranchProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetPullRequestReviewProtectionRequest = Request<
  ReposGetPullRequestReviewProtectionRequestPath,
  ReposGetPullRequestReviewProtection200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetPullRequestReviewProtectionResponse = Response<
  ReposGetPullRequestReviewProtection200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposGetPullRequestReviewProtectionHandler = (
  req: ReposGetPullRequestReviewProtectionRequest,
  res: ReposGetPullRequestReviewProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposUpdatePullRequestReviewProtectionRequest = Request<
  ReposUpdatePullRequestReviewProtectionRequestPath,
  | ReposUpdatePullRequestReviewProtection200ResponseBody
  | ReposUpdatePullRequestReviewProtection422ResponseBody,
  ReposUpdatePullRequestReviewProtectionRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdatePullRequestReviewProtectionResponse = Response<
  | ReposUpdatePullRequestReviewProtection200ResponseBody
  | ReposUpdatePullRequestReviewProtection422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ReposUpdatePullRequestReviewProtectionHandler = (
  req: ReposUpdatePullRequestReviewProtectionRequest,
  res: ReposUpdatePullRequestReviewProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeletePullRequestReviewProtectionRequest = Request<
  ReposDeletePullRequestReviewProtectionRequestPath,
  ReposDeletePullRequestReviewProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeletePullRequestReviewProtectionResponse = Response<
  ReposDeletePullRequestReviewProtection404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type ReposDeletePullRequestReviewProtectionHandler = (
  req: ReposDeletePullRequestReviewProtectionRequest,
  res: ReposDeletePullRequestReviewProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetCommitSignatureProtectionRequest = Request<
  ReposGetCommitSignatureProtectionRequestPath,
  | ReposGetCommitSignatureProtection200ResponseBody
  | ReposGetCommitSignatureProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetCommitSignatureProtectionResponse = Response<
  | ReposGetCommitSignatureProtection200ResponseBody
  | ReposGetCommitSignatureProtection404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetCommitSignatureProtectionHandler = (
  req: ReposGetCommitSignatureProtectionRequest,
  res: ReposGetCommitSignatureProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateCommitSignatureProtectionRequest = Request<
  ReposCreateCommitSignatureProtectionRequestPath,
  | ReposCreateCommitSignatureProtection200ResponseBody
  | ReposCreateCommitSignatureProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateCommitSignatureProtectionResponse = Response<
  | ReposCreateCommitSignatureProtection200ResponseBody
  | ReposCreateCommitSignatureProtection404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposCreateCommitSignatureProtectionHandler = (
  req: ReposCreateCommitSignatureProtectionRequest,
  res: ReposCreateCommitSignatureProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteCommitSignatureProtectionRequest = Request<
  ReposDeleteCommitSignatureProtectionRequestPath,
  ReposDeleteCommitSignatureProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteCommitSignatureProtectionResponse = Response<
  ReposDeleteCommitSignatureProtection404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type ReposDeleteCommitSignatureProtectionHandler = (
  req: ReposDeleteCommitSignatureProtectionRequest,
  res: ReposDeleteCommitSignatureProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetStatusChecksProtectionRequest = Request<
  ReposGetStatusChecksProtectionRequestPath,
  | ReposGetStatusChecksProtection200ResponseBody
  | ReposGetStatusChecksProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetStatusChecksProtectionResponse = Response<
  | ReposGetStatusChecksProtection200ResponseBody
  | ReposGetStatusChecksProtection404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetStatusChecksProtectionHandler = (
  req: ReposGetStatusChecksProtectionRequest,
  res: ReposGetStatusChecksProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposUpdateStatusCheckProtectionRequest = Request<
  ReposUpdateStatusCheckProtectionRequestPath,
  | ReposUpdateStatusCheckProtection200ResponseBody
  | ReposUpdateStatusCheckProtection404ResponseBody
  | ReposUpdateStatusCheckProtection422ResponseBody,
  ReposUpdateStatusCheckProtectionRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateStatusCheckProtectionResponse = Response<
  | ReposUpdateStatusCheckProtection200ResponseBody
  | ReposUpdateStatusCheckProtection404ResponseBody
  | ReposUpdateStatusCheckProtection422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type ReposUpdateStatusCheckProtectionHandler = (
  req: ReposUpdateStatusCheckProtectionRequest,
  res: ReposUpdateStatusCheckProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposRemoveStatusCheckProtectionRequest = Request<
  ReposRemoveStatusCheckProtectionRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposRemoveStatusCheckProtectionResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposRemoveStatusCheckProtectionHandler = (
  req: ReposRemoveStatusCheckProtectionRequest,
  res: ReposRemoveStatusCheckProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetAllStatusCheckContextsRequest = Request<
  ReposGetAllStatusCheckContextsRequestPath,
  | ReposGetAllStatusCheckContexts200ResponseBody
  | ReposGetAllStatusCheckContexts404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetAllStatusCheckContextsResponse = Response<
  | ReposGetAllStatusCheckContexts200ResponseBody
  | ReposGetAllStatusCheckContexts404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetAllStatusCheckContextsHandler = (
  req: ReposGetAllStatusCheckContextsRequest,
  res: ReposGetAllStatusCheckContextsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposAddStatusCheckContextsRequest = Request<
  ReposAddStatusCheckContextsRequestPath,
  | ReposAddStatusCheckContexts200ResponseBody
  | ReposAddStatusCheckContexts403ResponseBody
  | ReposAddStatusCheckContexts404ResponseBody
  | ReposAddStatusCheckContexts422ResponseBody,
  ReposAddStatusCheckContextsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposAddStatusCheckContextsResponse = Response<
  | ReposAddStatusCheckContexts200ResponseBody
  | ReposAddStatusCheckContexts403ResponseBody
  | ReposAddStatusCheckContexts404ResponseBody
  | ReposAddStatusCheckContexts422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export type ReposAddStatusCheckContextsHandler = (
  req: ReposAddStatusCheckContextsRequest,
  res: ReposAddStatusCheckContextsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposSetStatusCheckContextsRequest = Request<
  ReposSetStatusCheckContextsRequestPath,
  | ReposSetStatusCheckContexts200ResponseBody
  | ReposSetStatusCheckContexts404ResponseBody
  | ReposSetStatusCheckContexts422ResponseBody,
  ReposSetStatusCheckContextsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposSetStatusCheckContextsResponse = Response<
  | ReposSetStatusCheckContexts200ResponseBody
  | ReposSetStatusCheckContexts404ResponseBody
  | ReposSetStatusCheckContexts422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type ReposSetStatusCheckContextsHandler = (
  req: ReposSetStatusCheckContextsRequest,
  res: ReposSetStatusCheckContextsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposRemoveStatusCheckContextsRequest = Request<
  ReposRemoveStatusCheckContextsRequestPath,
  | ReposRemoveStatusCheckContexts200ResponseBody
  | ReposRemoveStatusCheckContexts404ResponseBody
  | ReposRemoveStatusCheckContexts422ResponseBody,
  ReposRemoveStatusCheckContextsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposRemoveStatusCheckContextsResponse = Response<
  | ReposRemoveStatusCheckContexts200ResponseBody
  | ReposRemoveStatusCheckContexts404ResponseBody
  | ReposRemoveStatusCheckContexts422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type ReposRemoveStatusCheckContextsHandler = (
  req: ReposRemoveStatusCheckContextsRequest,
  res: ReposRemoveStatusCheckContextsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetAccessRestrictionsRequest = Request<
  ReposGetAccessRestrictionsRequestPath,
  | ReposGetAccessRestrictions200ResponseBody
  | ReposGetAccessRestrictions404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetAccessRestrictionsResponse = Response<
  | ReposGetAccessRestrictions200ResponseBody
  | ReposGetAccessRestrictions404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetAccessRestrictionsHandler = (
  req: ReposGetAccessRestrictionsRequest,
  res: ReposGetAccessRestrictionsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteAccessRestrictionsRequest = Request<
  ReposDeleteAccessRestrictionsRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteAccessRestrictionsResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposDeleteAccessRestrictionsHandler = (
  req: ReposDeleteAccessRestrictionsRequest,
  res: ReposDeleteAccessRestrictionsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetAppsWithAccessToProtectedBranchRequest = Request<
  ReposGetAppsWithAccessToProtectedBranchRequestPath,
  | ReposGetAppsWithAccessToProtectedBranch200ResponseBody
  | ReposGetAppsWithAccessToProtectedBranch404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetAppsWithAccessToProtectedBranchResponse = Response<
  | ReposGetAppsWithAccessToProtectedBranch200ResponseBody
  | ReposGetAppsWithAccessToProtectedBranch404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetAppsWithAccessToProtectedBranchHandler = (
  req: ReposGetAppsWithAccessToProtectedBranchRequest,
  res: ReposGetAppsWithAccessToProtectedBranchResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposAddAppAccessRestrictionsRequest = Request<
  ReposAddAppAccessRestrictionsRequestPath,
  | ReposAddAppAccessRestrictions200ResponseBody
  | ReposAddAppAccessRestrictions422ResponseBody,
  ReposAddAppAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposAddAppAccessRestrictionsResponse = Response<
  | ReposAddAppAccessRestrictions200ResponseBody
  | ReposAddAppAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ReposAddAppAccessRestrictionsHandler = (
  req: ReposAddAppAccessRestrictionsRequest,
  res: ReposAddAppAccessRestrictionsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposSetAppAccessRestrictionsRequest = Request<
  ReposSetAppAccessRestrictionsRequestPath,
  | ReposSetAppAccessRestrictions200ResponseBody
  | ReposSetAppAccessRestrictions422ResponseBody,
  ReposSetAppAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposSetAppAccessRestrictionsResponse = Response<
  | ReposSetAppAccessRestrictions200ResponseBody
  | ReposSetAppAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ReposSetAppAccessRestrictionsHandler = (
  req: ReposSetAppAccessRestrictionsRequest,
  res: ReposSetAppAccessRestrictionsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposRemoveAppAccessRestrictionsRequest = Request<
  ReposRemoveAppAccessRestrictionsRequestPath,
  | ReposRemoveAppAccessRestrictions200ResponseBody
  | ReposRemoveAppAccessRestrictions422ResponseBody,
  ReposRemoveAppAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposRemoveAppAccessRestrictionsResponse = Response<
  | ReposRemoveAppAccessRestrictions200ResponseBody
  | ReposRemoveAppAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ReposRemoveAppAccessRestrictionsHandler = (
  req: ReposRemoveAppAccessRestrictionsRequest,
  res: ReposRemoveAppAccessRestrictionsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetTeamsWithAccessToProtectedBranchRequest = Request<
  ReposGetTeamsWithAccessToProtectedBranchRequestPath,
  | ReposGetTeamsWithAccessToProtectedBranch200ResponseBody
  | ReposGetTeamsWithAccessToProtectedBranch404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetTeamsWithAccessToProtectedBranchResponse = Response<
  | ReposGetTeamsWithAccessToProtectedBranch200ResponseBody
  | ReposGetTeamsWithAccessToProtectedBranch404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetTeamsWithAccessToProtectedBranchHandler = (
  req: ReposGetTeamsWithAccessToProtectedBranchRequest,
  res: ReposGetTeamsWithAccessToProtectedBranchResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposAddTeamAccessRestrictionsRequest = Request<
  ReposAddTeamAccessRestrictionsRequestPath,
  | ReposAddTeamAccessRestrictions200ResponseBody
  | ReposAddTeamAccessRestrictions422ResponseBody,
  ReposAddTeamAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposAddTeamAccessRestrictionsResponse = Response<
  | ReposAddTeamAccessRestrictions200ResponseBody
  | ReposAddTeamAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ReposAddTeamAccessRestrictionsHandler = (
  req: ReposAddTeamAccessRestrictionsRequest,
  res: ReposAddTeamAccessRestrictionsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposSetTeamAccessRestrictionsRequest = Request<
  ReposSetTeamAccessRestrictionsRequestPath,
  | ReposSetTeamAccessRestrictions200ResponseBody
  | ReposSetTeamAccessRestrictions422ResponseBody,
  ReposSetTeamAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposSetTeamAccessRestrictionsResponse = Response<
  | ReposSetTeamAccessRestrictions200ResponseBody
  | ReposSetTeamAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ReposSetTeamAccessRestrictionsHandler = (
  req: ReposSetTeamAccessRestrictionsRequest,
  res: ReposSetTeamAccessRestrictionsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposRemoveTeamAccessRestrictionsRequest = Request<
  ReposRemoveTeamAccessRestrictionsRequestPath,
  | ReposRemoveTeamAccessRestrictions200ResponseBody
  | ReposRemoveTeamAccessRestrictions422ResponseBody,
  ReposRemoveTeamAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposRemoveTeamAccessRestrictionsResponse = Response<
  | ReposRemoveTeamAccessRestrictions200ResponseBody
  | ReposRemoveTeamAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ReposRemoveTeamAccessRestrictionsHandler = (
  req: ReposRemoveTeamAccessRestrictionsRequest,
  res: ReposRemoveTeamAccessRestrictionsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetUsersWithAccessToProtectedBranchRequest = Request<
  ReposGetUsersWithAccessToProtectedBranchRequestPath,
  | ReposGetUsersWithAccessToProtectedBranch200ResponseBody
  | ReposGetUsersWithAccessToProtectedBranch404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetUsersWithAccessToProtectedBranchResponse = Response<
  | ReposGetUsersWithAccessToProtectedBranch200ResponseBody
  | ReposGetUsersWithAccessToProtectedBranch404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetUsersWithAccessToProtectedBranchHandler = (
  req: ReposGetUsersWithAccessToProtectedBranchRequest,
  res: ReposGetUsersWithAccessToProtectedBranchResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposAddUserAccessRestrictionsRequest = Request<
  ReposAddUserAccessRestrictionsRequestPath,
  | ReposAddUserAccessRestrictions200ResponseBody
  | ReposAddUserAccessRestrictions422ResponseBody,
  ReposAddUserAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposAddUserAccessRestrictionsResponse = Response<
  | ReposAddUserAccessRestrictions200ResponseBody
  | ReposAddUserAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ReposAddUserAccessRestrictionsHandler = (
  req: ReposAddUserAccessRestrictionsRequest,
  res: ReposAddUserAccessRestrictionsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposSetUserAccessRestrictionsRequest = Request<
  ReposSetUserAccessRestrictionsRequestPath,
  | ReposSetUserAccessRestrictions200ResponseBody
  | ReposSetUserAccessRestrictions422ResponseBody,
  ReposSetUserAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposSetUserAccessRestrictionsResponse = Response<
  | ReposSetUserAccessRestrictions200ResponseBody
  | ReposSetUserAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ReposSetUserAccessRestrictionsHandler = (
  req: ReposSetUserAccessRestrictionsRequest,
  res: ReposSetUserAccessRestrictionsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposRemoveUserAccessRestrictionsRequest = Request<
  ReposRemoveUserAccessRestrictionsRequestPath,
  | ReposRemoveUserAccessRestrictions200ResponseBody
  | ReposRemoveUserAccessRestrictions422ResponseBody,
  ReposRemoveUserAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposRemoveUserAccessRestrictionsResponse = Response<
  | ReposRemoveUserAccessRestrictions200ResponseBody
  | ReposRemoveUserAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ReposRemoveUserAccessRestrictionsHandler = (
  req: ReposRemoveUserAccessRestrictionsRequest,
  res: ReposRemoveUserAccessRestrictionsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposRenameBranchRequest = Request<
  ReposRenameBranchRequestPath,
  | ReposRenameBranch201ResponseBody
  | ReposRenameBranch403ResponseBody
  | ReposRenameBranch404ResponseBody
  | ReposRenameBranch422ResponseBody,
  ReposRenameBranchRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposRenameBranchResponse = Response<
  | ReposRenameBranch201ResponseBody
  | ReposRenameBranch403ResponseBody
  | ReposRenameBranch404ResponseBody
  | ReposRenameBranch422ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 422
>;

export type ReposRenameBranchHandler = (
  req: ReposRenameBranchRequest,
  res: ReposRenameBranchResponse,
  next: NextFunction
) => Promise<void> | void;

export type ChecksCreateRequest = Request<
  ChecksCreateRequestPath,
  ChecksCreate201ResponseBody,
  ChecksCreateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ChecksCreateResponse = Response<
  ChecksCreate201ResponseBody,
  Record<string, any>,
  201
>;

export type ChecksCreateHandler = (
  req: ChecksCreateRequest,
  res: ChecksCreateResponse,
  next: NextFunction
) => Promise<void> | void;

export type ChecksGetRequest = Request<
  ChecksGetRequestPath,
  ChecksGet200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ChecksGetResponse = Response<
  ChecksGet200ResponseBody,
  Record<string, any>,
  200
>;

export type ChecksGetHandler = (
  req: ChecksGetRequest,
  res: ChecksGetResponse,
  next: NextFunction
) => Promise<void> | void;

export type ChecksUpdateRequest = Request<
  ChecksUpdateRequestPath,
  ChecksUpdate200ResponseBody,
  ChecksUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ChecksUpdateResponse = Response<
  ChecksUpdate200ResponseBody,
  Record<string, any>,
  200
>;

export type ChecksUpdateHandler = (
  req: ChecksUpdateRequest,
  res: ChecksUpdateResponse,
  next: NextFunction
) => Promise<void> | void;

export type ChecksListAnnotationsRequest = Request<
  ChecksListAnnotationsRequestPath,
  ChecksListAnnotations200ResponseBody,
  unknown,
  ChecksListAnnotationsRequestQuery,
  Record<string, any>
>;

export type ChecksListAnnotationsResponse = Response<
  ChecksListAnnotations200ResponseBody,
  Record<string, any>,
  200
>;

export type ChecksListAnnotationsHandler = (
  req: ChecksListAnnotationsRequest,
  res: ChecksListAnnotationsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ChecksRerequestRunRequest = Request<
  ChecksRerequestRunRequestPath,
  | ChecksRerequestRun201ResponseBody
  | ChecksRerequestRun403ResponseBody
  | ChecksRerequestRun404ResponseBody
  | ChecksRerequestRun422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ChecksRerequestRunResponse = Response<
  | ChecksRerequestRun201ResponseBody
  | ChecksRerequestRun403ResponseBody
  | ChecksRerequestRun404ResponseBody
  | ChecksRerequestRun422ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 422
>;

export type ChecksRerequestRunHandler = (
  req: ChecksRerequestRunRequest,
  res: ChecksRerequestRunResponse,
  next: NextFunction
) => Promise<void> | void;

export type ChecksCreateSuiteRequest = Request<
  ChecksCreateSuiteRequestPath,
  ChecksCreateSuite200ResponseBody | ChecksCreateSuite201ResponseBody,
  ChecksCreateSuiteRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ChecksCreateSuiteResponse = Response<
  ChecksCreateSuite200ResponseBody | ChecksCreateSuite201ResponseBody,
  Record<string, any>,
  200 | 201
>;

export type ChecksCreateSuiteHandler = (
  req: ChecksCreateSuiteRequest,
  res: ChecksCreateSuiteResponse,
  next: NextFunction
) => Promise<void> | void;

export type ChecksSetSuitesPreferencesRequest = Request<
  ChecksSetSuitesPreferencesRequestPath,
  ChecksSetSuitesPreferences200ResponseBody,
  ChecksSetSuitesPreferencesRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ChecksSetSuitesPreferencesResponse = Response<
  ChecksSetSuitesPreferences200ResponseBody,
  Record<string, any>,
  200
>;

export type ChecksSetSuitesPreferencesHandler = (
  req: ChecksSetSuitesPreferencesRequest,
  res: ChecksSetSuitesPreferencesResponse,
  next: NextFunction
) => Promise<void> | void;

export type ChecksGetSuiteRequest = Request<
  ChecksGetSuiteRequestPath,
  ChecksGetSuite200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ChecksGetSuiteResponse = Response<
  ChecksGetSuite200ResponseBody,
  Record<string, any>,
  200
>;

export type ChecksGetSuiteHandler = (
  req: ChecksGetSuiteRequest,
  res: ChecksGetSuiteResponse,
  next: NextFunction
) => Promise<void> | void;

export type ChecksListForSuiteRequest = Request<
  ChecksListForSuiteRequestPath,
  ChecksListForSuite200ResponseBody,
  unknown,
  ChecksListForSuiteRequestQuery,
  Record<string, any>
>;

export type ChecksListForSuiteResponse = Response<
  ChecksListForSuite200ResponseBody,
  Record<string, any>,
  200
>;

export type ChecksListForSuiteHandler = (
  req: ChecksListForSuiteRequest,
  res: ChecksListForSuiteResponse,
  next: NextFunction
) => Promise<void> | void;

export type ChecksRerequestSuiteRequest = Request<
  ChecksRerequestSuiteRequestPath,
  ChecksRerequestSuite201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ChecksRerequestSuiteResponse = Response<
  ChecksRerequestSuite201ResponseBody,
  Record<string, any>,
  201
>;

export type ChecksRerequestSuiteHandler = (
  req: ChecksRerequestSuiteRequest,
  res: ChecksRerequestSuiteResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodeScanningListAlertsForRepoRequest = Request<
  CodeScanningListAlertsForRepoRequestPath,
  | CodeScanningListAlertsForRepo200ResponseBody
  | CodeScanningListAlertsForRepo403ResponseBody
  | CodeScanningListAlertsForRepo404ResponseBody
  | CodeScanningListAlertsForRepo503ResponseBody,
  unknown,
  CodeScanningListAlertsForRepoRequestQuery,
  Record<string, any>
>;

export type CodeScanningListAlertsForRepoResponse = Response<
  | CodeScanningListAlertsForRepo200ResponseBody
  | CodeScanningListAlertsForRepo403ResponseBody
  | CodeScanningListAlertsForRepo404ResponseBody
  | CodeScanningListAlertsForRepo503ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404 | 503
>;

export type CodeScanningListAlertsForRepoHandler = (
  req: CodeScanningListAlertsForRepoRequest,
  res: CodeScanningListAlertsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodeScanningGetAlertRequest = Request<
  CodeScanningGetAlertRequestPath,
  | CodeScanningGetAlert200ResponseBody
  | CodeScanningGetAlert403ResponseBody
  | CodeScanningGetAlert404ResponseBody
  | CodeScanningGetAlert503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningGetAlertResponse = Response<
  | CodeScanningGetAlert200ResponseBody
  | CodeScanningGetAlert403ResponseBody
  | CodeScanningGetAlert404ResponseBody
  | CodeScanningGetAlert503ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404 | 503
>;

export type CodeScanningGetAlertHandler = (
  req: CodeScanningGetAlertRequest,
  res: CodeScanningGetAlertResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodeScanningUpdateAlertRequest = Request<
  CodeScanningUpdateAlertRequestPath,
  | CodeScanningUpdateAlert200ResponseBody
  | CodeScanningUpdateAlert403ResponseBody
  | CodeScanningUpdateAlert404ResponseBody
  | CodeScanningUpdateAlert503ResponseBody,
  CodeScanningUpdateAlertRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningUpdateAlertResponse = Response<
  | CodeScanningUpdateAlert200ResponseBody
  | CodeScanningUpdateAlert403ResponseBody
  | CodeScanningUpdateAlert404ResponseBody
  | CodeScanningUpdateAlert503ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 503
>;

export type CodeScanningUpdateAlertHandler = (
  req: CodeScanningUpdateAlertRequest,
  res: CodeScanningUpdateAlertResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodeScanningListAlertInstancesRequest = Request<
  CodeScanningListAlertInstancesRequestPath,
  | CodeScanningListAlertInstances200ResponseBody
  | CodeScanningListAlertInstances403ResponseBody
  | CodeScanningListAlertInstances404ResponseBody
  | CodeScanningListAlertInstances503ResponseBody,
  unknown,
  CodeScanningListAlertInstancesRequestQuery,
  Record<string, any>
>;

export type CodeScanningListAlertInstancesResponse = Response<
  | CodeScanningListAlertInstances200ResponseBody
  | CodeScanningListAlertInstances403ResponseBody
  | CodeScanningListAlertInstances404ResponseBody
  | CodeScanningListAlertInstances503ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 503
>;

export type CodeScanningListAlertInstancesHandler = (
  req: CodeScanningListAlertInstancesRequest,
  res: CodeScanningListAlertInstancesResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodeScanningListRecentAnalysesRequest = Request<
  CodeScanningListRecentAnalysesRequestPath,
  | CodeScanningListRecentAnalyses200ResponseBody
  | CodeScanningListRecentAnalyses403ResponseBody
  | CodeScanningListRecentAnalyses404ResponseBody
  | CodeScanningListRecentAnalyses503ResponseBody,
  unknown,
  CodeScanningListRecentAnalysesRequestQuery,
  Record<string, any>
>;

export type CodeScanningListRecentAnalysesResponse = Response<
  | CodeScanningListRecentAnalyses200ResponseBody
  | CodeScanningListRecentAnalyses403ResponseBody
  | CodeScanningListRecentAnalyses404ResponseBody
  | CodeScanningListRecentAnalyses503ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 503
>;

export type CodeScanningListRecentAnalysesHandler = (
  req: CodeScanningListRecentAnalysesRequest,
  res: CodeScanningListRecentAnalysesResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodeScanningGetAnalysisRequest = Request<
  CodeScanningGetAnalysisRequestPath,
  | CodeScanningGetAnalysis200ResponseBody
  | CodeScanningGetAnalysis403ResponseBody
  | CodeScanningGetAnalysis404ResponseBody
  | CodeScanningGetAnalysis503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningGetAnalysisResponse = Response<
  | CodeScanningGetAnalysis200ResponseBody
  | CodeScanningGetAnalysis403ResponseBody
  | CodeScanningGetAnalysis404ResponseBody
  | CodeScanningGetAnalysis503ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 503
>;

export type CodeScanningGetAnalysisHandler = (
  req: CodeScanningGetAnalysisRequest,
  res: CodeScanningGetAnalysisResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodeScanningDeleteAnalysisRequest = Request<
  CodeScanningDeleteAnalysisRequestPath,
  | CodeScanningDeleteAnalysis200ResponseBody
  | CodeScanningDeleteAnalysis400ResponseBody
  | CodeScanningDeleteAnalysis403ResponseBody
  | CodeScanningDeleteAnalysis404ResponseBody
  | CodeScanningDeleteAnalysis503ResponseBody,
  unknown,
  CodeScanningDeleteAnalysisRequestQuery,
  Record<string, any>
>;

export type CodeScanningDeleteAnalysisResponse = Response<
  | CodeScanningDeleteAnalysis200ResponseBody
  | CodeScanningDeleteAnalysis400ResponseBody
  | CodeScanningDeleteAnalysis403ResponseBody
  | CodeScanningDeleteAnalysis404ResponseBody
  | CodeScanningDeleteAnalysis503ResponseBody,
  Record<string, any>,
  200 | 400 | 403 | 404 | 503
>;

export type CodeScanningDeleteAnalysisHandler = (
  req: CodeScanningDeleteAnalysisRequest,
  res: CodeScanningDeleteAnalysisResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodeScanningListCodeqlDatabasesRequest = Request<
  CodeScanningListCodeqlDatabasesRequestPath,
  | CodeScanningListCodeqlDatabases200ResponseBody
  | CodeScanningListCodeqlDatabases403ResponseBody
  | CodeScanningListCodeqlDatabases404ResponseBody
  | CodeScanningListCodeqlDatabases503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningListCodeqlDatabasesResponse = Response<
  | CodeScanningListCodeqlDatabases200ResponseBody
  | CodeScanningListCodeqlDatabases403ResponseBody
  | CodeScanningListCodeqlDatabases404ResponseBody
  | CodeScanningListCodeqlDatabases503ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 503
>;

export type CodeScanningListCodeqlDatabasesHandler = (
  req: CodeScanningListCodeqlDatabasesRequest,
  res: CodeScanningListCodeqlDatabasesResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodeScanningGetCodeqlDatabaseRequest = Request<
  CodeScanningGetCodeqlDatabaseRequestPath,
  | CodeScanningGetCodeqlDatabase200ResponseBody
  | CodeScanningGetCodeqlDatabase403ResponseBody
  | CodeScanningGetCodeqlDatabase404ResponseBody
  | CodeScanningGetCodeqlDatabase503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningGetCodeqlDatabaseResponse = Response<
  | CodeScanningGetCodeqlDatabase200ResponseBody
  | CodeScanningGetCodeqlDatabase403ResponseBody
  | CodeScanningGetCodeqlDatabase404ResponseBody
  | CodeScanningGetCodeqlDatabase503ResponseBody,
  Record<string, any>,
  200 | 302 | 403 | 404 | 503
>;

export type CodeScanningGetCodeqlDatabaseHandler = (
  req: CodeScanningGetCodeqlDatabaseRequest,
  res: CodeScanningGetCodeqlDatabaseResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodeScanningUploadSarifRequest = Request<
  CodeScanningUploadSarifRequestPath,
  | CodeScanningUploadSarif202ResponseBody
  | CodeScanningUploadSarif403ResponseBody
  | CodeScanningUploadSarif404ResponseBody
  | CodeScanningUploadSarif503ResponseBody,
  CodeScanningUploadSarifRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningUploadSarifResponse = Response<
  | CodeScanningUploadSarif202ResponseBody
  | CodeScanningUploadSarif403ResponseBody
  | CodeScanningUploadSarif404ResponseBody
  | CodeScanningUploadSarif503ResponseBody,
  Record<string, any>,
  202 | 400 | 403 | 404 | 413 | 503
>;

export type CodeScanningUploadSarifHandler = (
  req: CodeScanningUploadSarifRequest,
  res: CodeScanningUploadSarifResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodeScanningGetSarifRequest = Request<
  CodeScanningGetSarifRequestPath,
  | CodeScanningGetSarif200ResponseBody
  | CodeScanningGetSarif403ResponseBody
  | CodeScanningGetSarif503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningGetSarifResponse = Response<
  | CodeScanningGetSarif200ResponseBody
  | CodeScanningGetSarif403ResponseBody
  | CodeScanningGetSarif503ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 503
>;

export type CodeScanningGetSarifHandler = (
  req: CodeScanningGetSarifRequest,
  res: CodeScanningGetSarifResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCodeownersErrorsRequest = Request<
  ReposCodeownersErrorsRequestPath,
  ReposCodeownersErrors200ResponseBody,
  unknown,
  ReposCodeownersErrorsRequestQuery,
  Record<string, any>
>;

export type ReposCodeownersErrorsResponse = Response<
  ReposCodeownersErrors200ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposCodeownersErrorsHandler = (
  req: ReposCodeownersErrorsRequest,
  res: ReposCodeownersErrorsResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesListInRepositoryForAuthenticatedUserRequest = Request<
  CodespacesListInRepositoryForAuthenticatedUserRequestPath,
  | CodespacesListInRepositoryForAuthenticatedUser200ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser401ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser403ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser404ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser500ResponseBody,
  unknown,
  CodespacesListInRepositoryForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type CodespacesListInRepositoryForAuthenticatedUserResponse = Response<
  | CodespacesListInRepositoryForAuthenticatedUser200ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser401ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser403ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser404ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404 | 500
>;

export type CodespacesListInRepositoryForAuthenticatedUserHandler = (
  req: CodespacesListInRepositoryForAuthenticatedUserRequest,
  res: CodespacesListInRepositoryForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesCreateWithRepoForAuthenticatedUserRequest = Request<
  CodespacesCreateWithRepoForAuthenticatedUserRequestPath,
  | CodespacesCreateWithRepoForAuthenticatedUser201ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser202ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser400ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser401ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser403ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser404ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser503ResponseBody,
  CodespacesCreateWithRepoForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCreateWithRepoForAuthenticatedUserResponse = Response<
  | CodespacesCreateWithRepoForAuthenticatedUser201ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser202ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser400ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser401ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser403ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser404ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser503ResponseBody,
  Record<string, any>,
  201 | 202 | 400 | 401 | 403 | 404 | 503
>;

export type CodespacesCreateWithRepoForAuthenticatedUserHandler = (
  req: CodespacesCreateWithRepoForAuthenticatedUserRequest,
  res: CodespacesCreateWithRepoForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequest = Request<
  CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequestPath,
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser200ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser400ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser401ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser403ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser404ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser500ResponseBody,
  unknown,
  CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse = Response<
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser200ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser400ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser401ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser403ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser404ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 400 | 401 | 403 | 404 | 500
>;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserHandler = (
  req: CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequest,
  res: CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesRepoMachinesForAuthenticatedUserRequest = Request<
  CodespacesRepoMachinesForAuthenticatedUserRequestPath,
  | CodespacesRepoMachinesForAuthenticatedUser200ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser401ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser403ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser404ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser500ResponseBody,
  unknown,
  CodespacesRepoMachinesForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type CodespacesRepoMachinesForAuthenticatedUserResponse = Response<
  | CodespacesRepoMachinesForAuthenticatedUser200ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser401ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser403ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser404ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export type CodespacesRepoMachinesForAuthenticatedUserHandler = (
  req: CodespacesRepoMachinesForAuthenticatedUserRequest,
  res: CodespacesRepoMachinesForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesPreFlightWithRepoForAuthenticatedUserRequest = Request<
  CodespacesPreFlightWithRepoForAuthenticatedUserRequestPath,
  | CodespacesPreFlightWithRepoForAuthenticatedUser200ResponseBody
  | CodespacesPreFlightWithRepoForAuthenticatedUser401ResponseBody
  | CodespacesPreFlightWithRepoForAuthenticatedUser403ResponseBody
  | CodespacesPreFlightWithRepoForAuthenticatedUser404ResponseBody,
  unknown,
  CodespacesPreFlightWithRepoForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type CodespacesPreFlightWithRepoForAuthenticatedUserResponse = Response<
  | CodespacesPreFlightWithRepoForAuthenticatedUser200ResponseBody
  | CodespacesPreFlightWithRepoForAuthenticatedUser401ResponseBody
  | CodespacesPreFlightWithRepoForAuthenticatedUser403ResponseBody
  | CodespacesPreFlightWithRepoForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404
>;

export type CodespacesPreFlightWithRepoForAuthenticatedUserHandler = (
  req: CodespacesPreFlightWithRepoForAuthenticatedUserRequest,
  res: CodespacesPreFlightWithRepoForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesListRepoSecretsRequest = Request<
  CodespacesListRepoSecretsRequestPath,
  CodespacesListRepoSecrets200ResponseBody,
  unknown,
  CodespacesListRepoSecretsRequestQuery,
  Record<string, any>
>;

export type CodespacesListRepoSecretsResponse = Response<
  CodespacesListRepoSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export type CodespacesListRepoSecretsHandler = (
  req: CodespacesListRepoSecretsRequest,
  res: CodespacesListRepoSecretsResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesGetRepoPublicKeyRequest = Request<
  CodespacesGetRepoPublicKeyRequestPath,
  CodespacesGetRepoPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetRepoPublicKeyResponse = Response<
  CodespacesGetRepoPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export type CodespacesGetRepoPublicKeyHandler = (
  req: CodespacesGetRepoPublicKeyRequest,
  res: CodespacesGetRepoPublicKeyResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesGetRepoSecretRequest = Request<
  CodespacesGetRepoSecretRequestPath,
  CodespacesGetRepoSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetRepoSecretResponse = Response<
  CodespacesGetRepoSecret200ResponseBody,
  Record<string, any>,
  200
>;

export type CodespacesGetRepoSecretHandler = (
  req: CodespacesGetRepoSecretRequest,
  res: CodespacesGetRepoSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesCreateOrUpdateRepoSecretRequest = Request<
  CodespacesCreateOrUpdateRepoSecretRequestPath,
  CodespacesCreateOrUpdateRepoSecret201ResponseBody,
  CodespacesCreateOrUpdateRepoSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCreateOrUpdateRepoSecretResponse = Response<
  CodespacesCreateOrUpdateRepoSecret201ResponseBody,
  Record<string, any>,
  201 | 204
>;

export type CodespacesCreateOrUpdateRepoSecretHandler = (
  req: CodespacesCreateOrUpdateRepoSecretRequest,
  res: CodespacesCreateOrUpdateRepoSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesDeleteRepoSecretRequest = Request<
  CodespacesDeleteRepoSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesDeleteRepoSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type CodespacesDeleteRepoSecretHandler = (
  req: CodespacesDeleteRepoSecretRequest,
  res: CodespacesDeleteRepoSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListCollaboratorsRequest = Request<
  ReposListCollaboratorsRequestPath,
  ReposListCollaborators200ResponseBody | ReposListCollaborators404ResponseBody,
  unknown,
  ReposListCollaboratorsRequestQuery,
  Record<string, any>
>;

export type ReposListCollaboratorsResponse = Response<
  ReposListCollaborators200ResponseBody | ReposListCollaborators404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposListCollaboratorsHandler = (
  req: ReposListCollaboratorsRequest,
  res: ReposListCollaboratorsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCheckCollaboratorRequest = Request<
  ReposCheckCollaboratorRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposCheckCollaboratorResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export type ReposCheckCollaboratorHandler = (
  req: ReposCheckCollaboratorRequest,
  res: ReposCheckCollaboratorResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposAddCollaboratorRequest = Request<
  ReposAddCollaboratorRequestPath,
  | ReposAddCollaborator201ResponseBody
  | ReposAddCollaborator403ResponseBody
  | ReposAddCollaborator422ResponseBody,
  ReposAddCollaboratorRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposAddCollaboratorResponse = Response<
  | ReposAddCollaborator201ResponseBody
  | ReposAddCollaborator403ResponseBody
  | ReposAddCollaborator422ResponseBody,
  Record<string, any>,
  201 | 204 | 403 | 422
>;

export type ReposAddCollaboratorHandler = (
  req: ReposAddCollaboratorRequest,
  res: ReposAddCollaboratorResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposRemoveCollaboratorRequest = Request<
  ReposRemoveCollaboratorRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposRemoveCollaboratorResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposRemoveCollaboratorHandler = (
  req: ReposRemoveCollaboratorRequest,
  res: ReposRemoveCollaboratorResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetCollaboratorPermissionLevelRequest = Request<
  ReposGetCollaboratorPermissionLevelRequestPath,
  | ReposGetCollaboratorPermissionLevel200ResponseBody
  | ReposGetCollaboratorPermissionLevel404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetCollaboratorPermissionLevelResponse = Response<
  | ReposGetCollaboratorPermissionLevel200ResponseBody
  | ReposGetCollaboratorPermissionLevel404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetCollaboratorPermissionLevelHandler = (
  req: ReposGetCollaboratorPermissionLevelRequest,
  res: ReposGetCollaboratorPermissionLevelResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListCommitCommentsForRepoRequest = Request<
  ReposListCommitCommentsForRepoRequestPath,
  ReposListCommitCommentsForRepo200ResponseBody,
  unknown,
  ReposListCommitCommentsForRepoRequestQuery,
  Record<string, any>
>;

export type ReposListCommitCommentsForRepoResponse = Response<
  ReposListCommitCommentsForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListCommitCommentsForRepoHandler = (
  req: ReposListCommitCommentsForRepoRequest,
  res: ReposListCommitCommentsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetCommitCommentRequest = Request<
  ReposGetCommitCommentRequestPath,
  ReposGetCommitComment200ResponseBody | ReposGetCommitComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetCommitCommentResponse = Response<
  ReposGetCommitComment200ResponseBody | ReposGetCommitComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetCommitCommentHandler = (
  req: ReposGetCommitCommentRequest,
  res: ReposGetCommitCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposUpdateCommitCommentRequest = Request<
  ReposUpdateCommitCommentRequestPath,
  | ReposUpdateCommitComment200ResponseBody
  | ReposUpdateCommitComment404ResponseBody,
  ReposUpdateCommitCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateCommitCommentResponse = Response<
  | ReposUpdateCommitComment200ResponseBody
  | ReposUpdateCommitComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposUpdateCommitCommentHandler = (
  req: ReposUpdateCommitCommentRequest,
  res: ReposUpdateCommitCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteCommitCommentRequest = Request<
  ReposDeleteCommitCommentRequestPath,
  ReposDeleteCommitComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteCommitCommentResponse = Response<
  ReposDeleteCommitComment404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type ReposDeleteCommitCommentHandler = (
  req: ReposDeleteCommitCommentRequest,
  res: ReposDeleteCommitCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsListForCommitCommentRequest = Request<
  ReactionsListForCommitCommentRequestPath,
  | ReactionsListForCommitComment200ResponseBody
  | ReactionsListForCommitComment404ResponseBody,
  unknown,
  ReactionsListForCommitCommentRequestQuery,
  Record<string, any>
>;

export type ReactionsListForCommitCommentResponse = Response<
  | ReactionsListForCommitComment200ResponseBody
  | ReactionsListForCommitComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReactionsListForCommitCommentHandler = (
  req: ReactionsListForCommitCommentRequest,
  res: ReactionsListForCommitCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsCreateForCommitCommentRequest = Request<
  ReactionsCreateForCommitCommentRequestPath,
  | ReactionsCreateForCommitComment200ResponseBody
  | ReactionsCreateForCommitComment201ResponseBody
  | ReactionsCreateForCommitComment422ResponseBody,
  ReactionsCreateForCommitCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForCommitCommentResponse = Response<
  | ReactionsCreateForCommitComment200ResponseBody
  | ReactionsCreateForCommitComment201ResponseBody
  | ReactionsCreateForCommitComment422ResponseBody,
  Record<string, any>,
  200 | 201 | 422
>;

export type ReactionsCreateForCommitCommentHandler = (
  req: ReactionsCreateForCommitCommentRequest,
  res: ReactionsCreateForCommitCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsDeleteForCommitCommentRequest = Request<
  ReactionsDeleteForCommitCommentRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForCommitCommentResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReactionsDeleteForCommitCommentHandler = (
  req: ReactionsDeleteForCommitCommentRequest,
  res: ReactionsDeleteForCommitCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListCommitsRequest = Request<
  ReposListCommitsRequestPath,
  | ReposListCommits200ResponseBody
  | ReposListCommits400ResponseBody
  | ReposListCommits404ResponseBody
  | ReposListCommits409ResponseBody
  | ReposListCommits500ResponseBody,
  unknown,
  ReposListCommitsRequestQuery,
  Record<string, any>
>;

export type ReposListCommitsResponse = Response<
  | ReposListCommits200ResponseBody
  | ReposListCommits400ResponseBody
  | ReposListCommits404ResponseBody
  | ReposListCommits409ResponseBody
  | ReposListCommits500ResponseBody,
  Record<string, any>,
  200 | 400 | 404 | 409 | 500
>;

export type ReposListCommitsHandler = (
  req: ReposListCommitsRequest,
  res: ReposListCommitsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListBranchesForHeadCommitRequest = Request<
  ReposListBranchesForHeadCommitRequestPath,
  | ReposListBranchesForHeadCommit200ResponseBody
  | ReposListBranchesForHeadCommit422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposListBranchesForHeadCommitResponse = Response<
  | ReposListBranchesForHeadCommit200ResponseBody
  | ReposListBranchesForHeadCommit422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ReposListBranchesForHeadCommitHandler = (
  req: ReposListBranchesForHeadCommitRequest,
  res: ReposListBranchesForHeadCommitResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListCommentsForCommitRequest = Request<
  ReposListCommentsForCommitRequestPath,
  ReposListCommentsForCommit200ResponseBody,
  unknown,
  ReposListCommentsForCommitRequestQuery,
  Record<string, any>
>;

export type ReposListCommentsForCommitResponse = Response<
  ReposListCommentsForCommit200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListCommentsForCommitHandler = (
  req: ReposListCommentsForCommitRequest,
  res: ReposListCommentsForCommitResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateCommitCommentRequest = Request<
  ReposCreateCommitCommentRequestPath,
  | ReposCreateCommitComment201ResponseBody
  | ReposCreateCommitComment403ResponseBody
  | ReposCreateCommitComment422ResponseBody,
  ReposCreateCommitCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateCommitCommentResponse = Response<
  | ReposCreateCommitComment201ResponseBody
  | ReposCreateCommitComment403ResponseBody
  | ReposCreateCommitComment422ResponseBody,
  Record<string, any>,
  201 | 403 | 422
>;

export type ReposCreateCommitCommentHandler = (
  req: ReposCreateCommitCommentRequest,
  res: ReposCreateCommitCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListPullRequestsAssociatedWithCommitRequest = Request<
  ReposListPullRequestsAssociatedWithCommitRequestPath,
  ReposListPullRequestsAssociatedWithCommit200ResponseBody,
  unknown,
  ReposListPullRequestsAssociatedWithCommitRequestQuery,
  Record<string, any>
>;

export type ReposListPullRequestsAssociatedWithCommitResponse = Response<
  ReposListPullRequestsAssociatedWithCommit200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListPullRequestsAssociatedWithCommitHandler = (
  req: ReposListPullRequestsAssociatedWithCommitRequest,
  res: ReposListPullRequestsAssociatedWithCommitResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetCommitRequest = Request<
  ReposGetCommitRequestPath,
  | ReposGetCommit200ResponseBody
  | ReposGetCommit404ResponseBody
  | ReposGetCommit422ResponseBody
  | ReposGetCommit500ResponseBody
  | ReposGetCommit503ResponseBody,
  unknown,
  ReposGetCommitRequestQuery,
  Record<string, any>
>;

export type ReposGetCommitResponse = Response<
  | ReposGetCommit200ResponseBody
  | ReposGetCommit404ResponseBody
  | ReposGetCommit422ResponseBody
  | ReposGetCommit500ResponseBody
  | ReposGetCommit503ResponseBody,
  Record<string, any>,
  200 | 404 | 422 | 500 | 503
>;

export type ReposGetCommitHandler = (
  req: ReposGetCommitRequest,
  res: ReposGetCommitResponse,
  next: NextFunction
) => Promise<void> | void;

export type ChecksListForRefRequest = Request<
  ChecksListForRefRequestPath,
  ChecksListForRef200ResponseBody,
  unknown,
  ChecksListForRefRequestQuery,
  Record<string, any>
>;

export type ChecksListForRefResponse = Response<
  ChecksListForRef200ResponseBody,
  Record<string, any>,
  200
>;

export type ChecksListForRefHandler = (
  req: ChecksListForRefRequest,
  res: ChecksListForRefResponse,
  next: NextFunction
) => Promise<void> | void;

export type ChecksListSuitesForRefRequest = Request<
  ChecksListSuitesForRefRequestPath,
  ChecksListSuitesForRef200ResponseBody,
  unknown,
  ChecksListSuitesForRefRequestQuery,
  Record<string, any>
>;

export type ChecksListSuitesForRefResponse = Response<
  ChecksListSuitesForRef200ResponseBody,
  Record<string, any>,
  200
>;

export type ChecksListSuitesForRefHandler = (
  req: ChecksListSuitesForRefRequest,
  res: ChecksListSuitesForRefResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetCombinedStatusForRefRequest = Request<
  ReposGetCombinedStatusForRefRequestPath,
  | ReposGetCombinedStatusForRef200ResponseBody
  | ReposGetCombinedStatusForRef404ResponseBody,
  unknown,
  ReposGetCombinedStatusForRefRequestQuery,
  Record<string, any>
>;

export type ReposGetCombinedStatusForRefResponse = Response<
  | ReposGetCombinedStatusForRef200ResponseBody
  | ReposGetCombinedStatusForRef404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetCombinedStatusForRefHandler = (
  req: ReposGetCombinedStatusForRefRequest,
  res: ReposGetCombinedStatusForRefResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListCommitStatusesForRefRequest = Request<
  ReposListCommitStatusesForRefRequestPath,
  | ReposListCommitStatusesForRef200ResponseBody
  | ReposListCommitStatusesForRef301ResponseBody,
  unknown,
  ReposListCommitStatusesForRefRequestQuery,
  Record<string, any>
>;

export type ReposListCommitStatusesForRefResponse = Response<
  | ReposListCommitStatusesForRef200ResponseBody
  | ReposListCommitStatusesForRef301ResponseBody,
  Record<string, any>,
  200 | 301
>;

export type ReposListCommitStatusesForRefHandler = (
  req: ReposListCommitStatusesForRefRequest,
  res: ReposListCommitStatusesForRefResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetCommunityProfileMetricsRequest = Request<
  ReposGetCommunityProfileMetricsRequestPath,
  ReposGetCommunityProfileMetrics200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetCommunityProfileMetricsResponse = Response<
  ReposGetCommunityProfileMetrics200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposGetCommunityProfileMetricsHandler = (
  req: ReposGetCommunityProfileMetricsRequest,
  res: ReposGetCommunityProfileMetricsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCompareCommitsRequest = Request<
  ReposCompareCommitsRequestPath,
  | ReposCompareCommits200ResponseBody
  | ReposCompareCommits404ResponseBody
  | ReposCompareCommits500ResponseBody
  | ReposCompareCommits503ResponseBody,
  unknown,
  ReposCompareCommitsRequestQuery,
  Record<string, any>
>;

export type ReposCompareCommitsResponse = Response<
  | ReposCompareCommits200ResponseBody
  | ReposCompareCommits404ResponseBody
  | ReposCompareCommits500ResponseBody
  | ReposCompareCommits503ResponseBody,
  Record<string, any>,
  200 | 404 | 500 | 503
>;

export type ReposCompareCommitsHandler = (
  req: ReposCompareCommitsRequest,
  res: ReposCompareCommitsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetContentRequest = Request<
  ReposGetContentRequestPath,
  | ReposGetContent200ResponseBody
  | ReposGetContent403ResponseBody
  | ReposGetContent404ResponseBody,
  unknown,
  ReposGetContentRequestQuery,
  Record<string, any>
>;

export type ReposGetContentResponse = Response<
  | ReposGetContent200ResponseBody
  | ReposGetContent403ResponseBody
  | ReposGetContent404ResponseBody,
  Record<string, any>,
  200 | 302 | 403 | 404
>;

export type ReposGetContentHandler = (
  req: ReposGetContentRequest,
  res: ReposGetContentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateOrUpdateFileContentsRequest = Request<
  ReposCreateOrUpdateFileContentsRequestPath,
  | ReposCreateOrUpdateFileContents200ResponseBody
  | ReposCreateOrUpdateFileContents201ResponseBody
  | ReposCreateOrUpdateFileContents404ResponseBody
  | ReposCreateOrUpdateFileContents409ResponseBody
  | ReposCreateOrUpdateFileContents422ResponseBody,
  ReposCreateOrUpdateFileContentsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateOrUpdateFileContentsResponse = Response<
  | ReposCreateOrUpdateFileContents200ResponseBody
  | ReposCreateOrUpdateFileContents201ResponseBody
  | ReposCreateOrUpdateFileContents404ResponseBody
  | ReposCreateOrUpdateFileContents409ResponseBody
  | ReposCreateOrUpdateFileContents422ResponseBody,
  Record<string, any>,
  200 | 201 | 404 | 409 | 422
>;

export type ReposCreateOrUpdateFileContentsHandler = (
  req: ReposCreateOrUpdateFileContentsRequest,
  res: ReposCreateOrUpdateFileContentsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteFileRequest = Request<
  ReposDeleteFileRequestPath,
  | ReposDeleteFile200ResponseBody
  | ReposDeleteFile404ResponseBody
  | ReposDeleteFile409ResponseBody
  | ReposDeleteFile422ResponseBody
  | ReposDeleteFile503ResponseBody,
  ReposDeleteFileRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteFileResponse = Response<
  | ReposDeleteFile200ResponseBody
  | ReposDeleteFile404ResponseBody
  | ReposDeleteFile409ResponseBody
  | ReposDeleteFile422ResponseBody
  | ReposDeleteFile503ResponseBody,
  Record<string, any>,
  200 | 404 | 409 | 422 | 503
>;

export type ReposDeleteFileHandler = (
  req: ReposDeleteFileRequest,
  res: ReposDeleteFileResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListContributorsRequest = Request<
  ReposListContributorsRequestPath,
  | ReposListContributors200ResponseBody
  | ReposListContributors403ResponseBody
  | ReposListContributors404ResponseBody,
  unknown,
  ReposListContributorsRequestQuery,
  Record<string, any>
>;

export type ReposListContributorsResponse = Response<
  | ReposListContributors200ResponseBody
  | ReposListContributors403ResponseBody
  | ReposListContributors404ResponseBody,
  Record<string, any>,
  200 | 204 | 403 | 404
>;

export type ReposListContributorsHandler = (
  req: ReposListContributorsRequest,
  res: ReposListContributorsResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotListAlertsForRepoRequest = Request<
  DependabotListAlertsForRepoRequestPath,
  | DependabotListAlertsForRepo200ResponseBody
  | DependabotListAlertsForRepo400ResponseBody
  | DependabotListAlertsForRepo403ResponseBody
  | DependabotListAlertsForRepo404ResponseBody
  | DependabotListAlertsForRepo422ResponseBody,
  unknown,
  DependabotListAlertsForRepoRequestQuery,
  Record<string, any>
>;

export type DependabotListAlertsForRepoResponse = Response<
  | DependabotListAlertsForRepo200ResponseBody
  | DependabotListAlertsForRepo400ResponseBody
  | DependabotListAlertsForRepo403ResponseBody
  | DependabotListAlertsForRepo404ResponseBody
  | DependabotListAlertsForRepo422ResponseBody,
  Record<string, any>,
  200 | 304 | 400 | 403 | 404 | 422
>;

export type DependabotListAlertsForRepoHandler = (
  req: DependabotListAlertsForRepoRequest,
  res: DependabotListAlertsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotGetAlertRequest = Request<
  DependabotGetAlertRequestPath,
  | DependabotGetAlert200ResponseBody
  | DependabotGetAlert403ResponseBody
  | DependabotGetAlert404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotGetAlertResponse = Response<
  | DependabotGetAlert200ResponseBody
  | DependabotGetAlert403ResponseBody
  | DependabotGetAlert404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export type DependabotGetAlertHandler = (
  req: DependabotGetAlertRequest,
  res: DependabotGetAlertResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotUpdateAlertRequest = Request<
  DependabotUpdateAlertRequestPath,
  | DependabotUpdateAlert200ResponseBody
  | DependabotUpdateAlert400ResponseBody
  | DependabotUpdateAlert403ResponseBody
  | DependabotUpdateAlert404ResponseBody
  | DependabotUpdateAlert409ResponseBody
  | DependabotUpdateAlert422ResponseBody,
  DependabotUpdateAlertRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type DependabotUpdateAlertResponse = Response<
  | DependabotUpdateAlert200ResponseBody
  | DependabotUpdateAlert400ResponseBody
  | DependabotUpdateAlert403ResponseBody
  | DependabotUpdateAlert404ResponseBody
  | DependabotUpdateAlert409ResponseBody
  | DependabotUpdateAlert422ResponseBody,
  Record<string, any>,
  200 | 400 | 403 | 404 | 409 | 422
>;

export type DependabotUpdateAlertHandler = (
  req: DependabotUpdateAlertRequest,
  res: DependabotUpdateAlertResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotListRepoSecretsRequest = Request<
  DependabotListRepoSecretsRequestPath,
  DependabotListRepoSecrets200ResponseBody,
  unknown,
  DependabotListRepoSecretsRequestQuery,
  Record<string, any>
>;

export type DependabotListRepoSecretsResponse = Response<
  DependabotListRepoSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export type DependabotListRepoSecretsHandler = (
  req: DependabotListRepoSecretsRequest,
  res: DependabotListRepoSecretsResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotGetRepoPublicKeyRequest = Request<
  DependabotGetRepoPublicKeyRequestPath,
  DependabotGetRepoPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotGetRepoPublicKeyResponse = Response<
  DependabotGetRepoPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export type DependabotGetRepoPublicKeyHandler = (
  req: DependabotGetRepoPublicKeyRequest,
  res: DependabotGetRepoPublicKeyResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotGetRepoSecretRequest = Request<
  DependabotGetRepoSecretRequestPath,
  DependabotGetRepoSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotGetRepoSecretResponse = Response<
  DependabotGetRepoSecret200ResponseBody,
  Record<string, any>,
  200
>;

export type DependabotGetRepoSecretHandler = (
  req: DependabotGetRepoSecretRequest,
  res: DependabotGetRepoSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotCreateOrUpdateRepoSecretRequest = Request<
  DependabotCreateOrUpdateRepoSecretRequestPath,
  DependabotCreateOrUpdateRepoSecret201ResponseBody,
  DependabotCreateOrUpdateRepoSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type DependabotCreateOrUpdateRepoSecretResponse = Response<
  DependabotCreateOrUpdateRepoSecret201ResponseBody,
  Record<string, any>,
  201 | 204
>;

export type DependabotCreateOrUpdateRepoSecretHandler = (
  req: DependabotCreateOrUpdateRepoSecretRequest,
  res: DependabotCreateOrUpdateRepoSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependabotDeleteRepoSecretRequest = Request<
  DependabotDeleteRepoSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotDeleteRepoSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type DependabotDeleteRepoSecretHandler = (
  req: DependabotDeleteRepoSecretRequest,
  res: DependabotDeleteRepoSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependencyGraphDiffRangeRequest = Request<
  DependencyGraphDiffRangeRequestPath,
  | DependencyGraphDiffRange200ResponseBody
  | DependencyGraphDiffRange403ResponseBody
  | DependencyGraphDiffRange404ResponseBody,
  unknown,
  DependencyGraphDiffRangeRequestQuery,
  Record<string, any>
>;

export type DependencyGraphDiffRangeResponse = Response<
  | DependencyGraphDiffRange200ResponseBody
  | DependencyGraphDiffRange403ResponseBody
  | DependencyGraphDiffRange404ResponseBody,
  Record<string, any>,
  200 | 403 | 404
>;

export type DependencyGraphDiffRangeHandler = (
  req: DependencyGraphDiffRangeRequest,
  res: DependencyGraphDiffRangeResponse,
  next: NextFunction
) => Promise<void> | void;

export type DependencyGraphCreateRepositorySnapshotRequest = Request<
  DependencyGraphCreateRepositorySnapshotRequestPath,
  DependencyGraphCreateRepositorySnapshot201ResponseBody,
  DependencyGraphCreateRepositorySnapshotRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type DependencyGraphCreateRepositorySnapshotResponse = Response<
  DependencyGraphCreateRepositorySnapshot201ResponseBody,
  Record<string, any>,
  201
>;

export type DependencyGraphCreateRepositorySnapshotHandler = (
  req: DependencyGraphCreateRepositorySnapshotRequest,
  res: DependencyGraphCreateRepositorySnapshotResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListDeploymentsRequest = Request<
  ReposListDeploymentsRequestPath,
  ReposListDeployments200ResponseBody,
  unknown,
  ReposListDeploymentsRequestQuery,
  Record<string, any>
>;

export type ReposListDeploymentsResponse = Response<
  ReposListDeployments200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListDeploymentsHandler = (
  req: ReposListDeploymentsRequest,
  res: ReposListDeploymentsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateDeploymentRequest = Request<
  ReposCreateDeploymentRequestPath,
  | ReposCreateDeployment201ResponseBody
  | ReposCreateDeployment202ResponseBody
  | ReposCreateDeployment422ResponseBody,
  ReposCreateDeploymentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateDeploymentResponse = Response<
  | ReposCreateDeployment201ResponseBody
  | ReposCreateDeployment202ResponseBody
  | ReposCreateDeployment422ResponseBody,
  Record<string, any>,
  201 | 202 | 409 | 422
>;

export type ReposCreateDeploymentHandler = (
  req: ReposCreateDeploymentRequest,
  res: ReposCreateDeploymentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetDeploymentRequest = Request<
  ReposGetDeploymentRequestPath,
  ReposGetDeployment200ResponseBody | ReposGetDeployment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetDeploymentResponse = Response<
  ReposGetDeployment200ResponseBody | ReposGetDeployment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetDeploymentHandler = (
  req: ReposGetDeploymentRequest,
  res: ReposGetDeploymentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteDeploymentRequest = Request<
  ReposDeleteDeploymentRequestPath,
  ReposDeleteDeployment404ResponseBody | ReposDeleteDeployment422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteDeploymentResponse = Response<
  ReposDeleteDeployment404ResponseBody | ReposDeleteDeployment422ResponseBody,
  Record<string, any>,
  204 | 404 | 422
>;

export type ReposDeleteDeploymentHandler = (
  req: ReposDeleteDeploymentRequest,
  res: ReposDeleteDeploymentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListDeploymentStatusesRequest = Request<
  ReposListDeploymentStatusesRequestPath,
  | ReposListDeploymentStatuses200ResponseBody
  | ReposListDeploymentStatuses404ResponseBody,
  unknown,
  ReposListDeploymentStatusesRequestQuery,
  Record<string, any>
>;

export type ReposListDeploymentStatusesResponse = Response<
  | ReposListDeploymentStatuses200ResponseBody
  | ReposListDeploymentStatuses404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposListDeploymentStatusesHandler = (
  req: ReposListDeploymentStatusesRequest,
  res: ReposListDeploymentStatusesResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateDeploymentStatusRequest = Request<
  ReposCreateDeploymentStatusRequestPath,
  | ReposCreateDeploymentStatus201ResponseBody
  | ReposCreateDeploymentStatus422ResponseBody,
  ReposCreateDeploymentStatusRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateDeploymentStatusResponse = Response<
  | ReposCreateDeploymentStatus201ResponseBody
  | ReposCreateDeploymentStatus422ResponseBody,
  Record<string, any>,
  201 | 422
>;

export type ReposCreateDeploymentStatusHandler = (
  req: ReposCreateDeploymentStatusRequest,
  res: ReposCreateDeploymentStatusResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetDeploymentStatusRequest = Request<
  ReposGetDeploymentStatusRequestPath,
  | ReposGetDeploymentStatus200ResponseBody
  | ReposGetDeploymentStatus404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetDeploymentStatusResponse = Response<
  | ReposGetDeploymentStatus200ResponseBody
  | ReposGetDeploymentStatus404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetDeploymentStatusHandler = (
  req: ReposGetDeploymentStatusRequest,
  res: ReposGetDeploymentStatusResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateDispatchEventRequest = Request<
  ReposCreateDispatchEventRequestPath,
  ReposCreateDispatchEvent422ResponseBody,
  ReposCreateDispatchEventRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateDispatchEventResponse = Response<
  ReposCreateDispatchEvent422ResponseBody,
  Record<string, any>,
  204 | 422
>;

export type ReposCreateDispatchEventHandler = (
  req: ReposCreateDispatchEventRequest,
  res: ReposCreateDispatchEventResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetAllEnvironmentsRequest = Request<
  ReposGetAllEnvironmentsRequestPath,
  ReposGetAllEnvironments200ResponseBody,
  unknown,
  ReposGetAllEnvironmentsRequestQuery,
  Record<string, any>
>;

export type ReposGetAllEnvironmentsResponse = Response<
  ReposGetAllEnvironments200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposGetAllEnvironmentsHandler = (
  req: ReposGetAllEnvironmentsRequest,
  res: ReposGetAllEnvironmentsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetEnvironmentRequest = Request<
  ReposGetEnvironmentRequestPath,
  ReposGetEnvironment200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetEnvironmentResponse = Response<
  ReposGetEnvironment200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposGetEnvironmentHandler = (
  req: ReposGetEnvironmentRequest,
  res: ReposGetEnvironmentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateOrUpdateEnvironmentRequest = Request<
  ReposCreateOrUpdateEnvironmentRequestPath,
  | ReposCreateOrUpdateEnvironment200ResponseBody
  | ReposCreateOrUpdateEnvironment422ResponseBody,
  ReposCreateOrUpdateEnvironmentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateOrUpdateEnvironmentResponse = Response<
  | ReposCreateOrUpdateEnvironment200ResponseBody
  | ReposCreateOrUpdateEnvironment422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ReposCreateOrUpdateEnvironmentHandler = (
  req: ReposCreateOrUpdateEnvironmentRequest,
  res: ReposCreateOrUpdateEnvironmentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteAnEnvironmentRequest = Request<
  ReposDeleteAnEnvironmentRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteAnEnvironmentResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposDeleteAnEnvironmentHandler = (
  req: ReposDeleteAnEnvironmentRequest,
  res: ReposDeleteAnEnvironmentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListDeploymentBranchPoliciesRequest = Request<
  ReposListDeploymentBranchPoliciesRequestPath,
  ReposListDeploymentBranchPolicies200ResponseBody,
  unknown,
  ReposListDeploymentBranchPoliciesRequestQuery,
  Record<string, any>
>;

export type ReposListDeploymentBranchPoliciesResponse = Response<
  ReposListDeploymentBranchPolicies200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListDeploymentBranchPoliciesHandler = (
  req: ReposListDeploymentBranchPoliciesRequest,
  res: ReposListDeploymentBranchPoliciesResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateDeploymentBranchPolicyRequest = Request<
  ReposCreateDeploymentBranchPolicyRequestPath,
  ReposCreateDeploymentBranchPolicy200ResponseBody,
  ReposCreateDeploymentBranchPolicyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateDeploymentBranchPolicyResponse = Response<
  ReposCreateDeploymentBranchPolicy200ResponseBody,
  Record<string, any>,
  200 | 303 | 404
>;

export type ReposCreateDeploymentBranchPolicyHandler = (
  req: ReposCreateDeploymentBranchPolicyRequest,
  res: ReposCreateDeploymentBranchPolicyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetDeploymentBranchPolicyRequest = Request<
  ReposGetDeploymentBranchPolicyRequestPath,
  ReposGetDeploymentBranchPolicy200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetDeploymentBranchPolicyResponse = Response<
  ReposGetDeploymentBranchPolicy200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposGetDeploymentBranchPolicyHandler = (
  req: ReposGetDeploymentBranchPolicyRequest,
  res: ReposGetDeploymentBranchPolicyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposUpdateDeploymentBranchPolicyRequest = Request<
  ReposUpdateDeploymentBranchPolicyRequestPath,
  ReposUpdateDeploymentBranchPolicy200ResponseBody,
  ReposUpdateDeploymentBranchPolicyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateDeploymentBranchPolicyResponse = Response<
  ReposUpdateDeploymentBranchPolicy200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposUpdateDeploymentBranchPolicyHandler = (
  req: ReposUpdateDeploymentBranchPolicyRequest,
  res: ReposUpdateDeploymentBranchPolicyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteDeploymentBranchPolicyRequest = Request<
  ReposDeleteDeploymentBranchPolicyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteDeploymentBranchPolicyResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposDeleteDeploymentBranchPolicyHandler = (
  req: ReposDeleteDeploymentBranchPolicyRequest,
  res: ReposDeleteDeploymentBranchPolicyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListRepoEventsRequest = Request<
  ActivityListRepoEventsRequestPath,
  ActivityListRepoEvents200ResponseBody,
  unknown,
  ActivityListRepoEventsRequestQuery,
  Record<string, any>
>;

export type ActivityListRepoEventsResponse = Response<
  ActivityListRepoEvents200ResponseBody,
  Record<string, any>,
  200
>;

export type ActivityListRepoEventsHandler = (
  req: ActivityListRepoEventsRequest,
  res: ActivityListRepoEventsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListForksRequest = Request<
  ReposListForksRequestPath,
  ReposListForks200ResponseBody | ReposListForks400ResponseBody,
  unknown,
  ReposListForksRequestQuery,
  Record<string, any>
>;

export type ReposListForksResponse = Response<
  ReposListForks200ResponseBody | ReposListForks400ResponseBody,
  Record<string, any>,
  200 | 400
>;

export type ReposListForksHandler = (
  req: ReposListForksRequest,
  res: ReposListForksResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateForkRequest = Request<
  ReposCreateForkRequestPath,
  | ReposCreateFork202ResponseBody
  | ReposCreateFork400ResponseBody
  | ReposCreateFork403ResponseBody
  | ReposCreateFork404ResponseBody
  | ReposCreateFork422ResponseBody,
  ReposCreateForkRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateForkResponse = Response<
  | ReposCreateFork202ResponseBody
  | ReposCreateFork400ResponseBody
  | ReposCreateFork403ResponseBody
  | ReposCreateFork404ResponseBody
  | ReposCreateFork422ResponseBody,
  Record<string, any>,
  202 | 400 | 403 | 404 | 422
>;

export type ReposCreateForkHandler = (
  req: ReposCreateForkRequest,
  res: ReposCreateForkResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitCreateBlobRequest = Request<
  GitCreateBlobRequestPath,
  | GitCreateBlob201ResponseBody
  | GitCreateBlob403ResponseBody
  | GitCreateBlob404ResponseBody
  | GitCreateBlob409ResponseBody
  | GitCreateBlob422ResponseBody,
  GitCreateBlobRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GitCreateBlobResponse = Response<
  | GitCreateBlob201ResponseBody
  | GitCreateBlob403ResponseBody
  | GitCreateBlob404ResponseBody
  | GitCreateBlob409ResponseBody
  | GitCreateBlob422ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 409 | 422
>;

export type GitCreateBlobHandler = (
  req: GitCreateBlobRequest,
  res: GitCreateBlobResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitGetBlobRequest = Request<
  GitGetBlobRequestPath,
  | GitGetBlob200ResponseBody
  | GitGetBlob403ResponseBody
  | GitGetBlob404ResponseBody
  | GitGetBlob422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitGetBlobResponse = Response<
  | GitGetBlob200ResponseBody
  | GitGetBlob403ResponseBody
  | GitGetBlob404ResponseBody
  | GitGetBlob422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export type GitGetBlobHandler = (
  req: GitGetBlobRequest,
  res: GitGetBlobResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitCreateCommitRequest = Request<
  GitCreateCommitRequestPath,
  | GitCreateCommit201ResponseBody
  | GitCreateCommit404ResponseBody
  | GitCreateCommit422ResponseBody,
  GitCreateCommitRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GitCreateCommitResponse = Response<
  | GitCreateCommit201ResponseBody
  | GitCreateCommit404ResponseBody
  | GitCreateCommit422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export type GitCreateCommitHandler = (
  req: GitCreateCommitRequest,
  res: GitCreateCommitResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitGetCommitRequest = Request<
  GitGetCommitRequestPath,
  GitGetCommit200ResponseBody | GitGetCommit404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitGetCommitResponse = Response<
  GitGetCommit200ResponseBody | GitGetCommit404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type GitGetCommitHandler = (
  req: GitGetCommitRequest,
  res: GitGetCommitResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitListMatchingRefsRequest = Request<
  GitListMatchingRefsRequestPath,
  GitListMatchingRefs200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitListMatchingRefsResponse = Response<
  GitListMatchingRefs200ResponseBody,
  Record<string, any>,
  200
>;

export type GitListMatchingRefsHandler = (
  req: GitListMatchingRefsRequest,
  res: GitListMatchingRefsResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitGetRefRequest = Request<
  GitGetRefRequestPath,
  GitGetRef200ResponseBody | GitGetRef404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitGetRefResponse = Response<
  GitGetRef200ResponseBody | GitGetRef404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type GitGetRefHandler = (
  req: GitGetRefRequest,
  res: GitGetRefResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitCreateRefRequest = Request<
  GitCreateRefRequestPath,
  GitCreateRef201ResponseBody | GitCreateRef422ResponseBody,
  GitCreateRefRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GitCreateRefResponse = Response<
  GitCreateRef201ResponseBody | GitCreateRef422ResponseBody,
  Record<string, any>,
  201 | 422
>;

export type GitCreateRefHandler = (
  req: GitCreateRefRequest,
  res: GitCreateRefResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitUpdateRefRequest = Request<
  GitUpdateRefRequestPath,
  GitUpdateRef200ResponseBody | GitUpdateRef422ResponseBody,
  GitUpdateRefRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GitUpdateRefResponse = Response<
  GitUpdateRef200ResponseBody | GitUpdateRef422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type GitUpdateRefHandler = (
  req: GitUpdateRefRequest,
  res: GitUpdateRefResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitDeleteRefRequest = Request<
  GitDeleteRefRequestPath,
  GitDeleteRef422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitDeleteRefResponse = Response<
  GitDeleteRef422ResponseBody,
  Record<string, any>,
  204 | 422
>;

export type GitDeleteRefHandler = (
  req: GitDeleteRefRequest,
  res: GitDeleteRefResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitCreateTagRequest = Request<
  GitCreateTagRequestPath,
  GitCreateTag201ResponseBody | GitCreateTag422ResponseBody,
  GitCreateTagRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GitCreateTagResponse = Response<
  GitCreateTag201ResponseBody | GitCreateTag422ResponseBody,
  Record<string, any>,
  201 | 422
>;

export type GitCreateTagHandler = (
  req: GitCreateTagRequest,
  res: GitCreateTagResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitGetTagRequest = Request<
  GitGetTagRequestPath,
  GitGetTag200ResponseBody | GitGetTag404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitGetTagResponse = Response<
  GitGetTag200ResponseBody | GitGetTag404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type GitGetTagHandler = (
  req: GitGetTagRequest,
  res: GitGetTagResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitCreateTreeRequest = Request<
  GitCreateTreeRequestPath,
  | GitCreateTree201ResponseBody
  | GitCreateTree403ResponseBody
  | GitCreateTree404ResponseBody
  | GitCreateTree422ResponseBody,
  GitCreateTreeRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GitCreateTreeResponse = Response<
  | GitCreateTree201ResponseBody
  | GitCreateTree403ResponseBody
  | GitCreateTree404ResponseBody
  | GitCreateTree422ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 422
>;

export type GitCreateTreeHandler = (
  req: GitCreateTreeRequest,
  res: GitCreateTreeResponse,
  next: NextFunction
) => Promise<void> | void;

export type GitGetTreeRequest = Request<
  GitGetTreeRequestPath,
  | GitGetTree200ResponseBody
  | GitGetTree404ResponseBody
  | GitGetTree422ResponseBody,
  unknown,
  GitGetTreeRequestQuery,
  Record<string, any>
>;

export type GitGetTreeResponse = Response<
  | GitGetTree200ResponseBody
  | GitGetTree404ResponseBody
  | GitGetTree422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type GitGetTreeHandler = (
  req: GitGetTreeRequest,
  res: GitGetTreeResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListWebhooksRequest = Request<
  ReposListWebhooksRequestPath,
  ReposListWebhooks200ResponseBody | ReposListWebhooks404ResponseBody,
  unknown,
  ReposListWebhooksRequestQuery,
  Record<string, any>
>;

export type ReposListWebhooksResponse = Response<
  ReposListWebhooks200ResponseBody | ReposListWebhooks404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposListWebhooksHandler = (
  req: ReposListWebhooksRequest,
  res: ReposListWebhooksResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateWebhookRequest = Request<
  ReposCreateWebhookRequestPath,
  | ReposCreateWebhook201ResponseBody
  | ReposCreateWebhook403ResponseBody
  | ReposCreateWebhook404ResponseBody
  | ReposCreateWebhook422ResponseBody,
  ReposCreateWebhookRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateWebhookResponse = Response<
  | ReposCreateWebhook201ResponseBody
  | ReposCreateWebhook403ResponseBody
  | ReposCreateWebhook404ResponseBody
  | ReposCreateWebhook422ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 422
>;

export type ReposCreateWebhookHandler = (
  req: ReposCreateWebhookRequest,
  res: ReposCreateWebhookResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetWebhookRequest = Request<
  ReposGetWebhookRequestPath,
  ReposGetWebhook200ResponseBody | ReposGetWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetWebhookResponse = Response<
  ReposGetWebhook200ResponseBody | ReposGetWebhook404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetWebhookHandler = (
  req: ReposGetWebhookRequest,
  res: ReposGetWebhookResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposUpdateWebhookRequest = Request<
  ReposUpdateWebhookRequestPath,
  | ReposUpdateWebhook200ResponseBody
  | ReposUpdateWebhook404ResponseBody
  | ReposUpdateWebhook422ResponseBody,
  ReposUpdateWebhookRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateWebhookResponse = Response<
  | ReposUpdateWebhook200ResponseBody
  | ReposUpdateWebhook404ResponseBody
  | ReposUpdateWebhook422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type ReposUpdateWebhookHandler = (
  req: ReposUpdateWebhookRequest,
  res: ReposUpdateWebhookResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteWebhookRequest = Request<
  ReposDeleteWebhookRequestPath,
  ReposDeleteWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteWebhookResponse = Response<
  ReposDeleteWebhook404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type ReposDeleteWebhookHandler = (
  req: ReposDeleteWebhookRequest,
  res: ReposDeleteWebhookResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetWebhookConfigForRepoRequest = Request<
  ReposGetWebhookConfigForRepoRequestPath,
  ReposGetWebhookConfigForRepo200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetWebhookConfigForRepoResponse = Response<
  ReposGetWebhookConfigForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposGetWebhookConfigForRepoHandler = (
  req: ReposGetWebhookConfigForRepoRequest,
  res: ReposGetWebhookConfigForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposUpdateWebhookConfigForRepoRequest = Request<
  ReposUpdateWebhookConfigForRepoRequestPath,
  ReposUpdateWebhookConfigForRepo200ResponseBody,
  ReposUpdateWebhookConfigForRepoRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateWebhookConfigForRepoResponse = Response<
  ReposUpdateWebhookConfigForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposUpdateWebhookConfigForRepoHandler = (
  req: ReposUpdateWebhookConfigForRepoRequest,
  res: ReposUpdateWebhookConfigForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListWebhookDeliveriesRequest = Request<
  ReposListWebhookDeliveriesRequestPath,
  | ReposListWebhookDeliveries200ResponseBody
  | ReposListWebhookDeliveries400ResponseBody
  | ReposListWebhookDeliveries422ResponseBody,
  unknown,
  ReposListWebhookDeliveriesRequestQuery,
  Record<string, any>
>;

export type ReposListWebhookDeliveriesResponse = Response<
  | ReposListWebhookDeliveries200ResponseBody
  | ReposListWebhookDeliveries400ResponseBody
  | ReposListWebhookDeliveries422ResponseBody,
  Record<string, any>,
  200 | 400 | 422
>;

export type ReposListWebhookDeliveriesHandler = (
  req: ReposListWebhookDeliveriesRequest,
  res: ReposListWebhookDeliveriesResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetWebhookDeliveryRequest = Request<
  ReposGetWebhookDeliveryRequestPath,
  | ReposGetWebhookDelivery200ResponseBody
  | ReposGetWebhookDelivery400ResponseBody
  | ReposGetWebhookDelivery422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetWebhookDeliveryResponse = Response<
  | ReposGetWebhookDelivery200ResponseBody
  | ReposGetWebhookDelivery400ResponseBody
  | ReposGetWebhookDelivery422ResponseBody,
  Record<string, any>,
  200 | 400 | 422
>;

export type ReposGetWebhookDeliveryHandler = (
  req: ReposGetWebhookDeliveryRequest,
  res: ReposGetWebhookDeliveryResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposRedeliverWebhookDeliveryRequest = Request<
  ReposRedeliverWebhookDeliveryRequestPath,
  | ReposRedeliverWebhookDelivery202ResponseBody
  | ReposRedeliverWebhookDelivery400ResponseBody
  | ReposRedeliverWebhookDelivery422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposRedeliverWebhookDeliveryResponse = Response<
  | ReposRedeliverWebhookDelivery202ResponseBody
  | ReposRedeliverWebhookDelivery400ResponseBody
  | ReposRedeliverWebhookDelivery422ResponseBody,
  Record<string, any>,
  202 | 400 | 422
>;

export type ReposRedeliverWebhookDeliveryHandler = (
  req: ReposRedeliverWebhookDeliveryRequest,
  res: ReposRedeliverWebhookDeliveryResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposPingWebhookRequest = Request<
  ReposPingWebhookRequestPath,
  ReposPingWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposPingWebhookResponse = Response<
  ReposPingWebhook404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type ReposPingWebhookHandler = (
  req: ReposPingWebhookRequest,
  res: ReposPingWebhookResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposTestPushWebhookRequest = Request<
  ReposTestPushWebhookRequestPath,
  ReposTestPushWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposTestPushWebhookResponse = Response<
  ReposTestPushWebhook404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type ReposTestPushWebhookHandler = (
  req: ReposTestPushWebhookRequest,
  res: ReposTestPushWebhookResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsGetImportStatusRequest = Request<
  MigrationsGetImportStatusRequestPath,
  | MigrationsGetImportStatus200ResponseBody
  | MigrationsGetImportStatus404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsGetImportStatusResponse = Response<
  | MigrationsGetImportStatus200ResponseBody
  | MigrationsGetImportStatus404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type MigrationsGetImportStatusHandler = (
  req: MigrationsGetImportStatusRequest,
  res: MigrationsGetImportStatusResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsStartImportRequest = Request<
  MigrationsStartImportRequestPath,
  | MigrationsStartImport201ResponseBody
  | MigrationsStartImport404ResponseBody
  | MigrationsStartImport422ResponseBody,
  MigrationsStartImportRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsStartImportResponse = Response<
  | MigrationsStartImport201ResponseBody
  | MigrationsStartImport404ResponseBody
  | MigrationsStartImport422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export type MigrationsStartImportHandler = (
  req: MigrationsStartImportRequest,
  res: MigrationsStartImportResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsUpdateImportRequest = Request<
  MigrationsUpdateImportRequestPath,
  MigrationsUpdateImport200ResponseBody,
  MigrationsUpdateImportRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsUpdateImportResponse = Response<
  MigrationsUpdateImport200ResponseBody,
  Record<string, any>,
  200
>;

export type MigrationsUpdateImportHandler = (
  req: MigrationsUpdateImportRequest,
  res: MigrationsUpdateImportResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsCancelImportRequest = Request<
  MigrationsCancelImportRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsCancelImportResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type MigrationsCancelImportHandler = (
  req: MigrationsCancelImportRequest,
  res: MigrationsCancelImportResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsGetCommitAuthorsRequest = Request<
  MigrationsGetCommitAuthorsRequestPath,
  | MigrationsGetCommitAuthors200ResponseBody
  | MigrationsGetCommitAuthors404ResponseBody,
  unknown,
  MigrationsGetCommitAuthorsRequestQuery,
  Record<string, any>
>;

export type MigrationsGetCommitAuthorsResponse = Response<
  | MigrationsGetCommitAuthors200ResponseBody
  | MigrationsGetCommitAuthors404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type MigrationsGetCommitAuthorsHandler = (
  req: MigrationsGetCommitAuthorsRequest,
  res: MigrationsGetCommitAuthorsResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsMapCommitAuthorRequest = Request<
  MigrationsMapCommitAuthorRequestPath,
  | MigrationsMapCommitAuthor200ResponseBody
  | MigrationsMapCommitAuthor404ResponseBody
  | MigrationsMapCommitAuthor422ResponseBody,
  MigrationsMapCommitAuthorRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsMapCommitAuthorResponse = Response<
  | MigrationsMapCommitAuthor200ResponseBody
  | MigrationsMapCommitAuthor404ResponseBody
  | MigrationsMapCommitAuthor422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type MigrationsMapCommitAuthorHandler = (
  req: MigrationsMapCommitAuthorRequest,
  res: MigrationsMapCommitAuthorResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsGetLargeFilesRequest = Request<
  MigrationsGetLargeFilesRequestPath,
  MigrationsGetLargeFiles200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsGetLargeFilesResponse = Response<
  MigrationsGetLargeFiles200ResponseBody,
  Record<string, any>,
  200
>;

export type MigrationsGetLargeFilesHandler = (
  req: MigrationsGetLargeFilesRequest,
  res: MigrationsGetLargeFilesResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsSetLfsPreferenceRequest = Request<
  MigrationsSetLfsPreferenceRequestPath,
  | MigrationsSetLfsPreference200ResponseBody
  | MigrationsSetLfsPreference422ResponseBody,
  MigrationsSetLfsPreferenceRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsSetLfsPreferenceResponse = Response<
  | MigrationsSetLfsPreference200ResponseBody
  | MigrationsSetLfsPreference422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type MigrationsSetLfsPreferenceHandler = (
  req: MigrationsSetLfsPreferenceRequest,
  res: MigrationsSetLfsPreferenceResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsGetRepoInstallationRequest = Request<
  AppsGetRepoInstallationRequestPath,
  | AppsGetRepoInstallation200ResponseBody
  | AppsGetRepoInstallation301ResponseBody
  | AppsGetRepoInstallation404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetRepoInstallationResponse = Response<
  | AppsGetRepoInstallation200ResponseBody
  | AppsGetRepoInstallation301ResponseBody
  | AppsGetRepoInstallation404ResponseBody,
  Record<string, any>,
  200 | 301 | 404
>;

export type AppsGetRepoInstallationHandler = (
  req: AppsGetRepoInstallationRequest,
  res: AppsGetRepoInstallationResponse,
  next: NextFunction
) => Promise<void> | void;

export type InteractionsGetRestrictionsForRepoRequest = Request<
  InteractionsGetRestrictionsForRepoRequestPath,
  InteractionsGetRestrictionsForRepo200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsGetRestrictionsForRepoResponse = Response<
  InteractionsGetRestrictionsForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export type InteractionsGetRestrictionsForRepoHandler = (
  req: InteractionsGetRestrictionsForRepoRequest,
  res: InteractionsGetRestrictionsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type InteractionsSetRestrictionsForRepoRequest = Request<
  InteractionsSetRestrictionsForRepoRequestPath,
  InteractionsSetRestrictionsForRepo200ResponseBody,
  InteractionsSetRestrictionsForRepoRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsSetRestrictionsForRepoResponse = Response<
  InteractionsSetRestrictionsForRepo200ResponseBody,
  Record<string, any>,
  200 | 409
>;

export type InteractionsSetRestrictionsForRepoHandler = (
  req: InteractionsSetRestrictionsForRepoRequest,
  res: InteractionsSetRestrictionsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type InteractionsRemoveRestrictionsForRepoRequest = Request<
  InteractionsRemoveRestrictionsForRepoRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsRemoveRestrictionsForRepoResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export type InteractionsRemoveRestrictionsForRepoHandler = (
  req: InteractionsRemoveRestrictionsForRepoRequest,
  res: InteractionsRemoveRestrictionsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListInvitationsRequest = Request<
  ReposListInvitationsRequestPath,
  ReposListInvitations200ResponseBody,
  unknown,
  ReposListInvitationsRequestQuery,
  Record<string, any>
>;

export type ReposListInvitationsResponse = Response<
  ReposListInvitations200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListInvitationsHandler = (
  req: ReposListInvitationsRequest,
  res: ReposListInvitationsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposUpdateInvitationRequest = Request<
  ReposUpdateInvitationRequestPath,
  ReposUpdateInvitation200ResponseBody,
  ReposUpdateInvitationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateInvitationResponse = Response<
  ReposUpdateInvitation200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposUpdateInvitationHandler = (
  req: ReposUpdateInvitationRequest,
  res: ReposUpdateInvitationResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteInvitationRequest = Request<
  ReposDeleteInvitationRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteInvitationResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposDeleteInvitationHandler = (
  req: ReposDeleteInvitationRequest,
  res: ReposDeleteInvitationResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListForRepoRequest = Request<
  IssuesListForRepoRequestPath,
  | IssuesListForRepo200ResponseBody
  | IssuesListForRepo301ResponseBody
  | IssuesListForRepo404ResponseBody
  | IssuesListForRepo422ResponseBody,
  unknown,
  IssuesListForRepoRequestQuery,
  Record<string, any>
>;

export type IssuesListForRepoResponse = Response<
  | IssuesListForRepo200ResponseBody
  | IssuesListForRepo301ResponseBody
  | IssuesListForRepo404ResponseBody
  | IssuesListForRepo422ResponseBody,
  Record<string, any>,
  200 | 301 | 404 | 422
>;

export type IssuesListForRepoHandler = (
  req: IssuesListForRepoRequest,
  res: IssuesListForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesCreateRequest = Request<
  IssuesCreateRequestPath,
  | IssuesCreate201ResponseBody
  | IssuesCreate403ResponseBody
  | IssuesCreate404ResponseBody
  | IssuesCreate410ResponseBody
  | IssuesCreate422ResponseBody
  | IssuesCreate503ResponseBody,
  IssuesCreateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesCreateResponse = Response<
  | IssuesCreate201ResponseBody
  | IssuesCreate403ResponseBody
  | IssuesCreate404ResponseBody
  | IssuesCreate410ResponseBody
  | IssuesCreate422ResponseBody
  | IssuesCreate503ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 410 | 422 | 503
>;

export type IssuesCreateHandler = (
  req: IssuesCreateRequest,
  res: IssuesCreateResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListCommentsForRepoRequest = Request<
  IssuesListCommentsForRepoRequestPath,
  | IssuesListCommentsForRepo200ResponseBody
  | IssuesListCommentsForRepo404ResponseBody
  | IssuesListCommentsForRepo422ResponseBody,
  unknown,
  IssuesListCommentsForRepoRequestQuery,
  Record<string, any>
>;

export type IssuesListCommentsForRepoResponse = Response<
  | IssuesListCommentsForRepo200ResponseBody
  | IssuesListCommentsForRepo404ResponseBody
  | IssuesListCommentsForRepo422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type IssuesListCommentsForRepoHandler = (
  req: IssuesListCommentsForRepoRequest,
  res: IssuesListCommentsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesGetCommentRequest = Request<
  IssuesGetCommentRequestPath,
  IssuesGetComment200ResponseBody | IssuesGetComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesGetCommentResponse = Response<
  IssuesGetComment200ResponseBody | IssuesGetComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type IssuesGetCommentHandler = (
  req: IssuesGetCommentRequest,
  res: IssuesGetCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesUpdateCommentRequest = Request<
  IssuesUpdateCommentRequestPath,
  IssuesUpdateComment200ResponseBody | IssuesUpdateComment422ResponseBody,
  IssuesUpdateCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesUpdateCommentResponse = Response<
  IssuesUpdateComment200ResponseBody | IssuesUpdateComment422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type IssuesUpdateCommentHandler = (
  req: IssuesUpdateCommentRequest,
  res: IssuesUpdateCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesDeleteCommentRequest = Request<
  IssuesDeleteCommentRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesDeleteCommentResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type IssuesDeleteCommentHandler = (
  req: IssuesDeleteCommentRequest,
  res: IssuesDeleteCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsListForIssueCommentRequest = Request<
  ReactionsListForIssueCommentRequestPath,
  | ReactionsListForIssueComment200ResponseBody
  | ReactionsListForIssueComment404ResponseBody,
  unknown,
  ReactionsListForIssueCommentRequestQuery,
  Record<string, any>
>;

export type ReactionsListForIssueCommentResponse = Response<
  | ReactionsListForIssueComment200ResponseBody
  | ReactionsListForIssueComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReactionsListForIssueCommentHandler = (
  req: ReactionsListForIssueCommentRequest,
  res: ReactionsListForIssueCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsCreateForIssueCommentRequest = Request<
  ReactionsCreateForIssueCommentRequestPath,
  | ReactionsCreateForIssueComment200ResponseBody
  | ReactionsCreateForIssueComment201ResponseBody
  | ReactionsCreateForIssueComment422ResponseBody,
  ReactionsCreateForIssueCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForIssueCommentResponse = Response<
  | ReactionsCreateForIssueComment200ResponseBody
  | ReactionsCreateForIssueComment201ResponseBody
  | ReactionsCreateForIssueComment422ResponseBody,
  Record<string, any>,
  200 | 201 | 422
>;

export type ReactionsCreateForIssueCommentHandler = (
  req: ReactionsCreateForIssueCommentRequest,
  res: ReactionsCreateForIssueCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsDeleteForIssueCommentRequest = Request<
  ReactionsDeleteForIssueCommentRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForIssueCommentResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReactionsDeleteForIssueCommentHandler = (
  req: ReactionsDeleteForIssueCommentRequest,
  res: ReactionsDeleteForIssueCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListEventsForRepoRequest = Request<
  IssuesListEventsForRepoRequestPath,
  | IssuesListEventsForRepo200ResponseBody
  | IssuesListEventsForRepo422ResponseBody,
  unknown,
  IssuesListEventsForRepoRequestQuery,
  Record<string, any>
>;

export type IssuesListEventsForRepoResponse = Response<
  | IssuesListEventsForRepo200ResponseBody
  | IssuesListEventsForRepo422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type IssuesListEventsForRepoHandler = (
  req: IssuesListEventsForRepoRequest,
  res: IssuesListEventsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesGetEventRequest = Request<
  IssuesGetEventRequestPath,
  | IssuesGetEvent200ResponseBody
  | IssuesGetEvent403ResponseBody
  | IssuesGetEvent404ResponseBody
  | IssuesGetEvent410ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesGetEventResponse = Response<
  | IssuesGetEvent200ResponseBody
  | IssuesGetEvent403ResponseBody
  | IssuesGetEvent404ResponseBody
  | IssuesGetEvent410ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 410
>;

export type IssuesGetEventHandler = (
  req: IssuesGetEventRequest,
  res: IssuesGetEventResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesGetRequest = Request<
  IssuesGetRequestPath,
  | IssuesGet200ResponseBody
  | IssuesGet301ResponseBody
  | IssuesGet404ResponseBody
  | IssuesGet410ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesGetResponse = Response<
  | IssuesGet200ResponseBody
  | IssuesGet301ResponseBody
  | IssuesGet404ResponseBody
  | IssuesGet410ResponseBody,
  Record<string, any>,
  200 | 301 | 304 | 404 | 410
>;

export type IssuesGetHandler = (
  req: IssuesGetRequest,
  res: IssuesGetResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesUpdateRequest = Request<
  IssuesUpdateRequestPath,
  | IssuesUpdate200ResponseBody
  | IssuesUpdate301ResponseBody
  | IssuesUpdate403ResponseBody
  | IssuesUpdate404ResponseBody
  | IssuesUpdate410ResponseBody
  | IssuesUpdate422ResponseBody
  | IssuesUpdate503ResponseBody,
  IssuesUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesUpdateResponse = Response<
  | IssuesUpdate200ResponseBody
  | IssuesUpdate301ResponseBody
  | IssuesUpdate403ResponseBody
  | IssuesUpdate404ResponseBody
  | IssuesUpdate410ResponseBody
  | IssuesUpdate422ResponseBody
  | IssuesUpdate503ResponseBody,
  Record<string, any>,
  200 | 301 | 403 | 404 | 410 | 422 | 503
>;

export type IssuesUpdateHandler = (
  req: IssuesUpdateRequest,
  res: IssuesUpdateResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesAddAssigneesRequest = Request<
  IssuesAddAssigneesRequestPath,
  IssuesAddAssignees201ResponseBody,
  IssuesAddAssigneesRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesAddAssigneesResponse = Response<
  IssuesAddAssignees201ResponseBody,
  Record<string, any>,
  201
>;

export type IssuesAddAssigneesHandler = (
  req: IssuesAddAssigneesRequest,
  res: IssuesAddAssigneesResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesRemoveAssigneesRequest = Request<
  IssuesRemoveAssigneesRequestPath,
  IssuesRemoveAssignees200ResponseBody,
  IssuesRemoveAssigneesRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesRemoveAssigneesResponse = Response<
  IssuesRemoveAssignees200ResponseBody,
  Record<string, any>,
  200
>;

export type IssuesRemoveAssigneesHandler = (
  req: IssuesRemoveAssigneesRequest,
  res: IssuesRemoveAssigneesResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListCommentsRequest = Request<
  IssuesListCommentsRequestPath,
  | IssuesListComments200ResponseBody
  | IssuesListComments404ResponseBody
  | IssuesListComments410ResponseBody,
  unknown,
  IssuesListCommentsRequestQuery,
  Record<string, any>
>;

export type IssuesListCommentsResponse = Response<
  | IssuesListComments200ResponseBody
  | IssuesListComments404ResponseBody
  | IssuesListComments410ResponseBody,
  Record<string, any>,
  200 | 404 | 410
>;

export type IssuesListCommentsHandler = (
  req: IssuesListCommentsRequest,
  res: IssuesListCommentsResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesCreateCommentRequest = Request<
  IssuesCreateCommentRequestPath,
  | IssuesCreateComment201ResponseBody
  | IssuesCreateComment403ResponseBody
  | IssuesCreateComment404ResponseBody
  | IssuesCreateComment410ResponseBody
  | IssuesCreateComment422ResponseBody,
  IssuesCreateCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesCreateCommentResponse = Response<
  | IssuesCreateComment201ResponseBody
  | IssuesCreateComment403ResponseBody
  | IssuesCreateComment404ResponseBody
  | IssuesCreateComment410ResponseBody
  | IssuesCreateComment422ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 410 | 422
>;

export type IssuesCreateCommentHandler = (
  req: IssuesCreateCommentRequest,
  res: IssuesCreateCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListEventsRequest = Request<
  IssuesListEventsRequestPath,
  IssuesListEvents200ResponseBody | IssuesListEvents410ResponseBody,
  unknown,
  IssuesListEventsRequestQuery,
  Record<string, any>
>;

export type IssuesListEventsResponse = Response<
  IssuesListEvents200ResponseBody | IssuesListEvents410ResponseBody,
  Record<string, any>,
  200 | 410
>;

export type IssuesListEventsHandler = (
  req: IssuesListEventsRequest,
  res: IssuesListEventsResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListLabelsOnIssueRequest = Request<
  IssuesListLabelsOnIssueRequestPath,
  | IssuesListLabelsOnIssue200ResponseBody
  | IssuesListLabelsOnIssue301ResponseBody
  | IssuesListLabelsOnIssue404ResponseBody
  | IssuesListLabelsOnIssue410ResponseBody,
  unknown,
  IssuesListLabelsOnIssueRequestQuery,
  Record<string, any>
>;

export type IssuesListLabelsOnIssueResponse = Response<
  | IssuesListLabelsOnIssue200ResponseBody
  | IssuesListLabelsOnIssue301ResponseBody
  | IssuesListLabelsOnIssue404ResponseBody
  | IssuesListLabelsOnIssue410ResponseBody,
  Record<string, any>,
  200 | 301 | 404 | 410
>;

export type IssuesListLabelsOnIssueHandler = (
  req: IssuesListLabelsOnIssueRequest,
  res: IssuesListLabelsOnIssueResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesAddLabelsRequest = Request<
  IssuesAddLabelsRequestPath,
  | IssuesAddLabels200ResponseBody
  | IssuesAddLabels301ResponseBody
  | IssuesAddLabels404ResponseBody
  | IssuesAddLabels410ResponseBody
  | IssuesAddLabels422ResponseBody,
  IssuesAddLabelsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesAddLabelsResponse = Response<
  | IssuesAddLabels200ResponseBody
  | IssuesAddLabels301ResponseBody
  | IssuesAddLabels404ResponseBody
  | IssuesAddLabels410ResponseBody
  | IssuesAddLabels422ResponseBody,
  Record<string, any>,
  200 | 301 | 404 | 410 | 422
>;

export type IssuesAddLabelsHandler = (
  req: IssuesAddLabelsRequest,
  res: IssuesAddLabelsResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesSetLabelsRequest = Request<
  IssuesSetLabelsRequestPath,
  | IssuesSetLabels200ResponseBody
  | IssuesSetLabels301ResponseBody
  | IssuesSetLabels404ResponseBody
  | IssuesSetLabels410ResponseBody
  | IssuesSetLabels422ResponseBody,
  IssuesSetLabelsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesSetLabelsResponse = Response<
  | IssuesSetLabels200ResponseBody
  | IssuesSetLabels301ResponseBody
  | IssuesSetLabels404ResponseBody
  | IssuesSetLabels410ResponseBody
  | IssuesSetLabels422ResponseBody,
  Record<string, any>,
  200 | 301 | 404 | 410 | 422
>;

export type IssuesSetLabelsHandler = (
  req: IssuesSetLabelsRequest,
  res: IssuesSetLabelsResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesRemoveAllLabelsRequest = Request<
  IssuesRemoveAllLabelsRequestPath,
  | IssuesRemoveAllLabels301ResponseBody
  | IssuesRemoveAllLabels404ResponseBody
  | IssuesRemoveAllLabels410ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesRemoveAllLabelsResponse = Response<
  | IssuesRemoveAllLabels301ResponseBody
  | IssuesRemoveAllLabels404ResponseBody
  | IssuesRemoveAllLabels410ResponseBody,
  Record<string, any>,
  204 | 301 | 404 | 410
>;

export type IssuesRemoveAllLabelsHandler = (
  req: IssuesRemoveAllLabelsRequest,
  res: IssuesRemoveAllLabelsResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesRemoveLabelRequest = Request<
  IssuesRemoveLabelRequestPath,
  | IssuesRemoveLabel200ResponseBody
  | IssuesRemoveLabel301ResponseBody
  | IssuesRemoveLabel404ResponseBody
  | IssuesRemoveLabel410ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesRemoveLabelResponse = Response<
  | IssuesRemoveLabel200ResponseBody
  | IssuesRemoveLabel301ResponseBody
  | IssuesRemoveLabel404ResponseBody
  | IssuesRemoveLabel410ResponseBody,
  Record<string, any>,
  200 | 301 | 404 | 410
>;

export type IssuesRemoveLabelHandler = (
  req: IssuesRemoveLabelRequest,
  res: IssuesRemoveLabelResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesLockRequest = Request<
  IssuesLockRequestPath,
  | IssuesLock403ResponseBody
  | IssuesLock404ResponseBody
  | IssuesLock410ResponseBody
  | IssuesLock422ResponseBody,
  IssuesLockRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesLockResponse = Response<
  | IssuesLock403ResponseBody
  | IssuesLock404ResponseBody
  | IssuesLock410ResponseBody
  | IssuesLock422ResponseBody,
  Record<string, any>,
  204 | 403 | 404 | 410 | 422
>;

export type IssuesLockHandler = (
  req: IssuesLockRequest,
  res: IssuesLockResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesUnlockRequest = Request<
  IssuesUnlockRequestPath,
  IssuesUnlock403ResponseBody | IssuesUnlock404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesUnlockResponse = Response<
  IssuesUnlock403ResponseBody | IssuesUnlock404ResponseBody,
  Record<string, any>,
  204 | 403 | 404
>;

export type IssuesUnlockHandler = (
  req: IssuesUnlockRequest,
  res: IssuesUnlockResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsListForIssueRequest = Request<
  ReactionsListForIssueRequestPath,
  | ReactionsListForIssue200ResponseBody
  | ReactionsListForIssue404ResponseBody
  | ReactionsListForIssue410ResponseBody,
  unknown,
  ReactionsListForIssueRequestQuery,
  Record<string, any>
>;

export type ReactionsListForIssueResponse = Response<
  | ReactionsListForIssue200ResponseBody
  | ReactionsListForIssue404ResponseBody
  | ReactionsListForIssue410ResponseBody,
  Record<string, any>,
  200 | 404 | 410
>;

export type ReactionsListForIssueHandler = (
  req: ReactionsListForIssueRequest,
  res: ReactionsListForIssueResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsCreateForIssueRequest = Request<
  ReactionsCreateForIssueRequestPath,
  | ReactionsCreateForIssue200ResponseBody
  | ReactionsCreateForIssue201ResponseBody
  | ReactionsCreateForIssue422ResponseBody,
  ReactionsCreateForIssueRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForIssueResponse = Response<
  | ReactionsCreateForIssue200ResponseBody
  | ReactionsCreateForIssue201ResponseBody
  | ReactionsCreateForIssue422ResponseBody,
  Record<string, any>,
  200 | 201 | 422
>;

export type ReactionsCreateForIssueHandler = (
  req: ReactionsCreateForIssueRequest,
  res: ReactionsCreateForIssueResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsDeleteForIssueRequest = Request<
  ReactionsDeleteForIssueRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForIssueResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReactionsDeleteForIssueHandler = (
  req: ReactionsDeleteForIssueRequest,
  res: ReactionsDeleteForIssueResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListEventsForTimelineRequest = Request<
  IssuesListEventsForTimelineRequestPath,
  | IssuesListEventsForTimeline200ResponseBody
  | IssuesListEventsForTimeline404ResponseBody
  | IssuesListEventsForTimeline410ResponseBody,
  unknown,
  IssuesListEventsForTimelineRequestQuery,
  Record<string, any>
>;

export type IssuesListEventsForTimelineResponse = Response<
  | IssuesListEventsForTimeline200ResponseBody
  | IssuesListEventsForTimeline404ResponseBody
  | IssuesListEventsForTimeline410ResponseBody,
  Record<string, any>,
  200 | 404 | 410
>;

export type IssuesListEventsForTimelineHandler = (
  req: IssuesListEventsForTimelineRequest,
  res: IssuesListEventsForTimelineResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListDeployKeysRequest = Request<
  ReposListDeployKeysRequestPath,
  ReposListDeployKeys200ResponseBody,
  unknown,
  ReposListDeployKeysRequestQuery,
  Record<string, any>
>;

export type ReposListDeployKeysResponse = Response<
  ReposListDeployKeys200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListDeployKeysHandler = (
  req: ReposListDeployKeysRequest,
  res: ReposListDeployKeysResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateDeployKeyRequest = Request<
  ReposCreateDeployKeyRequestPath,
  ReposCreateDeployKey201ResponseBody | ReposCreateDeployKey422ResponseBody,
  ReposCreateDeployKeyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateDeployKeyResponse = Response<
  ReposCreateDeployKey201ResponseBody | ReposCreateDeployKey422ResponseBody,
  Record<string, any>,
  201 | 422
>;

export type ReposCreateDeployKeyHandler = (
  req: ReposCreateDeployKeyRequest,
  res: ReposCreateDeployKeyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetDeployKeyRequest = Request<
  ReposGetDeployKeyRequestPath,
  ReposGetDeployKey200ResponseBody | ReposGetDeployKey404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetDeployKeyResponse = Response<
  ReposGetDeployKey200ResponseBody | ReposGetDeployKey404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetDeployKeyHandler = (
  req: ReposGetDeployKeyRequest,
  res: ReposGetDeployKeyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteDeployKeyRequest = Request<
  ReposDeleteDeployKeyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteDeployKeyResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposDeleteDeployKeyHandler = (
  req: ReposDeleteDeployKeyRequest,
  res: ReposDeleteDeployKeyResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListLabelsForRepoRequest = Request<
  IssuesListLabelsForRepoRequestPath,
  | IssuesListLabelsForRepo200ResponseBody
  | IssuesListLabelsForRepo404ResponseBody,
  unknown,
  IssuesListLabelsForRepoRequestQuery,
  Record<string, any>
>;

export type IssuesListLabelsForRepoResponse = Response<
  | IssuesListLabelsForRepo200ResponseBody
  | IssuesListLabelsForRepo404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type IssuesListLabelsForRepoHandler = (
  req: IssuesListLabelsForRepoRequest,
  res: IssuesListLabelsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesCreateLabelRequest = Request<
  IssuesCreateLabelRequestPath,
  | IssuesCreateLabel201ResponseBody
  | IssuesCreateLabel404ResponseBody
  | IssuesCreateLabel422ResponseBody,
  IssuesCreateLabelRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesCreateLabelResponse = Response<
  | IssuesCreateLabel201ResponseBody
  | IssuesCreateLabel404ResponseBody
  | IssuesCreateLabel422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export type IssuesCreateLabelHandler = (
  req: IssuesCreateLabelRequest,
  res: IssuesCreateLabelResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesGetLabelRequest = Request<
  IssuesGetLabelRequestPath,
  IssuesGetLabel200ResponseBody | IssuesGetLabel404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesGetLabelResponse = Response<
  IssuesGetLabel200ResponseBody | IssuesGetLabel404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type IssuesGetLabelHandler = (
  req: IssuesGetLabelRequest,
  res: IssuesGetLabelResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesUpdateLabelRequest = Request<
  IssuesUpdateLabelRequestPath,
  IssuesUpdateLabel200ResponseBody,
  IssuesUpdateLabelRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesUpdateLabelResponse = Response<
  IssuesUpdateLabel200ResponseBody,
  Record<string, any>,
  200
>;

export type IssuesUpdateLabelHandler = (
  req: IssuesUpdateLabelRequest,
  res: IssuesUpdateLabelResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesDeleteLabelRequest = Request<
  IssuesDeleteLabelRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesDeleteLabelResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type IssuesDeleteLabelHandler = (
  req: IssuesDeleteLabelRequest,
  res: IssuesDeleteLabelResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListLanguagesRequest = Request<
  ReposListLanguagesRequestPath,
  ReposListLanguages200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposListLanguagesResponse = Response<
  ReposListLanguages200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListLanguagesHandler = (
  req: ReposListLanguagesRequest,
  res: ReposListLanguagesResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposEnableLfsForRepoRequest = Request<
  ReposEnableLfsForRepoRequestPath,
  ReposEnableLfsForRepo202ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposEnableLfsForRepoResponse = Response<
  ReposEnableLfsForRepo202ResponseBody,
  Record<string, any>,
  202 | 403
>;

export type ReposEnableLfsForRepoHandler = (
  req: ReposEnableLfsForRepoRequest,
  res: ReposEnableLfsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDisableLfsForRepoRequest = Request<
  ReposDisableLfsForRepoRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDisableLfsForRepoResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposDisableLfsForRepoHandler = (
  req: ReposDisableLfsForRepoRequest,
  res: ReposDisableLfsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type LicensesGetForRepoRequest = Request<
  LicensesGetForRepoRequestPath,
  LicensesGetForRepo200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type LicensesGetForRepoResponse = Response<
  LicensesGetForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export type LicensesGetForRepoHandler = (
  req: LicensesGetForRepoRequest,
  res: LicensesGetForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposMergeUpstreamRequest = Request<
  ReposMergeUpstreamRequestPath,
  ReposMergeUpstream200ResponseBody,
  ReposMergeUpstreamRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposMergeUpstreamResponse = Response<
  ReposMergeUpstream200ResponseBody,
  Record<string, any>,
  200 | 409 | 422
>;

export type ReposMergeUpstreamHandler = (
  req: ReposMergeUpstreamRequest,
  res: ReposMergeUpstreamResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposMergeRequest = Request<
  ReposMergeRequestPath,
  | ReposMerge201ResponseBody
  | ReposMerge403ResponseBody
  | ReposMerge422ResponseBody,
  ReposMergeRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposMergeResponse = Response<
  | ReposMerge201ResponseBody
  | ReposMerge403ResponseBody
  | ReposMerge422ResponseBody,
  Record<string, any>,
  201 | 204 | 403 | 404 | 409 | 422
>;

export type ReposMergeHandler = (
  req: ReposMergeRequest,
  res: ReposMergeResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListMilestonesRequest = Request<
  IssuesListMilestonesRequestPath,
  IssuesListMilestones200ResponseBody | IssuesListMilestones404ResponseBody,
  unknown,
  IssuesListMilestonesRequestQuery,
  Record<string, any>
>;

export type IssuesListMilestonesResponse = Response<
  IssuesListMilestones200ResponseBody | IssuesListMilestones404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type IssuesListMilestonesHandler = (
  req: IssuesListMilestonesRequest,
  res: IssuesListMilestonesResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesCreateMilestoneRequest = Request<
  IssuesCreateMilestoneRequestPath,
  | IssuesCreateMilestone201ResponseBody
  | IssuesCreateMilestone404ResponseBody
  | IssuesCreateMilestone422ResponseBody,
  IssuesCreateMilestoneRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesCreateMilestoneResponse = Response<
  | IssuesCreateMilestone201ResponseBody
  | IssuesCreateMilestone404ResponseBody
  | IssuesCreateMilestone422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export type IssuesCreateMilestoneHandler = (
  req: IssuesCreateMilestoneRequest,
  res: IssuesCreateMilestoneResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesGetMilestoneRequest = Request<
  IssuesGetMilestoneRequestPath,
  IssuesGetMilestone200ResponseBody | IssuesGetMilestone404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesGetMilestoneResponse = Response<
  IssuesGetMilestone200ResponseBody | IssuesGetMilestone404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type IssuesGetMilestoneHandler = (
  req: IssuesGetMilestoneRequest,
  res: IssuesGetMilestoneResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesUpdateMilestoneRequest = Request<
  IssuesUpdateMilestoneRequestPath,
  IssuesUpdateMilestone200ResponseBody,
  IssuesUpdateMilestoneRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesUpdateMilestoneResponse = Response<
  IssuesUpdateMilestone200ResponseBody,
  Record<string, any>,
  200
>;

export type IssuesUpdateMilestoneHandler = (
  req: IssuesUpdateMilestoneRequest,
  res: IssuesUpdateMilestoneResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesDeleteMilestoneRequest = Request<
  IssuesDeleteMilestoneRequestPath,
  IssuesDeleteMilestone404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesDeleteMilestoneResponse = Response<
  IssuesDeleteMilestone404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type IssuesDeleteMilestoneHandler = (
  req: IssuesDeleteMilestoneRequest,
  res: IssuesDeleteMilestoneResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListLabelsForMilestoneRequest = Request<
  IssuesListLabelsForMilestoneRequestPath,
  IssuesListLabelsForMilestone200ResponseBody,
  unknown,
  IssuesListLabelsForMilestoneRequestQuery,
  Record<string, any>
>;

export type IssuesListLabelsForMilestoneResponse = Response<
  IssuesListLabelsForMilestone200ResponseBody,
  Record<string, any>,
  200
>;

export type IssuesListLabelsForMilestoneHandler = (
  req: IssuesListLabelsForMilestoneRequest,
  res: IssuesListLabelsForMilestoneResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListRepoNotificationsForAuthenticatedUserRequest = Request<
  ActivityListRepoNotificationsForAuthenticatedUserRequestPath,
  ActivityListRepoNotificationsForAuthenticatedUser200ResponseBody,
  unknown,
  ActivityListRepoNotificationsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ActivityListRepoNotificationsForAuthenticatedUserResponse = Response<
  ActivityListRepoNotificationsForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export type ActivityListRepoNotificationsForAuthenticatedUserHandler = (
  req: ActivityListRepoNotificationsForAuthenticatedUserRequest,
  res: ActivityListRepoNotificationsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityMarkRepoNotificationsAsReadRequest = Request<
  ActivityMarkRepoNotificationsAsReadRequestPath,
  ActivityMarkRepoNotificationsAsRead202ResponseBody,
  ActivityMarkRepoNotificationsAsReadRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActivityMarkRepoNotificationsAsReadResponse = Response<
  ActivityMarkRepoNotificationsAsRead202ResponseBody,
  Record<string, any>,
  202 | 205
>;

export type ActivityMarkRepoNotificationsAsReadHandler = (
  req: ActivityMarkRepoNotificationsAsReadRequest,
  res: ActivityMarkRepoNotificationsAsReadResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetPagesRequest = Request<
  ReposGetPagesRequestPath,
  ReposGetPages200ResponseBody | ReposGetPages404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetPagesResponse = Response<
  ReposGetPages200ResponseBody | ReposGetPages404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetPagesHandler = (
  req: ReposGetPagesRequest,
  res: ReposGetPagesResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreatePagesSiteRequest = Request<
  ReposCreatePagesSiteRequestPath,
  | ReposCreatePagesSite201ResponseBody
  | ReposCreatePagesSite409ResponseBody
  | ReposCreatePagesSite422ResponseBody,
  ReposCreatePagesSiteRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreatePagesSiteResponse = Response<
  | ReposCreatePagesSite201ResponseBody
  | ReposCreatePagesSite409ResponseBody
  | ReposCreatePagesSite422ResponseBody,
  Record<string, any>,
  201 | 409 | 422
>;

export type ReposCreatePagesSiteHandler = (
  req: ReposCreatePagesSiteRequest,
  res: ReposCreatePagesSiteResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposUpdateInformationAboutPagesSiteRequest = Request<
  ReposUpdateInformationAboutPagesSiteRequestPath,
  | ReposUpdateInformationAboutPagesSite400ResponseBody
  | ReposUpdateInformationAboutPagesSite409ResponseBody
  | ReposUpdateInformationAboutPagesSite422ResponseBody,
  ReposUpdateInformationAboutPagesSiteRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateInformationAboutPagesSiteResponse = Response<
  | ReposUpdateInformationAboutPagesSite400ResponseBody
  | ReposUpdateInformationAboutPagesSite409ResponseBody
  | ReposUpdateInformationAboutPagesSite422ResponseBody,
  Record<string, any>,
  204 | 400 | 409 | 422
>;

export type ReposUpdateInformationAboutPagesSiteHandler = (
  req: ReposUpdateInformationAboutPagesSiteRequest,
  res: ReposUpdateInformationAboutPagesSiteResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeletePagesSiteRequest = Request<
  ReposDeletePagesSiteRequestPath,
  | ReposDeletePagesSite404ResponseBody
  | ReposDeletePagesSite409ResponseBody
  | ReposDeletePagesSite422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeletePagesSiteResponse = Response<
  | ReposDeletePagesSite404ResponseBody
  | ReposDeletePagesSite409ResponseBody
  | ReposDeletePagesSite422ResponseBody,
  Record<string, any>,
  204 | 404 | 409 | 422
>;

export type ReposDeletePagesSiteHandler = (
  req: ReposDeletePagesSiteRequest,
  res: ReposDeletePagesSiteResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListPagesBuildsRequest = Request<
  ReposListPagesBuildsRequestPath,
  ReposListPagesBuilds200ResponseBody,
  unknown,
  ReposListPagesBuildsRequestQuery,
  Record<string, any>
>;

export type ReposListPagesBuildsResponse = Response<
  ReposListPagesBuilds200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListPagesBuildsHandler = (
  req: ReposListPagesBuildsRequest,
  res: ReposListPagesBuildsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposRequestPagesBuildRequest = Request<
  ReposRequestPagesBuildRequestPath,
  ReposRequestPagesBuild201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposRequestPagesBuildResponse = Response<
  ReposRequestPagesBuild201ResponseBody,
  Record<string, any>,
  201
>;

export type ReposRequestPagesBuildHandler = (
  req: ReposRequestPagesBuildRequest,
  res: ReposRequestPagesBuildResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetLatestPagesBuildRequest = Request<
  ReposGetLatestPagesBuildRequestPath,
  ReposGetLatestPagesBuild200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetLatestPagesBuildResponse = Response<
  ReposGetLatestPagesBuild200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposGetLatestPagesBuildHandler = (
  req: ReposGetLatestPagesBuildRequest,
  res: ReposGetLatestPagesBuildResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetPagesBuildRequest = Request<
  ReposGetPagesBuildRequestPath,
  ReposGetPagesBuild200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetPagesBuildResponse = Response<
  ReposGetPagesBuild200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposGetPagesBuildHandler = (
  req: ReposGetPagesBuildRequest,
  res: ReposGetPagesBuildResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreatePagesDeploymentRequest = Request<
  ReposCreatePagesDeploymentRequestPath,
  | ReposCreatePagesDeployment200ResponseBody
  | ReposCreatePagesDeployment400ResponseBody
  | ReposCreatePagesDeployment404ResponseBody
  | ReposCreatePagesDeployment422ResponseBody,
  ReposCreatePagesDeploymentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreatePagesDeploymentResponse = Response<
  | ReposCreatePagesDeployment200ResponseBody
  | ReposCreatePagesDeployment400ResponseBody
  | ReposCreatePagesDeployment404ResponseBody
  | ReposCreatePagesDeployment422ResponseBody,
  Record<string, any>,
  200 | 400 | 404 | 422
>;

export type ReposCreatePagesDeploymentHandler = (
  req: ReposCreatePagesDeploymentRequest,
  res: ReposCreatePagesDeploymentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetPagesHealthCheckRequest = Request<
  ReposGetPagesHealthCheckRequestPath,
  | ReposGetPagesHealthCheck200ResponseBody
  | ReposGetPagesHealthCheck202ResponseBody
  | ReposGetPagesHealthCheck404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetPagesHealthCheckResponse = Response<
  | ReposGetPagesHealthCheck200ResponseBody
  | ReposGetPagesHealthCheck202ResponseBody
  | ReposGetPagesHealthCheck404ResponseBody,
  Record<string, any>,
  200 | 202 | 400 | 404 | 422
>;

export type ReposGetPagesHealthCheckHandler = (
  req: ReposGetPagesHealthCheckRequest,
  res: ReposGetPagesHealthCheckResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsListForRepoRequest = Request<
  ProjectsListForRepoRequestPath,
  | ProjectsListForRepo200ResponseBody
  | ProjectsListForRepo401ResponseBody
  | ProjectsListForRepo403ResponseBody
  | ProjectsListForRepo404ResponseBody
  | ProjectsListForRepo410ResponseBody
  | ProjectsListForRepo422ResponseBody,
  unknown,
  ProjectsListForRepoRequestQuery,
  Record<string, any>
>;

export type ProjectsListForRepoResponse = Response<
  | ProjectsListForRepo200ResponseBody
  | ProjectsListForRepo401ResponseBody
  | ProjectsListForRepo403ResponseBody
  | ProjectsListForRepo404ResponseBody
  | ProjectsListForRepo410ResponseBody
  | ProjectsListForRepo422ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404 | 410 | 422
>;

export type ProjectsListForRepoHandler = (
  req: ProjectsListForRepoRequest,
  res: ProjectsListForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsCreateForRepoRequest = Request<
  ProjectsCreateForRepoRequestPath,
  | ProjectsCreateForRepo201ResponseBody
  | ProjectsCreateForRepo401ResponseBody
  | ProjectsCreateForRepo403ResponseBody
  | ProjectsCreateForRepo404ResponseBody
  | ProjectsCreateForRepo410ResponseBody
  | ProjectsCreateForRepo422ResponseBody,
  ProjectsCreateForRepoRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsCreateForRepoResponse = Response<
  | ProjectsCreateForRepo201ResponseBody
  | ProjectsCreateForRepo401ResponseBody
  | ProjectsCreateForRepo403ResponseBody
  | ProjectsCreateForRepo404ResponseBody
  | ProjectsCreateForRepo410ResponseBody
  | ProjectsCreateForRepo422ResponseBody,
  Record<string, any>,
  201 | 401 | 403 | 404 | 410 | 422
>;

export type ProjectsCreateForRepoHandler = (
  req: ProjectsCreateForRepoRequest,
  res: ProjectsCreateForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsListRequest = Request<
  PullsListRequestPath,
  PullsList200ResponseBody | PullsList422ResponseBody,
  unknown,
  PullsListRequestQuery,
  Record<string, any>
>;

export type PullsListResponse = Response<
  PullsList200ResponseBody | PullsList422ResponseBody,
  Record<string, any>,
  200 | 304 | 422
>;

export type PullsListHandler = (
  req: PullsListRequest,
  res: PullsListResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsCreateRequest = Request<
  PullsCreateRequestPath,
  | PullsCreate201ResponseBody
  | PullsCreate403ResponseBody
  | PullsCreate422ResponseBody,
  PullsCreateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsCreateResponse = Response<
  | PullsCreate201ResponseBody
  | PullsCreate403ResponseBody
  | PullsCreate422ResponseBody,
  Record<string, any>,
  201 | 403 | 422
>;

export type PullsCreateHandler = (
  req: PullsCreateRequest,
  res: PullsCreateResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsListReviewCommentsForRepoRequest = Request<
  PullsListReviewCommentsForRepoRequestPath,
  PullsListReviewCommentsForRepo200ResponseBody,
  unknown,
  PullsListReviewCommentsForRepoRequestQuery,
  Record<string, any>
>;

export type PullsListReviewCommentsForRepoResponse = Response<
  PullsListReviewCommentsForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export type PullsListReviewCommentsForRepoHandler = (
  req: PullsListReviewCommentsForRepoRequest,
  res: PullsListReviewCommentsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsGetReviewCommentRequest = Request<
  PullsGetReviewCommentRequestPath,
  PullsGetReviewComment200ResponseBody | PullsGetReviewComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsGetReviewCommentResponse = Response<
  PullsGetReviewComment200ResponseBody | PullsGetReviewComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type PullsGetReviewCommentHandler = (
  req: PullsGetReviewCommentRequest,
  res: PullsGetReviewCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsUpdateReviewCommentRequest = Request<
  PullsUpdateReviewCommentRequestPath,
  PullsUpdateReviewComment200ResponseBody,
  PullsUpdateReviewCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsUpdateReviewCommentResponse = Response<
  PullsUpdateReviewComment200ResponseBody,
  Record<string, any>,
  200
>;

export type PullsUpdateReviewCommentHandler = (
  req: PullsUpdateReviewCommentRequest,
  res: PullsUpdateReviewCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsDeleteReviewCommentRequest = Request<
  PullsDeleteReviewCommentRequestPath,
  PullsDeleteReviewComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsDeleteReviewCommentResponse = Response<
  PullsDeleteReviewComment404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export type PullsDeleteReviewCommentHandler = (
  req: PullsDeleteReviewCommentRequest,
  res: PullsDeleteReviewCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsListForPullRequestReviewCommentRequest = Request<
  ReactionsListForPullRequestReviewCommentRequestPath,
  | ReactionsListForPullRequestReviewComment200ResponseBody
  | ReactionsListForPullRequestReviewComment404ResponseBody,
  unknown,
  ReactionsListForPullRequestReviewCommentRequestQuery,
  Record<string, any>
>;

export type ReactionsListForPullRequestReviewCommentResponse = Response<
  | ReactionsListForPullRequestReviewComment200ResponseBody
  | ReactionsListForPullRequestReviewComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReactionsListForPullRequestReviewCommentHandler = (
  req: ReactionsListForPullRequestReviewCommentRequest,
  res: ReactionsListForPullRequestReviewCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsCreateForPullRequestReviewCommentRequest = Request<
  ReactionsCreateForPullRequestReviewCommentRequestPath,
  | ReactionsCreateForPullRequestReviewComment200ResponseBody
  | ReactionsCreateForPullRequestReviewComment201ResponseBody
  | ReactionsCreateForPullRequestReviewComment422ResponseBody,
  ReactionsCreateForPullRequestReviewCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForPullRequestReviewCommentResponse = Response<
  | ReactionsCreateForPullRequestReviewComment200ResponseBody
  | ReactionsCreateForPullRequestReviewComment201ResponseBody
  | ReactionsCreateForPullRequestReviewComment422ResponseBody,
  Record<string, any>,
  200 | 201 | 422
>;

export type ReactionsCreateForPullRequestReviewCommentHandler = (
  req: ReactionsCreateForPullRequestReviewCommentRequest,
  res: ReactionsCreateForPullRequestReviewCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsDeleteForPullRequestCommentRequest = Request<
  ReactionsDeleteForPullRequestCommentRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForPullRequestCommentResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReactionsDeleteForPullRequestCommentHandler = (
  req: ReactionsDeleteForPullRequestCommentRequest,
  res: ReactionsDeleteForPullRequestCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsGetRequest = Request<
  PullsGetRequestPath,
  | PullsGet200ResponseBody
  | PullsGet404ResponseBody
  | PullsGet500ResponseBody
  | PullsGet503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsGetResponse = Response<
  | PullsGet200ResponseBody
  | PullsGet404ResponseBody
  | PullsGet500ResponseBody
  | PullsGet503ResponseBody,
  Record<string, any>,
  200 | 304 | 404 | 500 | 503
>;

export type PullsGetHandler = (
  req: PullsGetRequest,
  res: PullsGetResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsUpdateRequest = Request<
  PullsUpdateRequestPath,
  | PullsUpdate200ResponseBody
  | PullsUpdate403ResponseBody
  | PullsUpdate422ResponseBody,
  PullsUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsUpdateResponse = Response<
  | PullsUpdate200ResponseBody
  | PullsUpdate403ResponseBody
  | PullsUpdate422ResponseBody,
  Record<string, any>,
  200 | 403 | 422
>;

export type PullsUpdateHandler = (
  req: PullsUpdateRequest,
  res: PullsUpdateResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesCreateWithPrForAuthenticatedUserRequest = Request<
  CodespacesCreateWithPrForAuthenticatedUserRequestPath,
  | CodespacesCreateWithPrForAuthenticatedUser201ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser202ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser401ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser403ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser404ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser503ResponseBody,
  CodespacesCreateWithPrForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCreateWithPrForAuthenticatedUserResponse = Response<
  | CodespacesCreateWithPrForAuthenticatedUser201ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser202ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser401ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser403ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser404ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser503ResponseBody,
  Record<string, any>,
  201 | 202 | 401 | 403 | 404 | 503
>;

export type CodespacesCreateWithPrForAuthenticatedUserHandler = (
  req: CodespacesCreateWithPrForAuthenticatedUserRequest,
  res: CodespacesCreateWithPrForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsListReviewCommentsRequest = Request<
  PullsListReviewCommentsRequestPath,
  PullsListReviewComments200ResponseBody,
  unknown,
  PullsListReviewCommentsRequestQuery,
  Record<string, any>
>;

export type PullsListReviewCommentsResponse = Response<
  PullsListReviewComments200ResponseBody,
  Record<string, any>,
  200
>;

export type PullsListReviewCommentsHandler = (
  req: PullsListReviewCommentsRequest,
  res: PullsListReviewCommentsResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsCreateReviewCommentRequest = Request<
  PullsCreateReviewCommentRequestPath,
  | PullsCreateReviewComment201ResponseBody
  | PullsCreateReviewComment403ResponseBody
  | PullsCreateReviewComment422ResponseBody,
  PullsCreateReviewCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsCreateReviewCommentResponse = Response<
  | PullsCreateReviewComment201ResponseBody
  | PullsCreateReviewComment403ResponseBody
  | PullsCreateReviewComment422ResponseBody,
  Record<string, any>,
  201 | 403 | 422
>;

export type PullsCreateReviewCommentHandler = (
  req: PullsCreateReviewCommentRequest,
  res: PullsCreateReviewCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsCreateReplyForReviewCommentRequest = Request<
  PullsCreateReplyForReviewCommentRequestPath,
  | PullsCreateReplyForReviewComment201ResponseBody
  | PullsCreateReplyForReviewComment404ResponseBody,
  PullsCreateReplyForReviewCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsCreateReplyForReviewCommentResponse = Response<
  | PullsCreateReplyForReviewComment201ResponseBody
  | PullsCreateReplyForReviewComment404ResponseBody,
  Record<string, any>,
  201 | 404
>;

export type PullsCreateReplyForReviewCommentHandler = (
  req: PullsCreateReplyForReviewCommentRequest,
  res: PullsCreateReplyForReviewCommentResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsListCommitsRequest = Request<
  PullsListCommitsRequestPath,
  PullsListCommits200ResponseBody,
  unknown,
  PullsListCommitsRequestQuery,
  Record<string, any>
>;

export type PullsListCommitsResponse = Response<
  PullsListCommits200ResponseBody,
  Record<string, any>,
  200
>;

export type PullsListCommitsHandler = (
  req: PullsListCommitsRequest,
  res: PullsListCommitsResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsListFilesRequest = Request<
  PullsListFilesRequestPath,
  | PullsListFiles200ResponseBody
  | PullsListFiles422ResponseBody
  | PullsListFiles500ResponseBody
  | PullsListFiles503ResponseBody,
  unknown,
  PullsListFilesRequestQuery,
  Record<string, any>
>;

export type PullsListFilesResponse = Response<
  | PullsListFiles200ResponseBody
  | PullsListFiles422ResponseBody
  | PullsListFiles500ResponseBody
  | PullsListFiles503ResponseBody,
  Record<string, any>,
  200 | 422 | 500 | 503
>;

export type PullsListFilesHandler = (
  req: PullsListFilesRequest,
  res: PullsListFilesResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsCheckIfMergedRequest = Request<
  PullsCheckIfMergedRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsCheckIfMergedResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export type PullsCheckIfMergedHandler = (
  req: PullsCheckIfMergedRequest,
  res: PullsCheckIfMergedResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsMergeRequest = Request<
  PullsMergeRequestPath,
  | PullsMerge200ResponseBody
  | PullsMerge403ResponseBody
  | PullsMerge404ResponseBody
  | PullsMerge405ResponseBody
  | PullsMerge409ResponseBody
  | PullsMerge422ResponseBody,
  PullsMergeRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsMergeResponse = Response<
  | PullsMerge200ResponseBody
  | PullsMerge403ResponseBody
  | PullsMerge404ResponseBody
  | PullsMerge405ResponseBody
  | PullsMerge409ResponseBody
  | PullsMerge422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 405 | 409 | 422
>;

export type PullsMergeHandler = (
  req: PullsMergeRequest,
  res: PullsMergeResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsListRequestedReviewersRequest = Request<
  PullsListRequestedReviewersRequestPath,
  PullsListRequestedReviewers200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsListRequestedReviewersResponse = Response<
  PullsListRequestedReviewers200ResponseBody,
  Record<string, any>,
  200
>;

export type PullsListRequestedReviewersHandler = (
  req: PullsListRequestedReviewersRequest,
  res: PullsListRequestedReviewersResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsRequestReviewersRequest = Request<
  PullsRequestReviewersRequestPath,
  PullsRequestReviewers201ResponseBody | PullsRequestReviewers403ResponseBody,
  PullsRequestReviewersRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsRequestReviewersResponse = Response<
  PullsRequestReviewers201ResponseBody | PullsRequestReviewers403ResponseBody,
  Record<string, any>,
  201 | 403 | 422
>;

export type PullsRequestReviewersHandler = (
  req: PullsRequestReviewersRequest,
  res: PullsRequestReviewersResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsRemoveRequestedReviewersRequest = Request<
  PullsRemoveRequestedReviewersRequestPath,
  | PullsRemoveRequestedReviewers200ResponseBody
  | PullsRemoveRequestedReviewers422ResponseBody,
  PullsRemoveRequestedReviewersRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsRemoveRequestedReviewersResponse = Response<
  | PullsRemoveRequestedReviewers200ResponseBody
  | PullsRemoveRequestedReviewers422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type PullsRemoveRequestedReviewersHandler = (
  req: PullsRemoveRequestedReviewersRequest,
  res: PullsRemoveRequestedReviewersResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsListReviewsRequest = Request<
  PullsListReviewsRequestPath,
  PullsListReviews200ResponseBody,
  unknown,
  PullsListReviewsRequestQuery,
  Record<string, any>
>;

export type PullsListReviewsResponse = Response<
  PullsListReviews200ResponseBody,
  Record<string, any>,
  200
>;

export type PullsListReviewsHandler = (
  req: PullsListReviewsRequest,
  res: PullsListReviewsResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsCreateReviewRequest = Request<
  PullsCreateReviewRequestPath,
  | PullsCreateReview200ResponseBody
  | PullsCreateReview403ResponseBody
  | PullsCreateReview422ResponseBody,
  PullsCreateReviewRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsCreateReviewResponse = Response<
  | PullsCreateReview200ResponseBody
  | PullsCreateReview403ResponseBody
  | PullsCreateReview422ResponseBody,
  Record<string, any>,
  200 | 403 | 422
>;

export type PullsCreateReviewHandler = (
  req: PullsCreateReviewRequest,
  res: PullsCreateReviewResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsGetReviewRequest = Request<
  PullsGetReviewRequestPath,
  PullsGetReview200ResponseBody | PullsGetReview404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsGetReviewResponse = Response<
  PullsGetReview200ResponseBody | PullsGetReview404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type PullsGetReviewHandler = (
  req: PullsGetReviewRequest,
  res: PullsGetReviewResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsUpdateReviewRequest = Request<
  PullsUpdateReviewRequestPath,
  PullsUpdateReview200ResponseBody | PullsUpdateReview422ResponseBody,
  PullsUpdateReviewRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsUpdateReviewResponse = Response<
  PullsUpdateReview200ResponseBody | PullsUpdateReview422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type PullsUpdateReviewHandler = (
  req: PullsUpdateReviewRequest,
  res: PullsUpdateReviewResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsDeletePendingReviewRequest = Request<
  PullsDeletePendingReviewRequestPath,
  | PullsDeletePendingReview200ResponseBody
  | PullsDeletePendingReview404ResponseBody
  | PullsDeletePendingReview422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsDeletePendingReviewResponse = Response<
  | PullsDeletePendingReview200ResponseBody
  | PullsDeletePendingReview404ResponseBody
  | PullsDeletePendingReview422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type PullsDeletePendingReviewHandler = (
  req: PullsDeletePendingReviewRequest,
  res: PullsDeletePendingReviewResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsListCommentsForReviewRequest = Request<
  PullsListCommentsForReviewRequestPath,
  | PullsListCommentsForReview200ResponseBody
  | PullsListCommentsForReview404ResponseBody,
  unknown,
  PullsListCommentsForReviewRequestQuery,
  Record<string, any>
>;

export type PullsListCommentsForReviewResponse = Response<
  | PullsListCommentsForReview200ResponseBody
  | PullsListCommentsForReview404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type PullsListCommentsForReviewHandler = (
  req: PullsListCommentsForReviewRequest,
  res: PullsListCommentsForReviewResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsDismissReviewRequest = Request<
  PullsDismissReviewRequestPath,
  | PullsDismissReview200ResponseBody
  | PullsDismissReview404ResponseBody
  | PullsDismissReview422ResponseBody,
  PullsDismissReviewRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsDismissReviewResponse = Response<
  | PullsDismissReview200ResponseBody
  | PullsDismissReview404ResponseBody
  | PullsDismissReview422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type PullsDismissReviewHandler = (
  req: PullsDismissReviewRequest,
  res: PullsDismissReviewResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsSubmitReviewRequest = Request<
  PullsSubmitReviewRequestPath,
  | PullsSubmitReview200ResponseBody
  | PullsSubmitReview403ResponseBody
  | PullsSubmitReview404ResponseBody
  | PullsSubmitReview422ResponseBody,
  PullsSubmitReviewRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsSubmitReviewResponse = Response<
  | PullsSubmitReview200ResponseBody
  | PullsSubmitReview403ResponseBody
  | PullsSubmitReview404ResponseBody
  | PullsSubmitReview422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export type PullsSubmitReviewHandler = (
  req: PullsSubmitReviewRequest,
  res: PullsSubmitReviewResponse,
  next: NextFunction
) => Promise<void> | void;

export type PullsUpdateBranchRequest = Request<
  PullsUpdateBranchRequestPath,
  | PullsUpdateBranch202ResponseBody
  | PullsUpdateBranch403ResponseBody
  | PullsUpdateBranch422ResponseBody,
  PullsUpdateBranchRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsUpdateBranchResponse = Response<
  | PullsUpdateBranch202ResponseBody
  | PullsUpdateBranch403ResponseBody
  | PullsUpdateBranch422ResponseBody,
  Record<string, any>,
  202 | 403 | 422
>;

export type PullsUpdateBranchHandler = (
  req: PullsUpdateBranchRequest,
  res: PullsUpdateBranchResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetReadmeRequest = Request<
  ReposGetReadmeRequestPath,
  | ReposGetReadme200ResponseBody
  | ReposGetReadme404ResponseBody
  | ReposGetReadme422ResponseBody,
  unknown,
  ReposGetReadmeRequestQuery,
  Record<string, any>
>;

export type ReposGetReadmeResponse = Response<
  | ReposGetReadme200ResponseBody
  | ReposGetReadme404ResponseBody
  | ReposGetReadme422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type ReposGetReadmeHandler = (
  req: ReposGetReadmeRequest,
  res: ReposGetReadmeResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetReadmeInDirectoryRequest = Request<
  ReposGetReadmeInDirectoryRequestPath,
  | ReposGetReadmeInDirectory200ResponseBody
  | ReposGetReadmeInDirectory404ResponseBody
  | ReposGetReadmeInDirectory422ResponseBody,
  unknown,
  ReposGetReadmeInDirectoryRequestQuery,
  Record<string, any>
>;

export type ReposGetReadmeInDirectoryResponse = Response<
  | ReposGetReadmeInDirectory200ResponseBody
  | ReposGetReadmeInDirectory404ResponseBody
  | ReposGetReadmeInDirectory422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type ReposGetReadmeInDirectoryHandler = (
  req: ReposGetReadmeInDirectoryRequest,
  res: ReposGetReadmeInDirectoryResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListReleasesRequest = Request<
  ReposListReleasesRequestPath,
  ReposListReleases200ResponseBody | ReposListReleases404ResponseBody,
  unknown,
  ReposListReleasesRequestQuery,
  Record<string, any>
>;

export type ReposListReleasesResponse = Response<
  ReposListReleases200ResponseBody | ReposListReleases404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposListReleasesHandler = (
  req: ReposListReleasesRequest,
  res: ReposListReleasesResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateReleaseRequest = Request<
  ReposCreateReleaseRequestPath,
  | ReposCreateRelease201ResponseBody
  | ReposCreateRelease404ResponseBody
  | ReposCreateRelease422ResponseBody,
  ReposCreateReleaseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateReleaseResponse = Response<
  | ReposCreateRelease201ResponseBody
  | ReposCreateRelease404ResponseBody
  | ReposCreateRelease422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export type ReposCreateReleaseHandler = (
  req: ReposCreateReleaseRequest,
  res: ReposCreateReleaseResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetReleaseAssetRequest = Request<
  ReposGetReleaseAssetRequestPath,
  ReposGetReleaseAsset200ResponseBody | ReposGetReleaseAsset404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetReleaseAssetResponse = Response<
  ReposGetReleaseAsset200ResponseBody | ReposGetReleaseAsset404ResponseBody,
  Record<string, any>,
  200 | 302 | 404
>;

export type ReposGetReleaseAssetHandler = (
  req: ReposGetReleaseAssetRequest,
  res: ReposGetReleaseAssetResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposUpdateReleaseAssetRequest = Request<
  ReposUpdateReleaseAssetRequestPath,
  ReposUpdateReleaseAsset200ResponseBody,
  ReposUpdateReleaseAssetRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateReleaseAssetResponse = Response<
  ReposUpdateReleaseAsset200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposUpdateReleaseAssetHandler = (
  req: ReposUpdateReleaseAssetRequest,
  res: ReposUpdateReleaseAssetResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteReleaseAssetRequest = Request<
  ReposDeleteReleaseAssetRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteReleaseAssetResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposDeleteReleaseAssetHandler = (
  req: ReposDeleteReleaseAssetRequest,
  res: ReposDeleteReleaseAssetResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGenerateReleaseNotesRequest = Request<
  ReposGenerateReleaseNotesRequestPath,
  | ReposGenerateReleaseNotes200ResponseBody
  | ReposGenerateReleaseNotes404ResponseBody,
  ReposGenerateReleaseNotesRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposGenerateReleaseNotesResponse = Response<
  | ReposGenerateReleaseNotes200ResponseBody
  | ReposGenerateReleaseNotes404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGenerateReleaseNotesHandler = (
  req: ReposGenerateReleaseNotesRequest,
  res: ReposGenerateReleaseNotesResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetLatestReleaseRequest = Request<
  ReposGetLatestReleaseRequestPath,
  ReposGetLatestRelease200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetLatestReleaseResponse = Response<
  ReposGetLatestRelease200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposGetLatestReleaseHandler = (
  req: ReposGetLatestReleaseRequest,
  res: ReposGetLatestReleaseResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetReleaseByTagRequest = Request<
  ReposGetReleaseByTagRequestPath,
  ReposGetReleaseByTag200ResponseBody | ReposGetReleaseByTag404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetReleaseByTagResponse = Response<
  ReposGetReleaseByTag200ResponseBody | ReposGetReleaseByTag404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetReleaseByTagHandler = (
  req: ReposGetReleaseByTagRequest,
  res: ReposGetReleaseByTagResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetReleaseRequest = Request<
  ReposGetReleaseRequestPath,
  ReposGetRelease200ResponseBody | ReposGetRelease404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetReleaseResponse = Response<
  ReposGetRelease200ResponseBody | ReposGetRelease404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetReleaseHandler = (
  req: ReposGetReleaseRequest,
  res: ReposGetReleaseResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposUpdateReleaseRequest = Request<
  ReposUpdateReleaseRequestPath,
  ReposUpdateRelease200ResponseBody | ReposUpdateRelease404ResponseBody,
  ReposUpdateReleaseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateReleaseResponse = Response<
  ReposUpdateRelease200ResponseBody | ReposUpdateRelease404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposUpdateReleaseHandler = (
  req: ReposUpdateReleaseRequest,
  res: ReposUpdateReleaseResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteReleaseRequest = Request<
  ReposDeleteReleaseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteReleaseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposDeleteReleaseHandler = (
  req: ReposDeleteReleaseRequest,
  res: ReposDeleteReleaseResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListReleaseAssetsRequest = Request<
  ReposListReleaseAssetsRequestPath,
  ReposListReleaseAssets200ResponseBody,
  unknown,
  ReposListReleaseAssetsRequestQuery,
  Record<string, any>
>;

export type ReposListReleaseAssetsResponse = Response<
  ReposListReleaseAssets200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListReleaseAssetsHandler = (
  req: ReposListReleaseAssetsRequest,
  res: ReposListReleaseAssetsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposUploadReleaseAssetRequest = Request<
  ReposUploadReleaseAssetRequestPath,
  ReposUploadReleaseAsset201ResponseBody,
  unknown,
  ReposUploadReleaseAssetRequestQuery,
  Record<string, any>
>;

export type ReposUploadReleaseAssetResponse = Response<
  ReposUploadReleaseAsset201ResponseBody,
  Record<string, any>,
  201 | 422
>;

export type ReposUploadReleaseAssetHandler = (
  req: ReposUploadReleaseAssetRequest,
  res: ReposUploadReleaseAssetResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsListForReleaseRequest = Request<
  ReactionsListForReleaseRequestPath,
  | ReactionsListForRelease200ResponseBody
  | ReactionsListForRelease404ResponseBody,
  unknown,
  ReactionsListForReleaseRequestQuery,
  Record<string, any>
>;

export type ReactionsListForReleaseResponse = Response<
  | ReactionsListForRelease200ResponseBody
  | ReactionsListForRelease404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReactionsListForReleaseHandler = (
  req: ReactionsListForReleaseRequest,
  res: ReactionsListForReleaseResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsCreateForReleaseRequest = Request<
  ReactionsCreateForReleaseRequestPath,
  | ReactionsCreateForRelease200ResponseBody
  | ReactionsCreateForRelease201ResponseBody
  | ReactionsCreateForRelease422ResponseBody,
  ReactionsCreateForReleaseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForReleaseResponse = Response<
  | ReactionsCreateForRelease200ResponseBody
  | ReactionsCreateForRelease201ResponseBody
  | ReactionsCreateForRelease422ResponseBody,
  Record<string, any>,
  200 | 201 | 422
>;

export type ReactionsCreateForReleaseHandler = (
  req: ReactionsCreateForReleaseRequest,
  res: ReactionsCreateForReleaseResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsDeleteForReleaseRequest = Request<
  ReactionsDeleteForReleaseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForReleaseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReactionsDeleteForReleaseHandler = (
  req: ReactionsDeleteForReleaseRequest,
  res: ReactionsDeleteForReleaseResponse,
  next: NextFunction
) => Promise<void> | void;

export type SecretScanningListAlertsForRepoRequest = Request<
  SecretScanningListAlertsForRepoRequestPath,
  | SecretScanningListAlertsForRepo200ResponseBody
  | SecretScanningListAlertsForRepo503ResponseBody,
  unknown,
  SecretScanningListAlertsForRepoRequestQuery,
  Record<string, any>
>;

export type SecretScanningListAlertsForRepoResponse = Response<
  | SecretScanningListAlertsForRepo200ResponseBody
  | SecretScanningListAlertsForRepo503ResponseBody,
  Record<string, any>,
  200 | 404 | 503
>;

export type SecretScanningListAlertsForRepoHandler = (
  req: SecretScanningListAlertsForRepoRequest,
  res: SecretScanningListAlertsForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type SecretScanningGetAlertRequest = Request<
  SecretScanningGetAlertRequestPath,
  SecretScanningGetAlert200ResponseBody | SecretScanningGetAlert503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type SecretScanningGetAlertResponse = Response<
  SecretScanningGetAlert200ResponseBody | SecretScanningGetAlert503ResponseBody,
  Record<string, any>,
  200 | 304 | 404 | 503
>;

export type SecretScanningGetAlertHandler = (
  req: SecretScanningGetAlertRequest,
  res: SecretScanningGetAlertResponse,
  next: NextFunction
) => Promise<void> | void;

export type SecretScanningUpdateAlertRequest = Request<
  SecretScanningUpdateAlertRequestPath,
  | SecretScanningUpdateAlert200ResponseBody
  | SecretScanningUpdateAlert503ResponseBody,
  SecretScanningUpdateAlertRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type SecretScanningUpdateAlertResponse = Response<
  | SecretScanningUpdateAlert200ResponseBody
  | SecretScanningUpdateAlert503ResponseBody,
  Record<string, any>,
  200 | 400 | 404 | 422 | 503
>;

export type SecretScanningUpdateAlertHandler = (
  req: SecretScanningUpdateAlertRequest,
  res: SecretScanningUpdateAlertResponse,
  next: NextFunction
) => Promise<void> | void;

export type SecretScanningListLocationsForAlertRequest = Request<
  SecretScanningListLocationsForAlertRequestPath,
  | SecretScanningListLocationsForAlert200ResponseBody
  | SecretScanningListLocationsForAlert503ResponseBody,
  unknown,
  SecretScanningListLocationsForAlertRequestQuery,
  Record<string, any>
>;

export type SecretScanningListLocationsForAlertResponse = Response<
  | SecretScanningListLocationsForAlert200ResponseBody
  | SecretScanningListLocationsForAlert503ResponseBody,
  Record<string, any>,
  200 | 404 | 503
>;

export type SecretScanningListLocationsForAlertHandler = (
  req: SecretScanningListLocationsForAlertRequest,
  res: SecretScanningListLocationsForAlertResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListStargazersForRepoRequest = Request<
  ActivityListStargazersForRepoRequestPath,
  | ActivityListStargazersForRepo200ResponseBody
  | ActivityListStargazersForRepo422ResponseBody,
  unknown,
  ActivityListStargazersForRepoRequestQuery,
  Record<string, any>
>;

export type ActivityListStargazersForRepoResponse = Response<
  | ActivityListStargazersForRepo200ResponseBody
  | ActivityListStargazersForRepo422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ActivityListStargazersForRepoHandler = (
  req: ActivityListStargazersForRepoRequest,
  res: ActivityListStargazersForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetCodeFrequencyStatsRequest = Request<
  ReposGetCodeFrequencyStatsRequestPath,
  | ReposGetCodeFrequencyStats200ResponseBody
  | ReposGetCodeFrequencyStats202ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetCodeFrequencyStatsResponse = Response<
  | ReposGetCodeFrequencyStats200ResponseBody
  | ReposGetCodeFrequencyStats202ResponseBody,
  Record<string, any>,
  200 | 202 | 204
>;

export type ReposGetCodeFrequencyStatsHandler = (
  req: ReposGetCodeFrequencyStatsRequest,
  res: ReposGetCodeFrequencyStatsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetCommitActivityStatsRequest = Request<
  ReposGetCommitActivityStatsRequestPath,
  | ReposGetCommitActivityStats200ResponseBody
  | ReposGetCommitActivityStats202ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetCommitActivityStatsResponse = Response<
  | ReposGetCommitActivityStats200ResponseBody
  | ReposGetCommitActivityStats202ResponseBody,
  Record<string, any>,
  200 | 202 | 204
>;

export type ReposGetCommitActivityStatsHandler = (
  req: ReposGetCommitActivityStatsRequest,
  res: ReposGetCommitActivityStatsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetContributorsStatsRequest = Request<
  ReposGetContributorsStatsRequestPath,
  | ReposGetContributorsStats200ResponseBody
  | ReposGetContributorsStats202ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetContributorsStatsResponse = Response<
  | ReposGetContributorsStats200ResponseBody
  | ReposGetContributorsStats202ResponseBody,
  Record<string, any>,
  200 | 202 | 204
>;

export type ReposGetContributorsStatsHandler = (
  req: ReposGetContributorsStatsRequest,
  res: ReposGetContributorsStatsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetParticipationStatsRequest = Request<
  ReposGetParticipationStatsRequestPath,
  | ReposGetParticipationStats200ResponseBody
  | ReposGetParticipationStats404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetParticipationStatsResponse = Response<
  | ReposGetParticipationStats200ResponseBody
  | ReposGetParticipationStats404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetParticipationStatsHandler = (
  req: ReposGetParticipationStatsRequest,
  res: ReposGetParticipationStatsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetPunchCardStatsRequest = Request<
  ReposGetPunchCardStatsRequestPath,
  ReposGetPunchCardStats200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetPunchCardStatsResponse = Response<
  ReposGetPunchCardStats200ResponseBody,
  Record<string, any>,
  200 | 204
>;

export type ReposGetPunchCardStatsHandler = (
  req: ReposGetPunchCardStatsRequest,
  res: ReposGetPunchCardStatsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateCommitStatusRequest = Request<
  ReposCreateCommitStatusRequestPath,
  ReposCreateCommitStatus201ResponseBody,
  ReposCreateCommitStatusRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateCommitStatusResponse = Response<
  ReposCreateCommitStatus201ResponseBody,
  Record<string, any>,
  201
>;

export type ReposCreateCommitStatusHandler = (
  req: ReposCreateCommitStatusRequest,
  res: ReposCreateCommitStatusResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListWatchersForRepoRequest = Request<
  ActivityListWatchersForRepoRequestPath,
  ActivityListWatchersForRepo200ResponseBody,
  unknown,
  ActivityListWatchersForRepoRequestQuery,
  Record<string, any>
>;

export type ActivityListWatchersForRepoResponse = Response<
  ActivityListWatchersForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export type ActivityListWatchersForRepoHandler = (
  req: ActivityListWatchersForRepoRequest,
  res: ActivityListWatchersForRepoResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityGetRepoSubscriptionRequest = Request<
  ActivityGetRepoSubscriptionRequestPath,
  | ActivityGetRepoSubscription200ResponseBody
  | ActivityGetRepoSubscription403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityGetRepoSubscriptionResponse = Response<
  | ActivityGetRepoSubscription200ResponseBody
  | ActivityGetRepoSubscription403ResponseBody,
  Record<string, any>,
  200 | 403 | 404
>;

export type ActivityGetRepoSubscriptionHandler = (
  req: ActivityGetRepoSubscriptionRequest,
  res: ActivityGetRepoSubscriptionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivitySetRepoSubscriptionRequest = Request<
  ActivitySetRepoSubscriptionRequestPath,
  ActivitySetRepoSubscription200ResponseBody,
  ActivitySetRepoSubscriptionRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActivitySetRepoSubscriptionResponse = Response<
  ActivitySetRepoSubscription200ResponseBody,
  Record<string, any>,
  200
>;

export type ActivitySetRepoSubscriptionHandler = (
  req: ActivitySetRepoSubscriptionRequest,
  res: ActivitySetRepoSubscriptionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityDeleteRepoSubscriptionRequest = Request<
  ActivityDeleteRepoSubscriptionRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityDeleteRepoSubscriptionResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActivityDeleteRepoSubscriptionHandler = (
  req: ActivityDeleteRepoSubscriptionRequest,
  res: ActivityDeleteRepoSubscriptionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListTagsRequest = Request<
  ReposListTagsRequestPath,
  ReposListTags200ResponseBody,
  unknown,
  ReposListTagsRequestQuery,
  Record<string, any>
>;

export type ReposListTagsResponse = Response<
  ReposListTags200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListTagsHandler = (
  req: ReposListTagsRequest,
  res: ReposListTagsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListTagProtectionRequest = Request<
  ReposListTagProtectionRequestPath,
  | ReposListTagProtection200ResponseBody
  | ReposListTagProtection403ResponseBody
  | ReposListTagProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposListTagProtectionResponse = Response<
  | ReposListTagProtection200ResponseBody
  | ReposListTagProtection403ResponseBody
  | ReposListTagProtection404ResponseBody,
  Record<string, any>,
  200 | 403 | 404
>;

export type ReposListTagProtectionHandler = (
  req: ReposListTagProtectionRequest,
  res: ReposListTagProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateTagProtectionRequest = Request<
  ReposCreateTagProtectionRequestPath,
  | ReposCreateTagProtection201ResponseBody
  | ReposCreateTagProtection403ResponseBody
  | ReposCreateTagProtection404ResponseBody,
  ReposCreateTagProtectionRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateTagProtectionResponse = Response<
  | ReposCreateTagProtection201ResponseBody
  | ReposCreateTagProtection403ResponseBody
  | ReposCreateTagProtection404ResponseBody,
  Record<string, any>,
  201 | 403 | 404
>;

export type ReposCreateTagProtectionHandler = (
  req: ReposCreateTagProtectionRequest,
  res: ReposCreateTagProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeleteTagProtectionRequest = Request<
  ReposDeleteTagProtectionRequestPath,
  | ReposDeleteTagProtection403ResponseBody
  | ReposDeleteTagProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteTagProtectionResponse = Response<
  | ReposDeleteTagProtection403ResponseBody
  | ReposDeleteTagProtection404ResponseBody,
  Record<string, any>,
  204 | 403 | 404
>;

export type ReposDeleteTagProtectionHandler = (
  req: ReposDeleteTagProtectionRequest,
  res: ReposDeleteTagProtectionResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDownloadTarballArchiveRequest = Request<
  ReposDownloadTarballArchiveRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDownloadTarballArchiveResponse = Response<
  unknown,
  Record<string, any>,
  302
>;

export type ReposDownloadTarballArchiveHandler = (
  req: ReposDownloadTarballArchiveRequest,
  res: ReposDownloadTarballArchiveResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListTeamsRequest = Request<
  ReposListTeamsRequestPath,
  ReposListTeams200ResponseBody,
  unknown,
  ReposListTeamsRequestQuery,
  Record<string, any>
>;

export type ReposListTeamsResponse = Response<
  ReposListTeams200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListTeamsHandler = (
  req: ReposListTeamsRequest,
  res: ReposListTeamsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetAllTopicsRequest = Request<
  ReposGetAllTopicsRequestPath,
  ReposGetAllTopics200ResponseBody | ReposGetAllTopics404ResponseBody,
  unknown,
  ReposGetAllTopicsRequestQuery,
  Record<string, any>
>;

export type ReposGetAllTopicsResponse = Response<
  ReposGetAllTopics200ResponseBody | ReposGetAllTopics404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type ReposGetAllTopicsHandler = (
  req: ReposGetAllTopicsRequest,
  res: ReposGetAllTopicsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposReplaceAllTopicsRequest = Request<
  ReposReplaceAllTopicsRequestPath,
  | ReposReplaceAllTopics200ResponseBody
  | ReposReplaceAllTopics404ResponseBody
  | ReposReplaceAllTopics422ResponseBody,
  ReposReplaceAllTopicsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposReplaceAllTopicsResponse = Response<
  | ReposReplaceAllTopics200ResponseBody
  | ReposReplaceAllTopics404ResponseBody
  | ReposReplaceAllTopics422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type ReposReplaceAllTopicsHandler = (
  req: ReposReplaceAllTopicsRequest,
  res: ReposReplaceAllTopicsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetClonesRequest = Request<
  ReposGetClonesRequestPath,
  ReposGetClones200ResponseBody | ReposGetClones403ResponseBody,
  unknown,
  ReposGetClonesRequestQuery,
  Record<string, any>
>;

export type ReposGetClonesResponse = Response<
  ReposGetClones200ResponseBody | ReposGetClones403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export type ReposGetClonesHandler = (
  req: ReposGetClonesRequest,
  res: ReposGetClonesResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetTopPathsRequest = Request<
  ReposGetTopPathsRequestPath,
  ReposGetTopPaths200ResponseBody | ReposGetTopPaths403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetTopPathsResponse = Response<
  ReposGetTopPaths200ResponseBody | ReposGetTopPaths403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export type ReposGetTopPathsHandler = (
  req: ReposGetTopPathsRequest,
  res: ReposGetTopPathsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetTopReferrersRequest = Request<
  ReposGetTopReferrersRequestPath,
  ReposGetTopReferrers200ResponseBody | ReposGetTopReferrers403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetTopReferrersResponse = Response<
  ReposGetTopReferrers200ResponseBody | ReposGetTopReferrers403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export type ReposGetTopReferrersHandler = (
  req: ReposGetTopReferrersRequest,
  res: ReposGetTopReferrersResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposGetViewsRequest = Request<
  ReposGetViewsRequestPath,
  ReposGetViews200ResponseBody | ReposGetViews403ResponseBody,
  unknown,
  ReposGetViewsRequestQuery,
  Record<string, any>
>;

export type ReposGetViewsResponse = Response<
  ReposGetViews200ResponseBody | ReposGetViews403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export type ReposGetViewsHandler = (
  req: ReposGetViewsRequest,
  res: ReposGetViewsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposTransferRequest = Request<
  ReposTransferRequestPath,
  ReposTransfer202ResponseBody,
  ReposTransferRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposTransferResponse = Response<
  ReposTransfer202ResponseBody,
  Record<string, any>,
  202
>;

export type ReposTransferHandler = (
  req: ReposTransferRequest,
  res: ReposTransferResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCheckVulnerabilityAlertsRequest = Request<
  ReposCheckVulnerabilityAlertsRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposCheckVulnerabilityAlertsResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export type ReposCheckVulnerabilityAlertsHandler = (
  req: ReposCheckVulnerabilityAlertsRequest,
  res: ReposCheckVulnerabilityAlertsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposEnableVulnerabilityAlertsRequest = Request<
  ReposEnableVulnerabilityAlertsRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposEnableVulnerabilityAlertsResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposEnableVulnerabilityAlertsHandler = (
  req: ReposEnableVulnerabilityAlertsRequest,
  res: ReposEnableVulnerabilityAlertsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDisableVulnerabilityAlertsRequest = Request<
  ReposDisableVulnerabilityAlertsRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDisableVulnerabilityAlertsResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ReposDisableVulnerabilityAlertsHandler = (
  req: ReposDisableVulnerabilityAlertsRequest,
  res: ReposDisableVulnerabilityAlertsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDownloadZipballArchiveRequest = Request<
  ReposDownloadZipballArchiveRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDownloadZipballArchiveResponse = Response<
  unknown,
  Record<string, any>,
  302
>;

export type ReposDownloadZipballArchiveHandler = (
  req: ReposDownloadZipballArchiveRequest,
  res: ReposDownloadZipballArchiveResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateUsingTemplateRequest = Request<
  ReposCreateUsingTemplateRequestPath,
  ReposCreateUsingTemplate201ResponseBody,
  ReposCreateUsingTemplateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateUsingTemplateResponse = Response<
  ReposCreateUsingTemplate201ResponseBody,
  Record<string, any>,
  201
>;

export type ReposCreateUsingTemplateHandler = (
  req: ReposCreateUsingTemplateRequest,
  res: ReposCreateUsingTemplateResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListPublicRequest = Request<
  ParamsDictionary,
  ReposListPublic200ResponseBody | ReposListPublic422ResponseBody,
  unknown,
  ReposListPublicRequestQuery,
  Record<string, any>
>;

export type ReposListPublicResponse = Response<
  ReposListPublic200ResponseBody | ReposListPublic422ResponseBody,
  Record<string, any>,
  200 | 304 | 422
>;

export type ReposListPublicHandler = (
  req: ReposListPublicRequest,
  res: ReposListPublicResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsListEnvironmentSecretsRequest = Request<
  ActionsListEnvironmentSecretsRequestPath,
  ActionsListEnvironmentSecrets200ResponseBody,
  unknown,
  ActionsListEnvironmentSecretsRequestQuery,
  Record<string, any>
>;

export type ActionsListEnvironmentSecretsResponse = Response<
  ActionsListEnvironmentSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsListEnvironmentSecretsHandler = (
  req: ActionsListEnvironmentSecretsRequest,
  res: ActionsListEnvironmentSecretsResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetEnvironmentPublicKeyRequest = Request<
  ActionsGetEnvironmentPublicKeyRequestPath,
  ActionsGetEnvironmentPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetEnvironmentPublicKeyResponse = Response<
  ActionsGetEnvironmentPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetEnvironmentPublicKeyHandler = (
  req: ActionsGetEnvironmentPublicKeyRequest,
  res: ActionsGetEnvironmentPublicKeyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsGetEnvironmentSecretRequest = Request<
  ActionsGetEnvironmentSecretRequestPath,
  ActionsGetEnvironmentSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetEnvironmentSecretResponse = Response<
  ActionsGetEnvironmentSecret200ResponseBody,
  Record<string, any>,
  200
>;

export type ActionsGetEnvironmentSecretHandler = (
  req: ActionsGetEnvironmentSecretRequest,
  res: ActionsGetEnvironmentSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsCreateOrUpdateEnvironmentSecretRequest = Request<
  ActionsCreateOrUpdateEnvironmentSecretRequestPath,
  ActionsCreateOrUpdateEnvironmentSecret201ResponseBody,
  ActionsCreateOrUpdateEnvironmentSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateOrUpdateEnvironmentSecretResponse = Response<
  ActionsCreateOrUpdateEnvironmentSecret201ResponseBody,
  Record<string, any>,
  201 | 204
>;

export type ActionsCreateOrUpdateEnvironmentSecretHandler = (
  req: ActionsCreateOrUpdateEnvironmentSecretRequest,
  res: ActionsCreateOrUpdateEnvironmentSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActionsDeleteEnvironmentSecretRequest = Request<
  ActionsDeleteEnvironmentSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteEnvironmentSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type ActionsDeleteEnvironmentSecretHandler = (
  req: ActionsDeleteEnvironmentSecretRequest,
  res: ActionsDeleteEnvironmentSecretResponse,
  next: NextFunction
) => Promise<void> | void;

export type SearchCodeRequest = Request<
  ParamsDictionary,
  | SearchCode200ResponseBody
  | SearchCode403ResponseBody
  | SearchCode422ResponseBody
  | SearchCode503ResponseBody,
  unknown,
  SearchCodeRequestQuery,
  Record<string, any>
>;

export type SearchCodeResponse = Response<
  | SearchCode200ResponseBody
  | SearchCode403ResponseBody
  | SearchCode422ResponseBody
  | SearchCode503ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 422 | 503
>;

export type SearchCodeHandler = (
  req: SearchCodeRequest,
  res: SearchCodeResponse,
  next: NextFunction
) => Promise<void> | void;

export type SearchCommitsRequest = Request<
  ParamsDictionary,
  SearchCommits200ResponseBody,
  unknown,
  SearchCommitsRequestQuery,
  Record<string, any>
>;

export type SearchCommitsResponse = Response<
  SearchCommits200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export type SearchCommitsHandler = (
  req: SearchCommitsRequest,
  res: SearchCommitsResponse,
  next: NextFunction
) => Promise<void> | void;

export type SearchIssuesAndPullRequestsRequest = Request<
  ParamsDictionary,
  | SearchIssuesAndPullRequests200ResponseBody
  | SearchIssuesAndPullRequests403ResponseBody
  | SearchIssuesAndPullRequests422ResponseBody
  | SearchIssuesAndPullRequests503ResponseBody,
  unknown,
  SearchIssuesAndPullRequestsRequestQuery,
  Record<string, any>
>;

export type SearchIssuesAndPullRequestsResponse = Response<
  | SearchIssuesAndPullRequests200ResponseBody
  | SearchIssuesAndPullRequests403ResponseBody
  | SearchIssuesAndPullRequests422ResponseBody
  | SearchIssuesAndPullRequests503ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 422 | 503
>;

export type SearchIssuesAndPullRequestsHandler = (
  req: SearchIssuesAndPullRequestsRequest,
  res: SearchIssuesAndPullRequestsResponse,
  next: NextFunction
) => Promise<void> | void;

export type SearchLabelsRequest = Request<
  ParamsDictionary,
  | SearchLabels200ResponseBody
  | SearchLabels403ResponseBody
  | SearchLabels404ResponseBody
  | SearchLabels422ResponseBody,
  unknown,
  SearchLabelsRequestQuery,
  Record<string, any>
>;

export type SearchLabelsResponse = Response<
  | SearchLabels200ResponseBody
  | SearchLabels403ResponseBody
  | SearchLabels404ResponseBody
  | SearchLabels422ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404 | 422
>;

export type SearchLabelsHandler = (
  req: SearchLabelsRequest,
  res: SearchLabelsResponse,
  next: NextFunction
) => Promise<void> | void;

export type SearchReposRequest = Request<
  ParamsDictionary,
  | SearchRepos200ResponseBody
  | SearchRepos422ResponseBody
  | SearchRepos503ResponseBody,
  unknown,
  SearchReposRequestQuery,
  Record<string, any>
>;

export type SearchReposResponse = Response<
  | SearchRepos200ResponseBody
  | SearchRepos422ResponseBody
  | SearchRepos503ResponseBody,
  Record<string, any>,
  200 | 304 | 422 | 503
>;

export type SearchReposHandler = (
  req: SearchReposRequest,
  res: SearchReposResponse,
  next: NextFunction
) => Promise<void> | void;

export type SearchTopicsRequest = Request<
  ParamsDictionary,
  SearchTopics200ResponseBody,
  unknown,
  SearchTopicsRequestQuery,
  Record<string, any>
>;

export type SearchTopicsResponse = Response<
  SearchTopics200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export type SearchTopicsHandler = (
  req: SearchTopicsRequest,
  res: SearchTopicsResponse,
  next: NextFunction
) => Promise<void> | void;

export type SearchUsersRequest = Request<
  ParamsDictionary,
  | SearchUsers200ResponseBody
  | SearchUsers422ResponseBody
  | SearchUsers503ResponseBody,
  unknown,
  SearchUsersRequestQuery,
  Record<string, any>
>;

export type SearchUsersResponse = Response<
  | SearchUsers200ResponseBody
  | SearchUsers422ResponseBody
  | SearchUsers503ResponseBody,
  Record<string, any>,
  200 | 304 | 422 | 503
>;

export type SearchUsersHandler = (
  req: SearchUsersRequest,
  res: SearchUsersResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsGetLegacyRequest = Request<
  TeamsGetLegacyRequestPath,
  TeamsGetLegacy200ResponseBody | TeamsGetLegacy404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetLegacyResponse = Response<
  TeamsGetLegacy200ResponseBody | TeamsGetLegacy404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type TeamsGetLegacyHandler = (
  req: TeamsGetLegacyRequest,
  res: TeamsGetLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsUpdateLegacyRequest = Request<
  TeamsUpdateLegacyRequestPath,
  | TeamsUpdateLegacy200ResponseBody
  | TeamsUpdateLegacy201ResponseBody
  | TeamsUpdateLegacy403ResponseBody
  | TeamsUpdateLegacy404ResponseBody
  | TeamsUpdateLegacy422ResponseBody,
  TeamsUpdateLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsUpdateLegacyResponse = Response<
  | TeamsUpdateLegacy200ResponseBody
  | TeamsUpdateLegacy201ResponseBody
  | TeamsUpdateLegacy403ResponseBody
  | TeamsUpdateLegacy404ResponseBody
  | TeamsUpdateLegacy422ResponseBody,
  Record<string, any>,
  200 | 201 | 403 | 404 | 422
>;

export type TeamsUpdateLegacyHandler = (
  req: TeamsUpdateLegacyRequest,
  res: TeamsUpdateLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsDeleteLegacyRequest = Request<
  TeamsDeleteLegacyRequestPath,
  TeamsDeleteLegacy404ResponseBody | TeamsDeleteLegacy422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsDeleteLegacyResponse = Response<
  TeamsDeleteLegacy404ResponseBody | TeamsDeleteLegacy422ResponseBody,
  Record<string, any>,
  204 | 404 | 422
>;

export type TeamsDeleteLegacyHandler = (
  req: TeamsDeleteLegacyRequest,
  res: TeamsDeleteLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListDiscussionsLegacyRequest = Request<
  TeamsListDiscussionsLegacyRequestPath,
  TeamsListDiscussionsLegacy200ResponseBody,
  unknown,
  TeamsListDiscussionsLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListDiscussionsLegacyResponse = Response<
  TeamsListDiscussionsLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsListDiscussionsLegacyHandler = (
  req: TeamsListDiscussionsLegacyRequest,
  res: TeamsListDiscussionsLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsCreateDiscussionLegacyRequest = Request<
  TeamsCreateDiscussionLegacyRequestPath,
  TeamsCreateDiscussionLegacy201ResponseBody,
  TeamsCreateDiscussionLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCreateDiscussionLegacyResponse = Response<
  TeamsCreateDiscussionLegacy201ResponseBody,
  Record<string, any>,
  201
>;

export type TeamsCreateDiscussionLegacyHandler = (
  req: TeamsCreateDiscussionLegacyRequest,
  res: TeamsCreateDiscussionLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsGetDiscussionLegacyRequest = Request<
  TeamsGetDiscussionLegacyRequestPath,
  TeamsGetDiscussionLegacy200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetDiscussionLegacyResponse = Response<
  TeamsGetDiscussionLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsGetDiscussionLegacyHandler = (
  req: TeamsGetDiscussionLegacyRequest,
  res: TeamsGetDiscussionLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsUpdateDiscussionLegacyRequest = Request<
  TeamsUpdateDiscussionLegacyRequestPath,
  TeamsUpdateDiscussionLegacy200ResponseBody,
  TeamsUpdateDiscussionLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsUpdateDiscussionLegacyResponse = Response<
  TeamsUpdateDiscussionLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsUpdateDiscussionLegacyHandler = (
  req: TeamsUpdateDiscussionLegacyRequest,
  res: TeamsUpdateDiscussionLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsDeleteDiscussionLegacyRequest = Request<
  TeamsDeleteDiscussionLegacyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsDeleteDiscussionLegacyResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type TeamsDeleteDiscussionLegacyHandler = (
  req: TeamsDeleteDiscussionLegacyRequest,
  res: TeamsDeleteDiscussionLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListDiscussionCommentsLegacyRequest = Request<
  TeamsListDiscussionCommentsLegacyRequestPath,
  TeamsListDiscussionCommentsLegacy200ResponseBody,
  unknown,
  TeamsListDiscussionCommentsLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListDiscussionCommentsLegacyResponse = Response<
  TeamsListDiscussionCommentsLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsListDiscussionCommentsLegacyHandler = (
  req: TeamsListDiscussionCommentsLegacyRequest,
  res: TeamsListDiscussionCommentsLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsCreateDiscussionCommentLegacyRequest = Request<
  TeamsCreateDiscussionCommentLegacyRequestPath,
  TeamsCreateDiscussionCommentLegacy201ResponseBody,
  TeamsCreateDiscussionCommentLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCreateDiscussionCommentLegacyResponse = Response<
  TeamsCreateDiscussionCommentLegacy201ResponseBody,
  Record<string, any>,
  201
>;

export type TeamsCreateDiscussionCommentLegacyHandler = (
  req: TeamsCreateDiscussionCommentLegacyRequest,
  res: TeamsCreateDiscussionCommentLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsGetDiscussionCommentLegacyRequest = Request<
  TeamsGetDiscussionCommentLegacyRequestPath,
  TeamsGetDiscussionCommentLegacy200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetDiscussionCommentLegacyResponse = Response<
  TeamsGetDiscussionCommentLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsGetDiscussionCommentLegacyHandler = (
  req: TeamsGetDiscussionCommentLegacyRequest,
  res: TeamsGetDiscussionCommentLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsUpdateDiscussionCommentLegacyRequest = Request<
  TeamsUpdateDiscussionCommentLegacyRequestPath,
  TeamsUpdateDiscussionCommentLegacy200ResponseBody,
  TeamsUpdateDiscussionCommentLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsUpdateDiscussionCommentLegacyResponse = Response<
  TeamsUpdateDiscussionCommentLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsUpdateDiscussionCommentLegacyHandler = (
  req: TeamsUpdateDiscussionCommentLegacyRequest,
  res: TeamsUpdateDiscussionCommentLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsDeleteDiscussionCommentLegacyRequest = Request<
  TeamsDeleteDiscussionCommentLegacyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsDeleteDiscussionCommentLegacyResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type TeamsDeleteDiscussionCommentLegacyHandler = (
  req: TeamsDeleteDiscussionCommentLegacyRequest,
  res: TeamsDeleteDiscussionCommentLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsListForTeamDiscussionCommentLegacyRequest = Request<
  ReactionsListForTeamDiscussionCommentLegacyRequestPath,
  ReactionsListForTeamDiscussionCommentLegacy200ResponseBody,
  unknown,
  ReactionsListForTeamDiscussionCommentLegacyRequestQuery,
  Record<string, any>
>;

export type ReactionsListForTeamDiscussionCommentLegacyResponse = Response<
  ReactionsListForTeamDiscussionCommentLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export type ReactionsListForTeamDiscussionCommentLegacyHandler = (
  req: ReactionsListForTeamDiscussionCommentLegacyRequest,
  res: ReactionsListForTeamDiscussionCommentLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsCreateForTeamDiscussionCommentLegacyRequest = Request<
  ReactionsCreateForTeamDiscussionCommentLegacyRequestPath,
  ReactionsCreateForTeamDiscussionCommentLegacy201ResponseBody,
  ReactionsCreateForTeamDiscussionCommentLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForTeamDiscussionCommentLegacyResponse = Response<
  ReactionsCreateForTeamDiscussionCommentLegacy201ResponseBody,
  Record<string, any>,
  201
>;

export type ReactionsCreateForTeamDiscussionCommentLegacyHandler = (
  req: ReactionsCreateForTeamDiscussionCommentLegacyRequest,
  res: ReactionsCreateForTeamDiscussionCommentLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsListForTeamDiscussionLegacyRequest = Request<
  ReactionsListForTeamDiscussionLegacyRequestPath,
  ReactionsListForTeamDiscussionLegacy200ResponseBody,
  unknown,
  ReactionsListForTeamDiscussionLegacyRequestQuery,
  Record<string, any>
>;

export type ReactionsListForTeamDiscussionLegacyResponse = Response<
  ReactionsListForTeamDiscussionLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export type ReactionsListForTeamDiscussionLegacyHandler = (
  req: ReactionsListForTeamDiscussionLegacyRequest,
  res: ReactionsListForTeamDiscussionLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReactionsCreateForTeamDiscussionLegacyRequest = Request<
  ReactionsCreateForTeamDiscussionLegacyRequestPath,
  ReactionsCreateForTeamDiscussionLegacy201ResponseBody,
  ReactionsCreateForTeamDiscussionLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForTeamDiscussionLegacyResponse = Response<
  ReactionsCreateForTeamDiscussionLegacy201ResponseBody,
  Record<string, any>,
  201
>;

export type ReactionsCreateForTeamDiscussionLegacyHandler = (
  req: ReactionsCreateForTeamDiscussionLegacyRequest,
  res: ReactionsCreateForTeamDiscussionLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListPendingInvitationsLegacyRequest = Request<
  TeamsListPendingInvitationsLegacyRequestPath,
  TeamsListPendingInvitationsLegacy200ResponseBody,
  unknown,
  TeamsListPendingInvitationsLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListPendingInvitationsLegacyResponse = Response<
  TeamsListPendingInvitationsLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export type TeamsListPendingInvitationsLegacyHandler = (
  req: TeamsListPendingInvitationsLegacyRequest,
  res: TeamsListPendingInvitationsLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListMembersLegacyRequest = Request<
  TeamsListMembersLegacyRequestPath,
  TeamsListMembersLegacy200ResponseBody | TeamsListMembersLegacy404ResponseBody,
  unknown,
  TeamsListMembersLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListMembersLegacyResponse = Response<
  TeamsListMembersLegacy200ResponseBody | TeamsListMembersLegacy404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type TeamsListMembersLegacyHandler = (
  req: TeamsListMembersLegacyRequest,
  res: TeamsListMembersLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsGetMemberLegacyRequest = Request<
  TeamsGetMemberLegacyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetMemberLegacyResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export type TeamsGetMemberLegacyHandler = (
  req: TeamsGetMemberLegacyRequest,
  res: TeamsGetMemberLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsAddMemberLegacyRequest = Request<
  TeamsAddMemberLegacyRequestPath,
  TeamsAddMemberLegacy403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddMemberLegacyResponse = Response<
  TeamsAddMemberLegacy403ResponseBody,
  Record<string, any>,
  204 | 403 | 404 | 422
>;

export type TeamsAddMemberLegacyHandler = (
  req: TeamsAddMemberLegacyRequest,
  res: TeamsAddMemberLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsRemoveMemberLegacyRequest = Request<
  TeamsRemoveMemberLegacyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveMemberLegacyResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export type TeamsRemoveMemberLegacyHandler = (
  req: TeamsRemoveMemberLegacyRequest,
  res: TeamsRemoveMemberLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsGetMembershipForUserLegacyRequest = Request<
  TeamsGetMembershipForUserLegacyRequestPath,
  | TeamsGetMembershipForUserLegacy200ResponseBody
  | TeamsGetMembershipForUserLegacy404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetMembershipForUserLegacyResponse = Response<
  | TeamsGetMembershipForUserLegacy200ResponseBody
  | TeamsGetMembershipForUserLegacy404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type TeamsGetMembershipForUserLegacyHandler = (
  req: TeamsGetMembershipForUserLegacyRequest,
  res: TeamsGetMembershipForUserLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsAddOrUpdateMembershipForUserLegacyRequest = Request<
  TeamsAddOrUpdateMembershipForUserLegacyRequestPath,
  | TeamsAddOrUpdateMembershipForUserLegacy200ResponseBody
  | TeamsAddOrUpdateMembershipForUserLegacy404ResponseBody,
  TeamsAddOrUpdateMembershipForUserLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddOrUpdateMembershipForUserLegacyResponse = Response<
  | TeamsAddOrUpdateMembershipForUserLegacy200ResponseBody
  | TeamsAddOrUpdateMembershipForUserLegacy404ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export type TeamsAddOrUpdateMembershipForUserLegacyHandler = (
  req: TeamsAddOrUpdateMembershipForUserLegacyRequest,
  res: TeamsAddOrUpdateMembershipForUserLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsRemoveMembershipForUserLegacyRequest = Request<
  TeamsRemoveMembershipForUserLegacyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveMembershipForUserLegacyResponse = Response<
  unknown,
  Record<string, any>,
  204 | 403
>;

export type TeamsRemoveMembershipForUserLegacyHandler = (
  req: TeamsRemoveMembershipForUserLegacyRequest,
  res: TeamsRemoveMembershipForUserLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListProjectsLegacyRequest = Request<
  TeamsListProjectsLegacyRequestPath,
  | TeamsListProjectsLegacy200ResponseBody
  | TeamsListProjectsLegacy404ResponseBody,
  unknown,
  TeamsListProjectsLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListProjectsLegacyResponse = Response<
  | TeamsListProjectsLegacy200ResponseBody
  | TeamsListProjectsLegacy404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type TeamsListProjectsLegacyHandler = (
  req: TeamsListProjectsLegacyRequest,
  res: TeamsListProjectsLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsCheckPermissionsForProjectLegacyRequest = Request<
  TeamsCheckPermissionsForProjectLegacyRequestPath,
  TeamsCheckPermissionsForProjectLegacy200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCheckPermissionsForProjectLegacyResponse = Response<
  TeamsCheckPermissionsForProjectLegacy200ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type TeamsCheckPermissionsForProjectLegacyHandler = (
  req: TeamsCheckPermissionsForProjectLegacyRequest,
  res: TeamsCheckPermissionsForProjectLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsAddOrUpdateProjectPermissionsLegacyRequest = Request<
  TeamsAddOrUpdateProjectPermissionsLegacyRequestPath,
  | TeamsAddOrUpdateProjectPermissionsLegacy403ResponseBody
  | TeamsAddOrUpdateProjectPermissionsLegacy404ResponseBody
  | TeamsAddOrUpdateProjectPermissionsLegacy422ResponseBody,
  TeamsAddOrUpdateProjectPermissionsLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddOrUpdateProjectPermissionsLegacyResponse = Response<
  | TeamsAddOrUpdateProjectPermissionsLegacy403ResponseBody
  | TeamsAddOrUpdateProjectPermissionsLegacy404ResponseBody
  | TeamsAddOrUpdateProjectPermissionsLegacy422ResponseBody,
  Record<string, any>,
  204 | 403 | 404 | 422
>;

export type TeamsAddOrUpdateProjectPermissionsLegacyHandler = (
  req: TeamsAddOrUpdateProjectPermissionsLegacyRequest,
  res: TeamsAddOrUpdateProjectPermissionsLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsRemoveProjectLegacyRequest = Request<
  TeamsRemoveProjectLegacyRequestPath,
  | TeamsRemoveProjectLegacy404ResponseBody
  | TeamsRemoveProjectLegacy422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveProjectLegacyResponse = Response<
  | TeamsRemoveProjectLegacy404ResponseBody
  | TeamsRemoveProjectLegacy422ResponseBody,
  Record<string, any>,
  204 | 404 | 422
>;

export type TeamsRemoveProjectLegacyHandler = (
  req: TeamsRemoveProjectLegacyRequest,
  res: TeamsRemoveProjectLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListReposLegacyRequest = Request<
  TeamsListReposLegacyRequestPath,
  TeamsListReposLegacy200ResponseBody | TeamsListReposLegacy404ResponseBody,
  unknown,
  TeamsListReposLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListReposLegacyResponse = Response<
  TeamsListReposLegacy200ResponseBody | TeamsListReposLegacy404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type TeamsListReposLegacyHandler = (
  req: TeamsListReposLegacyRequest,
  res: TeamsListReposLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsCheckPermissionsForRepoLegacyRequest = Request<
  TeamsCheckPermissionsForRepoLegacyRequestPath,
  TeamsCheckPermissionsForRepoLegacy200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCheckPermissionsForRepoLegacyResponse = Response<
  TeamsCheckPermissionsForRepoLegacy200ResponseBody,
  Record<string, any>,
  200 | 204 | 404
>;

export type TeamsCheckPermissionsForRepoLegacyHandler = (
  req: TeamsCheckPermissionsForRepoLegacyRequest,
  res: TeamsCheckPermissionsForRepoLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsAddOrUpdateRepoPermissionsLegacyRequest = Request<
  TeamsAddOrUpdateRepoPermissionsLegacyRequestPath,
  | TeamsAddOrUpdateRepoPermissionsLegacy403ResponseBody
  | TeamsAddOrUpdateRepoPermissionsLegacy422ResponseBody,
  TeamsAddOrUpdateRepoPermissionsLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddOrUpdateRepoPermissionsLegacyResponse = Response<
  | TeamsAddOrUpdateRepoPermissionsLegacy403ResponseBody
  | TeamsAddOrUpdateRepoPermissionsLegacy422ResponseBody,
  Record<string, any>,
  204 | 403 | 422
>;

export type TeamsAddOrUpdateRepoPermissionsLegacyHandler = (
  req: TeamsAddOrUpdateRepoPermissionsLegacyRequest,
  res: TeamsAddOrUpdateRepoPermissionsLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsRemoveRepoLegacyRequest = Request<
  TeamsRemoveRepoLegacyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveRepoLegacyResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type TeamsRemoveRepoLegacyHandler = (
  req: TeamsRemoveRepoLegacyRequest,
  res: TeamsRemoveRepoLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListChildLegacyRequest = Request<
  TeamsListChildLegacyRequestPath,
  | TeamsListChildLegacy200ResponseBody
  | TeamsListChildLegacy403ResponseBody
  | TeamsListChildLegacy404ResponseBody
  | TeamsListChildLegacy422ResponseBody,
  unknown,
  TeamsListChildLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListChildLegacyResponse = Response<
  | TeamsListChildLegacy200ResponseBody
  | TeamsListChildLegacy403ResponseBody
  | TeamsListChildLegacy404ResponseBody
  | TeamsListChildLegacy422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export type TeamsListChildLegacyHandler = (
  req: TeamsListChildLegacyRequest,
  res: TeamsListChildLegacyResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersGetAuthenticatedRequest = Request<
  ParamsDictionary,
  | UsersGetAuthenticated200ResponseBody
  | UsersGetAuthenticated401ResponseBody
  | UsersGetAuthenticated403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersGetAuthenticatedResponse = Response<
  | UsersGetAuthenticated200ResponseBody
  | UsersGetAuthenticated401ResponseBody
  | UsersGetAuthenticated403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type UsersGetAuthenticatedHandler = (
  req: UsersGetAuthenticatedRequest,
  res: UsersGetAuthenticatedResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersUpdateAuthenticatedRequest = Request<
  ParamsDictionary,
  | UsersUpdateAuthenticated200ResponseBody
  | UsersUpdateAuthenticated401ResponseBody
  | UsersUpdateAuthenticated403ResponseBody
  | UsersUpdateAuthenticated404ResponseBody
  | UsersUpdateAuthenticated422ResponseBody,
  UsersUpdateAuthenticatedRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersUpdateAuthenticatedResponse = Response<
  | UsersUpdateAuthenticated200ResponseBody
  | UsersUpdateAuthenticated401ResponseBody
  | UsersUpdateAuthenticated403ResponseBody
  | UsersUpdateAuthenticated404ResponseBody
  | UsersUpdateAuthenticated422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 422
>;

export type UsersUpdateAuthenticatedHandler = (
  req: UsersUpdateAuthenticatedRequest,
  res: UsersUpdateAuthenticatedResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListBlockedByAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListBlockedByAuthenticatedUser200ResponseBody
  | UsersListBlockedByAuthenticatedUser401ResponseBody
  | UsersListBlockedByAuthenticatedUser403ResponseBody
  | UsersListBlockedByAuthenticatedUser404ResponseBody,
  unknown,
  UsersListBlockedByAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListBlockedByAuthenticatedUserResponse = Response<
  | UsersListBlockedByAuthenticatedUser200ResponseBody
  | UsersListBlockedByAuthenticatedUser401ResponseBody
  | UsersListBlockedByAuthenticatedUser403ResponseBody
  | UsersListBlockedByAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export type UsersListBlockedByAuthenticatedUserHandler = (
  req: UsersListBlockedByAuthenticatedUserRequest,
  res: UsersListBlockedByAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersCheckBlockedRequest = Request<
  UsersCheckBlockedRequestPath,
  | UsersCheckBlocked401ResponseBody
  | UsersCheckBlocked403ResponseBody
  | UsersCheckBlocked404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersCheckBlockedResponse = Response<
  | UsersCheckBlocked401ResponseBody
  | UsersCheckBlocked403ResponseBody
  | UsersCheckBlocked404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export type UsersCheckBlockedHandler = (
  req: UsersCheckBlockedRequest,
  res: UsersCheckBlockedResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersBlockRequest = Request<
  UsersBlockRequestPath,
  | UsersBlock401ResponseBody
  | UsersBlock403ResponseBody
  | UsersBlock404ResponseBody
  | UsersBlock422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersBlockResponse = Response<
  | UsersBlock401ResponseBody
  | UsersBlock403ResponseBody
  | UsersBlock404ResponseBody
  | UsersBlock422ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404 | 422
>;

export type UsersBlockHandler = (
  req: UsersBlockRequest,
  res: UsersBlockResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersUnblockRequest = Request<
  UsersUnblockRequestPath,
  | UsersUnblock401ResponseBody
  | UsersUnblock403ResponseBody
  | UsersUnblock404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersUnblockResponse = Response<
  | UsersUnblock401ResponseBody
  | UsersUnblock403ResponseBody
  | UsersUnblock404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export type UsersUnblockHandler = (
  req: UsersUnblockRequest,
  res: UsersUnblockResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesListForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | CodespacesListForAuthenticatedUser200ResponseBody
  | CodespacesListForAuthenticatedUser401ResponseBody
  | CodespacesListForAuthenticatedUser403ResponseBody
  | CodespacesListForAuthenticatedUser404ResponseBody
  | CodespacesListForAuthenticatedUser500ResponseBody,
  unknown,
  CodespacesListForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type CodespacesListForAuthenticatedUserResponse = Response<
  | CodespacesListForAuthenticatedUser200ResponseBody
  | CodespacesListForAuthenticatedUser401ResponseBody
  | CodespacesListForAuthenticatedUser403ResponseBody
  | CodespacesListForAuthenticatedUser404ResponseBody
  | CodespacesListForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export type CodespacesListForAuthenticatedUserHandler = (
  req: CodespacesListForAuthenticatedUserRequest,
  res: CodespacesListForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesCreateForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | CodespacesCreateForAuthenticatedUser201ResponseBody
  | CodespacesCreateForAuthenticatedUser202ResponseBody
  | CodespacesCreateForAuthenticatedUser401ResponseBody
  | CodespacesCreateForAuthenticatedUser403ResponseBody
  | CodespacesCreateForAuthenticatedUser404ResponseBody
  | CodespacesCreateForAuthenticatedUser503ResponseBody,
  CodespacesCreateForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCreateForAuthenticatedUserResponse = Response<
  | CodespacesCreateForAuthenticatedUser201ResponseBody
  | CodespacesCreateForAuthenticatedUser202ResponseBody
  | CodespacesCreateForAuthenticatedUser401ResponseBody
  | CodespacesCreateForAuthenticatedUser403ResponseBody
  | CodespacesCreateForAuthenticatedUser404ResponseBody
  | CodespacesCreateForAuthenticatedUser503ResponseBody,
  Record<string, any>,
  201 | 202 | 401 | 403 | 404 | 503
>;

export type CodespacesCreateForAuthenticatedUserHandler = (
  req: CodespacesCreateForAuthenticatedUserRequest,
  res: CodespacesCreateForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesListSecretsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  CodespacesListSecretsForAuthenticatedUser200ResponseBody,
  unknown,
  CodespacesListSecretsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type CodespacesListSecretsForAuthenticatedUserResponse = Response<
  CodespacesListSecretsForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export type CodespacesListSecretsForAuthenticatedUserHandler = (
  req: CodespacesListSecretsForAuthenticatedUserRequest,
  res: CodespacesListSecretsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesGetPublicKeyForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  CodespacesGetPublicKeyForAuthenticatedUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetPublicKeyForAuthenticatedUserResponse = Response<
  CodespacesGetPublicKeyForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export type CodespacesGetPublicKeyForAuthenticatedUserHandler = (
  req: CodespacesGetPublicKeyForAuthenticatedUserRequest,
  res: CodespacesGetPublicKeyForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesGetSecretForAuthenticatedUserRequest = Request<
  CodespacesGetSecretForAuthenticatedUserRequestPath,
  CodespacesGetSecretForAuthenticatedUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetSecretForAuthenticatedUserResponse = Response<
  CodespacesGetSecretForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export type CodespacesGetSecretForAuthenticatedUserHandler = (
  req: CodespacesGetSecretForAuthenticatedUserRequest,
  res: CodespacesGetSecretForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesCreateOrUpdateSecretForAuthenticatedUserRequest = Request<
  CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestPath,
  | CodespacesCreateOrUpdateSecretForAuthenticatedUser201ResponseBody
  | CodespacesCreateOrUpdateSecretForAuthenticatedUser404ResponseBody
  | CodespacesCreateOrUpdateSecretForAuthenticatedUser422ResponseBody,
  CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCreateOrUpdateSecretForAuthenticatedUserResponse = Response<
  | CodespacesCreateOrUpdateSecretForAuthenticatedUser201ResponseBody
  | CodespacesCreateOrUpdateSecretForAuthenticatedUser404ResponseBody
  | CodespacesCreateOrUpdateSecretForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 204 | 404 | 422
>;

export type CodespacesCreateOrUpdateSecretForAuthenticatedUserHandler = (
  req: CodespacesCreateOrUpdateSecretForAuthenticatedUserRequest,
  res: CodespacesCreateOrUpdateSecretForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesDeleteSecretForAuthenticatedUserRequest = Request<
  CodespacesDeleteSecretForAuthenticatedUserRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesDeleteSecretForAuthenticatedUserResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type CodespacesDeleteSecretForAuthenticatedUserHandler = (
  req: CodespacesDeleteSecretForAuthenticatedUserRequest,
  res: CodespacesDeleteSecretForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesListRepositoriesForSecretForAuthenticatedUserRequest = Request<
  CodespacesListRepositoriesForSecretForAuthenticatedUserRequestPath,
  | CodespacesListRepositoriesForSecretForAuthenticatedUser200ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser401ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser403ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser404ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesListRepositoriesForSecretForAuthenticatedUserResponse = Response<
  | CodespacesListRepositoriesForSecretForAuthenticatedUser200ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser401ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser403ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser404ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404 | 500
>;

export type CodespacesListRepositoriesForSecretForAuthenticatedUserHandler = (
  req: CodespacesListRepositoriesForSecretForAuthenticatedUserRequest,
  res: CodespacesListRepositoriesForSecretForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesSetRepositoriesForSecretForAuthenticatedUserRequest = Request<
  CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestPath,
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser401ResponseBody
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser403ResponseBody
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser404ResponseBody
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser500ResponseBody,
  CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesSetRepositoriesForSecretForAuthenticatedUserResponse = Response<
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser401ResponseBody
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser403ResponseBody
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser404ResponseBody
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404 | 500
>;

export type CodespacesSetRepositoriesForSecretForAuthenticatedUserHandler = (
  req: CodespacesSetRepositoriesForSecretForAuthenticatedUserRequest,
  res: CodespacesSetRepositoriesForSecretForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesAddRepositoryForSecretForAuthenticatedUserRequest = Request<
  CodespacesAddRepositoryForSecretForAuthenticatedUserRequestPath,
  | CodespacesAddRepositoryForSecretForAuthenticatedUser401ResponseBody
  | CodespacesAddRepositoryForSecretForAuthenticatedUser403ResponseBody
  | CodespacesAddRepositoryForSecretForAuthenticatedUser404ResponseBody
  | CodespacesAddRepositoryForSecretForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesAddRepositoryForSecretForAuthenticatedUserResponse = Response<
  | CodespacesAddRepositoryForSecretForAuthenticatedUser401ResponseBody
  | CodespacesAddRepositoryForSecretForAuthenticatedUser403ResponseBody
  | CodespacesAddRepositoryForSecretForAuthenticatedUser404ResponseBody
  | CodespacesAddRepositoryForSecretForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404 | 500
>;

export type CodespacesAddRepositoryForSecretForAuthenticatedUserHandler = (
  req: CodespacesAddRepositoryForSecretForAuthenticatedUserRequest,
  res: CodespacesAddRepositoryForSecretForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUserRequest = Request<
  CodespacesRemoveRepositoryForSecretForAuthenticatedUserRequestPath,
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser401ResponseBody
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser403ResponseBody
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser404ResponseBody
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse = Response<
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser401ResponseBody
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser403ResponseBody
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser404ResponseBody
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404 | 500
>;

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUserHandler = (
  req: CodespacesRemoveRepositoryForSecretForAuthenticatedUserRequest,
  res: CodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesGetForAuthenticatedUserRequest = Request<
  CodespacesGetForAuthenticatedUserRequestPath,
  | CodespacesGetForAuthenticatedUser200ResponseBody
  | CodespacesGetForAuthenticatedUser401ResponseBody
  | CodespacesGetForAuthenticatedUser403ResponseBody
  | CodespacesGetForAuthenticatedUser404ResponseBody
  | CodespacesGetForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetForAuthenticatedUserResponse = Response<
  | CodespacesGetForAuthenticatedUser200ResponseBody
  | CodespacesGetForAuthenticatedUser401ResponseBody
  | CodespacesGetForAuthenticatedUser403ResponseBody
  | CodespacesGetForAuthenticatedUser404ResponseBody
  | CodespacesGetForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export type CodespacesGetForAuthenticatedUserHandler = (
  req: CodespacesGetForAuthenticatedUserRequest,
  res: CodespacesGetForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesUpdateForAuthenticatedUserRequest = Request<
  CodespacesUpdateForAuthenticatedUserRequestPath,
  | CodespacesUpdateForAuthenticatedUser200ResponseBody
  | CodespacesUpdateForAuthenticatedUser401ResponseBody
  | CodespacesUpdateForAuthenticatedUser403ResponseBody
  | CodespacesUpdateForAuthenticatedUser404ResponseBody,
  CodespacesUpdateForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesUpdateForAuthenticatedUserResponse = Response<
  | CodespacesUpdateForAuthenticatedUser200ResponseBody
  | CodespacesUpdateForAuthenticatedUser401ResponseBody
  | CodespacesUpdateForAuthenticatedUser403ResponseBody
  | CodespacesUpdateForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404
>;

export type CodespacesUpdateForAuthenticatedUserHandler = (
  req: CodespacesUpdateForAuthenticatedUserRequest,
  res: CodespacesUpdateForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesDeleteForAuthenticatedUserRequest = Request<
  CodespacesDeleteForAuthenticatedUserRequestPath,
  | CodespacesDeleteForAuthenticatedUser202ResponseBody
  | CodespacesDeleteForAuthenticatedUser401ResponseBody
  | CodespacesDeleteForAuthenticatedUser403ResponseBody
  | CodespacesDeleteForAuthenticatedUser404ResponseBody
  | CodespacesDeleteForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesDeleteForAuthenticatedUserResponse = Response<
  | CodespacesDeleteForAuthenticatedUser202ResponseBody
  | CodespacesDeleteForAuthenticatedUser401ResponseBody
  | CodespacesDeleteForAuthenticatedUser403ResponseBody
  | CodespacesDeleteForAuthenticatedUser404ResponseBody
  | CodespacesDeleteForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  202 | 304 | 401 | 403 | 404 | 500
>;

export type CodespacesDeleteForAuthenticatedUserHandler = (
  req: CodespacesDeleteForAuthenticatedUserRequest,
  res: CodespacesDeleteForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesExportForAuthenticatedUserRequest = Request<
  CodespacesExportForAuthenticatedUserRequestPath,
  | CodespacesExportForAuthenticatedUser202ResponseBody
  | CodespacesExportForAuthenticatedUser401ResponseBody
  | CodespacesExportForAuthenticatedUser403ResponseBody
  | CodespacesExportForAuthenticatedUser404ResponseBody
  | CodespacesExportForAuthenticatedUser422ResponseBody
  | CodespacesExportForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesExportForAuthenticatedUserResponse = Response<
  | CodespacesExportForAuthenticatedUser202ResponseBody
  | CodespacesExportForAuthenticatedUser401ResponseBody
  | CodespacesExportForAuthenticatedUser403ResponseBody
  | CodespacesExportForAuthenticatedUser404ResponseBody
  | CodespacesExportForAuthenticatedUser422ResponseBody
  | CodespacesExportForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  202 | 401 | 403 | 404 | 422 | 500
>;

export type CodespacesExportForAuthenticatedUserHandler = (
  req: CodespacesExportForAuthenticatedUserRequest,
  res: CodespacesExportForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesGetExportDetailsForAuthenticatedUserRequest = Request<
  CodespacesGetExportDetailsForAuthenticatedUserRequestPath,
  | CodespacesGetExportDetailsForAuthenticatedUser200ResponseBody
  | CodespacesGetExportDetailsForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetExportDetailsForAuthenticatedUserResponse = Response<
  | CodespacesGetExportDetailsForAuthenticatedUser200ResponseBody
  | CodespacesGetExportDetailsForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type CodespacesGetExportDetailsForAuthenticatedUserHandler = (
  req: CodespacesGetExportDetailsForAuthenticatedUserRequest,
  res: CodespacesGetExportDetailsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesCodespaceMachinesForAuthenticatedUserRequest = Request<
  CodespacesCodespaceMachinesForAuthenticatedUserRequestPath,
  | CodespacesCodespaceMachinesForAuthenticatedUser200ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser401ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser403ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser404ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCodespaceMachinesForAuthenticatedUserResponse = Response<
  | CodespacesCodespaceMachinesForAuthenticatedUser200ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser401ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser403ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser404ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export type CodespacesCodespaceMachinesForAuthenticatedUserHandler = (
  req: CodespacesCodespaceMachinesForAuthenticatedUserRequest,
  res: CodespacesCodespaceMachinesForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesStartForAuthenticatedUserRequest = Request<
  CodespacesStartForAuthenticatedUserRequestPath,
  | CodespacesStartForAuthenticatedUser200ResponseBody
  | CodespacesStartForAuthenticatedUser400ResponseBody
  | CodespacesStartForAuthenticatedUser401ResponseBody
  | CodespacesStartForAuthenticatedUser402ResponseBody
  | CodespacesStartForAuthenticatedUser403ResponseBody
  | CodespacesStartForAuthenticatedUser404ResponseBody
  | CodespacesStartForAuthenticatedUser409ResponseBody
  | CodespacesStartForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesStartForAuthenticatedUserResponse = Response<
  | CodespacesStartForAuthenticatedUser200ResponseBody
  | CodespacesStartForAuthenticatedUser400ResponseBody
  | CodespacesStartForAuthenticatedUser401ResponseBody
  | CodespacesStartForAuthenticatedUser402ResponseBody
  | CodespacesStartForAuthenticatedUser403ResponseBody
  | CodespacesStartForAuthenticatedUser404ResponseBody
  | CodespacesStartForAuthenticatedUser409ResponseBody
  | CodespacesStartForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 304 | 400 | 401 | 402 | 403 | 404 | 409 | 500
>;

export type CodespacesStartForAuthenticatedUserHandler = (
  req: CodespacesStartForAuthenticatedUserRequest,
  res: CodespacesStartForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type CodespacesStopForAuthenticatedUserRequest = Request<
  CodespacesStopForAuthenticatedUserRequestPath,
  | CodespacesStopForAuthenticatedUser200ResponseBody
  | CodespacesStopForAuthenticatedUser401ResponseBody
  | CodespacesStopForAuthenticatedUser403ResponseBody
  | CodespacesStopForAuthenticatedUser404ResponseBody
  | CodespacesStopForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesStopForAuthenticatedUserResponse = Response<
  | CodespacesStopForAuthenticatedUser200ResponseBody
  | CodespacesStopForAuthenticatedUser401ResponseBody
  | CodespacesStopForAuthenticatedUser403ResponseBody
  | CodespacesStopForAuthenticatedUser404ResponseBody
  | CodespacesStopForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404 | 500
>;

export type CodespacesStopForAuthenticatedUserHandler = (
  req: CodespacesStopForAuthenticatedUserRequest,
  res: CodespacesStopForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser200ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser401ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser403ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser404ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser422ResponseBody,
  UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse = Response<
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser200ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser401ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser403ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser404ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 422
>;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUserHandler = (
  req: UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequest,
  res: UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListEmailsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListEmailsForAuthenticatedUser200ResponseBody
  | UsersListEmailsForAuthenticatedUser401ResponseBody
  | UsersListEmailsForAuthenticatedUser403ResponseBody
  | UsersListEmailsForAuthenticatedUser404ResponseBody,
  unknown,
  UsersListEmailsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListEmailsForAuthenticatedUserResponse = Response<
  | UsersListEmailsForAuthenticatedUser200ResponseBody
  | UsersListEmailsForAuthenticatedUser401ResponseBody
  | UsersListEmailsForAuthenticatedUser403ResponseBody
  | UsersListEmailsForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export type UsersListEmailsForAuthenticatedUserHandler = (
  req: UsersListEmailsForAuthenticatedUserRequest,
  res: UsersListEmailsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersAddEmailForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersAddEmailForAuthenticatedUser201ResponseBody
  | UsersAddEmailForAuthenticatedUser401ResponseBody
  | UsersAddEmailForAuthenticatedUser403ResponseBody
  | UsersAddEmailForAuthenticatedUser404ResponseBody
  | UsersAddEmailForAuthenticatedUser422ResponseBody,
  UsersAddEmailForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersAddEmailForAuthenticatedUserResponse = Response<
  | UsersAddEmailForAuthenticatedUser201ResponseBody
  | UsersAddEmailForAuthenticatedUser401ResponseBody
  | UsersAddEmailForAuthenticatedUser403ResponseBody
  | UsersAddEmailForAuthenticatedUser404ResponseBody
  | UsersAddEmailForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 404 | 422
>;

export type UsersAddEmailForAuthenticatedUserHandler = (
  req: UsersAddEmailForAuthenticatedUserRequest,
  res: UsersAddEmailForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersDeleteEmailForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersDeleteEmailForAuthenticatedUser401ResponseBody
  | UsersDeleteEmailForAuthenticatedUser403ResponseBody
  | UsersDeleteEmailForAuthenticatedUser404ResponseBody
  | UsersDeleteEmailForAuthenticatedUser422ResponseBody,
  UsersDeleteEmailForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersDeleteEmailForAuthenticatedUserResponse = Response<
  | UsersDeleteEmailForAuthenticatedUser401ResponseBody
  | UsersDeleteEmailForAuthenticatedUser403ResponseBody
  | UsersDeleteEmailForAuthenticatedUser404ResponseBody
  | UsersDeleteEmailForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404 | 422
>;

export type UsersDeleteEmailForAuthenticatedUserHandler = (
  req: UsersDeleteEmailForAuthenticatedUserRequest,
  res: UsersDeleteEmailForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListFollowersForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListFollowersForAuthenticatedUser200ResponseBody
  | UsersListFollowersForAuthenticatedUser401ResponseBody
  | UsersListFollowersForAuthenticatedUser403ResponseBody,
  unknown,
  UsersListFollowersForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListFollowersForAuthenticatedUserResponse = Response<
  | UsersListFollowersForAuthenticatedUser200ResponseBody
  | UsersListFollowersForAuthenticatedUser401ResponseBody
  | UsersListFollowersForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type UsersListFollowersForAuthenticatedUserHandler = (
  req: UsersListFollowersForAuthenticatedUserRequest,
  res: UsersListFollowersForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListFollowedByAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListFollowedByAuthenticatedUser200ResponseBody
  | UsersListFollowedByAuthenticatedUser401ResponseBody
  | UsersListFollowedByAuthenticatedUser403ResponseBody,
  unknown,
  UsersListFollowedByAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListFollowedByAuthenticatedUserResponse = Response<
  | UsersListFollowedByAuthenticatedUser200ResponseBody
  | UsersListFollowedByAuthenticatedUser401ResponseBody
  | UsersListFollowedByAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type UsersListFollowedByAuthenticatedUserHandler = (
  req: UsersListFollowedByAuthenticatedUserRequest,
  res: UsersListFollowedByAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersCheckPersonIsFollowedByAuthenticatedRequest = Request<
  UsersCheckPersonIsFollowedByAuthenticatedRequestPath,
  | UsersCheckPersonIsFollowedByAuthenticated401ResponseBody
  | UsersCheckPersonIsFollowedByAuthenticated403ResponseBody
  | UsersCheckPersonIsFollowedByAuthenticated404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersCheckPersonIsFollowedByAuthenticatedResponse = Response<
  | UsersCheckPersonIsFollowedByAuthenticated401ResponseBody
  | UsersCheckPersonIsFollowedByAuthenticated403ResponseBody
  | UsersCheckPersonIsFollowedByAuthenticated404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export type UsersCheckPersonIsFollowedByAuthenticatedHandler = (
  req: UsersCheckPersonIsFollowedByAuthenticatedRequest,
  res: UsersCheckPersonIsFollowedByAuthenticatedResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersFollowRequest = Request<
  UsersFollowRequestPath,
  | UsersFollow401ResponseBody
  | UsersFollow403ResponseBody
  | UsersFollow404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersFollowResponse = Response<
  | UsersFollow401ResponseBody
  | UsersFollow403ResponseBody
  | UsersFollow404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export type UsersFollowHandler = (
  req: UsersFollowRequest,
  res: UsersFollowResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersUnfollowRequest = Request<
  UsersUnfollowRequestPath,
  | UsersUnfollow401ResponseBody
  | UsersUnfollow403ResponseBody
  | UsersUnfollow404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersUnfollowResponse = Response<
  | UsersUnfollow401ResponseBody
  | UsersUnfollow403ResponseBody
  | UsersUnfollow404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export type UsersUnfollowHandler = (
  req: UsersUnfollowRequest,
  res: UsersUnfollowResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListGpgKeysForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListGpgKeysForAuthenticatedUser200ResponseBody
  | UsersListGpgKeysForAuthenticatedUser401ResponseBody
  | UsersListGpgKeysForAuthenticatedUser403ResponseBody
  | UsersListGpgKeysForAuthenticatedUser404ResponseBody,
  unknown,
  UsersListGpgKeysForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListGpgKeysForAuthenticatedUserResponse = Response<
  | UsersListGpgKeysForAuthenticatedUser200ResponseBody
  | UsersListGpgKeysForAuthenticatedUser401ResponseBody
  | UsersListGpgKeysForAuthenticatedUser403ResponseBody
  | UsersListGpgKeysForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export type UsersListGpgKeysForAuthenticatedUserHandler = (
  req: UsersListGpgKeysForAuthenticatedUserRequest,
  res: UsersListGpgKeysForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersCreateGpgKeyForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersCreateGpgKeyForAuthenticatedUser201ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser401ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser403ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser404ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser422ResponseBody,
  UsersCreateGpgKeyForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersCreateGpgKeyForAuthenticatedUserResponse = Response<
  | UsersCreateGpgKeyForAuthenticatedUser201ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser401ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser403ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser404ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 404 | 422
>;

export type UsersCreateGpgKeyForAuthenticatedUserHandler = (
  req: UsersCreateGpgKeyForAuthenticatedUserRequest,
  res: UsersCreateGpgKeyForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersGetGpgKeyForAuthenticatedUserRequest = Request<
  UsersGetGpgKeyForAuthenticatedUserRequestPath,
  | UsersGetGpgKeyForAuthenticatedUser200ResponseBody
  | UsersGetGpgKeyForAuthenticatedUser401ResponseBody
  | UsersGetGpgKeyForAuthenticatedUser403ResponseBody
  | UsersGetGpgKeyForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersGetGpgKeyForAuthenticatedUserResponse = Response<
  | UsersGetGpgKeyForAuthenticatedUser200ResponseBody
  | UsersGetGpgKeyForAuthenticatedUser401ResponseBody
  | UsersGetGpgKeyForAuthenticatedUser403ResponseBody
  | UsersGetGpgKeyForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export type UsersGetGpgKeyForAuthenticatedUserHandler = (
  req: UsersGetGpgKeyForAuthenticatedUserRequest,
  res: UsersGetGpgKeyForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersDeleteGpgKeyForAuthenticatedUserRequest = Request<
  UsersDeleteGpgKeyForAuthenticatedUserRequestPath,
  | UsersDeleteGpgKeyForAuthenticatedUser401ResponseBody
  | UsersDeleteGpgKeyForAuthenticatedUser403ResponseBody
  | UsersDeleteGpgKeyForAuthenticatedUser404ResponseBody
  | UsersDeleteGpgKeyForAuthenticatedUser422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersDeleteGpgKeyForAuthenticatedUserResponse = Response<
  | UsersDeleteGpgKeyForAuthenticatedUser401ResponseBody
  | UsersDeleteGpgKeyForAuthenticatedUser403ResponseBody
  | UsersDeleteGpgKeyForAuthenticatedUser404ResponseBody
  | UsersDeleteGpgKeyForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404 | 422
>;

export type UsersDeleteGpgKeyForAuthenticatedUserHandler = (
  req: UsersDeleteGpgKeyForAuthenticatedUserRequest,
  res: UsersDeleteGpgKeyForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsListInstallationsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | AppsListInstallationsForAuthenticatedUser200ResponseBody
  | AppsListInstallationsForAuthenticatedUser401ResponseBody
  | AppsListInstallationsForAuthenticatedUser403ResponseBody,
  unknown,
  AppsListInstallationsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type AppsListInstallationsForAuthenticatedUserResponse = Response<
  | AppsListInstallationsForAuthenticatedUser200ResponseBody
  | AppsListInstallationsForAuthenticatedUser401ResponseBody
  | AppsListInstallationsForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type AppsListInstallationsForAuthenticatedUserHandler = (
  req: AppsListInstallationsForAuthenticatedUserRequest,
  res: AppsListInstallationsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsListInstallationReposForAuthenticatedUserRequest = Request<
  AppsListInstallationReposForAuthenticatedUserRequestPath,
  | AppsListInstallationReposForAuthenticatedUser200ResponseBody
  | AppsListInstallationReposForAuthenticatedUser403ResponseBody
  | AppsListInstallationReposForAuthenticatedUser404ResponseBody,
  unknown,
  AppsListInstallationReposForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type AppsListInstallationReposForAuthenticatedUserResponse = Response<
  | AppsListInstallationReposForAuthenticatedUser200ResponseBody
  | AppsListInstallationReposForAuthenticatedUser403ResponseBody
  | AppsListInstallationReposForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export type AppsListInstallationReposForAuthenticatedUserHandler = (
  req: AppsListInstallationReposForAuthenticatedUserRequest,
  res: AppsListInstallationReposForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsAddRepoToInstallationForAuthenticatedUserRequest = Request<
  AppsAddRepoToInstallationForAuthenticatedUserRequestPath,
  | AppsAddRepoToInstallationForAuthenticatedUser403ResponseBody
  | AppsAddRepoToInstallationForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsAddRepoToInstallationForAuthenticatedUserResponse = Response<
  | AppsAddRepoToInstallationForAuthenticatedUser403ResponseBody
  | AppsAddRepoToInstallationForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export type AppsAddRepoToInstallationForAuthenticatedUserHandler = (
  req: AppsAddRepoToInstallationForAuthenticatedUserRequest,
  res: AppsAddRepoToInstallationForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsRemoveRepoFromInstallationForAuthenticatedUserRequest = Request<
  AppsRemoveRepoFromInstallationForAuthenticatedUserRequestPath,
  | AppsRemoveRepoFromInstallationForAuthenticatedUser403ResponseBody
  | AppsRemoveRepoFromInstallationForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsRemoveRepoFromInstallationForAuthenticatedUserResponse = Response<
  | AppsRemoveRepoFromInstallationForAuthenticatedUser403ResponseBody
  | AppsRemoveRepoFromInstallationForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export type AppsRemoveRepoFromInstallationForAuthenticatedUserHandler = (
  req: AppsRemoveRepoFromInstallationForAuthenticatedUserRequest,
  res: AppsRemoveRepoFromInstallationForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type InteractionsGetRestrictionsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  InteractionsGetRestrictionsForAuthenticatedUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsGetRestrictionsForAuthenticatedUserResponse = Response<
  InteractionsGetRestrictionsForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200 | 204
>;

export type InteractionsGetRestrictionsForAuthenticatedUserHandler = (
  req: InteractionsGetRestrictionsForAuthenticatedUserRequest,
  res: InteractionsGetRestrictionsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type InteractionsSetRestrictionsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | InteractionsSetRestrictionsForAuthenticatedUser200ResponseBody
  | InteractionsSetRestrictionsForAuthenticatedUser422ResponseBody,
  InteractionsSetRestrictionsForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsSetRestrictionsForAuthenticatedUserResponse = Response<
  | InteractionsSetRestrictionsForAuthenticatedUser200ResponseBody
  | InteractionsSetRestrictionsForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type InteractionsSetRestrictionsForAuthenticatedUserHandler = (
  req: InteractionsSetRestrictionsForAuthenticatedUserRequest,
  res: InteractionsSetRestrictionsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type InteractionsRemoveRestrictionsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsRemoveRestrictionsForAuthenticatedUserResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export type InteractionsRemoveRestrictionsForAuthenticatedUserHandler = (
  req: InteractionsRemoveRestrictionsForAuthenticatedUserRequest,
  res: InteractionsRemoveRestrictionsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type IssuesListForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | IssuesListForAuthenticatedUser200ResponseBody
  | IssuesListForAuthenticatedUser404ResponseBody,
  unknown,
  IssuesListForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type IssuesListForAuthenticatedUserResponse = Response<
  | IssuesListForAuthenticatedUser200ResponseBody
  | IssuesListForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 404
>;

export type IssuesListForAuthenticatedUserHandler = (
  req: IssuesListForAuthenticatedUserRequest,
  res: IssuesListForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListPublicSshKeysForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListPublicSshKeysForAuthenticatedUser200ResponseBody
  | UsersListPublicSshKeysForAuthenticatedUser401ResponseBody
  | UsersListPublicSshKeysForAuthenticatedUser403ResponseBody
  | UsersListPublicSshKeysForAuthenticatedUser404ResponseBody,
  unknown,
  UsersListPublicSshKeysForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListPublicSshKeysForAuthenticatedUserResponse = Response<
  | UsersListPublicSshKeysForAuthenticatedUser200ResponseBody
  | UsersListPublicSshKeysForAuthenticatedUser401ResponseBody
  | UsersListPublicSshKeysForAuthenticatedUser403ResponseBody
  | UsersListPublicSshKeysForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export type UsersListPublicSshKeysForAuthenticatedUserHandler = (
  req: UsersListPublicSshKeysForAuthenticatedUserRequest,
  res: UsersListPublicSshKeysForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersCreatePublicSshKeyForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersCreatePublicSshKeyForAuthenticatedUser201ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser401ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser403ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser404ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser422ResponseBody,
  UsersCreatePublicSshKeyForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersCreatePublicSshKeyForAuthenticatedUserResponse = Response<
  | UsersCreatePublicSshKeyForAuthenticatedUser201ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser401ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser403ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser404ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 404 | 422
>;

export type UsersCreatePublicSshKeyForAuthenticatedUserHandler = (
  req: UsersCreatePublicSshKeyForAuthenticatedUserRequest,
  res: UsersCreatePublicSshKeyForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersGetPublicSshKeyForAuthenticatedUserRequest = Request<
  UsersGetPublicSshKeyForAuthenticatedUserRequestPath,
  | UsersGetPublicSshKeyForAuthenticatedUser200ResponseBody
  | UsersGetPublicSshKeyForAuthenticatedUser401ResponseBody
  | UsersGetPublicSshKeyForAuthenticatedUser403ResponseBody
  | UsersGetPublicSshKeyForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersGetPublicSshKeyForAuthenticatedUserResponse = Response<
  | UsersGetPublicSshKeyForAuthenticatedUser200ResponseBody
  | UsersGetPublicSshKeyForAuthenticatedUser401ResponseBody
  | UsersGetPublicSshKeyForAuthenticatedUser403ResponseBody
  | UsersGetPublicSshKeyForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export type UsersGetPublicSshKeyForAuthenticatedUserHandler = (
  req: UsersGetPublicSshKeyForAuthenticatedUserRequest,
  res: UsersGetPublicSshKeyForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersDeletePublicSshKeyForAuthenticatedUserRequest = Request<
  UsersDeletePublicSshKeyForAuthenticatedUserRequestPath,
  | UsersDeletePublicSshKeyForAuthenticatedUser401ResponseBody
  | UsersDeletePublicSshKeyForAuthenticatedUser403ResponseBody
  | UsersDeletePublicSshKeyForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersDeletePublicSshKeyForAuthenticatedUserResponse = Response<
  | UsersDeletePublicSshKeyForAuthenticatedUser401ResponseBody
  | UsersDeletePublicSshKeyForAuthenticatedUser403ResponseBody
  | UsersDeletePublicSshKeyForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export type UsersDeletePublicSshKeyForAuthenticatedUserHandler = (
  req: UsersDeletePublicSshKeyForAuthenticatedUserRequest,
  res: UsersDeletePublicSshKeyForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsListSubscriptionsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | AppsListSubscriptionsForAuthenticatedUser200ResponseBody
  | AppsListSubscriptionsForAuthenticatedUser401ResponseBody
  | AppsListSubscriptionsForAuthenticatedUser404ResponseBody,
  unknown,
  AppsListSubscriptionsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type AppsListSubscriptionsForAuthenticatedUserResponse = Response<
  | AppsListSubscriptionsForAuthenticatedUser200ResponseBody
  | AppsListSubscriptionsForAuthenticatedUser401ResponseBody
  | AppsListSubscriptionsForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 404
>;

export type AppsListSubscriptionsForAuthenticatedUserHandler = (
  req: AppsListSubscriptionsForAuthenticatedUserRequest,
  res: AppsListSubscriptionsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsListSubscriptionsForAuthenticatedUserStubbedRequest = Request<
  ParamsDictionary,
  | AppsListSubscriptionsForAuthenticatedUserStubbed200ResponseBody
  | AppsListSubscriptionsForAuthenticatedUserStubbed401ResponseBody,
  unknown,
  AppsListSubscriptionsForAuthenticatedUserStubbedRequestQuery,
  Record<string, any>
>;

export type AppsListSubscriptionsForAuthenticatedUserStubbedResponse = Response<
  | AppsListSubscriptionsForAuthenticatedUserStubbed200ResponseBody
  | AppsListSubscriptionsForAuthenticatedUserStubbed401ResponseBody,
  Record<string, any>,
  200 | 304 | 401
>;

export type AppsListSubscriptionsForAuthenticatedUserStubbedHandler = (
  req: AppsListSubscriptionsForAuthenticatedUserStubbedRequest,
  res: AppsListSubscriptionsForAuthenticatedUserStubbedResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListMembershipsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | OrgsListMembershipsForAuthenticatedUser200ResponseBody
  | OrgsListMembershipsForAuthenticatedUser401ResponseBody
  | OrgsListMembershipsForAuthenticatedUser403ResponseBody
  | OrgsListMembershipsForAuthenticatedUser422ResponseBody,
  unknown,
  OrgsListMembershipsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type OrgsListMembershipsForAuthenticatedUserResponse = Response<
  | OrgsListMembershipsForAuthenticatedUser200ResponseBody
  | OrgsListMembershipsForAuthenticatedUser401ResponseBody
  | OrgsListMembershipsForAuthenticatedUser403ResponseBody
  | OrgsListMembershipsForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 422
>;

export type OrgsListMembershipsForAuthenticatedUserHandler = (
  req: OrgsListMembershipsForAuthenticatedUserRequest,
  res: OrgsListMembershipsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsGetMembershipForAuthenticatedUserRequest = Request<
  OrgsGetMembershipForAuthenticatedUserRequestPath,
  | OrgsGetMembershipForAuthenticatedUser200ResponseBody
  | OrgsGetMembershipForAuthenticatedUser403ResponseBody
  | OrgsGetMembershipForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetMembershipForAuthenticatedUserResponse = Response<
  | OrgsGetMembershipForAuthenticatedUser200ResponseBody
  | OrgsGetMembershipForAuthenticatedUser403ResponseBody
  | OrgsGetMembershipForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 403 | 404
>;

export type OrgsGetMembershipForAuthenticatedUserHandler = (
  req: OrgsGetMembershipForAuthenticatedUserRequest,
  res: OrgsGetMembershipForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsUpdateMembershipForAuthenticatedUserRequest = Request<
  OrgsUpdateMembershipForAuthenticatedUserRequestPath,
  | OrgsUpdateMembershipForAuthenticatedUser200ResponseBody
  | OrgsUpdateMembershipForAuthenticatedUser403ResponseBody
  | OrgsUpdateMembershipForAuthenticatedUser404ResponseBody
  | OrgsUpdateMembershipForAuthenticatedUser422ResponseBody,
  OrgsUpdateMembershipForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsUpdateMembershipForAuthenticatedUserResponse = Response<
  | OrgsUpdateMembershipForAuthenticatedUser200ResponseBody
  | OrgsUpdateMembershipForAuthenticatedUser403ResponseBody
  | OrgsUpdateMembershipForAuthenticatedUser404ResponseBody
  | OrgsUpdateMembershipForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export type OrgsUpdateMembershipForAuthenticatedUserHandler = (
  req: OrgsUpdateMembershipForAuthenticatedUserRequest,
  res: OrgsUpdateMembershipForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsListForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | MigrationsListForAuthenticatedUser200ResponseBody
  | MigrationsListForAuthenticatedUser401ResponseBody
  | MigrationsListForAuthenticatedUser403ResponseBody,
  unknown,
  MigrationsListForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type MigrationsListForAuthenticatedUserResponse = Response<
  | MigrationsListForAuthenticatedUser200ResponseBody
  | MigrationsListForAuthenticatedUser401ResponseBody
  | MigrationsListForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type MigrationsListForAuthenticatedUserHandler = (
  req: MigrationsListForAuthenticatedUserRequest,
  res: MigrationsListForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsStartForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | MigrationsStartForAuthenticatedUser201ResponseBody
  | MigrationsStartForAuthenticatedUser401ResponseBody
  | MigrationsStartForAuthenticatedUser403ResponseBody
  | MigrationsStartForAuthenticatedUser422ResponseBody,
  MigrationsStartForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsStartForAuthenticatedUserResponse = Response<
  | MigrationsStartForAuthenticatedUser201ResponseBody
  | MigrationsStartForAuthenticatedUser401ResponseBody
  | MigrationsStartForAuthenticatedUser403ResponseBody
  | MigrationsStartForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 422
>;

export type MigrationsStartForAuthenticatedUserHandler = (
  req: MigrationsStartForAuthenticatedUserRequest,
  res: MigrationsStartForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsGetStatusForAuthenticatedUserRequest = Request<
  MigrationsGetStatusForAuthenticatedUserRequestPath,
  | MigrationsGetStatusForAuthenticatedUser200ResponseBody
  | MigrationsGetStatusForAuthenticatedUser401ResponseBody
  | MigrationsGetStatusForAuthenticatedUser403ResponseBody
  | MigrationsGetStatusForAuthenticatedUser404ResponseBody,
  unknown,
  MigrationsGetStatusForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type MigrationsGetStatusForAuthenticatedUserResponse = Response<
  | MigrationsGetStatusForAuthenticatedUser200ResponseBody
  | MigrationsGetStatusForAuthenticatedUser401ResponseBody
  | MigrationsGetStatusForAuthenticatedUser403ResponseBody
  | MigrationsGetStatusForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export type MigrationsGetStatusForAuthenticatedUserHandler = (
  req: MigrationsGetStatusForAuthenticatedUserRequest,
  res: MigrationsGetStatusForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsGetArchiveForAuthenticatedUserRequest = Request<
  MigrationsGetArchiveForAuthenticatedUserRequestPath,
  | MigrationsGetArchiveForAuthenticatedUser401ResponseBody
  | MigrationsGetArchiveForAuthenticatedUser403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsGetArchiveForAuthenticatedUserResponse = Response<
  | MigrationsGetArchiveForAuthenticatedUser401ResponseBody
  | MigrationsGetArchiveForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  302 | 304 | 401 | 403
>;

export type MigrationsGetArchiveForAuthenticatedUserHandler = (
  req: MigrationsGetArchiveForAuthenticatedUserRequest,
  res: MigrationsGetArchiveForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsDeleteArchiveForAuthenticatedUserRequest = Request<
  MigrationsDeleteArchiveForAuthenticatedUserRequestPath,
  | MigrationsDeleteArchiveForAuthenticatedUser401ResponseBody
  | MigrationsDeleteArchiveForAuthenticatedUser403ResponseBody
  | MigrationsDeleteArchiveForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsDeleteArchiveForAuthenticatedUserResponse = Response<
  | MigrationsDeleteArchiveForAuthenticatedUser401ResponseBody
  | MigrationsDeleteArchiveForAuthenticatedUser403ResponseBody
  | MigrationsDeleteArchiveForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export type MigrationsDeleteArchiveForAuthenticatedUserHandler = (
  req: MigrationsDeleteArchiveForAuthenticatedUserRequest,
  res: MigrationsDeleteArchiveForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsUnlockRepoForAuthenticatedUserRequest = Request<
  MigrationsUnlockRepoForAuthenticatedUserRequestPath,
  | MigrationsUnlockRepoForAuthenticatedUser401ResponseBody
  | MigrationsUnlockRepoForAuthenticatedUser403ResponseBody
  | MigrationsUnlockRepoForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsUnlockRepoForAuthenticatedUserResponse = Response<
  | MigrationsUnlockRepoForAuthenticatedUser401ResponseBody
  | MigrationsUnlockRepoForAuthenticatedUser403ResponseBody
  | MigrationsUnlockRepoForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export type MigrationsUnlockRepoForAuthenticatedUserHandler = (
  req: MigrationsUnlockRepoForAuthenticatedUserRequest,
  res: MigrationsUnlockRepoForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type MigrationsListReposForAuthenticatedUserRequest = Request<
  MigrationsListReposForAuthenticatedUserRequestPath,
  | MigrationsListReposForAuthenticatedUser200ResponseBody
  | MigrationsListReposForAuthenticatedUser404ResponseBody,
  unknown,
  MigrationsListReposForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type MigrationsListReposForAuthenticatedUserResponse = Response<
  | MigrationsListReposForAuthenticatedUser200ResponseBody
  | MigrationsListReposForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type MigrationsListReposForAuthenticatedUserHandler = (
  req: MigrationsListReposForAuthenticatedUserRequest,
  res: MigrationsListReposForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | OrgsListForAuthenticatedUser200ResponseBody
  | OrgsListForAuthenticatedUser401ResponseBody
  | OrgsListForAuthenticatedUser403ResponseBody,
  unknown,
  OrgsListForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type OrgsListForAuthenticatedUserResponse = Response<
  | OrgsListForAuthenticatedUser200ResponseBody
  | OrgsListForAuthenticatedUser401ResponseBody
  | OrgsListForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type OrgsListForAuthenticatedUserHandler = (
  req: OrgsListForAuthenticatedUserRequest,
  res: OrgsListForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesListPackagesForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  PackagesListPackagesForAuthenticatedUser200ResponseBody,
  unknown,
  PackagesListPackagesForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type PackagesListPackagesForAuthenticatedUserResponse = Response<
  PackagesListPackagesForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export type PackagesListPackagesForAuthenticatedUserHandler = (
  req: PackagesListPackagesForAuthenticatedUserRequest,
  res: PackagesListPackagesForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesGetPackageForAuthenticatedUserRequest = Request<
  PackagesGetPackageForAuthenticatedUserRequestPath,
  PackagesGetPackageForAuthenticatedUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetPackageForAuthenticatedUserResponse = Response<
  PackagesGetPackageForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export type PackagesGetPackageForAuthenticatedUserHandler = (
  req: PackagesGetPackageForAuthenticatedUserRequest,
  res: PackagesGetPackageForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesDeletePackageForAuthenticatedUserRequest = Request<
  PackagesDeletePackageForAuthenticatedUserRequestPath,
  | PackagesDeletePackageForAuthenticatedUser401ResponseBody
  | PackagesDeletePackageForAuthenticatedUser403ResponseBody
  | PackagesDeletePackageForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesDeletePackageForAuthenticatedUserResponse = Response<
  | PackagesDeletePackageForAuthenticatedUser401ResponseBody
  | PackagesDeletePackageForAuthenticatedUser403ResponseBody
  | PackagesDeletePackageForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export type PackagesDeletePackageForAuthenticatedUserHandler = (
  req: PackagesDeletePackageForAuthenticatedUserRequest,
  res: PackagesDeletePackageForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesRestorePackageForAuthenticatedUserRequest = Request<
  PackagesRestorePackageForAuthenticatedUserRequestPath,
  | PackagesRestorePackageForAuthenticatedUser401ResponseBody
  | PackagesRestorePackageForAuthenticatedUser403ResponseBody
  | PackagesRestorePackageForAuthenticatedUser404ResponseBody,
  unknown,
  PackagesRestorePackageForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type PackagesRestorePackageForAuthenticatedUserResponse = Response<
  | PackagesRestorePackageForAuthenticatedUser401ResponseBody
  | PackagesRestorePackageForAuthenticatedUser403ResponseBody
  | PackagesRestorePackageForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export type PackagesRestorePackageForAuthenticatedUserHandler = (
  req: PackagesRestorePackageForAuthenticatedUserRequest,
  res: PackagesRestorePackageForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest = Request<
  PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequestPath,
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser200ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser401ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser403ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser404ResponseBody,
  unknown,
  PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse = Response<
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser200ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser401ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser403ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404
>;

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserHandler = (
  req: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest,
  res: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesGetPackageVersionForAuthenticatedUserRequest = Request<
  PackagesGetPackageVersionForAuthenticatedUserRequestPath,
  PackagesGetPackageVersionForAuthenticatedUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetPackageVersionForAuthenticatedUserResponse = Response<
  PackagesGetPackageVersionForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export type PackagesGetPackageVersionForAuthenticatedUserHandler = (
  req: PackagesGetPackageVersionForAuthenticatedUserRequest,
  res: PackagesGetPackageVersionForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesDeletePackageVersionForAuthenticatedUserRequest = Request<
  PackagesDeletePackageVersionForAuthenticatedUserRequestPath,
  | PackagesDeletePackageVersionForAuthenticatedUser401ResponseBody
  | PackagesDeletePackageVersionForAuthenticatedUser403ResponseBody
  | PackagesDeletePackageVersionForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesDeletePackageVersionForAuthenticatedUserResponse = Response<
  | PackagesDeletePackageVersionForAuthenticatedUser401ResponseBody
  | PackagesDeletePackageVersionForAuthenticatedUser403ResponseBody
  | PackagesDeletePackageVersionForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export type PackagesDeletePackageVersionForAuthenticatedUserHandler = (
  req: PackagesDeletePackageVersionForAuthenticatedUserRequest,
  res: PackagesDeletePackageVersionForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesRestorePackageVersionForAuthenticatedUserRequest = Request<
  PackagesRestorePackageVersionForAuthenticatedUserRequestPath,
  | PackagesRestorePackageVersionForAuthenticatedUser401ResponseBody
  | PackagesRestorePackageVersionForAuthenticatedUser403ResponseBody
  | PackagesRestorePackageVersionForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesRestorePackageVersionForAuthenticatedUserResponse = Response<
  | PackagesRestorePackageVersionForAuthenticatedUser401ResponseBody
  | PackagesRestorePackageVersionForAuthenticatedUser403ResponseBody
  | PackagesRestorePackageVersionForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export type PackagesRestorePackageVersionForAuthenticatedUserHandler = (
  req: PackagesRestorePackageVersionForAuthenticatedUserRequest,
  res: PackagesRestorePackageVersionForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsCreateForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ProjectsCreateForAuthenticatedUser201ResponseBody
  | ProjectsCreateForAuthenticatedUser401ResponseBody
  | ProjectsCreateForAuthenticatedUser403ResponseBody
  | ProjectsCreateForAuthenticatedUser422ResponseBody,
  ProjectsCreateForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsCreateForAuthenticatedUserResponse = Response<
  | ProjectsCreateForAuthenticatedUser201ResponseBody
  | ProjectsCreateForAuthenticatedUser401ResponseBody
  | ProjectsCreateForAuthenticatedUser403ResponseBody
  | ProjectsCreateForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 422
>;

export type ProjectsCreateForAuthenticatedUserHandler = (
  req: ProjectsCreateForAuthenticatedUserRequest,
  res: ProjectsCreateForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListPublicEmailsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListPublicEmailsForAuthenticatedUser200ResponseBody
  | UsersListPublicEmailsForAuthenticatedUser401ResponseBody
  | UsersListPublicEmailsForAuthenticatedUser403ResponseBody
  | UsersListPublicEmailsForAuthenticatedUser404ResponseBody,
  unknown,
  UsersListPublicEmailsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListPublicEmailsForAuthenticatedUserResponse = Response<
  | UsersListPublicEmailsForAuthenticatedUser200ResponseBody
  | UsersListPublicEmailsForAuthenticatedUser401ResponseBody
  | UsersListPublicEmailsForAuthenticatedUser403ResponseBody
  | UsersListPublicEmailsForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export type UsersListPublicEmailsForAuthenticatedUserHandler = (
  req: UsersListPublicEmailsForAuthenticatedUserRequest,
  res: UsersListPublicEmailsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ReposListForAuthenticatedUser200ResponseBody
  | ReposListForAuthenticatedUser401ResponseBody
  | ReposListForAuthenticatedUser403ResponseBody
  | ReposListForAuthenticatedUser422ResponseBody,
  unknown,
  ReposListForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ReposListForAuthenticatedUserResponse = Response<
  | ReposListForAuthenticatedUser200ResponseBody
  | ReposListForAuthenticatedUser401ResponseBody
  | ReposListForAuthenticatedUser403ResponseBody
  | ReposListForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 422
>;

export type ReposListForAuthenticatedUserHandler = (
  req: ReposListForAuthenticatedUserRequest,
  res: ReposListForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposCreateForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ReposCreateForAuthenticatedUser201ResponseBody
  | ReposCreateForAuthenticatedUser400ResponseBody
  | ReposCreateForAuthenticatedUser401ResponseBody
  | ReposCreateForAuthenticatedUser403ResponseBody
  | ReposCreateForAuthenticatedUser404ResponseBody
  | ReposCreateForAuthenticatedUser422ResponseBody,
  ReposCreateForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateForAuthenticatedUserResponse = Response<
  | ReposCreateForAuthenticatedUser201ResponseBody
  | ReposCreateForAuthenticatedUser400ResponseBody
  | ReposCreateForAuthenticatedUser401ResponseBody
  | ReposCreateForAuthenticatedUser403ResponseBody
  | ReposCreateForAuthenticatedUser404ResponseBody
  | ReposCreateForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 400 | 401 | 403 | 404 | 422
>;

export type ReposCreateForAuthenticatedUserHandler = (
  req: ReposCreateForAuthenticatedUserRequest,
  res: ReposCreateForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListInvitationsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ReposListInvitationsForAuthenticatedUser200ResponseBody
  | ReposListInvitationsForAuthenticatedUser401ResponseBody
  | ReposListInvitationsForAuthenticatedUser403ResponseBody
  | ReposListInvitationsForAuthenticatedUser404ResponseBody,
  unknown,
  ReposListInvitationsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ReposListInvitationsForAuthenticatedUserResponse = Response<
  | ReposListInvitationsForAuthenticatedUser200ResponseBody
  | ReposListInvitationsForAuthenticatedUser401ResponseBody
  | ReposListInvitationsForAuthenticatedUser403ResponseBody
  | ReposListInvitationsForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export type ReposListInvitationsForAuthenticatedUserHandler = (
  req: ReposListInvitationsForAuthenticatedUserRequest,
  res: ReposListInvitationsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposAcceptInvitationForAuthenticatedUserRequest = Request<
  ReposAcceptInvitationForAuthenticatedUserRequestPath,
  | ReposAcceptInvitationForAuthenticatedUser403ResponseBody
  | ReposAcceptInvitationForAuthenticatedUser404ResponseBody
  | ReposAcceptInvitationForAuthenticatedUser409ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposAcceptInvitationForAuthenticatedUserResponse = Response<
  | ReposAcceptInvitationForAuthenticatedUser403ResponseBody
  | ReposAcceptInvitationForAuthenticatedUser404ResponseBody
  | ReposAcceptInvitationForAuthenticatedUser409ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404 | 409
>;

export type ReposAcceptInvitationForAuthenticatedUserHandler = (
  req: ReposAcceptInvitationForAuthenticatedUserRequest,
  res: ReposAcceptInvitationForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposDeclineInvitationForAuthenticatedUserRequest = Request<
  ReposDeclineInvitationForAuthenticatedUserRequestPath,
  | ReposDeclineInvitationForAuthenticatedUser403ResponseBody
  | ReposDeclineInvitationForAuthenticatedUser404ResponseBody
  | ReposDeclineInvitationForAuthenticatedUser409ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeclineInvitationForAuthenticatedUserResponse = Response<
  | ReposDeclineInvitationForAuthenticatedUser403ResponseBody
  | ReposDeclineInvitationForAuthenticatedUser404ResponseBody
  | ReposDeclineInvitationForAuthenticatedUser409ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404 | 409
>;

export type ReposDeclineInvitationForAuthenticatedUserHandler = (
  req: ReposDeclineInvitationForAuthenticatedUserRequest,
  res: ReposDeclineInvitationForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListSshSigningKeysForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListSshSigningKeysForAuthenticatedUser200ResponseBody
  | UsersListSshSigningKeysForAuthenticatedUser401ResponseBody
  | UsersListSshSigningKeysForAuthenticatedUser403ResponseBody
  | UsersListSshSigningKeysForAuthenticatedUser404ResponseBody,
  unknown,
  UsersListSshSigningKeysForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListSshSigningKeysForAuthenticatedUserResponse = Response<
  | UsersListSshSigningKeysForAuthenticatedUser200ResponseBody
  | UsersListSshSigningKeysForAuthenticatedUser401ResponseBody
  | UsersListSshSigningKeysForAuthenticatedUser403ResponseBody
  | UsersListSshSigningKeysForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export type UsersListSshSigningKeysForAuthenticatedUserHandler = (
  req: UsersListSshSigningKeysForAuthenticatedUserRequest,
  res: UsersListSshSigningKeysForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersCreateSshSigningKeyForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersCreateSshSigningKeyForAuthenticatedUser201ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser401ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser403ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser404ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser422ResponseBody,
  UsersCreateSshSigningKeyForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersCreateSshSigningKeyForAuthenticatedUserResponse = Response<
  | UsersCreateSshSigningKeyForAuthenticatedUser201ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser401ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser403ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser404ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 404 | 422
>;

export type UsersCreateSshSigningKeyForAuthenticatedUserHandler = (
  req: UsersCreateSshSigningKeyForAuthenticatedUserRequest,
  res: UsersCreateSshSigningKeyForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersGetSshSigningKeyForAuthenticatedUserRequest = Request<
  UsersGetSshSigningKeyForAuthenticatedUserRequestPath,
  | UsersGetSshSigningKeyForAuthenticatedUser200ResponseBody
  | UsersGetSshSigningKeyForAuthenticatedUser401ResponseBody
  | UsersGetSshSigningKeyForAuthenticatedUser403ResponseBody
  | UsersGetSshSigningKeyForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersGetSshSigningKeyForAuthenticatedUserResponse = Response<
  | UsersGetSshSigningKeyForAuthenticatedUser200ResponseBody
  | UsersGetSshSigningKeyForAuthenticatedUser401ResponseBody
  | UsersGetSshSigningKeyForAuthenticatedUser403ResponseBody
  | UsersGetSshSigningKeyForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export type UsersGetSshSigningKeyForAuthenticatedUserHandler = (
  req: UsersGetSshSigningKeyForAuthenticatedUserRequest,
  res: UsersGetSshSigningKeyForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersDeleteSshSigningKeyForAuthenticatedUserRequest = Request<
  UsersDeleteSshSigningKeyForAuthenticatedUserRequestPath,
  | UsersDeleteSshSigningKeyForAuthenticatedUser401ResponseBody
  | UsersDeleteSshSigningKeyForAuthenticatedUser403ResponseBody
  | UsersDeleteSshSigningKeyForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersDeleteSshSigningKeyForAuthenticatedUserResponse = Response<
  | UsersDeleteSshSigningKeyForAuthenticatedUser401ResponseBody
  | UsersDeleteSshSigningKeyForAuthenticatedUser403ResponseBody
  | UsersDeleteSshSigningKeyForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export type UsersDeleteSshSigningKeyForAuthenticatedUserHandler = (
  req: UsersDeleteSshSigningKeyForAuthenticatedUserRequest,
  res: UsersDeleteSshSigningKeyForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListReposStarredByAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ActivityListReposStarredByAuthenticatedUser200ResponseBody
  | ActivityListReposStarredByAuthenticatedUser401ResponseBody
  | ActivityListReposStarredByAuthenticatedUser403ResponseBody,
  unknown,
  ActivityListReposStarredByAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ActivityListReposStarredByAuthenticatedUserResponse = Response<
  | ActivityListReposStarredByAuthenticatedUser200ResponseBody
  | ActivityListReposStarredByAuthenticatedUser401ResponseBody
  | ActivityListReposStarredByAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type ActivityListReposStarredByAuthenticatedUserHandler = (
  req: ActivityListReposStarredByAuthenticatedUserRequest,
  res: ActivityListReposStarredByAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityCheckRepoIsStarredByAuthenticatedUserRequest = Request<
  ActivityCheckRepoIsStarredByAuthenticatedUserRequestPath,
  | ActivityCheckRepoIsStarredByAuthenticatedUser401ResponseBody
  | ActivityCheckRepoIsStarredByAuthenticatedUser403ResponseBody
  | ActivityCheckRepoIsStarredByAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityCheckRepoIsStarredByAuthenticatedUserResponse = Response<
  | ActivityCheckRepoIsStarredByAuthenticatedUser401ResponseBody
  | ActivityCheckRepoIsStarredByAuthenticatedUser403ResponseBody
  | ActivityCheckRepoIsStarredByAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export type ActivityCheckRepoIsStarredByAuthenticatedUserHandler = (
  req: ActivityCheckRepoIsStarredByAuthenticatedUserRequest,
  res: ActivityCheckRepoIsStarredByAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityStarRepoForAuthenticatedUserRequest = Request<
  ActivityStarRepoForAuthenticatedUserRequestPath,
  | ActivityStarRepoForAuthenticatedUser401ResponseBody
  | ActivityStarRepoForAuthenticatedUser403ResponseBody
  | ActivityStarRepoForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityStarRepoForAuthenticatedUserResponse = Response<
  | ActivityStarRepoForAuthenticatedUser401ResponseBody
  | ActivityStarRepoForAuthenticatedUser403ResponseBody
  | ActivityStarRepoForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export type ActivityStarRepoForAuthenticatedUserHandler = (
  req: ActivityStarRepoForAuthenticatedUserRequest,
  res: ActivityStarRepoForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityUnstarRepoForAuthenticatedUserRequest = Request<
  ActivityUnstarRepoForAuthenticatedUserRequestPath,
  | ActivityUnstarRepoForAuthenticatedUser401ResponseBody
  | ActivityUnstarRepoForAuthenticatedUser403ResponseBody
  | ActivityUnstarRepoForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityUnstarRepoForAuthenticatedUserResponse = Response<
  | ActivityUnstarRepoForAuthenticatedUser401ResponseBody
  | ActivityUnstarRepoForAuthenticatedUser403ResponseBody
  | ActivityUnstarRepoForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export type ActivityUnstarRepoForAuthenticatedUserHandler = (
  req: ActivityUnstarRepoForAuthenticatedUserRequest,
  res: ActivityUnstarRepoForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListWatchedReposForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ActivityListWatchedReposForAuthenticatedUser200ResponseBody
  | ActivityListWatchedReposForAuthenticatedUser401ResponseBody
  | ActivityListWatchedReposForAuthenticatedUser403ResponseBody,
  unknown,
  ActivityListWatchedReposForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ActivityListWatchedReposForAuthenticatedUserResponse = Response<
  | ActivityListWatchedReposForAuthenticatedUser200ResponseBody
  | ActivityListWatchedReposForAuthenticatedUser401ResponseBody
  | ActivityListWatchedReposForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export type ActivityListWatchedReposForAuthenticatedUserHandler = (
  req: ActivityListWatchedReposForAuthenticatedUserRequest,
  res: ActivityListWatchedReposForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type TeamsListForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | TeamsListForAuthenticatedUser200ResponseBody
  | TeamsListForAuthenticatedUser403ResponseBody
  | TeamsListForAuthenticatedUser404ResponseBody,
  unknown,
  TeamsListForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type TeamsListForAuthenticatedUserResponse = Response<
  | TeamsListForAuthenticatedUser200ResponseBody
  | TeamsListForAuthenticatedUser403ResponseBody
  | TeamsListForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export type TeamsListForAuthenticatedUserHandler = (
  req: TeamsListForAuthenticatedUserRequest,
  res: TeamsListForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListRequest = Request<
  ParamsDictionary,
  UsersList200ResponseBody,
  unknown,
  UsersListRequestQuery,
  Record<string, any>
>;

export type UsersListResponse = Response<
  UsersList200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export type UsersListHandler = (
  req: UsersListRequest,
  res: UsersListResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersGetByUsernameRequest = Request<
  UsersGetByUsernameRequestPath,
  UsersGetByUsername200ResponseBody | UsersGetByUsername404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersGetByUsernameResponse = Response<
  UsersGetByUsername200ResponseBody | UsersGetByUsername404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export type UsersGetByUsernameHandler = (
  req: UsersGetByUsernameRequest,
  res: UsersGetByUsernameResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListEventsForAuthenticatedUserRequest = Request<
  ActivityListEventsForAuthenticatedUserRequestPath,
  ActivityListEventsForAuthenticatedUser200ResponseBody,
  unknown,
  ActivityListEventsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ActivityListEventsForAuthenticatedUserResponse = Response<
  ActivityListEventsForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export type ActivityListEventsForAuthenticatedUserHandler = (
  req: ActivityListEventsForAuthenticatedUserRequest,
  res: ActivityListEventsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListOrgEventsForAuthenticatedUserRequest = Request<
  ActivityListOrgEventsForAuthenticatedUserRequestPath,
  ActivityListOrgEventsForAuthenticatedUser200ResponseBody,
  unknown,
  ActivityListOrgEventsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ActivityListOrgEventsForAuthenticatedUserResponse = Response<
  ActivityListOrgEventsForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export type ActivityListOrgEventsForAuthenticatedUserHandler = (
  req: ActivityListOrgEventsForAuthenticatedUserRequest,
  res: ActivityListOrgEventsForAuthenticatedUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListPublicEventsForUserRequest = Request<
  ActivityListPublicEventsForUserRequestPath,
  ActivityListPublicEventsForUser200ResponseBody,
  unknown,
  ActivityListPublicEventsForUserRequestQuery,
  Record<string, any>
>;

export type ActivityListPublicEventsForUserResponse = Response<
  ActivityListPublicEventsForUser200ResponseBody,
  Record<string, any>,
  200
>;

export type ActivityListPublicEventsForUserHandler = (
  req: ActivityListPublicEventsForUserRequest,
  res: ActivityListPublicEventsForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListFollowersForUserRequest = Request<
  UsersListFollowersForUserRequestPath,
  UsersListFollowersForUser200ResponseBody,
  unknown,
  UsersListFollowersForUserRequestQuery,
  Record<string, any>
>;

export type UsersListFollowersForUserResponse = Response<
  UsersListFollowersForUser200ResponseBody,
  Record<string, any>,
  200
>;

export type UsersListFollowersForUserHandler = (
  req: UsersListFollowersForUserRequest,
  res: UsersListFollowersForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListFollowingForUserRequest = Request<
  UsersListFollowingForUserRequestPath,
  UsersListFollowingForUser200ResponseBody,
  unknown,
  UsersListFollowingForUserRequestQuery,
  Record<string, any>
>;

export type UsersListFollowingForUserResponse = Response<
  UsersListFollowingForUser200ResponseBody,
  Record<string, any>,
  200
>;

export type UsersListFollowingForUserHandler = (
  req: UsersListFollowingForUserRequest,
  res: UsersListFollowingForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersCheckFollowingForUserRequest = Request<
  UsersCheckFollowingForUserRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersCheckFollowingForUserResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export type UsersCheckFollowingForUserHandler = (
  req: UsersCheckFollowingForUserRequest,
  res: UsersCheckFollowingForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type GistsListForUserRequest = Request<
  GistsListForUserRequestPath,
  GistsListForUser200ResponseBody | GistsListForUser422ResponseBody,
  unknown,
  GistsListForUserRequestQuery,
  Record<string, any>
>;

export type GistsListForUserResponse = Response<
  GistsListForUser200ResponseBody | GistsListForUser422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type GistsListForUserHandler = (
  req: GistsListForUserRequest,
  res: GistsListForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListGpgKeysForUserRequest = Request<
  UsersListGpgKeysForUserRequestPath,
  UsersListGpgKeysForUser200ResponseBody,
  unknown,
  UsersListGpgKeysForUserRequestQuery,
  Record<string, any>
>;

export type UsersListGpgKeysForUserResponse = Response<
  UsersListGpgKeysForUser200ResponseBody,
  Record<string, any>,
  200
>;

export type UsersListGpgKeysForUserHandler = (
  req: UsersListGpgKeysForUserRequest,
  res: UsersListGpgKeysForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersGetContextForUserRequest = Request<
  UsersGetContextForUserRequestPath,
  | UsersGetContextForUser200ResponseBody
  | UsersGetContextForUser404ResponseBody
  | UsersGetContextForUser422ResponseBody,
  unknown,
  UsersGetContextForUserRequestQuery,
  Record<string, any>
>;

export type UsersGetContextForUserResponse = Response<
  | UsersGetContextForUser200ResponseBody
  | UsersGetContextForUser404ResponseBody
  | UsersGetContextForUser422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export type UsersGetContextForUserHandler = (
  req: UsersGetContextForUserRequest,
  res: UsersGetContextForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type AppsGetUserInstallationRequest = Request<
  AppsGetUserInstallationRequestPath,
  AppsGetUserInstallation200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetUserInstallationResponse = Response<
  AppsGetUserInstallation200ResponseBody,
  Record<string, any>,
  200
>;

export type AppsGetUserInstallationHandler = (
  req: AppsGetUserInstallationRequest,
  res: AppsGetUserInstallationResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListPublicKeysForUserRequest = Request<
  UsersListPublicKeysForUserRequestPath,
  UsersListPublicKeysForUser200ResponseBody,
  unknown,
  UsersListPublicKeysForUserRequestQuery,
  Record<string, any>
>;

export type UsersListPublicKeysForUserResponse = Response<
  UsersListPublicKeysForUser200ResponseBody,
  Record<string, any>,
  200
>;

export type UsersListPublicKeysForUserHandler = (
  req: UsersListPublicKeysForUserRequest,
  res: UsersListPublicKeysForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type OrgsListForUserRequest = Request<
  OrgsListForUserRequestPath,
  OrgsListForUser200ResponseBody,
  unknown,
  OrgsListForUserRequestQuery,
  Record<string, any>
>;

export type OrgsListForUserResponse = Response<
  OrgsListForUser200ResponseBody,
  Record<string, any>,
  200
>;

export type OrgsListForUserHandler = (
  req: OrgsListForUserRequest,
  res: OrgsListForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesListPackagesForUserRequest = Request<
  PackagesListPackagesForUserRequestPath,
  | PackagesListPackagesForUser200ResponseBody
  | PackagesListPackagesForUser401ResponseBody
  | PackagesListPackagesForUser403ResponseBody,
  unknown,
  PackagesListPackagesForUserRequestQuery,
  Record<string, any>
>;

export type PackagesListPackagesForUserResponse = Response<
  | PackagesListPackagesForUser200ResponseBody
  | PackagesListPackagesForUser401ResponseBody
  | PackagesListPackagesForUser403ResponseBody,
  Record<string, any>,
  200 | 401 | 403
>;

export type PackagesListPackagesForUserHandler = (
  req: PackagesListPackagesForUserRequest,
  res: PackagesListPackagesForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesGetPackageForUserRequest = Request<
  PackagesGetPackageForUserRequestPath,
  PackagesGetPackageForUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetPackageForUserResponse = Response<
  PackagesGetPackageForUser200ResponseBody,
  Record<string, any>,
  200
>;

export type PackagesGetPackageForUserHandler = (
  req: PackagesGetPackageForUserRequest,
  res: PackagesGetPackageForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesDeletePackageForUserRequest = Request<
  PackagesDeletePackageForUserRequestPath,
  | PackagesDeletePackageForUser401ResponseBody
  | PackagesDeletePackageForUser403ResponseBody
  | PackagesDeletePackageForUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesDeletePackageForUserResponse = Response<
  | PackagesDeletePackageForUser401ResponseBody
  | PackagesDeletePackageForUser403ResponseBody
  | PackagesDeletePackageForUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export type PackagesDeletePackageForUserHandler = (
  req: PackagesDeletePackageForUserRequest,
  res: PackagesDeletePackageForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesRestorePackageForUserRequest = Request<
  PackagesRestorePackageForUserRequestPath,
  | PackagesRestorePackageForUser401ResponseBody
  | PackagesRestorePackageForUser403ResponseBody
  | PackagesRestorePackageForUser404ResponseBody,
  unknown,
  PackagesRestorePackageForUserRequestQuery,
  Record<string, any>
>;

export type PackagesRestorePackageForUserResponse = Response<
  | PackagesRestorePackageForUser401ResponseBody
  | PackagesRestorePackageForUser403ResponseBody
  | PackagesRestorePackageForUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export type PackagesRestorePackageForUserHandler = (
  req: PackagesRestorePackageForUserRequest,
  res: PackagesRestorePackageForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesGetAllPackageVersionsForPackageOwnedByUserRequest = Request<
  PackagesGetAllPackageVersionsForPackageOwnedByUserRequestPath,
  | PackagesGetAllPackageVersionsForPackageOwnedByUser200ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByUser401ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByUser403ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetAllPackageVersionsForPackageOwnedByUserResponse = Response<
  | PackagesGetAllPackageVersionsForPackageOwnedByUser200ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByUser401ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByUser403ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByUser404ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404
>;

export type PackagesGetAllPackageVersionsForPackageOwnedByUserHandler = (
  req: PackagesGetAllPackageVersionsForPackageOwnedByUserRequest,
  res: PackagesGetAllPackageVersionsForPackageOwnedByUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesGetPackageVersionForUserRequest = Request<
  PackagesGetPackageVersionForUserRequestPath,
  PackagesGetPackageVersionForUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetPackageVersionForUserResponse = Response<
  PackagesGetPackageVersionForUser200ResponseBody,
  Record<string, any>,
  200
>;

export type PackagesGetPackageVersionForUserHandler = (
  req: PackagesGetPackageVersionForUserRequest,
  res: PackagesGetPackageVersionForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesDeletePackageVersionForUserRequest = Request<
  PackagesDeletePackageVersionForUserRequestPath,
  | PackagesDeletePackageVersionForUser401ResponseBody
  | PackagesDeletePackageVersionForUser403ResponseBody
  | PackagesDeletePackageVersionForUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesDeletePackageVersionForUserResponse = Response<
  | PackagesDeletePackageVersionForUser401ResponseBody
  | PackagesDeletePackageVersionForUser403ResponseBody
  | PackagesDeletePackageVersionForUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export type PackagesDeletePackageVersionForUserHandler = (
  req: PackagesDeletePackageVersionForUserRequest,
  res: PackagesDeletePackageVersionForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type PackagesRestorePackageVersionForUserRequest = Request<
  PackagesRestorePackageVersionForUserRequestPath,
  | PackagesRestorePackageVersionForUser401ResponseBody
  | PackagesRestorePackageVersionForUser403ResponseBody
  | PackagesRestorePackageVersionForUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesRestorePackageVersionForUserResponse = Response<
  | PackagesRestorePackageVersionForUser401ResponseBody
  | PackagesRestorePackageVersionForUser403ResponseBody
  | PackagesRestorePackageVersionForUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export type PackagesRestorePackageVersionForUserHandler = (
  req: PackagesRestorePackageVersionForUserRequest,
  res: PackagesRestorePackageVersionForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ProjectsListForUserRequest = Request<
  ProjectsListForUserRequestPath,
  ProjectsListForUser200ResponseBody | ProjectsListForUser422ResponseBody,
  unknown,
  ProjectsListForUserRequestQuery,
  Record<string, any>
>;

export type ProjectsListForUserResponse = Response<
  ProjectsListForUser200ResponseBody | ProjectsListForUser422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export type ProjectsListForUserHandler = (
  req: ProjectsListForUserRequest,
  res: ProjectsListForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListReceivedEventsForUserRequest = Request<
  ActivityListReceivedEventsForUserRequestPath,
  ActivityListReceivedEventsForUser200ResponseBody,
  unknown,
  ActivityListReceivedEventsForUserRequestQuery,
  Record<string, any>
>;

export type ActivityListReceivedEventsForUserResponse = Response<
  ActivityListReceivedEventsForUser200ResponseBody,
  Record<string, any>,
  200
>;

export type ActivityListReceivedEventsForUserHandler = (
  req: ActivityListReceivedEventsForUserRequest,
  res: ActivityListReceivedEventsForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListReceivedPublicEventsForUserRequest = Request<
  ActivityListReceivedPublicEventsForUserRequestPath,
  ActivityListReceivedPublicEventsForUser200ResponseBody,
  unknown,
  ActivityListReceivedPublicEventsForUserRequestQuery,
  Record<string, any>
>;

export type ActivityListReceivedPublicEventsForUserResponse = Response<
  ActivityListReceivedPublicEventsForUser200ResponseBody,
  Record<string, any>,
  200
>;

export type ActivityListReceivedPublicEventsForUserHandler = (
  req: ActivityListReceivedPublicEventsForUserRequest,
  res: ActivityListReceivedPublicEventsForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ReposListForUserRequest = Request<
  ReposListForUserRequestPath,
  ReposListForUser200ResponseBody,
  unknown,
  ReposListForUserRequestQuery,
  Record<string, any>
>;

export type ReposListForUserResponse = Response<
  ReposListForUser200ResponseBody,
  Record<string, any>,
  200
>;

export type ReposListForUserHandler = (
  req: ReposListForUserRequest,
  res: ReposListForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type BillingGetGithubActionsBillingUserRequest = Request<
  BillingGetGithubActionsBillingUserRequestPath,
  BillingGetGithubActionsBillingUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type BillingGetGithubActionsBillingUserResponse = Response<
  BillingGetGithubActionsBillingUser200ResponseBody,
  Record<string, any>,
  200
>;

export type BillingGetGithubActionsBillingUserHandler = (
  req: BillingGetGithubActionsBillingUserRequest,
  res: BillingGetGithubActionsBillingUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type BillingGetGithubPackagesBillingUserRequest = Request<
  BillingGetGithubPackagesBillingUserRequestPath,
  BillingGetGithubPackagesBillingUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type BillingGetGithubPackagesBillingUserResponse = Response<
  BillingGetGithubPackagesBillingUser200ResponseBody,
  Record<string, any>,
  200
>;

export type BillingGetGithubPackagesBillingUserHandler = (
  req: BillingGetGithubPackagesBillingUserRequest,
  res: BillingGetGithubPackagesBillingUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type BillingGetSharedStorageBillingUserRequest = Request<
  BillingGetSharedStorageBillingUserRequestPath,
  BillingGetSharedStorageBillingUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type BillingGetSharedStorageBillingUserResponse = Response<
  BillingGetSharedStorageBillingUser200ResponseBody,
  Record<string, any>,
  200
>;

export type BillingGetSharedStorageBillingUserHandler = (
  req: BillingGetSharedStorageBillingUserRequest,
  res: BillingGetSharedStorageBillingUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type UsersListSshSigningKeysForUserRequest = Request<
  UsersListSshSigningKeysForUserRequestPath,
  UsersListSshSigningKeysForUser200ResponseBody,
  unknown,
  UsersListSshSigningKeysForUserRequestQuery,
  Record<string, any>
>;

export type UsersListSshSigningKeysForUserResponse = Response<
  UsersListSshSigningKeysForUser200ResponseBody,
  Record<string, any>,
  200
>;

export type UsersListSshSigningKeysForUserHandler = (
  req: UsersListSshSigningKeysForUserRequest,
  res: UsersListSshSigningKeysForUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListReposStarredByUserRequest = Request<
  ActivityListReposStarredByUserRequestPath,
  ActivityListReposStarredByUser200ResponseBody,
  unknown,
  ActivityListReposStarredByUserRequestQuery,
  Record<string, any>
>;

export type ActivityListReposStarredByUserResponse = Response<
  ActivityListReposStarredByUser200ResponseBody,
  Record<string, any>,
  200
>;

export type ActivityListReposStarredByUserHandler = (
  req: ActivityListReposStarredByUserRequest,
  res: ActivityListReposStarredByUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type ActivityListReposWatchedByUserRequest = Request<
  ActivityListReposWatchedByUserRequestPath,
  ActivityListReposWatchedByUser200ResponseBody,
  unknown,
  ActivityListReposWatchedByUserRequestQuery,
  Record<string, any>
>;

export type ActivityListReposWatchedByUserResponse = Response<
  ActivityListReposWatchedByUser200ResponseBody,
  Record<string, any>,
  200
>;

export type ActivityListReposWatchedByUserHandler = (
  req: ActivityListReposWatchedByUserRequest,
  res: ActivityListReposWatchedByUserResponse,
  next: NextFunction
) => Promise<void> | void;

export type MetaGetZenRequest = Request<
  ParamsDictionary,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MetaGetZenResponse = Response<unknown, Record<string, any>, 200>;

export type MetaGetZenHandler = (
  req: MetaGetZenRequest,
  res: MetaGetZenResponse,
  next: NextFunction
) => Promise<void> | void;

export type Handlers = {
  metaRoot: MetaRootHandler;
  appsGetAuthenticated: AppsGetAuthenticatedHandler;
  appsCreateFromManifest: AppsCreateFromManifestHandler;
  appsGetWebhookConfigForApp: AppsGetWebhookConfigForAppHandler;
  appsUpdateWebhookConfigForApp: AppsUpdateWebhookConfigForAppHandler;
  appsListWebhookDeliveries: AppsListWebhookDeliveriesHandler;
  appsGetWebhookDelivery: AppsGetWebhookDeliveryHandler;
  appsRedeliverWebhookDelivery: AppsRedeliverWebhookDeliveryHandler;
  appsListInstallations: AppsListInstallationsHandler;
  appsGetInstallation: AppsGetInstallationHandler;
  appsDeleteInstallation: AppsDeleteInstallationHandler;
  appsCreateInstallationAccessToken: AppsCreateInstallationAccessTokenHandler;
  appsSuspendInstallation: AppsSuspendInstallationHandler;
  appsUnsuspendInstallation: AppsUnsuspendInstallationHandler;
  appsDeleteAuthorization: AppsDeleteAuthorizationHandler;
  appsCheckToken: AppsCheckTokenHandler;
  appsResetToken: AppsResetTokenHandler;
  appsDeleteToken: AppsDeleteTokenHandler;
  appsScopeToken: AppsScopeTokenHandler;
  appsGetBySlug: AppsGetBySlugHandler;
  codesOfConductGetAllCodesOfConduct: CodesOfConductGetAllCodesOfConductHandler;
  codesOfConductGetConductCode: CodesOfConductGetConductCodeHandler;
  emojisGet: EmojisGetHandler;
  enterpriseAdminGetServerStatistics: EnterpriseAdminGetServerStatisticsHandler;
  actionsGetActionsCacheUsageForEnterprise: ActionsGetActionsCacheUsageForEnterpriseHandler;
  enterpriseAdminGetGithubActionsPermissionsEnterprise: EnterpriseAdminGetGithubActionsPermissionsEnterpriseHandler;
  enterpriseAdminSetGithubActionsPermissionsEnterprise: EnterpriseAdminSetGithubActionsPermissionsEnterpriseHandler;
  enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise: EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseHandler;
  enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise: EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseHandler;
  enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise: EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseHandler;
  enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise: EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseHandler;
  enterpriseAdminGetAllowedActionsEnterprise: EnterpriseAdminGetAllowedActionsEnterpriseHandler;
  enterpriseAdminSetAllowedActionsEnterprise: EnterpriseAdminSetAllowedActionsEnterpriseHandler;
  actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise: ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler;
  actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise: ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler;
  enterpriseAdminListSelfHostedRunnerGroupsForEnterprise: EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseHandler;
  enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise: EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseHandler;
  enterpriseAdminGetSelfHostedRunnerGroupForEnterprise: EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseHandler;
  enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise: EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseHandler;
  enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise: EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseHandler;
  enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise: EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler;
  enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise: EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler;
  enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise: EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler;
  enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise: EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler;
  enterpriseAdminListSelfHostedRunnersInGroupForEnterprise: EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseHandler;
  enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise: EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseHandler;
  enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise: EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseHandler;
  enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise: EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseHandler;
  enterpriseAdminListSelfHostedRunnersForEnterprise: EnterpriseAdminListSelfHostedRunnersForEnterpriseHandler;
  enterpriseAdminListRunnerApplicationsForEnterprise: EnterpriseAdminListRunnerApplicationsForEnterpriseHandler;
  enterpriseAdminCreateRegistrationTokenForEnterprise: EnterpriseAdminCreateRegistrationTokenForEnterpriseHandler;
  enterpriseAdminCreateRemoveTokenForEnterprise: EnterpriseAdminCreateRemoveTokenForEnterpriseHandler;
  enterpriseAdminGetSelfHostedRunnerForEnterprise: EnterpriseAdminGetSelfHostedRunnerForEnterpriseHandler;
  enterpriseAdminDeleteSelfHostedRunnerFromEnterprise: EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseHandler;
  enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise: EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseHandler;
  enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise: EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseHandler;
  enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise: EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseHandler;
  enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise: EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseHandler;
  enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise: EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseHandler;
  codeScanningListAlertsForEnterprise: CodeScanningListAlertsForEnterpriseHandler;
  secretScanningListAlertsForEnterprise: SecretScanningListAlertsForEnterpriseHandler;
  billingGetGithubAdvancedSecurityBillingGhe: BillingGetGithubAdvancedSecurityBillingGheHandler;
  activityListPublicEvents: ActivityListPublicEventsHandler;
  activityGetFeeds: ActivityGetFeedsHandler;
  gistsList: GistsListHandler;
  gistsCreate: GistsCreateHandler;
  gistsListPublic: GistsListPublicHandler;
  gistsListStarred: GistsListStarredHandler;
  gistsGet: GistsGetHandler;
  gistsUpdate: GistsUpdateHandler;
  gistsDelete: GistsDeleteHandler;
  gistsListComments: GistsListCommentsHandler;
  gistsCreateComment: GistsCreateCommentHandler;
  gistsGetComment: GistsGetCommentHandler;
  gistsUpdateComment: GistsUpdateCommentHandler;
  gistsDeleteComment: GistsDeleteCommentHandler;
  gistsListCommits: GistsListCommitsHandler;
  gistsListForks: GistsListForksHandler;
  gistsFork: GistsForkHandler;
  gistsCheckIsStarred: GistsCheckIsStarredHandler;
  gistsStar: GistsStarHandler;
  gistsUnstar: GistsUnstarHandler;
  gistsGetRevision: GistsGetRevisionHandler;
  gitignoreGetAllTemplates: GitignoreGetAllTemplatesHandler;
  gitignoreGetTemplate: GitignoreGetTemplateHandler;
  appsListReposAccessibleToInstallation: AppsListReposAccessibleToInstallationHandler;
  appsRevokeInstallationAccessToken: AppsRevokeInstallationAccessTokenHandler;
  issuesList: IssuesListHandler;
  licensesGetAllCommonlyUsed: LicensesGetAllCommonlyUsedHandler;
  licensesGet: LicensesGetHandler;
  markdownRender: MarkdownRenderHandler;
  markdownRenderRaw: MarkdownRenderRawHandler;
  appsGetSubscriptionPlanForAccount: AppsGetSubscriptionPlanForAccountHandler;
  appsListPlans: AppsListPlansHandler;
  appsListAccountsForPlan: AppsListAccountsForPlanHandler;
  appsGetSubscriptionPlanForAccountStubbed: AppsGetSubscriptionPlanForAccountStubbedHandler;
  appsListPlansStubbed: AppsListPlansStubbedHandler;
  appsListAccountsForPlanStubbed: AppsListAccountsForPlanStubbedHandler;
  metaGet: MetaGetHandler;
  activityListPublicEventsForRepoNetwork: ActivityListPublicEventsForRepoNetworkHandler;
  activityListNotificationsForAuthenticatedUser: ActivityListNotificationsForAuthenticatedUserHandler;
  activityMarkNotificationsAsRead: ActivityMarkNotificationsAsReadHandler;
  activityGetThread: ActivityGetThreadHandler;
  activityMarkThreadAsRead: ActivityMarkThreadAsReadHandler;
  activityGetThreadSubscriptionForAuthenticatedUser: ActivityGetThreadSubscriptionForAuthenticatedUserHandler;
  activitySetThreadSubscription: ActivitySetThreadSubscriptionHandler;
  activityDeleteThreadSubscription: ActivityDeleteThreadSubscriptionHandler;
  metaGetOctocat: MetaGetOctocatHandler;
  orgsList: OrgsListHandler;
  orgsListCustomRoles: OrgsListCustomRolesHandler;
  orgsGet: OrgsGetHandler;
  orgsUpdate: OrgsUpdateHandler;
  actionsGetActionsCacheUsageForOrg: ActionsGetActionsCacheUsageForOrgHandler;
  actionsGetActionsCacheUsageByRepoForOrg: ActionsGetActionsCacheUsageByRepoForOrgHandler;
  actionsGetGithubActionsPermissionsOrganization: ActionsGetGithubActionsPermissionsOrganizationHandler;
  actionsSetGithubActionsPermissionsOrganization: ActionsSetGithubActionsPermissionsOrganizationHandler;
  actionsListSelectedRepositoriesEnabledGithubActionsOrganization: ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationHandler;
  actionsSetSelectedRepositoriesEnabledGithubActionsOrganization: ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationHandler;
  actionsEnableSelectedRepositoryGithubActionsOrganization: ActionsEnableSelectedRepositoryGithubActionsOrganizationHandler;
  actionsDisableSelectedRepositoryGithubActionsOrganization: ActionsDisableSelectedRepositoryGithubActionsOrganizationHandler;
  actionsGetAllowedActionsOrganization: ActionsGetAllowedActionsOrganizationHandler;
  actionsSetAllowedActionsOrganization: ActionsSetAllowedActionsOrganizationHandler;
  actionsGetGithubActionsDefaultWorkflowPermissionsOrganization: ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationHandler;
  actionsSetGithubActionsDefaultWorkflowPermissionsOrganization: ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationHandler;
  actionsListSelfHostedRunnerGroupsForOrg: ActionsListSelfHostedRunnerGroupsForOrgHandler;
  actionsCreateSelfHostedRunnerGroupForOrg: ActionsCreateSelfHostedRunnerGroupForOrgHandler;
  actionsGetSelfHostedRunnerGroupForOrg: ActionsGetSelfHostedRunnerGroupForOrgHandler;
  actionsUpdateSelfHostedRunnerGroupForOrg: ActionsUpdateSelfHostedRunnerGroupForOrgHandler;
  actionsDeleteSelfHostedRunnerGroupFromOrg: ActionsDeleteSelfHostedRunnerGroupFromOrgHandler;
  actionsListRepoAccessToSelfHostedRunnerGroupInOrg: ActionsListRepoAccessToSelfHostedRunnerGroupInOrgHandler;
  actionsSetRepoAccessToSelfHostedRunnerGroupInOrg: ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgHandler;
  actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgHandler;
  actionsListSelfHostedRunnersInGroupForOrg: ActionsListSelfHostedRunnersInGroupForOrgHandler;
  actionsSetSelfHostedRunnersInGroupForOrg: ActionsSetSelfHostedRunnersInGroupForOrgHandler;
  actionsAddSelfHostedRunnerToGroupForOrg: ActionsAddSelfHostedRunnerToGroupForOrgHandler;
  actionsRemoveSelfHostedRunnerFromGroupForOrg: ActionsRemoveSelfHostedRunnerFromGroupForOrgHandler;
  actionsListSelfHostedRunnersForOrg: ActionsListSelfHostedRunnersForOrgHandler;
  actionsListRunnerApplicationsForOrg: ActionsListRunnerApplicationsForOrgHandler;
  actionsCreateRegistrationTokenForOrg: ActionsCreateRegistrationTokenForOrgHandler;
  actionsCreateRemoveTokenForOrg: ActionsCreateRemoveTokenForOrgHandler;
  actionsGetSelfHostedRunnerForOrg: ActionsGetSelfHostedRunnerForOrgHandler;
  actionsDeleteSelfHostedRunnerFromOrg: ActionsDeleteSelfHostedRunnerFromOrgHandler;
  actionsListLabelsForSelfHostedRunnerForOrg: ActionsListLabelsForSelfHostedRunnerForOrgHandler;
  actionsAddCustomLabelsToSelfHostedRunnerForOrg: ActionsAddCustomLabelsToSelfHostedRunnerForOrgHandler;
  actionsSetCustomLabelsForSelfHostedRunnerForOrg: ActionsSetCustomLabelsForSelfHostedRunnerForOrgHandler;
  actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgHandler;
  actionsRemoveCustomLabelFromSelfHostedRunnerForOrg: ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgHandler;
  actionsListOrgSecrets: ActionsListOrgSecretsHandler;
  actionsGetOrgPublicKey: ActionsGetOrgPublicKeyHandler;
  actionsGetOrgSecret: ActionsGetOrgSecretHandler;
  actionsCreateOrUpdateOrgSecret: ActionsCreateOrUpdateOrgSecretHandler;
  actionsDeleteOrgSecret: ActionsDeleteOrgSecretHandler;
  actionsListSelectedReposForOrgSecret: ActionsListSelectedReposForOrgSecretHandler;
  actionsSetSelectedReposForOrgSecret: ActionsSetSelectedReposForOrgSecretHandler;
  actionsAddSelectedRepoToOrgSecret: ActionsAddSelectedRepoToOrgSecretHandler;
  actionsRemoveSelectedRepoFromOrgSecret: ActionsRemoveSelectedRepoFromOrgSecretHandler;
  orgsListBlockedUsers: OrgsListBlockedUsersHandler;
  orgsCheckBlockedUser: OrgsCheckBlockedUserHandler;
  orgsBlockUser: OrgsBlockUserHandler;
  orgsUnblockUser: OrgsUnblockUserHandler;
  codeScanningListAlertsForOrg: CodeScanningListAlertsForOrgHandler;
  codespacesListInOrganization: CodespacesListInOrganizationHandler;
  codespacesSetCodespacesBilling: CodespacesSetCodespacesBillingHandler;
  codespacesListOrgSecrets: CodespacesListOrgSecretsHandler;
  codespacesGetOrgPublicKey: CodespacesGetOrgPublicKeyHandler;
  codespacesGetOrgSecret: CodespacesGetOrgSecretHandler;
  codespacesCreateOrUpdateOrgSecret: CodespacesCreateOrUpdateOrgSecretHandler;
  codespacesDeleteOrgSecret: CodespacesDeleteOrgSecretHandler;
  codespacesListSelectedReposForOrgSecret: CodespacesListSelectedReposForOrgSecretHandler;
  codespacesSetSelectedReposForOrgSecret: CodespacesSetSelectedReposForOrgSecretHandler;
  codespacesAddSelectedRepoToOrgSecret: CodespacesAddSelectedRepoToOrgSecretHandler;
  codespacesRemoveSelectedRepoFromOrgSecret: CodespacesRemoveSelectedRepoFromOrgSecretHandler;
  orgsCreateCustomRole: OrgsCreateCustomRoleHandler;
  orgsGetCustomRole: OrgsGetCustomRoleHandler;
  orgsUpdateCustomRole: OrgsUpdateCustomRoleHandler;
  orgsDeleteCustomRole: OrgsDeleteCustomRoleHandler;
  dependabotListAlertsForOrg: DependabotListAlertsForOrgHandler;
  dependabotListOrgSecrets: DependabotListOrgSecretsHandler;
  dependabotGetOrgPublicKey: DependabotGetOrgPublicKeyHandler;
  dependabotGetOrgSecret: DependabotGetOrgSecretHandler;
  dependabotCreateOrUpdateOrgSecret: DependabotCreateOrUpdateOrgSecretHandler;
  dependabotDeleteOrgSecret: DependabotDeleteOrgSecretHandler;
  dependabotListSelectedReposForOrgSecret: DependabotListSelectedReposForOrgSecretHandler;
  dependabotSetSelectedReposForOrgSecret: DependabotSetSelectedReposForOrgSecretHandler;
  dependabotAddSelectedRepoToOrgSecret: DependabotAddSelectedRepoToOrgSecretHandler;
  dependabotRemoveSelectedRepoFromOrgSecret: DependabotRemoveSelectedRepoFromOrgSecretHandler;
  activityListPublicOrgEvents: ActivityListPublicOrgEventsHandler;
  orgsListFailedInvitations: OrgsListFailedInvitationsHandler;
  orgsListFineGrainedPermissions: OrgsListFineGrainedPermissionsHandler;
  orgsListWebhooks: OrgsListWebhooksHandler;
  orgsCreateWebhook: OrgsCreateWebhookHandler;
  orgsGetWebhook: OrgsGetWebhookHandler;
  orgsUpdateWebhook: OrgsUpdateWebhookHandler;
  orgsDeleteWebhook: OrgsDeleteWebhookHandler;
  orgsGetWebhookConfigForOrg: OrgsGetWebhookConfigForOrgHandler;
  orgsUpdateWebhookConfigForOrg: OrgsUpdateWebhookConfigForOrgHandler;
  orgsListWebhookDeliveries: OrgsListWebhookDeliveriesHandler;
  orgsGetWebhookDelivery: OrgsGetWebhookDeliveryHandler;
  orgsRedeliverWebhookDelivery: OrgsRedeliverWebhookDeliveryHandler;
  orgsPingWebhook: OrgsPingWebhookHandler;
  appsGetOrgInstallation: AppsGetOrgInstallationHandler;
  orgsListAppInstallations: OrgsListAppInstallationsHandler;
  interactionsGetRestrictionsForOrg: InteractionsGetRestrictionsForOrgHandler;
  interactionsSetRestrictionsForOrg: InteractionsSetRestrictionsForOrgHandler;
  interactionsRemoveRestrictionsForOrg: InteractionsRemoveRestrictionsForOrgHandler;
  orgsListPendingInvitations: OrgsListPendingInvitationsHandler;
  orgsCreateInvitation: OrgsCreateInvitationHandler;
  orgsCancelInvitation: OrgsCancelInvitationHandler;
  orgsListInvitationTeams: OrgsListInvitationTeamsHandler;
  issuesListForOrg: IssuesListForOrgHandler;
  orgsListMembers: OrgsListMembersHandler;
  orgsCheckMembershipForUser: OrgsCheckMembershipForUserHandler;
  orgsRemoveMember: OrgsRemoveMemberHandler;
  codespacesGetCodespacesForUserInOrg: CodespacesGetCodespacesForUserInOrgHandler;
  codespacesDeleteFromOrganization: CodespacesDeleteFromOrganizationHandler;
  codespacesStopInOrganization: CodespacesStopInOrganizationHandler;
  orgsGetMembershipForUser: OrgsGetMembershipForUserHandler;
  orgsSetMembershipForUser: OrgsSetMembershipForUserHandler;
  orgsRemoveMembershipForUser: OrgsRemoveMembershipForUserHandler;
  migrationsListForOrg: MigrationsListForOrgHandler;
  migrationsStartForOrg: MigrationsStartForOrgHandler;
  migrationsGetStatusForOrg: MigrationsGetStatusForOrgHandler;
  migrationsDownloadArchiveForOrg: MigrationsDownloadArchiveForOrgHandler;
  migrationsDeleteArchiveForOrg: MigrationsDeleteArchiveForOrgHandler;
  migrationsUnlockRepoForOrg: MigrationsUnlockRepoForOrgHandler;
  migrationsListReposForOrg: MigrationsListReposForOrgHandler;
  orgsListOutsideCollaborators: OrgsListOutsideCollaboratorsHandler;
  orgsConvertMemberToOutsideCollaborator: OrgsConvertMemberToOutsideCollaboratorHandler;
  orgsRemoveOutsideCollaborator: OrgsRemoveOutsideCollaboratorHandler;
  packagesListPackagesForOrganization: PackagesListPackagesForOrganizationHandler;
  packagesGetPackageForOrganization: PackagesGetPackageForOrganizationHandler;
  packagesDeletePackageForOrg: PackagesDeletePackageForOrgHandler;
  packagesRestorePackageForOrg: PackagesRestorePackageForOrgHandler;
  packagesGetAllPackageVersionsForPackageOwnedByOrg: PackagesGetAllPackageVersionsForPackageOwnedByOrgHandler;
  packagesGetPackageVersionForOrganization: PackagesGetPackageVersionForOrganizationHandler;
  packagesDeletePackageVersionForOrg: PackagesDeletePackageVersionForOrgHandler;
  packagesRestorePackageVersionForOrg: PackagesRestorePackageVersionForOrgHandler;
  projectsListForOrg: ProjectsListForOrgHandler;
  projectsCreateForOrg: ProjectsCreateForOrgHandler;
  orgsListPublicMembers: OrgsListPublicMembersHandler;
  orgsCheckPublicMembershipForUser: OrgsCheckPublicMembershipForUserHandler;
  orgsSetPublicMembershipForAuthenticatedUser: OrgsSetPublicMembershipForAuthenticatedUserHandler;
  orgsRemovePublicMembershipForAuthenticatedUser: OrgsRemovePublicMembershipForAuthenticatedUserHandler;
  reposListForOrg: ReposListForOrgHandler;
  reposCreateInOrg: ReposCreateInOrgHandler;
  secretScanningListAlertsForOrg: SecretScanningListAlertsForOrgHandler;
  orgsListSecurityManagerTeams: OrgsListSecurityManagerTeamsHandler;
  orgsAddSecurityManagerTeam: OrgsAddSecurityManagerTeamHandler;
  orgsRemoveSecurityManagerTeam: OrgsRemoveSecurityManagerTeamHandler;
  billingGetGithubActionsBillingOrg: BillingGetGithubActionsBillingOrgHandler;
  billingGetGithubAdvancedSecurityBillingOrg: BillingGetGithubAdvancedSecurityBillingOrgHandler;
  billingGetGithubPackagesBillingOrg: BillingGetGithubPackagesBillingOrgHandler;
  billingGetSharedStorageBillingOrg: BillingGetSharedStorageBillingOrgHandler;
  teamsList: TeamsListHandler;
  teamsCreate: TeamsCreateHandler;
  teamsGetByName: TeamsGetByNameHandler;
  teamsUpdateInOrg: TeamsUpdateInOrgHandler;
  teamsDeleteInOrg: TeamsDeleteInOrgHandler;
  teamsListDiscussionsInOrg: TeamsListDiscussionsInOrgHandler;
  teamsCreateDiscussionInOrg: TeamsCreateDiscussionInOrgHandler;
  teamsGetDiscussionInOrg: TeamsGetDiscussionInOrgHandler;
  teamsUpdateDiscussionInOrg: TeamsUpdateDiscussionInOrgHandler;
  teamsDeleteDiscussionInOrg: TeamsDeleteDiscussionInOrgHandler;
  teamsListDiscussionCommentsInOrg: TeamsListDiscussionCommentsInOrgHandler;
  teamsCreateDiscussionCommentInOrg: TeamsCreateDiscussionCommentInOrgHandler;
  teamsGetDiscussionCommentInOrg: TeamsGetDiscussionCommentInOrgHandler;
  teamsUpdateDiscussionCommentInOrg: TeamsUpdateDiscussionCommentInOrgHandler;
  teamsDeleteDiscussionCommentInOrg: TeamsDeleteDiscussionCommentInOrgHandler;
  reactionsListForTeamDiscussionCommentInOrg: ReactionsListForTeamDiscussionCommentInOrgHandler;
  reactionsCreateForTeamDiscussionCommentInOrg: ReactionsCreateForTeamDiscussionCommentInOrgHandler;
  reactionsDeleteForTeamDiscussionComment: ReactionsDeleteForTeamDiscussionCommentHandler;
  reactionsListForTeamDiscussionInOrg: ReactionsListForTeamDiscussionInOrgHandler;
  reactionsCreateForTeamDiscussionInOrg: ReactionsCreateForTeamDiscussionInOrgHandler;
  reactionsDeleteForTeamDiscussion: ReactionsDeleteForTeamDiscussionHandler;
  teamsListPendingInvitationsInOrg: TeamsListPendingInvitationsInOrgHandler;
  teamsListMembersInOrg: TeamsListMembersInOrgHandler;
  teamsGetMembershipForUserInOrg: TeamsGetMembershipForUserInOrgHandler;
  teamsAddOrUpdateMembershipForUserInOrg: TeamsAddOrUpdateMembershipForUserInOrgHandler;
  teamsRemoveMembershipForUserInOrg: TeamsRemoveMembershipForUserInOrgHandler;
  teamsListProjectsInOrg: TeamsListProjectsInOrgHandler;
  teamsCheckPermissionsForProjectInOrg: TeamsCheckPermissionsForProjectInOrgHandler;
  teamsAddOrUpdateProjectPermissionsInOrg: TeamsAddOrUpdateProjectPermissionsInOrgHandler;
  teamsRemoveProjectInOrg: TeamsRemoveProjectInOrgHandler;
  teamsListReposInOrg: TeamsListReposInOrgHandler;
  teamsCheckPermissionsForRepoInOrg: TeamsCheckPermissionsForRepoInOrgHandler;
  teamsAddOrUpdateRepoPermissionsInOrg: TeamsAddOrUpdateRepoPermissionsInOrgHandler;
  teamsRemoveRepoInOrg: TeamsRemoveRepoInOrgHandler;
  teamsListChildInOrg: TeamsListChildInOrgHandler;
  orgsEnableOrDisableSecurityProductOnAllOrgRepos: OrgsEnableOrDisableSecurityProductOnAllOrgReposHandler;
  projectsGetCard: ProjectsGetCardHandler;
  projectsUpdateCard: ProjectsUpdateCardHandler;
  projectsDeleteCard: ProjectsDeleteCardHandler;
  projectsMoveCard: ProjectsMoveCardHandler;
  projectsGetColumn: ProjectsGetColumnHandler;
  projectsUpdateColumn: ProjectsUpdateColumnHandler;
  projectsDeleteColumn: ProjectsDeleteColumnHandler;
  projectsListCards: ProjectsListCardsHandler;
  projectsCreateCard: ProjectsCreateCardHandler;
  projectsMoveColumn: ProjectsMoveColumnHandler;
  projectsGet: ProjectsGetHandler;
  projectsUpdate: ProjectsUpdateHandler;
  projectsDelete: ProjectsDeleteHandler;
  projectsListCollaborators: ProjectsListCollaboratorsHandler;
  projectsAddCollaborator: ProjectsAddCollaboratorHandler;
  projectsRemoveCollaborator: ProjectsRemoveCollaboratorHandler;
  projectsGetPermissionForUser: ProjectsGetPermissionForUserHandler;
  projectsListColumns: ProjectsListColumnsHandler;
  projectsCreateColumn: ProjectsCreateColumnHandler;
  rateLimitGet: RateLimitGetHandler;
  reposGet: ReposGetHandler;
  reposUpdate: ReposUpdateHandler;
  reposDelete: ReposDeleteHandler;
  actionsListArtifactsForRepo: ActionsListArtifactsForRepoHandler;
  actionsGetArtifact: ActionsGetArtifactHandler;
  actionsDeleteArtifact: ActionsDeleteArtifactHandler;
  actionsDownloadArtifact: ActionsDownloadArtifactHandler;
  actionsGetActionsCacheUsage: ActionsGetActionsCacheUsageHandler;
  actionsGetActionsCacheList: ActionsGetActionsCacheListHandler;
  actionsDeleteActionsCacheByKey: ActionsDeleteActionsCacheByKeyHandler;
  actionsDeleteActionsCacheById: ActionsDeleteActionsCacheByIdHandler;
  actionsGetJobForWorkflowRun: ActionsGetJobForWorkflowRunHandler;
  actionsDownloadJobLogsForWorkflowRun: ActionsDownloadJobLogsForWorkflowRunHandler;
  actionsReRunJobForWorkflowRun: ActionsReRunJobForWorkflowRunHandler;
  actionsGetGithubActionsPermissionsRepository: ActionsGetGithubActionsPermissionsRepositoryHandler;
  actionsSetGithubActionsPermissionsRepository: ActionsSetGithubActionsPermissionsRepositoryHandler;
  actionsGetWorkflowAccessToRepository: ActionsGetWorkflowAccessToRepositoryHandler;
  actionsSetWorkflowAccessToRepository: ActionsSetWorkflowAccessToRepositoryHandler;
  actionsGetAllowedActionsRepository: ActionsGetAllowedActionsRepositoryHandler;
  actionsSetAllowedActionsRepository: ActionsSetAllowedActionsRepositoryHandler;
  actionsGetGithubActionsDefaultWorkflowPermissionsRepository: ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryHandler;
  actionsSetGithubActionsDefaultWorkflowPermissionsRepository: ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryHandler;
  actionsListSelfHostedRunnersForRepo: ActionsListSelfHostedRunnersForRepoHandler;
  actionsListRunnerApplicationsForRepo: ActionsListRunnerApplicationsForRepoHandler;
  actionsCreateRegistrationTokenForRepo: ActionsCreateRegistrationTokenForRepoHandler;
  actionsCreateRemoveTokenForRepo: ActionsCreateRemoveTokenForRepoHandler;
  actionsGetSelfHostedRunnerForRepo: ActionsGetSelfHostedRunnerForRepoHandler;
  actionsDeleteSelfHostedRunnerFromRepo: ActionsDeleteSelfHostedRunnerFromRepoHandler;
  actionsListLabelsForSelfHostedRunnerForRepo: ActionsListLabelsForSelfHostedRunnerForRepoHandler;
  actionsAddCustomLabelsToSelfHostedRunnerForRepo: ActionsAddCustomLabelsToSelfHostedRunnerForRepoHandler;
  actionsSetCustomLabelsForSelfHostedRunnerForRepo: ActionsSetCustomLabelsForSelfHostedRunnerForRepoHandler;
  actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoHandler;
  actionsRemoveCustomLabelFromSelfHostedRunnerForRepo: ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoHandler;
  actionsListWorkflowRunsForRepo: ActionsListWorkflowRunsForRepoHandler;
  actionsGetWorkflowRun: ActionsGetWorkflowRunHandler;
  actionsDeleteWorkflowRun: ActionsDeleteWorkflowRunHandler;
  actionsGetReviewsForRun: ActionsGetReviewsForRunHandler;
  actionsApproveWorkflowRun: ActionsApproveWorkflowRunHandler;
  actionsListWorkflowRunArtifacts: ActionsListWorkflowRunArtifactsHandler;
  actionsGetWorkflowRunAttempt: ActionsGetWorkflowRunAttemptHandler;
  actionsListJobsForWorkflowRunAttempt: ActionsListJobsForWorkflowRunAttemptHandler;
  actionsDownloadWorkflowRunAttemptLogs: ActionsDownloadWorkflowRunAttemptLogsHandler;
  actionsCancelWorkflowRun: ActionsCancelWorkflowRunHandler;
  actionsListJobsForWorkflowRun: ActionsListJobsForWorkflowRunHandler;
  actionsDownloadWorkflowRunLogs: ActionsDownloadWorkflowRunLogsHandler;
  actionsDeleteWorkflowRunLogs: ActionsDeleteWorkflowRunLogsHandler;
  actionsGetPendingDeploymentsForRun: ActionsGetPendingDeploymentsForRunHandler;
  actionsReviewPendingDeploymentsForRun: ActionsReviewPendingDeploymentsForRunHandler;
  actionsReRunWorkflow: ActionsReRunWorkflowHandler;
  actionsReRunWorkflowFailedJobs: ActionsReRunWorkflowFailedJobsHandler;
  actionsGetWorkflowRunUsage: ActionsGetWorkflowRunUsageHandler;
  actionsListRepoSecrets: ActionsListRepoSecretsHandler;
  actionsGetRepoPublicKey: ActionsGetRepoPublicKeyHandler;
  actionsGetRepoSecret: ActionsGetRepoSecretHandler;
  actionsCreateOrUpdateRepoSecret: ActionsCreateOrUpdateRepoSecretHandler;
  actionsDeleteRepoSecret: ActionsDeleteRepoSecretHandler;
  actionsListRepoWorkflows: ActionsListRepoWorkflowsHandler;
  actionsGetWorkflow: ActionsGetWorkflowHandler;
  actionsDisableWorkflow: ActionsDisableWorkflowHandler;
  actionsCreateWorkflowDispatch: ActionsCreateWorkflowDispatchHandler;
  actionsEnableWorkflow: ActionsEnableWorkflowHandler;
  actionsListWorkflowRuns: ActionsListWorkflowRunsHandler;
  actionsGetWorkflowUsage: ActionsGetWorkflowUsageHandler;
  issuesListAssignees: IssuesListAssigneesHandler;
  issuesCheckUserCanBeAssigned: IssuesCheckUserCanBeAssignedHandler;
  reposListAutolinks: ReposListAutolinksHandler;
  reposCreateAutolink: ReposCreateAutolinkHandler;
  reposGetAutolink: ReposGetAutolinkHandler;
  reposDeleteAutolink: ReposDeleteAutolinkHandler;
  reposEnableAutomatedSecurityFixes: ReposEnableAutomatedSecurityFixesHandler;
  reposDisableAutomatedSecurityFixes: ReposDisableAutomatedSecurityFixesHandler;
  reposListBranches: ReposListBranchesHandler;
  reposGetBranch: ReposGetBranchHandler;
  reposGetBranchProtection: ReposGetBranchProtectionHandler;
  reposUpdateBranchProtection: ReposUpdateBranchProtectionHandler;
  reposDeleteBranchProtection: ReposDeleteBranchProtectionHandler;
  reposGetAdminBranchProtection: ReposGetAdminBranchProtectionHandler;
  reposSetAdminBranchProtection: ReposSetAdminBranchProtectionHandler;
  reposDeleteAdminBranchProtection: ReposDeleteAdminBranchProtectionHandler;
  reposGetPullRequestReviewProtection: ReposGetPullRequestReviewProtectionHandler;
  reposUpdatePullRequestReviewProtection: ReposUpdatePullRequestReviewProtectionHandler;
  reposDeletePullRequestReviewProtection: ReposDeletePullRequestReviewProtectionHandler;
  reposGetCommitSignatureProtection: ReposGetCommitSignatureProtectionHandler;
  reposCreateCommitSignatureProtection: ReposCreateCommitSignatureProtectionHandler;
  reposDeleteCommitSignatureProtection: ReposDeleteCommitSignatureProtectionHandler;
  reposGetStatusChecksProtection: ReposGetStatusChecksProtectionHandler;
  reposUpdateStatusCheckProtection: ReposUpdateStatusCheckProtectionHandler;
  reposRemoveStatusCheckProtection: ReposRemoveStatusCheckProtectionHandler;
  reposGetAllStatusCheckContexts: ReposGetAllStatusCheckContextsHandler;
  reposAddStatusCheckContexts: ReposAddStatusCheckContextsHandler;
  reposSetStatusCheckContexts: ReposSetStatusCheckContextsHandler;
  reposRemoveStatusCheckContexts: ReposRemoveStatusCheckContextsHandler;
  reposGetAccessRestrictions: ReposGetAccessRestrictionsHandler;
  reposDeleteAccessRestrictions: ReposDeleteAccessRestrictionsHandler;
  reposGetAppsWithAccessToProtectedBranch: ReposGetAppsWithAccessToProtectedBranchHandler;
  reposAddAppAccessRestrictions: ReposAddAppAccessRestrictionsHandler;
  reposSetAppAccessRestrictions: ReposSetAppAccessRestrictionsHandler;
  reposRemoveAppAccessRestrictions: ReposRemoveAppAccessRestrictionsHandler;
  reposGetTeamsWithAccessToProtectedBranch: ReposGetTeamsWithAccessToProtectedBranchHandler;
  reposAddTeamAccessRestrictions: ReposAddTeamAccessRestrictionsHandler;
  reposSetTeamAccessRestrictions: ReposSetTeamAccessRestrictionsHandler;
  reposRemoveTeamAccessRestrictions: ReposRemoveTeamAccessRestrictionsHandler;
  reposGetUsersWithAccessToProtectedBranch: ReposGetUsersWithAccessToProtectedBranchHandler;
  reposAddUserAccessRestrictions: ReposAddUserAccessRestrictionsHandler;
  reposSetUserAccessRestrictions: ReposSetUserAccessRestrictionsHandler;
  reposRemoveUserAccessRestrictions: ReposRemoveUserAccessRestrictionsHandler;
  reposRenameBranch: ReposRenameBranchHandler;
  checksCreate: ChecksCreateHandler;
  checksGet: ChecksGetHandler;
  checksUpdate: ChecksUpdateHandler;
  checksListAnnotations: ChecksListAnnotationsHandler;
  checksRerequestRun: ChecksRerequestRunHandler;
  checksCreateSuite: ChecksCreateSuiteHandler;
  checksSetSuitesPreferences: ChecksSetSuitesPreferencesHandler;
  checksGetSuite: ChecksGetSuiteHandler;
  checksListForSuite: ChecksListForSuiteHandler;
  checksRerequestSuite: ChecksRerequestSuiteHandler;
  codeScanningListAlertsForRepo: CodeScanningListAlertsForRepoHandler;
  codeScanningGetAlert: CodeScanningGetAlertHandler;
  codeScanningUpdateAlert: CodeScanningUpdateAlertHandler;
  codeScanningListAlertInstances: CodeScanningListAlertInstancesHandler;
  codeScanningListRecentAnalyses: CodeScanningListRecentAnalysesHandler;
  codeScanningGetAnalysis: CodeScanningGetAnalysisHandler;
  codeScanningDeleteAnalysis: CodeScanningDeleteAnalysisHandler;
  codeScanningListCodeqlDatabases: CodeScanningListCodeqlDatabasesHandler;
  codeScanningGetCodeqlDatabase: CodeScanningGetCodeqlDatabaseHandler;
  codeScanningUploadSarif: CodeScanningUploadSarifHandler;
  codeScanningGetSarif: CodeScanningGetSarifHandler;
  reposCodeownersErrors: ReposCodeownersErrorsHandler;
  codespacesListInRepositoryForAuthenticatedUser: CodespacesListInRepositoryForAuthenticatedUserHandler;
  codespacesCreateWithRepoForAuthenticatedUser: CodespacesCreateWithRepoForAuthenticatedUserHandler;
  codespacesListDevcontainersInRepositoryForAuthenticatedUser: CodespacesListDevcontainersInRepositoryForAuthenticatedUserHandler;
  codespacesRepoMachinesForAuthenticatedUser: CodespacesRepoMachinesForAuthenticatedUserHandler;
  codespacesPreFlightWithRepoForAuthenticatedUser: CodespacesPreFlightWithRepoForAuthenticatedUserHandler;
  codespacesListRepoSecrets: CodespacesListRepoSecretsHandler;
  codespacesGetRepoPublicKey: CodespacesGetRepoPublicKeyHandler;
  codespacesGetRepoSecret: CodespacesGetRepoSecretHandler;
  codespacesCreateOrUpdateRepoSecret: CodespacesCreateOrUpdateRepoSecretHandler;
  codespacesDeleteRepoSecret: CodespacesDeleteRepoSecretHandler;
  reposListCollaborators: ReposListCollaboratorsHandler;
  reposCheckCollaborator: ReposCheckCollaboratorHandler;
  reposAddCollaborator: ReposAddCollaboratorHandler;
  reposRemoveCollaborator: ReposRemoveCollaboratorHandler;
  reposGetCollaboratorPermissionLevel: ReposGetCollaboratorPermissionLevelHandler;
  reposListCommitCommentsForRepo: ReposListCommitCommentsForRepoHandler;
  reposGetCommitComment: ReposGetCommitCommentHandler;
  reposUpdateCommitComment: ReposUpdateCommitCommentHandler;
  reposDeleteCommitComment: ReposDeleteCommitCommentHandler;
  reactionsListForCommitComment: ReactionsListForCommitCommentHandler;
  reactionsCreateForCommitComment: ReactionsCreateForCommitCommentHandler;
  reactionsDeleteForCommitComment: ReactionsDeleteForCommitCommentHandler;
  reposListCommits: ReposListCommitsHandler;
  reposListBranchesForHeadCommit: ReposListBranchesForHeadCommitHandler;
  reposListCommentsForCommit: ReposListCommentsForCommitHandler;
  reposCreateCommitComment: ReposCreateCommitCommentHandler;
  reposListPullRequestsAssociatedWithCommit: ReposListPullRequestsAssociatedWithCommitHandler;
  reposGetCommit: ReposGetCommitHandler;
  checksListForRef: ChecksListForRefHandler;
  checksListSuitesForRef: ChecksListSuitesForRefHandler;
  reposGetCombinedStatusForRef: ReposGetCombinedStatusForRefHandler;
  reposListCommitStatusesForRef: ReposListCommitStatusesForRefHandler;
  reposGetCommunityProfileMetrics: ReposGetCommunityProfileMetricsHandler;
  reposCompareCommits: ReposCompareCommitsHandler;
  reposGetContent: ReposGetContentHandler;
  reposCreateOrUpdateFileContents: ReposCreateOrUpdateFileContentsHandler;
  reposDeleteFile: ReposDeleteFileHandler;
  reposListContributors: ReposListContributorsHandler;
  dependabotListAlertsForRepo: DependabotListAlertsForRepoHandler;
  dependabotGetAlert: DependabotGetAlertHandler;
  dependabotUpdateAlert: DependabotUpdateAlertHandler;
  dependabotListRepoSecrets: DependabotListRepoSecretsHandler;
  dependabotGetRepoPublicKey: DependabotGetRepoPublicKeyHandler;
  dependabotGetRepoSecret: DependabotGetRepoSecretHandler;
  dependabotCreateOrUpdateRepoSecret: DependabotCreateOrUpdateRepoSecretHandler;
  dependabotDeleteRepoSecret: DependabotDeleteRepoSecretHandler;
  dependencyGraphDiffRange: DependencyGraphDiffRangeHandler;
  dependencyGraphCreateRepositorySnapshot: DependencyGraphCreateRepositorySnapshotHandler;
  reposListDeployments: ReposListDeploymentsHandler;
  reposCreateDeployment: ReposCreateDeploymentHandler;
  reposGetDeployment: ReposGetDeploymentHandler;
  reposDeleteDeployment: ReposDeleteDeploymentHandler;
  reposListDeploymentStatuses: ReposListDeploymentStatusesHandler;
  reposCreateDeploymentStatus: ReposCreateDeploymentStatusHandler;
  reposGetDeploymentStatus: ReposGetDeploymentStatusHandler;
  reposCreateDispatchEvent: ReposCreateDispatchEventHandler;
  reposGetAllEnvironments: ReposGetAllEnvironmentsHandler;
  reposGetEnvironment: ReposGetEnvironmentHandler;
  reposCreateOrUpdateEnvironment: ReposCreateOrUpdateEnvironmentHandler;
  reposDeleteAnEnvironment: ReposDeleteAnEnvironmentHandler;
  reposListDeploymentBranchPolicies: ReposListDeploymentBranchPoliciesHandler;
  reposCreateDeploymentBranchPolicy: ReposCreateDeploymentBranchPolicyHandler;
  reposGetDeploymentBranchPolicy: ReposGetDeploymentBranchPolicyHandler;
  reposUpdateDeploymentBranchPolicy: ReposUpdateDeploymentBranchPolicyHandler;
  reposDeleteDeploymentBranchPolicy: ReposDeleteDeploymentBranchPolicyHandler;
  activityListRepoEvents: ActivityListRepoEventsHandler;
  reposListForks: ReposListForksHandler;
  reposCreateFork: ReposCreateForkHandler;
  gitCreateBlob: GitCreateBlobHandler;
  gitGetBlob: GitGetBlobHandler;
  gitCreateCommit: GitCreateCommitHandler;
  gitGetCommit: GitGetCommitHandler;
  gitListMatchingRefs: GitListMatchingRefsHandler;
  gitGetRef: GitGetRefHandler;
  gitCreateRef: GitCreateRefHandler;
  gitUpdateRef: GitUpdateRefHandler;
  gitDeleteRef: GitDeleteRefHandler;
  gitCreateTag: GitCreateTagHandler;
  gitGetTag: GitGetTagHandler;
  gitCreateTree: GitCreateTreeHandler;
  gitGetTree: GitGetTreeHandler;
  reposListWebhooks: ReposListWebhooksHandler;
  reposCreateWebhook: ReposCreateWebhookHandler;
  reposGetWebhook: ReposGetWebhookHandler;
  reposUpdateWebhook: ReposUpdateWebhookHandler;
  reposDeleteWebhook: ReposDeleteWebhookHandler;
  reposGetWebhookConfigForRepo: ReposGetWebhookConfigForRepoHandler;
  reposUpdateWebhookConfigForRepo: ReposUpdateWebhookConfigForRepoHandler;
  reposListWebhookDeliveries: ReposListWebhookDeliveriesHandler;
  reposGetWebhookDelivery: ReposGetWebhookDeliveryHandler;
  reposRedeliverWebhookDelivery: ReposRedeliverWebhookDeliveryHandler;
  reposPingWebhook: ReposPingWebhookHandler;
  reposTestPushWebhook: ReposTestPushWebhookHandler;
  migrationsGetImportStatus: MigrationsGetImportStatusHandler;
  migrationsStartImport: MigrationsStartImportHandler;
  migrationsUpdateImport: MigrationsUpdateImportHandler;
  migrationsCancelImport: MigrationsCancelImportHandler;
  migrationsGetCommitAuthors: MigrationsGetCommitAuthorsHandler;
  migrationsMapCommitAuthor: MigrationsMapCommitAuthorHandler;
  migrationsGetLargeFiles: MigrationsGetLargeFilesHandler;
  migrationsSetLfsPreference: MigrationsSetLfsPreferenceHandler;
  appsGetRepoInstallation: AppsGetRepoInstallationHandler;
  interactionsGetRestrictionsForRepo: InteractionsGetRestrictionsForRepoHandler;
  interactionsSetRestrictionsForRepo: InteractionsSetRestrictionsForRepoHandler;
  interactionsRemoveRestrictionsForRepo: InteractionsRemoveRestrictionsForRepoHandler;
  reposListInvitations: ReposListInvitationsHandler;
  reposUpdateInvitation: ReposUpdateInvitationHandler;
  reposDeleteInvitation: ReposDeleteInvitationHandler;
  issuesListForRepo: IssuesListForRepoHandler;
  issuesCreate: IssuesCreateHandler;
  issuesListCommentsForRepo: IssuesListCommentsForRepoHandler;
  issuesGetComment: IssuesGetCommentHandler;
  issuesUpdateComment: IssuesUpdateCommentHandler;
  issuesDeleteComment: IssuesDeleteCommentHandler;
  reactionsListForIssueComment: ReactionsListForIssueCommentHandler;
  reactionsCreateForIssueComment: ReactionsCreateForIssueCommentHandler;
  reactionsDeleteForIssueComment: ReactionsDeleteForIssueCommentHandler;
  issuesListEventsForRepo: IssuesListEventsForRepoHandler;
  issuesGetEvent: IssuesGetEventHandler;
  issuesGet: IssuesGetHandler;
  issuesUpdate: IssuesUpdateHandler;
  issuesAddAssignees: IssuesAddAssigneesHandler;
  issuesRemoveAssignees: IssuesRemoveAssigneesHandler;
  issuesListComments: IssuesListCommentsHandler;
  issuesCreateComment: IssuesCreateCommentHandler;
  issuesListEvents: IssuesListEventsHandler;
  issuesListLabelsOnIssue: IssuesListLabelsOnIssueHandler;
  issuesAddLabels: IssuesAddLabelsHandler;
  issuesSetLabels: IssuesSetLabelsHandler;
  issuesRemoveAllLabels: IssuesRemoveAllLabelsHandler;
  issuesRemoveLabel: IssuesRemoveLabelHandler;
  issuesLock: IssuesLockHandler;
  issuesUnlock: IssuesUnlockHandler;
  reactionsListForIssue: ReactionsListForIssueHandler;
  reactionsCreateForIssue: ReactionsCreateForIssueHandler;
  reactionsDeleteForIssue: ReactionsDeleteForIssueHandler;
  issuesListEventsForTimeline: IssuesListEventsForTimelineHandler;
  reposListDeployKeys: ReposListDeployKeysHandler;
  reposCreateDeployKey: ReposCreateDeployKeyHandler;
  reposGetDeployKey: ReposGetDeployKeyHandler;
  reposDeleteDeployKey: ReposDeleteDeployKeyHandler;
  issuesListLabelsForRepo: IssuesListLabelsForRepoHandler;
  issuesCreateLabel: IssuesCreateLabelHandler;
  issuesGetLabel: IssuesGetLabelHandler;
  issuesUpdateLabel: IssuesUpdateLabelHandler;
  issuesDeleteLabel: IssuesDeleteLabelHandler;
  reposListLanguages: ReposListLanguagesHandler;
  reposEnableLfsForRepo: ReposEnableLfsForRepoHandler;
  reposDisableLfsForRepo: ReposDisableLfsForRepoHandler;
  licensesGetForRepo: LicensesGetForRepoHandler;
  reposMergeUpstream: ReposMergeUpstreamHandler;
  reposMerge: ReposMergeHandler;
  issuesListMilestones: IssuesListMilestonesHandler;
  issuesCreateMilestone: IssuesCreateMilestoneHandler;
  issuesGetMilestone: IssuesGetMilestoneHandler;
  issuesUpdateMilestone: IssuesUpdateMilestoneHandler;
  issuesDeleteMilestone: IssuesDeleteMilestoneHandler;
  issuesListLabelsForMilestone: IssuesListLabelsForMilestoneHandler;
  activityListRepoNotificationsForAuthenticatedUser: ActivityListRepoNotificationsForAuthenticatedUserHandler;
  activityMarkRepoNotificationsAsRead: ActivityMarkRepoNotificationsAsReadHandler;
  reposGetPages: ReposGetPagesHandler;
  reposCreatePagesSite: ReposCreatePagesSiteHandler;
  reposUpdateInformationAboutPagesSite: ReposUpdateInformationAboutPagesSiteHandler;
  reposDeletePagesSite: ReposDeletePagesSiteHandler;
  reposListPagesBuilds: ReposListPagesBuildsHandler;
  reposRequestPagesBuild: ReposRequestPagesBuildHandler;
  reposGetLatestPagesBuild: ReposGetLatestPagesBuildHandler;
  reposGetPagesBuild: ReposGetPagesBuildHandler;
  reposCreatePagesDeployment: ReposCreatePagesDeploymentHandler;
  reposGetPagesHealthCheck: ReposGetPagesHealthCheckHandler;
  projectsListForRepo: ProjectsListForRepoHandler;
  projectsCreateForRepo: ProjectsCreateForRepoHandler;
  pullsList: PullsListHandler;
  pullsCreate: PullsCreateHandler;
  pullsListReviewCommentsForRepo: PullsListReviewCommentsForRepoHandler;
  pullsGetReviewComment: PullsGetReviewCommentHandler;
  pullsUpdateReviewComment: PullsUpdateReviewCommentHandler;
  pullsDeleteReviewComment: PullsDeleteReviewCommentHandler;
  reactionsListForPullRequestReviewComment: ReactionsListForPullRequestReviewCommentHandler;
  reactionsCreateForPullRequestReviewComment: ReactionsCreateForPullRequestReviewCommentHandler;
  reactionsDeleteForPullRequestComment: ReactionsDeleteForPullRequestCommentHandler;
  pullsGet: PullsGetHandler;
  pullsUpdate: PullsUpdateHandler;
  codespacesCreateWithPrForAuthenticatedUser: CodespacesCreateWithPrForAuthenticatedUserHandler;
  pullsListReviewComments: PullsListReviewCommentsHandler;
  pullsCreateReviewComment: PullsCreateReviewCommentHandler;
  pullsCreateReplyForReviewComment: PullsCreateReplyForReviewCommentHandler;
  pullsListCommits: PullsListCommitsHandler;
  pullsListFiles: PullsListFilesHandler;
  pullsCheckIfMerged: PullsCheckIfMergedHandler;
  pullsMerge: PullsMergeHandler;
  pullsListRequestedReviewers: PullsListRequestedReviewersHandler;
  pullsRequestReviewers: PullsRequestReviewersHandler;
  pullsRemoveRequestedReviewers: PullsRemoveRequestedReviewersHandler;
  pullsListReviews: PullsListReviewsHandler;
  pullsCreateReview: PullsCreateReviewHandler;
  pullsGetReview: PullsGetReviewHandler;
  pullsUpdateReview: PullsUpdateReviewHandler;
  pullsDeletePendingReview: PullsDeletePendingReviewHandler;
  pullsListCommentsForReview: PullsListCommentsForReviewHandler;
  pullsDismissReview: PullsDismissReviewHandler;
  pullsSubmitReview: PullsSubmitReviewHandler;
  pullsUpdateBranch: PullsUpdateBranchHandler;
  reposGetReadme: ReposGetReadmeHandler;
  reposGetReadmeInDirectory: ReposGetReadmeInDirectoryHandler;
  reposListReleases: ReposListReleasesHandler;
  reposCreateRelease: ReposCreateReleaseHandler;
  reposGetReleaseAsset: ReposGetReleaseAssetHandler;
  reposUpdateReleaseAsset: ReposUpdateReleaseAssetHandler;
  reposDeleteReleaseAsset: ReposDeleteReleaseAssetHandler;
  reposGenerateReleaseNotes: ReposGenerateReleaseNotesHandler;
  reposGetLatestRelease: ReposGetLatestReleaseHandler;
  reposGetReleaseByTag: ReposGetReleaseByTagHandler;
  reposGetRelease: ReposGetReleaseHandler;
  reposUpdateRelease: ReposUpdateReleaseHandler;
  reposDeleteRelease: ReposDeleteReleaseHandler;
  reposListReleaseAssets: ReposListReleaseAssetsHandler;
  reposUploadReleaseAsset: ReposUploadReleaseAssetHandler;
  reactionsListForRelease: ReactionsListForReleaseHandler;
  reactionsCreateForRelease: ReactionsCreateForReleaseHandler;
  reactionsDeleteForRelease: ReactionsDeleteForReleaseHandler;
  secretScanningListAlertsForRepo: SecretScanningListAlertsForRepoHandler;
  secretScanningGetAlert: SecretScanningGetAlertHandler;
  secretScanningUpdateAlert: SecretScanningUpdateAlertHandler;
  secretScanningListLocationsForAlert: SecretScanningListLocationsForAlertHandler;
  activityListStargazersForRepo: ActivityListStargazersForRepoHandler;
  reposGetCodeFrequencyStats: ReposGetCodeFrequencyStatsHandler;
  reposGetCommitActivityStats: ReposGetCommitActivityStatsHandler;
  reposGetContributorsStats: ReposGetContributorsStatsHandler;
  reposGetParticipationStats: ReposGetParticipationStatsHandler;
  reposGetPunchCardStats: ReposGetPunchCardStatsHandler;
  reposCreateCommitStatus: ReposCreateCommitStatusHandler;
  activityListWatchersForRepo: ActivityListWatchersForRepoHandler;
  activityGetRepoSubscription: ActivityGetRepoSubscriptionHandler;
  activitySetRepoSubscription: ActivitySetRepoSubscriptionHandler;
  activityDeleteRepoSubscription: ActivityDeleteRepoSubscriptionHandler;
  reposListTags: ReposListTagsHandler;
  reposListTagProtection: ReposListTagProtectionHandler;
  reposCreateTagProtection: ReposCreateTagProtectionHandler;
  reposDeleteTagProtection: ReposDeleteTagProtectionHandler;
  reposDownloadTarballArchive: ReposDownloadTarballArchiveHandler;
  reposListTeams: ReposListTeamsHandler;
  reposGetAllTopics: ReposGetAllTopicsHandler;
  reposReplaceAllTopics: ReposReplaceAllTopicsHandler;
  reposGetClones: ReposGetClonesHandler;
  reposGetTopPaths: ReposGetTopPathsHandler;
  reposGetTopReferrers: ReposGetTopReferrersHandler;
  reposGetViews: ReposGetViewsHandler;
  reposTransfer: ReposTransferHandler;
  reposCheckVulnerabilityAlerts: ReposCheckVulnerabilityAlertsHandler;
  reposEnableVulnerabilityAlerts: ReposEnableVulnerabilityAlertsHandler;
  reposDisableVulnerabilityAlerts: ReposDisableVulnerabilityAlertsHandler;
  reposDownloadZipballArchive: ReposDownloadZipballArchiveHandler;
  reposCreateUsingTemplate: ReposCreateUsingTemplateHandler;
  reposListPublic: ReposListPublicHandler;
  actionsListEnvironmentSecrets: ActionsListEnvironmentSecretsHandler;
  actionsGetEnvironmentPublicKey: ActionsGetEnvironmentPublicKeyHandler;
  actionsGetEnvironmentSecret: ActionsGetEnvironmentSecretHandler;
  actionsCreateOrUpdateEnvironmentSecret: ActionsCreateOrUpdateEnvironmentSecretHandler;
  actionsDeleteEnvironmentSecret: ActionsDeleteEnvironmentSecretHandler;
  searchCode: SearchCodeHandler;
  searchCommits: SearchCommitsHandler;
  searchIssuesAndPullRequests: SearchIssuesAndPullRequestsHandler;
  searchLabels: SearchLabelsHandler;
  searchRepos: SearchReposHandler;
  searchTopics: SearchTopicsHandler;
  searchUsers: SearchUsersHandler;
  teamsGetLegacy: TeamsGetLegacyHandler;
  teamsUpdateLegacy: TeamsUpdateLegacyHandler;
  teamsDeleteLegacy: TeamsDeleteLegacyHandler;
  teamsListDiscussionsLegacy: TeamsListDiscussionsLegacyHandler;
  teamsCreateDiscussionLegacy: TeamsCreateDiscussionLegacyHandler;
  teamsGetDiscussionLegacy: TeamsGetDiscussionLegacyHandler;
  teamsUpdateDiscussionLegacy: TeamsUpdateDiscussionLegacyHandler;
  teamsDeleteDiscussionLegacy: TeamsDeleteDiscussionLegacyHandler;
  teamsListDiscussionCommentsLegacy: TeamsListDiscussionCommentsLegacyHandler;
  teamsCreateDiscussionCommentLegacy: TeamsCreateDiscussionCommentLegacyHandler;
  teamsGetDiscussionCommentLegacy: TeamsGetDiscussionCommentLegacyHandler;
  teamsUpdateDiscussionCommentLegacy: TeamsUpdateDiscussionCommentLegacyHandler;
  teamsDeleteDiscussionCommentLegacy: TeamsDeleteDiscussionCommentLegacyHandler;
  reactionsListForTeamDiscussionCommentLegacy: ReactionsListForTeamDiscussionCommentLegacyHandler;
  reactionsCreateForTeamDiscussionCommentLegacy: ReactionsCreateForTeamDiscussionCommentLegacyHandler;
  reactionsListForTeamDiscussionLegacy: ReactionsListForTeamDiscussionLegacyHandler;
  reactionsCreateForTeamDiscussionLegacy: ReactionsCreateForTeamDiscussionLegacyHandler;
  teamsListPendingInvitationsLegacy: TeamsListPendingInvitationsLegacyHandler;
  teamsListMembersLegacy: TeamsListMembersLegacyHandler;
  teamsGetMemberLegacy: TeamsGetMemberLegacyHandler;
  teamsAddMemberLegacy: TeamsAddMemberLegacyHandler;
  teamsRemoveMemberLegacy: TeamsRemoveMemberLegacyHandler;
  teamsGetMembershipForUserLegacy: TeamsGetMembershipForUserLegacyHandler;
  teamsAddOrUpdateMembershipForUserLegacy: TeamsAddOrUpdateMembershipForUserLegacyHandler;
  teamsRemoveMembershipForUserLegacy: TeamsRemoveMembershipForUserLegacyHandler;
  teamsListProjectsLegacy: TeamsListProjectsLegacyHandler;
  teamsCheckPermissionsForProjectLegacy: TeamsCheckPermissionsForProjectLegacyHandler;
  teamsAddOrUpdateProjectPermissionsLegacy: TeamsAddOrUpdateProjectPermissionsLegacyHandler;
  teamsRemoveProjectLegacy: TeamsRemoveProjectLegacyHandler;
  teamsListReposLegacy: TeamsListReposLegacyHandler;
  teamsCheckPermissionsForRepoLegacy: TeamsCheckPermissionsForRepoLegacyHandler;
  teamsAddOrUpdateRepoPermissionsLegacy: TeamsAddOrUpdateRepoPermissionsLegacyHandler;
  teamsRemoveRepoLegacy: TeamsRemoveRepoLegacyHandler;
  teamsListChildLegacy: TeamsListChildLegacyHandler;
  usersGetAuthenticated: UsersGetAuthenticatedHandler;
  usersUpdateAuthenticated: UsersUpdateAuthenticatedHandler;
  usersListBlockedByAuthenticatedUser: UsersListBlockedByAuthenticatedUserHandler;
  usersCheckBlocked: UsersCheckBlockedHandler;
  usersBlock: UsersBlockHandler;
  usersUnblock: UsersUnblockHandler;
  codespacesListForAuthenticatedUser: CodespacesListForAuthenticatedUserHandler;
  codespacesCreateForAuthenticatedUser: CodespacesCreateForAuthenticatedUserHandler;
  codespacesListSecretsForAuthenticatedUser: CodespacesListSecretsForAuthenticatedUserHandler;
  codespacesGetPublicKeyForAuthenticatedUser: CodespacesGetPublicKeyForAuthenticatedUserHandler;
  codespacesGetSecretForAuthenticatedUser: CodespacesGetSecretForAuthenticatedUserHandler;
  codespacesCreateOrUpdateSecretForAuthenticatedUser: CodespacesCreateOrUpdateSecretForAuthenticatedUserHandler;
  codespacesDeleteSecretForAuthenticatedUser: CodespacesDeleteSecretForAuthenticatedUserHandler;
  codespacesListRepositoriesForSecretForAuthenticatedUser: CodespacesListRepositoriesForSecretForAuthenticatedUserHandler;
  codespacesSetRepositoriesForSecretForAuthenticatedUser: CodespacesSetRepositoriesForSecretForAuthenticatedUserHandler;
  codespacesAddRepositoryForSecretForAuthenticatedUser: CodespacesAddRepositoryForSecretForAuthenticatedUserHandler;
  codespacesRemoveRepositoryForSecretForAuthenticatedUser: CodespacesRemoveRepositoryForSecretForAuthenticatedUserHandler;
  codespacesGetForAuthenticatedUser: CodespacesGetForAuthenticatedUserHandler;
  codespacesUpdateForAuthenticatedUser: CodespacesUpdateForAuthenticatedUserHandler;
  codespacesDeleteForAuthenticatedUser: CodespacesDeleteForAuthenticatedUserHandler;
  codespacesExportForAuthenticatedUser: CodespacesExportForAuthenticatedUserHandler;
  codespacesGetExportDetailsForAuthenticatedUser: CodespacesGetExportDetailsForAuthenticatedUserHandler;
  codespacesCodespaceMachinesForAuthenticatedUser: CodespacesCodespaceMachinesForAuthenticatedUserHandler;
  codespacesStartForAuthenticatedUser: CodespacesStartForAuthenticatedUserHandler;
  codespacesStopForAuthenticatedUser: CodespacesStopForAuthenticatedUserHandler;
  usersSetPrimaryEmailVisibilityForAuthenticatedUser: UsersSetPrimaryEmailVisibilityForAuthenticatedUserHandler;
  usersListEmailsForAuthenticatedUser: UsersListEmailsForAuthenticatedUserHandler;
  usersAddEmailForAuthenticatedUser: UsersAddEmailForAuthenticatedUserHandler;
  usersDeleteEmailForAuthenticatedUser: UsersDeleteEmailForAuthenticatedUserHandler;
  usersListFollowersForAuthenticatedUser: UsersListFollowersForAuthenticatedUserHandler;
  usersListFollowedByAuthenticatedUser: UsersListFollowedByAuthenticatedUserHandler;
  usersCheckPersonIsFollowedByAuthenticated: UsersCheckPersonIsFollowedByAuthenticatedHandler;
  usersFollow: UsersFollowHandler;
  usersUnfollow: UsersUnfollowHandler;
  usersListGpgKeysForAuthenticatedUser: UsersListGpgKeysForAuthenticatedUserHandler;
  usersCreateGpgKeyForAuthenticatedUser: UsersCreateGpgKeyForAuthenticatedUserHandler;
  usersGetGpgKeyForAuthenticatedUser: UsersGetGpgKeyForAuthenticatedUserHandler;
  usersDeleteGpgKeyForAuthenticatedUser: UsersDeleteGpgKeyForAuthenticatedUserHandler;
  appsListInstallationsForAuthenticatedUser: AppsListInstallationsForAuthenticatedUserHandler;
  appsListInstallationReposForAuthenticatedUser: AppsListInstallationReposForAuthenticatedUserHandler;
  appsAddRepoToInstallationForAuthenticatedUser: AppsAddRepoToInstallationForAuthenticatedUserHandler;
  appsRemoveRepoFromInstallationForAuthenticatedUser: AppsRemoveRepoFromInstallationForAuthenticatedUserHandler;
  interactionsGetRestrictionsForAuthenticatedUser: InteractionsGetRestrictionsForAuthenticatedUserHandler;
  interactionsSetRestrictionsForAuthenticatedUser: InteractionsSetRestrictionsForAuthenticatedUserHandler;
  interactionsRemoveRestrictionsForAuthenticatedUser: InteractionsRemoveRestrictionsForAuthenticatedUserHandler;
  issuesListForAuthenticatedUser: IssuesListForAuthenticatedUserHandler;
  usersListPublicSshKeysForAuthenticatedUser: UsersListPublicSshKeysForAuthenticatedUserHandler;
  usersCreatePublicSshKeyForAuthenticatedUser: UsersCreatePublicSshKeyForAuthenticatedUserHandler;
  usersGetPublicSshKeyForAuthenticatedUser: UsersGetPublicSshKeyForAuthenticatedUserHandler;
  usersDeletePublicSshKeyForAuthenticatedUser: UsersDeletePublicSshKeyForAuthenticatedUserHandler;
  appsListSubscriptionsForAuthenticatedUser: AppsListSubscriptionsForAuthenticatedUserHandler;
  appsListSubscriptionsForAuthenticatedUserStubbed: AppsListSubscriptionsForAuthenticatedUserStubbedHandler;
  orgsListMembershipsForAuthenticatedUser: OrgsListMembershipsForAuthenticatedUserHandler;
  orgsGetMembershipForAuthenticatedUser: OrgsGetMembershipForAuthenticatedUserHandler;
  orgsUpdateMembershipForAuthenticatedUser: OrgsUpdateMembershipForAuthenticatedUserHandler;
  migrationsListForAuthenticatedUser: MigrationsListForAuthenticatedUserHandler;
  migrationsStartForAuthenticatedUser: MigrationsStartForAuthenticatedUserHandler;
  migrationsGetStatusForAuthenticatedUser: MigrationsGetStatusForAuthenticatedUserHandler;
  migrationsGetArchiveForAuthenticatedUser: MigrationsGetArchiveForAuthenticatedUserHandler;
  migrationsDeleteArchiveForAuthenticatedUser: MigrationsDeleteArchiveForAuthenticatedUserHandler;
  migrationsUnlockRepoForAuthenticatedUser: MigrationsUnlockRepoForAuthenticatedUserHandler;
  migrationsListReposForAuthenticatedUser: MigrationsListReposForAuthenticatedUserHandler;
  orgsListForAuthenticatedUser: OrgsListForAuthenticatedUserHandler;
  packagesListPackagesForAuthenticatedUser: PackagesListPackagesForAuthenticatedUserHandler;
  packagesGetPackageForAuthenticatedUser: PackagesGetPackageForAuthenticatedUserHandler;
  packagesDeletePackageForAuthenticatedUser: PackagesDeletePackageForAuthenticatedUserHandler;
  packagesRestorePackageForAuthenticatedUser: PackagesRestorePackageForAuthenticatedUserHandler;
  packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserHandler;
  packagesGetPackageVersionForAuthenticatedUser: PackagesGetPackageVersionForAuthenticatedUserHandler;
  packagesDeletePackageVersionForAuthenticatedUser: PackagesDeletePackageVersionForAuthenticatedUserHandler;
  packagesRestorePackageVersionForAuthenticatedUser: PackagesRestorePackageVersionForAuthenticatedUserHandler;
  projectsCreateForAuthenticatedUser: ProjectsCreateForAuthenticatedUserHandler;
  usersListPublicEmailsForAuthenticatedUser: UsersListPublicEmailsForAuthenticatedUserHandler;
  reposListForAuthenticatedUser: ReposListForAuthenticatedUserHandler;
  reposCreateForAuthenticatedUser: ReposCreateForAuthenticatedUserHandler;
  reposListInvitationsForAuthenticatedUser: ReposListInvitationsForAuthenticatedUserHandler;
  reposAcceptInvitationForAuthenticatedUser: ReposAcceptInvitationForAuthenticatedUserHandler;
  reposDeclineInvitationForAuthenticatedUser: ReposDeclineInvitationForAuthenticatedUserHandler;
  usersListSshSigningKeysForAuthenticatedUser: UsersListSshSigningKeysForAuthenticatedUserHandler;
  usersCreateSshSigningKeyForAuthenticatedUser: UsersCreateSshSigningKeyForAuthenticatedUserHandler;
  usersGetSshSigningKeyForAuthenticatedUser: UsersGetSshSigningKeyForAuthenticatedUserHandler;
  usersDeleteSshSigningKeyForAuthenticatedUser: UsersDeleteSshSigningKeyForAuthenticatedUserHandler;
  activityListReposStarredByAuthenticatedUser: ActivityListReposStarredByAuthenticatedUserHandler;
  activityCheckRepoIsStarredByAuthenticatedUser: ActivityCheckRepoIsStarredByAuthenticatedUserHandler;
  activityStarRepoForAuthenticatedUser: ActivityStarRepoForAuthenticatedUserHandler;
  activityUnstarRepoForAuthenticatedUser: ActivityUnstarRepoForAuthenticatedUserHandler;
  activityListWatchedReposForAuthenticatedUser: ActivityListWatchedReposForAuthenticatedUserHandler;
  teamsListForAuthenticatedUser: TeamsListForAuthenticatedUserHandler;
  usersList: UsersListHandler;
  usersGetByUsername: UsersGetByUsernameHandler;
  activityListEventsForAuthenticatedUser: ActivityListEventsForAuthenticatedUserHandler;
  activityListOrgEventsForAuthenticatedUser: ActivityListOrgEventsForAuthenticatedUserHandler;
  activityListPublicEventsForUser: ActivityListPublicEventsForUserHandler;
  usersListFollowersForUser: UsersListFollowersForUserHandler;
  usersListFollowingForUser: UsersListFollowingForUserHandler;
  usersCheckFollowingForUser: UsersCheckFollowingForUserHandler;
  gistsListForUser: GistsListForUserHandler;
  usersListGpgKeysForUser: UsersListGpgKeysForUserHandler;
  usersGetContextForUser: UsersGetContextForUserHandler;
  appsGetUserInstallation: AppsGetUserInstallationHandler;
  usersListPublicKeysForUser: UsersListPublicKeysForUserHandler;
  orgsListForUser: OrgsListForUserHandler;
  packagesListPackagesForUser: PackagesListPackagesForUserHandler;
  packagesGetPackageForUser: PackagesGetPackageForUserHandler;
  packagesDeletePackageForUser: PackagesDeletePackageForUserHandler;
  packagesRestorePackageForUser: PackagesRestorePackageForUserHandler;
  packagesGetAllPackageVersionsForPackageOwnedByUser: PackagesGetAllPackageVersionsForPackageOwnedByUserHandler;
  packagesGetPackageVersionForUser: PackagesGetPackageVersionForUserHandler;
  packagesDeletePackageVersionForUser: PackagesDeletePackageVersionForUserHandler;
  packagesRestorePackageVersionForUser: PackagesRestorePackageVersionForUserHandler;
  projectsListForUser: ProjectsListForUserHandler;
  activityListReceivedEventsForUser: ActivityListReceivedEventsForUserHandler;
  activityListReceivedPublicEventsForUser: ActivityListReceivedPublicEventsForUserHandler;
  reposListForUser: ReposListForUserHandler;
  billingGetGithubActionsBillingUser: BillingGetGithubActionsBillingUserHandler;
  billingGetGithubPackagesBillingUser: BillingGetGithubPackagesBillingUserHandler;
  billingGetSharedStorageBillingUser: BillingGetSharedStorageBillingUserHandler;
  usersListSshSigningKeysForUser: UsersListSshSigningKeysForUserHandler;
  activityListReposStarredByUser: ActivityListReposStarredByUserHandler;
  activityListReposWatchedByUser: ActivityListReposWatchedByUserHandler;
  metaGetZen: MetaGetZenHandler;
};

const { validate } = new ExpressJonValidator.Validator({
  strict: false,
  coerceTypes: true
});

export const addHandlers = (app: Express, handlers: Partial<Handlers>) => {
  const router = Router();

  router.get(
    '/',

    async (req, res, next) => {
      const handler = handlers['metaRoot'];

      if (!handler) {
        return next(new Error('/ not handled'));
      }

      try {
        await handler(
          (req as unknown) as MetaRootRequest,
          res as MetaRootResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/app',

    async (req, res, next) => {
      const handler = handlers['appsGetAuthenticated'];

      if (!handler) {
        return next(new Error('/app not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsGetAuthenticatedRequest,
          res as AppsGetAuthenticatedResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/app-manifests/:code/conversions',

    validate({
      params: {
        type: 'object',
        properties: { code: { type: 'string' } },
        required: ['code']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsCreateFromManifest'];

      if (!handler) {
        return next(new Error('/app-manifests/:code/conversions not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsCreateFromManifestRequest,
          res as AppsCreateFromManifestResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/app/hook/config',

    async (req, res, next) => {
      const handler = handlers['appsGetWebhookConfigForApp'];

      if (!handler) {
        return next(new Error('/app/hook/config not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsGetWebhookConfigForAppRequest,
          res as AppsGetWebhookConfigForAppResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/app/hook/config',

    validate({
      body: {
        type: 'object',
        properties: {
          url: { $ref: '#/definitions/webhook-config-url' },
          content_type: { $ref: '#/definitions/webhook-config-content-type' },
          secret: { $ref: '#/definitions/webhook-config-secret' },
          insecure_ssl: { $ref: '#/definitions/webhook-config-insecure-ssl' }
        },
        definitions: {
          'webhook-config-url': {
            type: 'string',
            description: 'The URL to which the payloads will be delivered.',
            example: 'https://example.com/webhook',
            format: 'uri',
            title: 'webhook-config-url'
          },
          'webhook-config-content-type': {
            type: 'string',
            description:
              'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
            example: '"json"',
            title: 'webhook-config-content-type'
          },
          'webhook-config-secret': {
            type: 'string',
            description:
              'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
            example: '"********"',
            title: 'webhook-config-secret'
          },
          'webhook-config-insecure-ssl': {
            oneOf: [
              {
                type: 'string',
                description:
                  'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                example: '"0"'
              },
              { type: 'number' }
            ],
            title: 'webhook-config-insecure-ssl'
          }
        }
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsUpdateWebhookConfigForApp'];

      if (!handler) {
        return next(new Error('/app/hook/config not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsUpdateWebhookConfigForAppRequest,
          res as AppsUpdateWebhookConfigForAppResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/app/hook/deliveries',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          cursor: { type: 'string' }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsListWebhookDeliveries'];

      if (!handler) {
        return next(new Error('/app/hook/deliveries not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsListWebhookDeliveriesRequest,
          res as AppsListWebhookDeliveriesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/app/hook/deliveries/:delivery_id',

    validate({
      params: {
        type: 'object',
        properties: { delivery_id: { type: 'integer' } },
        required: ['delivery_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsGetWebhookDelivery'];

      if (!handler) {
        return next(new Error('/app/hook/deliveries/:delivery_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsGetWebhookDeliveryRequest,
          res as AppsGetWebhookDeliveryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/app/hook/deliveries/:delivery_id/attempts',

    validate({
      params: {
        type: 'object',
        properties: { delivery_id: { type: 'integer' } },
        required: ['delivery_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsRedeliverWebhookDelivery'];

      if (!handler) {
        return next(
          new Error('/app/hook/deliveries/:delivery_id/attempts not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as AppsRedeliverWebhookDeliveryRequest,
          res as AppsRedeliverWebhookDeliveryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/app/installations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 },
          since: { type: 'string', format: 'date-time' },
          outdated: { type: 'string' }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsListInstallations'];

      if (!handler) {
        return next(new Error('/app/installations not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsListInstallationsRequest,
          res as AppsListInstallationsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/app/installations/:installation_id',

    validate({
      params: {
        type: 'object',
        properties: { installation_id: { type: 'integer' } },
        required: ['installation_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsGetInstallation'];

      if (!handler) {
        return next(
          new Error('/app/installations/:installation_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as AppsGetInstallationRequest,
          res as AppsGetInstallationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/app/installations/:installation_id',

    validate({
      params: {
        type: 'object',
        properties: { installation_id: { type: 'integer' } },
        required: ['installation_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsDeleteInstallation'];

      if (!handler) {
        return next(
          new Error('/app/installations/:installation_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as AppsDeleteInstallationRequest,
          res as AppsDeleteInstallationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/app/installations/:installation_id/access_tokens',

    validate({
      body: {
        type: 'object',
        properties: {
          repositories: {
            description:
              'List of repository names that the token should have access to',
            type: 'array',
            items: { type: 'string', example: 'rails' }
          },
          repository_ids: {
            description:
              'List of repository IDs that the token should have access to',
            example: [1],
            type: 'array',
            items: { type: 'integer' }
          },
          permissions: { $ref: '#/definitions/app-permissions' }
        },
        definitions: {
          'app-permissions': {
            title: 'App Permissions',
            type: 'object',
            description:
              'The permissions granted to the user-to-server access token.',
            properties: {
              actions: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts.',
                enum: ['read', 'write']
              },
              administration: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation.',
                enum: ['read', 'write']
              },
              checks: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for checks on code.',
                enum: ['read', 'write']
              },
              contents: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges.',
                enum: ['read', 'write']
              },
              deployments: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for deployments and deployment statuses.',
                enum: ['read', 'write']
              },
              environments: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for managing repository environments.',
                enum: ['read', 'write']
              },
              issues: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones.',
                enum: ['read', 'write']
              },
              metadata: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata.',
                enum: ['read', 'write']
              },
              packages: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for packages published to GitHub Packages.',
                enum: ['read', 'write']
              },
              pages: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds.',
                enum: ['read', 'write']
              },
              pull_requests: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges.',
                enum: ['read', 'write']
              },
              repository_announcement_banners: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to view and manage announcement banners for a repository.',
                enum: ['read', 'write']
              },
              repository_hooks: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage the post-receive hooks for a repository.',
                enum: ['read', 'write']
              },
              repository_projects: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage repository projects, columns, and cards.',
                enum: ['read', 'write', 'admin']
              },
              secret_scanning_alerts: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to view and manage secret scanning alerts.',
                enum: ['read', 'write']
              },
              secrets: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage repository secrets.',
                enum: ['read', 'write']
              },
              security_events: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to view and manage security events like code scanning alerts.',
                enum: ['read', 'write']
              },
              single_file: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage just a single file.',
                enum: ['read', 'write']
              },
              statuses: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for commit statuses.',
                enum: ['read', 'write']
              },
              vulnerability_alerts: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage Dependabot alerts.',
                enum: ['read', 'write']
              },
              workflows: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to update GitHub Actions workflow files.',
                enum: ['write']
              },
              members: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for organization teams and members.',
                enum: ['read', 'write']
              },
              organization_administration: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage access to an organization.',
                enum: ['read', 'write']
              },
              organization_custom_roles: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for custom roles management. This property is in beta and is subject to change.',
                enum: ['read', 'write']
              },
              organization_announcement_banners: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to view and manage announcement banners for an organization.',
                enum: ['read', 'write']
              },
              organization_hooks: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage the post-receive hooks for an organization.',
                enum: ['read', 'write']
              },
              organization_plan: {
                type: 'string',
                description:
                  "The level of permission to grant the access token for viewing an organization's plan.",
                enum: ['read']
              },
              organization_projects: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage organization projects and projects beta (where available).',
                enum: ['read', 'write', 'admin']
              },
              organization_packages: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for organization packages published to GitHub Packages.',
                enum: ['read', 'write']
              },
              organization_secrets: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage organization secrets.',
                enum: ['read', 'write']
              },
              organization_self_hosted_runners: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization.',
                enum: ['read', 'write']
              },
              organization_user_blocking: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to view and manage users blocked by the organization.',
                enum: ['read', 'write']
              },
              team_discussions: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage team discussions and related comments.',
                enum: ['read', 'write']
              }
            },
            example: {
              contents: 'read',
              issues: 'read',
              deployments: 'write',
              single_file: 'read'
            }
          }
        }
      },

      params: {
        type: 'object',
        properties: { installation_id: { type: 'integer' } },
        required: ['installation_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsCreateInstallationAccessToken'];

      if (!handler) {
        return next(
          new Error(
            '/app/installations/:installation_id/access_tokens not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as AppsCreateInstallationAccessTokenRequest,
          res as AppsCreateInstallationAccessTokenResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/app/installations/:installation_id/suspended',

    validate({
      params: {
        type: 'object',
        properties: { installation_id: { type: 'integer' } },
        required: ['installation_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsSuspendInstallation'];

      if (!handler) {
        return next(
          new Error('/app/installations/:installation_id/suspended not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as AppsSuspendInstallationRequest,
          res as AppsSuspendInstallationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/app/installations/:installation_id/suspended',

    validate({
      params: {
        type: 'object',
        properties: { installation_id: { type: 'integer' } },
        required: ['installation_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsUnsuspendInstallation'];

      if (!handler) {
        return next(
          new Error('/app/installations/:installation_id/suspended not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as AppsUnsuspendInstallationRequest,
          res as AppsUnsuspendInstallationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/applications/:client_id/grant',

    validate({
      body: {
        type: 'object',
        properties: {
          access_token: {
            type: 'string',
            description:
              'The OAuth access token used to authenticate to the GitHub API.'
          }
        },
        required: ['access_token']
      },

      params: {
        type: 'object',
        properties: { client_id: { type: 'string' } },
        required: ['client_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsDeleteAuthorization'];

      if (!handler) {
        return next(new Error('/applications/:client_id/grant not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsDeleteAuthorizationRequest,
          res as AppsDeleteAuthorizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/applications/:client_id/token',

    validate({
      body: {
        properties: {
          access_token: {
            description: 'The access_token of the OAuth application.',
            type: 'string'
          }
        },
        required: ['access_token'],
        type: 'object'
      },

      params: {
        type: 'object',
        properties: { client_id: { type: 'string' } },
        required: ['client_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsCheckToken'];

      if (!handler) {
        return next(new Error('/applications/:client_id/token not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsCheckTokenRequest,
          res as AppsCheckTokenResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/applications/:client_id/token',

    validate({
      body: {
        properties: {
          access_token: {
            description: 'The access_token of the OAuth application.',
            type: 'string'
          }
        },
        required: ['access_token'],
        type: 'object'
      },

      params: {
        type: 'object',
        properties: { client_id: { type: 'string' } },
        required: ['client_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsResetToken'];

      if (!handler) {
        return next(new Error('/applications/:client_id/token not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsResetTokenRequest,
          res as AppsResetTokenResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/applications/:client_id/token',

    validate({
      body: {
        type: 'object',
        properties: {
          access_token: {
            type: 'string',
            description:
              'The OAuth access token used to authenticate to the GitHub API.'
          }
        },
        required: ['access_token']
      },

      params: {
        type: 'object',
        properties: { client_id: { type: 'string' } },
        required: ['client_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsDeleteToken'];

      if (!handler) {
        return next(new Error('/applications/:client_id/token not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsDeleteTokenRequest,
          res as AppsDeleteTokenResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/applications/:client_id/token/scoped',

    validate({
      body: {
        type: 'object',
        properties: {
          access_token: {
            type: 'string',
            description:
              'The OAuth access token used to authenticate to the GitHub API.',
            example: 'e72e16c7e42f292c6912e7710c838347ae178b4a'
          },
          target: {
            description:
              'The name of the user or organization to scope the user-to-server access token to. **Required** unless `target_id` is specified.',
            type: 'string',
            example: 'octocat'
          },
          target_id: {
            description:
              'The ID of the user or organization to scope the user-to-server access token to. **Required** unless `target` is specified.',
            example: 1,
            type: 'integer'
          },
          repositories: {
            description:
              'The list of repository names to scope the user-to-server access token to. `repositories` may not be specified if `repository_ids` is specified.',
            type: 'array',
            items: { type: 'string', example: 'rails' }
          },
          repository_ids: {
            description:
              'The list of repository IDs to scope the user-to-server access token to. `repository_ids` may not be specified if `repositories` is specified.',
            example: [1],
            type: 'array',
            items: { type: 'integer' }
          },
          permissions: { $ref: '#/definitions/app-permissions' }
        },
        required: ['access_token'],
        definitions: {
          'app-permissions': {
            title: 'App Permissions',
            type: 'object',
            description:
              'The permissions granted to the user-to-server access token.',
            properties: {
              actions: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts.',
                enum: ['read', 'write']
              },
              administration: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation.',
                enum: ['read', 'write']
              },
              checks: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for checks on code.',
                enum: ['read', 'write']
              },
              contents: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges.',
                enum: ['read', 'write']
              },
              deployments: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for deployments and deployment statuses.',
                enum: ['read', 'write']
              },
              environments: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for managing repository environments.',
                enum: ['read', 'write']
              },
              issues: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones.',
                enum: ['read', 'write']
              },
              metadata: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata.',
                enum: ['read', 'write']
              },
              packages: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for packages published to GitHub Packages.',
                enum: ['read', 'write']
              },
              pages: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds.',
                enum: ['read', 'write']
              },
              pull_requests: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges.',
                enum: ['read', 'write']
              },
              repository_announcement_banners: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to view and manage announcement banners for a repository.',
                enum: ['read', 'write']
              },
              repository_hooks: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage the post-receive hooks for a repository.',
                enum: ['read', 'write']
              },
              repository_projects: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage repository projects, columns, and cards.',
                enum: ['read', 'write', 'admin']
              },
              secret_scanning_alerts: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to view and manage secret scanning alerts.',
                enum: ['read', 'write']
              },
              secrets: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage repository secrets.',
                enum: ['read', 'write']
              },
              security_events: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to view and manage security events like code scanning alerts.',
                enum: ['read', 'write']
              },
              single_file: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage just a single file.',
                enum: ['read', 'write']
              },
              statuses: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for commit statuses.',
                enum: ['read', 'write']
              },
              vulnerability_alerts: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage Dependabot alerts.',
                enum: ['read', 'write']
              },
              workflows: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to update GitHub Actions workflow files.',
                enum: ['write']
              },
              members: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for organization teams and members.',
                enum: ['read', 'write']
              },
              organization_administration: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage access to an organization.',
                enum: ['read', 'write']
              },
              organization_custom_roles: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for custom roles management. This property is in beta and is subject to change.',
                enum: ['read', 'write']
              },
              organization_announcement_banners: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to view and manage announcement banners for an organization.',
                enum: ['read', 'write']
              },
              organization_hooks: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage the post-receive hooks for an organization.',
                enum: ['read', 'write']
              },
              organization_plan: {
                type: 'string',
                description:
                  "The level of permission to grant the access token for viewing an organization's plan.",
                enum: ['read']
              },
              organization_projects: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage organization projects and projects beta (where available).',
                enum: ['read', 'write', 'admin']
              },
              organization_packages: {
                type: 'string',
                description:
                  'The level of permission to grant the access token for organization packages published to GitHub Packages.',
                enum: ['read', 'write']
              },
              organization_secrets: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage organization secrets.',
                enum: ['read', 'write']
              },
              organization_self_hosted_runners: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization.',
                enum: ['read', 'write']
              },
              organization_user_blocking: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to view and manage users blocked by the organization.',
                enum: ['read', 'write']
              },
              team_discussions: {
                type: 'string',
                description:
                  'The level of permission to grant the access token to manage team discussions and related comments.',
                enum: ['read', 'write']
              }
            },
            example: {
              contents: 'read',
              issues: 'read',
              deployments: 'write',
              single_file: 'read'
            }
          }
        }
      },

      params: {
        type: 'object',
        properties: { client_id: { type: 'string' } },
        required: ['client_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsScopeToken'];

      if (!handler) {
        return next(
          new Error('/applications/:client_id/token/scoped not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as AppsScopeTokenRequest,
          res as AppsScopeTokenResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/apps/:app_slug',

    validate({
      params: {
        type: 'object',
        properties: { app_slug: { type: 'string' } },
        required: ['app_slug']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsGetBySlug'];

      if (!handler) {
        return next(new Error('/apps/:app_slug not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsGetBySlugRequest,
          res as AppsGetBySlugResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/codes_of_conduct',

    async (req, res, next) => {
      const handler = handlers['codesOfConductGetAllCodesOfConduct'];

      if (!handler) {
        return next(new Error('/codes_of_conduct not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodesOfConductGetAllCodesOfConductRequest,
          res as CodesOfConductGetAllCodesOfConductResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/codes_of_conduct/:key',

    validate({
      params: {
        type: 'object',
        properties: { key: { type: 'string' } },
        required: ['key']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codesOfConductGetConductCode'];

      if (!handler) {
        return next(new Error('/codes_of_conduct/:key not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodesOfConductGetConductCodeRequest,
          res as CodesOfConductGetConductCodeResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/emojis',

    async (req, res, next) => {
      const handler = handlers['emojisGet'];

      if (!handler) {
        return next(new Error('/emojis not handled'));
      }

      try {
        await handler(
          (req as unknown) as EmojisGetRequest,
          res as EmojisGetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprise-installation/:enterprise_or_org/server-statistics',

    validate({
      query: {
        type: 'object',
        properties: {
          date_start: { type: 'string' },
          date_end: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { enterprise_or_org: { type: 'string' } },
        required: ['enterprise_or_org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['enterpriseAdminGetServerStatistics'];

      if (!handler) {
        return next(
          new Error(
            '/enterprise-installation/:enterprise_or_org/server-statistics not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminGetServerStatisticsRequest,
          res as EnterpriseAdminGetServerStatisticsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/actions/cache/usage',

    validate({
      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetActionsCacheUsageForEnterprise'];

      if (!handler) {
        return next(
          new Error('/enterprises/:enterprise/actions/cache/usage not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetActionsCacheUsageForEnterpriseRequest,
          res as ActionsGetActionsCacheUsageForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/actions/permissions',

    validate({
      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminGetGithubActionsPermissionsEnterprise'];

      if (!handler) {
        return next(
          new Error('/enterprises/:enterprise/actions/permissions not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest,
          res as EnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/enterprises/:enterprise/actions/permissions',

    validate({
      body: {
        type: 'object',
        properties: {
          enabled_organizations: {
            $ref: '#/definitions/enabled-organizations'
          },
          allowed_actions: { $ref: '#/definitions/allowed-actions' }
        },
        required: ['enabled_organizations'],
        definitions: {
          'enabled-organizations': {
            type: 'string',
            description:
              'The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions.',
            enum: ['all', 'none', 'selected'],
            title: 'enabled-organizations'
          },
          'allowed-actions': {
            type: 'string',
            description:
              'The permissions policy that controls the actions and reusable workflows that are allowed to run.',
            enum: ['all', 'local_only', 'selected'],
            title: 'allowed-actions'
          }
        }
      },

      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminSetGithubActionsPermissionsEnterprise'];

      if (!handler) {
        return next(
          new Error('/enterprises/:enterprise/actions/permissions not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest,
          res as EnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/actions/permissions/organizations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise'
        ];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/permissions/organizations not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest,
          res as EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/enterprises/:enterprise/actions/permissions/organizations',

    validate({
      body: {
        type: 'object',
        properties: {
          selected_organization_ids: {
            description:
              'List of organization IDs to enable for GitHub Actions.',
            type: 'array',
            items: {
              type: 'integer',
              description: 'Unique identifier of the organization.'
            }
          }
        },
        required: ['selected_organization_ids']
      },

      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise'
        ];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/permissions/organizations not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest,
          res as EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/enterprises/:enterprise/actions/permissions/organizations/:org_id',

    validate({
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          org_id: { type: 'integer' }
        },
        required: ['enterprise', 'org_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise'
        ];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/permissions/organizations/:org_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest,
          res as EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/enterprises/:enterprise/actions/permissions/organizations/:org_id',

    validate({
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          org_id: { type: 'integer' }
        },
        required: ['enterprise', 'org_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise'
        ];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/permissions/organizations/:org_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest,
          res as EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/actions/permissions/selected-actions',

    validate({
      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['enterpriseAdminGetAllowedActionsEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/permissions/selected-actions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminGetAllowedActionsEnterpriseRequest,
          res as EnterpriseAdminGetAllowedActionsEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/enterprises/:enterprise/actions/permissions/selected-actions',

    validate({
      body: {
        $ref: '#/definitions/selected-actions',
        definitions: {
          'selected-actions': {
            type: 'object',
            properties: {
              github_owned_allowed: {
                type: 'boolean',
                description:
                  'Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.'
              },
              verified_allowed: {
                type: 'boolean',
                description:
                  'Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators.'
              },
              patterns_allowed: {
                type: 'array',
                description:
                  'Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`."',
                items: { type: 'string' }
              }
            },
            title: 'selected-actions'
          }
        }
      },

      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['enterpriseAdminSetAllowedActionsEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/permissions/selected-actions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminSetAllowedActionsEnterpriseRequest,
          res as EnterpriseAdminSetAllowedActionsEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/actions/permissions/workflow',

    validate({
      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/permissions/workflow not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest,
          res as ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/enterprises/:enterprise/actions/permissions/workflow',

    validate({
      body: {
        $ref: '#/definitions/actions-set-default-workflow-permissions',
        definitions: {
          'actions-set-default-workflow-permissions': {
            type: 'object',
            properties: {
              default_workflow_permissions: {
                $ref: '#/definitions/actions-default-workflow-permissions'
              },
              can_approve_pull_request_reviews: {
                $ref: '#/definitions/actions-can-approve-pull-request-reviews'
              }
            },
            title: 'actions-set-default-workflow-permissions'
          },
          'actions-default-workflow-permissions': {
            type: 'string',
            description:
              'The default workflow permissions granted to the GITHUB_TOKEN when running workflows.',
            enum: ['read', 'write'],
            title: 'actions-default-workflow-permissions'
          },
          'actions-can-approve-pull-request-reviews': {
            type: 'boolean',
            description:
              'Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.',
            title: 'actions-can-approve-pull-request-reviews'
          }
        }
      },

      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/permissions/workflow not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest,
          res as ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/actions/runner-groups',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 },
          visible_to_organization: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminListSelfHostedRunnerGroupsForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runner-groups not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest,
          res as EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/enterprises/:enterprise/actions/runner-groups',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { description: 'Name of the runner group.', type: 'string' },
          visibility: {
            description:
              'Visibility of a runner group. You can select all organizations or select individual organization.',
            type: 'string',
            enum: ['selected', 'all']
          },
          selected_organization_ids: {
            description:
              'List of organization IDs that can access the runner group.',
            type: 'array',
            items: {
              type: 'integer',
              description: 'Unique identifier of the organization.'
            }
          },
          runners: {
            description: 'List of runner IDs to add to the runner group.',
            type: 'array',
            items: {
              type: 'integer',
              description: 'Unique identifier of the runner.'
            }
          },
          allows_public_repositories: {
            description:
              'Whether the runner group can be used by `public` repositories.',
            type: 'boolean',
            default: false
          },
          restricted_to_workflows: {
            description:
              'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.',
            type: 'boolean',
            default: false
          },
          selected_workflows: {
            description:
              'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.',
            type: 'array',
            items: {
              type: 'string',
              description:
                'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.',
              example: 'octo-org/octo-repo/.github/workflows/deploy.yaml@main'
            }
          }
        },
        required: ['name']
      },

      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runner-groups not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest,
          res as EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/actions/runner-groups/:runner_group_id',

    validate({
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminGetSelfHostedRunnerGroupForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runner-groups/:runner_group_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest,
          res as EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/enterprises/:enterprise/actions/runner-groups/:runner_group_id',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { description: 'Name of the runner group.', type: 'string' },
          visibility: {
            description:
              'Visibility of a runner group. You can select all organizations or select individual organizations.',
            type: 'string',
            enum: ['selected', 'all'],
            default: 'all'
          },
          allows_public_repositories: {
            description:
              'Whether the runner group can be used by `public` repositories.',
            type: 'boolean',
            default: false
          },
          restricted_to_workflows: {
            description:
              'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.',
            type: 'boolean',
            default: false
          },
          selected_workflows: {
            description:
              'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.',
            type: 'array',
            items: {
              type: 'string',
              description:
                'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.',
              example: 'octo-org/octo-repo/.github/workflows/deploy.yaml@main'
            }
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runner-groups/:runner_group_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest,
          res as EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/enterprises/:enterprise/actions/runner-groups/:runner_group_id',

    validate({
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runner-groups/:runner_group_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest,
          res as EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/organizations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise'
        ];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/organizations not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
          res as EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/organizations',

    validate({
      body: {
        type: 'object',
        properties: {
          selected_organization_ids: {
            description:
              'List of organization IDs that can access the runner group.',
            type: 'array',
            items: {
              type: 'integer',
              description: 'Unique identifier of the organization.'
            }
          }
        },
        required: ['selected_organization_ids']
      },

      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise'
        ];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/organizations not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
          res as EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/organizations/:org_id',

    validate({
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_group_id: { type: 'integer' },
          org_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_group_id', 'org_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise'
        ];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/organizations/:org_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
          res as EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/organizations/:org_id',

    validate({
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_group_id: { type: 'integer' },
          org_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_group_id', 'org_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise'
        ];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/organizations/:org_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
          res as EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/runners',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminListSelfHostedRunnersInGroupForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/runners not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest,
          res as EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/runners',

    validate({
      body: {
        type: 'object',
        properties: {
          runners: {
            description: 'List of runner IDs to add to the runner group.',
            type: 'array',
            items: {
              type: 'integer',
              description: 'Unique identifier of the runner.'
            }
          }
        },
        required: ['runners']
      },

      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/runners not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest,
          res as EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/runners/:runner_id',

    validate({
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_group_id: { type: 'integer' },
          runner_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_group_id', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/runners/:runner_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest,
          res as EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/runners/:runner_id',

    validate({
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_group_id: { type: 'integer' },
          runner_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_group_id', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/runners/:runner_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest,
          res as EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/actions/runners',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminListSelfHostedRunnersForEnterprise'];

      if (!handler) {
        return next(
          new Error('/enterprises/:enterprise/actions/runners not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminListSelfHostedRunnersForEnterpriseRequest,
          res as EnterpriseAdminListSelfHostedRunnersForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/actions/runners/downloads',

    validate({
      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminListRunnerApplicationsForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runners/downloads not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminListRunnerApplicationsForEnterpriseRequest,
          res as EnterpriseAdminListRunnerApplicationsForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/enterprises/:enterprise/actions/runners/registration-token',

    validate({
      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminCreateRegistrationTokenForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runners/registration-token not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminCreateRegistrationTokenForEnterpriseRequest,
          res as EnterpriseAdminCreateRegistrationTokenForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/enterprises/:enterprise/actions/runners/remove-token',

    validate({
      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['enterpriseAdminCreateRemoveTokenForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runners/remove-token not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminCreateRemoveTokenForEnterpriseRequest,
          res as EnterpriseAdminCreateRemoveTokenForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/actions/runners/:runner_id',

    validate({
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminGetSelfHostedRunnerForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runners/:runner_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest,
          res as EnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/enterprises/:enterprise/actions/runners/:runner_id',

    validate({
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminDeleteSelfHostedRunnerFromEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runners/:runner_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest,
          res as EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/actions/runners/:runner_id/labels',

    validate({
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runners/:runner_id/labels not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseRequest,
          res as EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/enterprises/:enterprise/actions/runners/:runner_id/labels',

    validate({
      body: {
        type: 'object',
        required: ['labels'],
        properties: {
          labels: {
            type: 'array',
            minItems: 1,
            maxItems: 100,
            description: 'The names of the custom labels to add to the runner.',
            items: { type: 'string' }
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise'
        ];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runners/:runner_id/labels not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest,
          res as EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/enterprises/:enterprise/actions/runners/:runner_id/labels',

    validate({
      body: {
        type: 'object',
        required: ['labels'],
        properties: {
          labels: {
            type: 'array',
            minItems: 0,
            maxItems: 100,
            description:
              'The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.',
            items: { type: 'string' }
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise'
        ];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runners/:runner_id/labels not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest,
          res as EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/enterprises/:enterprise/actions/runners/:runner_id/labels',

    validate({
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_id: { type: 'integer' }
        },
        required: ['enterprise', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise'
        ];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runners/:runner_id/labels not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequest,
          res as EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/enterprises/:enterprise/actions/runners/:runner_id/labels/:name',

    validate({
      params: {
        type: 'object',
        properties: {
          enterprise: { type: 'string' },
          runner_id: { type: 'integer' },
          name: { type: 'string' }
        },
        required: ['enterprise', 'runner_id', 'name']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise'
        ];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/actions/runners/:runner_id/labels/:name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseRequest,
          res as EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/code-scanning/alerts',

    validate({
      query: {
        type: 'object',
        properties: {
          tool_name: { $ref: '#/definitions/code-scanning-analysis-tool-name' },
          tool_guid: { $ref: '#/definitions/code-scanning-analysis-tool-guid' },
          before: { type: 'string' },
          after: { type: 'string' },
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          state: { $ref: '#/definitions/code-scanning-alert-state' },
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          }
        },
        required: [],
        definitions: {
          'code-scanning-analysis-tool-name': {
            type: 'string',
            description:
              'The name of the tool used to generate the code scanning analysis.',
            title: 'code-scanning-analysis-tool-name'
          },
          'code-scanning-analysis-tool-guid': {
            nullable: true,
            type: 'string',
            description:
              'The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.',
            title: 'code-scanning-analysis-tool-guid'
          },
          'code-scanning-alert-state': {
            type: 'string',
            description: 'State of a code scanning alert.',
            enum: ['open', 'closed', 'dismissed', 'fixed'],
            title: 'code-scanning-alert-state'
          }
        }
      },
      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codeScanningListAlertsForEnterprise'];

      if (!handler) {
        return next(
          new Error('/enterprises/:enterprise/code-scanning/alerts not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodeScanningListAlertsForEnterpriseRequest,
          res as CodeScanningListAlertsForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/secret-scanning/alerts',

    validate({
      query: {
        type: 'object',
        properties: {
          state: { type: 'string', enum: ['open', 'resolved'] },
          secret_type: { type: 'string' },
          resolution: { type: 'string' },
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          per_page: { type: 'integer', default: 30 },
          before: { type: 'string' },
          after: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['secretScanningListAlertsForEnterprise'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/secret-scanning/alerts not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as SecretScanningListAlertsForEnterpriseRequest,
          res as SecretScanningListAlertsForEnterpriseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/enterprises/:enterprise/settings/billing/advanced-security',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { enterprise: { type: 'string' } },
        required: ['enterprise']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['billingGetGithubAdvancedSecurityBillingGhe'];

      if (!handler) {
        return next(
          new Error(
            '/enterprises/:enterprise/settings/billing/advanced-security not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as BillingGetGithubAdvancedSecurityBillingGheRequest,
          res as BillingGetGithubAdvancedSecurityBillingGheResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/events',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListPublicEvents'];

      if (!handler) {
        return next(new Error('/events not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListPublicEventsRequest,
          res as ActivityListPublicEventsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/feeds',

    async (req, res, next) => {
      const handler = handlers['activityGetFeeds'];

      if (!handler) {
        return next(new Error('/feeds not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityGetFeedsRequest,
          res as ActivityGetFeedsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/gists',

    validate({
      query: {
        type: 'object',
        properties: {
          since: { type: 'string', format: 'date-time' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsList'];

      if (!handler) {
        return next(new Error('/gists not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsListRequest,
          res as GistsListResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/gists',

    validate({
      body: {
        properties: {
          description: {
            description: 'Description of the gist',
            example: 'Example Ruby script',
            type: 'string'
          },
          files: {
            description:
              'Names and content for the files that make up the gist',
            example: { 'hello.rb': { content: 'puts "Hello, World!"' } },
            type: 'object',
            additionalProperties: {
              type: 'object',
              properties: {
                content: {
                  description: 'Content of the file',
                  readOnly: false,
                  type: 'string'
                }
              },
              required: ['content']
            }
          },
          public: {
            oneOf: [
              {
                description: 'Flag indicating whether the gist is public',
                example: true,
                type: 'boolean',
                default: false
              },
              {
                type: 'string',
                example: 'true',
                default: 'false',
                enum: ['true', 'false']
              }
            ]
          }
        },
        required: ['files'],
        type: 'object'
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsCreate'];

      if (!handler) {
        return next(new Error('/gists not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsCreateRequest,
          res as GistsCreateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/gists/public',

    validate({
      query: {
        type: 'object',
        properties: {
          since: { type: 'string', format: 'date-time' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsListPublic'];

      if (!handler) {
        return next(new Error('/gists/public not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsListPublicRequest,
          res as GistsListPublicResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/gists/starred',

    validate({
      query: {
        type: 'object',
        properties: {
          since: { type: 'string', format: 'date-time' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsListStarred'];

      if (!handler) {
        return next(new Error('/gists/starred not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsListStarredRequest,
          res as GistsListStarredResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/gists/:gist_id',

    validate({
      params: {
        type: 'object',
        properties: { gist_id: { type: 'string' } },
        required: ['gist_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsGet'];

      if (!handler) {
        return next(new Error('/gists/:gist_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsGetRequest,
          res as GistsGetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/gists/:gist_id',

    validate({
      body: {
        properties: {
          description: {
            description: 'The description of the gist.',
            example: 'Example Ruby script',
            type: 'string'
          },
          files: {
            description:
              'The gist files to be updated, renamed, or deleted. Each `key` must match the current filename\n(including extension) of the targeted gist file. For example: `hello.py`.\n\nTo delete a file, set the whole file to null. For example: `hello.py : null`.',
            example: {
              'hello.rb': { content: 'blah', filename: 'goodbye.rb' }
            },
            type: 'object',
            additionalProperties: {
              type: 'object',
              nullable: true,
              properties: {
                content: {
                  description: 'The new content of the file.',
                  type: 'string'
                },
                filename: {
                  description: 'The new filename for the file.',
                  type: 'string',
                  nullable: true
                }
              },
              anyOf: [
                { required: ['content'] },
                { required: ['filename'] },
                { type: 'object', maxProperties: 0 }
              ]
            }
          }
        },
        anyOf: [{ required: ['description'] }, { required: ['files'] }],
        type: 'object',
        nullable: true
      },

      params: {
        type: 'object',
        properties: { gist_id: { type: 'string' } },
        required: ['gist_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsUpdate'];

      if (!handler) {
        return next(new Error('/gists/:gist_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsUpdateRequest,
          res as GistsUpdateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/gists/:gist_id',

    validate({
      params: {
        type: 'object',
        properties: { gist_id: { type: 'string' } },
        required: ['gist_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsDelete'];

      if (!handler) {
        return next(new Error('/gists/:gist_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsDeleteRequest,
          res as GistsDeleteResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/gists/:gist_id/comments',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { gist_id: { type: 'string' } },
        required: ['gist_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsListComments'];

      if (!handler) {
        return next(new Error('/gists/:gist_id/comments not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsListCommentsRequest,
          res as GistsListCommentsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/gists/:gist_id/comments',

    validate({
      body: {
        properties: {
          body: {
            description: 'The comment text.',
            type: 'string',
            maxLength: 65535,
            example: 'Body of the attachment'
          }
        },
        type: 'object',
        required: ['body']
      },

      params: {
        type: 'object',
        properties: { gist_id: { type: 'string' } },
        required: ['gist_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsCreateComment'];

      if (!handler) {
        return next(new Error('/gists/:gist_id/comments not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsCreateCommentRequest,
          res as GistsCreateCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/gists/:gist_id/comments/:comment_id',

    validate({
      params: {
        type: 'object',
        properties: {
          gist_id: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['gist_id', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsGetComment'];

      if (!handler) {
        return next(
          new Error('/gists/:gist_id/comments/:comment_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as GistsGetCommentRequest,
          res as GistsGetCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/gists/:gist_id/comments/:comment_id',

    validate({
      body: {
        properties: {
          body: {
            description: 'The comment text.',
            type: 'string',
            maxLength: 65535,
            example: 'Body of the attachment'
          }
        },
        type: 'object',
        required: ['body']
      },

      params: {
        type: 'object',
        properties: {
          gist_id: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['gist_id', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsUpdateComment'];

      if (!handler) {
        return next(
          new Error('/gists/:gist_id/comments/:comment_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as GistsUpdateCommentRequest,
          res as GistsUpdateCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/gists/:gist_id/comments/:comment_id',

    validate({
      params: {
        type: 'object',
        properties: {
          gist_id: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['gist_id', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsDeleteComment'];

      if (!handler) {
        return next(
          new Error('/gists/:gist_id/comments/:comment_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as GistsDeleteCommentRequest,
          res as GistsDeleteCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/gists/:gist_id/commits',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { gist_id: { type: 'string' } },
        required: ['gist_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsListCommits'];

      if (!handler) {
        return next(new Error('/gists/:gist_id/commits not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsListCommitsRequest,
          res as GistsListCommitsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/gists/:gist_id/forks',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { gist_id: { type: 'string' } },
        required: ['gist_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsListForks'];

      if (!handler) {
        return next(new Error('/gists/:gist_id/forks not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsListForksRequest,
          res as GistsListForksResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/gists/:gist_id/forks',

    validate({
      params: {
        type: 'object',
        properties: { gist_id: { type: 'string' } },
        required: ['gist_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsFork'];

      if (!handler) {
        return next(new Error('/gists/:gist_id/forks not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsForkRequest,
          res as GistsForkResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/gists/:gist_id/star',

    validate({
      params: {
        type: 'object',
        properties: { gist_id: { type: 'string' } },
        required: ['gist_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsCheckIsStarred'];

      if (!handler) {
        return next(new Error('/gists/:gist_id/star not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsCheckIsStarredRequest,
          res as GistsCheckIsStarredResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/gists/:gist_id/star',

    validate({
      params: {
        type: 'object',
        properties: { gist_id: { type: 'string' } },
        required: ['gist_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsStar'];

      if (!handler) {
        return next(new Error('/gists/:gist_id/star not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsStarRequest,
          res as GistsStarResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/gists/:gist_id/star',

    validate({
      params: {
        type: 'object',
        properties: { gist_id: { type: 'string' } },
        required: ['gist_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsUnstar'];

      if (!handler) {
        return next(new Error('/gists/:gist_id/star not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsUnstarRequest,
          res as GistsUnstarResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/gists/:gist_id/:sha',

    validate({
      params: {
        type: 'object',
        properties: { gist_id: { type: 'string' }, sha: { type: 'string' } },
        required: ['gist_id', 'sha']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsGetRevision'];

      if (!handler) {
        return next(new Error('/gists/:gist_id/:sha not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsGetRevisionRequest,
          res as GistsGetRevisionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/gitignore/templates',

    async (req, res, next) => {
      const handler = handlers['gitignoreGetAllTemplates'];

      if (!handler) {
        return next(new Error('/gitignore/templates not handled'));
      }

      try {
        await handler(
          (req as unknown) as GitignoreGetAllTemplatesRequest,
          res as GitignoreGetAllTemplatesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/gitignore/templates/:name',

    validate({
      params: {
        type: 'object',
        properties: { name: { type: 'string' } },
        required: ['name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitignoreGetTemplate'];

      if (!handler) {
        return next(new Error('/gitignore/templates/:name not handled'));
      }

      try {
        await handler(
          (req as unknown) as GitignoreGetTemplateRequest,
          res as GitignoreGetTemplateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/installation/repositories',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsListReposAccessibleToInstallation'];

      if (!handler) {
        return next(new Error('/installation/repositories not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsListReposAccessibleToInstallationRequest,
          res as AppsListReposAccessibleToInstallationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/installation/token',

    async (req, res, next) => {
      const handler = handlers['appsRevokeInstallationAccessToken'];

      if (!handler) {
        return next(new Error('/installation/token not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsRevokeInstallationAccessTokenRequest,
          res as AppsRevokeInstallationAccessTokenResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/issues',

    validate({
      query: {
        type: 'object',
        properties: {
          filter: {
            type: 'string',
            enum: [
              'assigned',
              'created',
              'mentioned',
              'subscribed',
              'repos',
              'all'
            ],
            default: 'assigned'
          },
          state: {
            type: 'string',
            enum: ['open', 'closed', 'all'],
            default: 'open'
          },
          labels: { type: 'string' },
          sort: {
            type: 'string',
            enum: ['created', 'updated', 'comments'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          since: { type: 'string', format: 'date-time' },
          collab: { type: 'boolean' },
          orgs: { type: 'boolean' },
          owned: { type: 'boolean' },
          pulls: { type: 'boolean' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesList'];

      if (!handler) {
        return next(new Error('/issues not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesListRequest,
          res as IssuesListResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/licenses',

    validate({
      query: {
        type: 'object',
        properties: {
          featured: { type: 'boolean' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['licensesGetAllCommonlyUsed'];

      if (!handler) {
        return next(new Error('/licenses not handled'));
      }

      try {
        await handler(
          (req as unknown) as LicensesGetAllCommonlyUsedRequest,
          res as LicensesGetAllCommonlyUsedResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/licenses/:license',

    validate({
      params: {
        type: 'object',
        properties: { license: { type: 'string' } },
        required: ['license']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['licensesGet'];

      if (!handler) {
        return next(new Error('/licenses/:license not handled'));
      }

      try {
        await handler(
          (req as unknown) as LicensesGetRequest,
          res as LicensesGetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/markdown',

    validate({
      body: {
        properties: {
          text: {
            description: 'The Markdown text to render in HTML.',
            type: 'string'
          },
          mode: {
            description: 'The rendering mode.',
            enum: ['markdown', 'gfm'],
            default: 'markdown',
            example: 'markdown',
            type: 'string'
          },
          context: {
            description:
              'The repository context to use when creating references in `gfm` mode.  For example, setting `context` to `octo-org/octo-repo` will change the text `#42` into an HTML link to issue 42 in the `octo-org/octo-repo` repository.',
            type: 'string'
          }
        },
        required: ['text'],
        type: 'object'
      }
    }),

    async (req, res, next) => {
      const handler = handlers['markdownRender'];

      if (!handler) {
        return next(new Error('/markdown not handled'));
      }

      try {
        await handler(
          (req as unknown) as MarkdownRenderRequest,
          res as MarkdownRenderResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/markdown/raw',

    async (req, res, next) => {
      const handler = handlers['markdownRenderRaw'];

      if (!handler) {
        return next(new Error('/markdown/raw not handled'));
      }

      try {
        await handler(
          (req as unknown) as MarkdownRenderRawRequest,
          res as MarkdownRenderRawResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/marketplace_listing/accounts/:account_id',

    validate({
      params: {
        type: 'object',
        properties: { account_id: { type: 'integer' } },
        required: ['account_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsGetSubscriptionPlanForAccount'];

      if (!handler) {
        return next(
          new Error('/marketplace_listing/accounts/:account_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as AppsGetSubscriptionPlanForAccountRequest,
          res as AppsGetSubscriptionPlanForAccountResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/marketplace_listing/plans',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsListPlans'];

      if (!handler) {
        return next(new Error('/marketplace_listing/plans not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsListPlansRequest,
          res as AppsListPlansResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/marketplace_listing/plans/:plan_id/accounts',

    validate({
      query: {
        type: 'object',
        properties: {
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'] },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { plan_id: { type: 'integer' } },
        required: ['plan_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsListAccountsForPlan'];

      if (!handler) {
        return next(
          new Error('/marketplace_listing/plans/:plan_id/accounts not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as AppsListAccountsForPlanRequest,
          res as AppsListAccountsForPlanResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/marketplace_listing/stubbed/accounts/:account_id',

    validate({
      params: {
        type: 'object',
        properties: { account_id: { type: 'integer' } },
        required: ['account_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsGetSubscriptionPlanForAccountStubbed'];

      if (!handler) {
        return next(
          new Error(
            '/marketplace_listing/stubbed/accounts/:account_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as AppsGetSubscriptionPlanForAccountStubbedRequest,
          res as AppsGetSubscriptionPlanForAccountStubbedResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/marketplace_listing/stubbed/plans',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsListPlansStubbed'];

      if (!handler) {
        return next(
          new Error('/marketplace_listing/stubbed/plans not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as AppsListPlansStubbedRequest,
          res as AppsListPlansStubbedResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/marketplace_listing/stubbed/plans/:plan_id/accounts',

    validate({
      query: {
        type: 'object',
        properties: {
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'] },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { plan_id: { type: 'integer' } },
        required: ['plan_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsListAccountsForPlanStubbed'];

      if (!handler) {
        return next(
          new Error(
            '/marketplace_listing/stubbed/plans/:plan_id/accounts not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as AppsListAccountsForPlanStubbedRequest,
          res as AppsListAccountsForPlanStubbedResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/meta',

    async (req, res, next) => {
      const handler = handlers['metaGet'];

      if (!handler) {
        return next(new Error('/meta not handled'));
      }

      try {
        await handler(
          (req as unknown) as MetaGetRequest,
          res as MetaGetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/networks/:owner/:repo/events',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListPublicEventsForRepoNetwork'];

      if (!handler) {
        return next(new Error('/networks/:owner/:repo/events not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListPublicEventsForRepoNetworkRequest,
          res as ActivityListPublicEventsForRepoNetworkResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/notifications',

    validate({
      query: {
        type: 'object',
        properties: {
          all: { type: 'boolean', default: false },
          participating: { type: 'boolean', default: false },
          since: { type: 'string', format: 'date-time' },
          before: { type: 'string', format: 'date-time' },
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 50 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListNotificationsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/notifications not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListNotificationsForAuthenticatedUserRequest,
          res as ActivityListNotificationsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/notifications',

    validate({
      body: {
        type: 'object',
        properties: {
          last_read_at: {
            description:
              'Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.',
            type: 'string',
            format: 'date-time'
          },
          read: {
            description: 'Whether the notification has been read.',
            type: 'boolean'
          }
        }
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityMarkNotificationsAsRead'];

      if (!handler) {
        return next(new Error('/notifications not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityMarkNotificationsAsReadRequest,
          res as ActivityMarkNotificationsAsReadResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/notifications/threads/:thread_id',

    validate({
      params: {
        type: 'object',
        properties: { thread_id: { type: 'integer' } },
        required: ['thread_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityGetThread'];

      if (!handler) {
        return next(new Error('/notifications/threads/:thread_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityGetThreadRequest,
          res as ActivityGetThreadResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/notifications/threads/:thread_id',

    validate({
      params: {
        type: 'object',
        properties: { thread_id: { type: 'integer' } },
        required: ['thread_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityMarkThreadAsRead'];

      if (!handler) {
        return next(new Error('/notifications/threads/:thread_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityMarkThreadAsReadRequest,
          res as ActivityMarkThreadAsReadResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/notifications/threads/:thread_id/subscription',

    validate({
      params: {
        type: 'object',
        properties: { thread_id: { type: 'integer' } },
        required: ['thread_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['activityGetThreadSubscriptionForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/notifications/threads/:thread_id/subscription not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActivityGetThreadSubscriptionForAuthenticatedUserRequest,
          res as ActivityGetThreadSubscriptionForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/notifications/threads/:thread_id/subscription',

    validate({
      body: {
        properties: {
          ignored: {
            description: 'Whether to block all notifications from a thread.',
            default: false,
            type: 'boolean'
          }
        },
        type: 'object'
      },

      params: {
        type: 'object',
        properties: { thread_id: { type: 'integer' } },
        required: ['thread_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activitySetThreadSubscription'];

      if (!handler) {
        return next(
          new Error(
            '/notifications/threads/:thread_id/subscription not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActivitySetThreadSubscriptionRequest,
          res as ActivitySetThreadSubscriptionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/notifications/threads/:thread_id/subscription',

    validate({
      params: {
        type: 'object',
        properties: { thread_id: { type: 'integer' } },
        required: ['thread_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityDeleteThreadSubscription'];

      if (!handler) {
        return next(
          new Error(
            '/notifications/threads/:thread_id/subscription not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActivityDeleteThreadSubscriptionRequest,
          res as ActivityDeleteThreadSubscriptionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/octocat',

    validate({
      query: {
        type: 'object',
        properties: { s: { type: 'string' } },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['metaGetOctocat'];

      if (!handler) {
        return next(new Error('/octocat not handled'));
      }

      try {
        await handler(
          (req as unknown) as MetaGetOctocatRequest,
          res as MetaGetOctocatResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/organizations',

    validate({
      query: {
        type: 'object',
        properties: {
          since: { type: 'integer' },
          per_page: { type: 'integer', default: 30 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsList'];

      if (!handler) {
        return next(new Error('/organizations not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsListRequest,
          res as OrgsListResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/organizations/:organization_id/custom_roles',

    validate({
      params: {
        type: 'object',
        properties: { organization_id: { type: 'string' } },
        required: ['organization_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListCustomRoles'];

      if (!handler) {
        return next(
          new Error('/organizations/:organization_id/custom_roles not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsListCustomRolesRequest,
          res as OrgsListCustomRolesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsGet'];

      if (!handler) {
        return next(new Error('/orgs/:org not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsGetRequest,
          res as OrgsGetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/orgs/:org',

    validate({
      body: {
        type: 'object',
        properties: {
          billing_email: {
            type: 'string',
            description:
              'Billing email address. This address is not publicized.'
          },
          company: { type: 'string', description: 'The company name.' },
          email: {
            type: 'string',
            description: 'The publicly visible email address.'
          },
          twitter_username: {
            type: 'string',
            description: 'The Twitter username of the company.'
          },
          location: { type: 'string', description: 'The location.' },
          name: {
            type: 'string',
            description: 'The shorthand name of the company.'
          },
          description: {
            type: 'string',
            description: 'The description of the company.'
          },
          has_organization_projects: {
            type: 'boolean',
            description:
              'Whether an organization can use organization projects.'
          },
          has_repository_projects: {
            type: 'boolean',
            description:
              'Whether repositories that belong to the organization can use repository projects.'
          },
          default_repository_permission: {
            type: 'string',
            description:
              'Default permission level members have for organization repositories.',
            enum: ['read', 'write', 'admin', 'none'],
            default: 'read'
          },
          members_can_create_repositories: {
            type: 'boolean',
            description:
              'Whether of non-admin organization members can create repositories. **Note:** A parameter can override this parameter. See `members_allowed_repository_creation_type` in this table for details.',
            default: true
          },
          members_can_create_internal_repositories: {
            type: 'boolean',
            description:
              'Whether organization members can create internal repositories, which are visible to all enterprise members. You can only allow members to create internal repositories if your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.'
          },
          members_can_create_private_repositories: {
            type: 'boolean',
            description:
              'Whether organization members can create private repositories, which are visible to organization members with permission. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.'
          },
          members_can_create_public_repositories: {
            type: 'boolean',
            description:
              'Whether organization members can create public repositories, which are visible to anyone. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.'
          },
          members_allowed_repository_creation_type: {
            type: 'string',
            description:
              'Specifies which types of repositories non-admin organization members can create. `private` is only available to repositories that are part of an organization on GitHub Enterprise Cloud. \n**Note:** This parameter is deprecated and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details.',
            enum: ['all', 'private', 'none']
          },
          members_can_create_pages: {
            type: 'boolean',
            description:
              'Whether organization members can create GitHub Pages sites. Existing published sites will not be impacted.',
            default: true
          },
          members_can_create_public_pages: {
            type: 'boolean',
            description:
              'Whether organization members can create public GitHub Pages sites. Existing published sites will not be impacted.',
            default: true
          },
          members_can_create_private_pages: {
            type: 'boolean',
            description:
              'Whether organization members can create private GitHub Pages sites. Existing published sites will not be impacted.',
            default: true
          },
          members_can_fork_private_repositories: {
            type: 'boolean',
            description:
              'Whether organization members can fork private organization repositories.',
            default: false
          },
          web_commit_signoff_required: {
            type: 'boolean',
            description:
              "Whether contributors to organization repositories are required to sign off on commits they make through GitHub's web interface.",
            default: false
          },
          blog: { type: 'string', example: '"http://github.blog"' },
          advanced_security_enabled_for_new_repositories: {
            type: 'boolean',
            description:
              'Whether GitHub Advanced Security is automatically enabled for new repositories.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
          },
          dependabot_alerts_enabled_for_new_repositories: {
            type: 'boolean',
            description:
              'Whether Dependabot alerts is automatically enabled for new repositories.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
          },
          dependabot_security_updates_enabled_for_new_repositories: {
            type: 'boolean',
            description:
              'Whether Dependabot security updates is automatically enabled for new repositories.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
          },
          dependency_graph_enabled_for_new_repositories: {
            type: 'boolean',
            description:
              'Whether dependency graph is automatically enabled for new repositories.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
          },
          secret_scanning_enabled_for_new_repositories: {
            type: 'boolean',
            description:
              'Whether secret scanning is automatically enabled for new repositories.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
          },
          secret_scanning_push_protection_enabled_for_new_repositories: {
            type: 'boolean',
            description:
              'Whether secret scanning push protection is automatically enabled for new repositories.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsUpdate'];

      if (!handler) {
        return next(new Error('/orgs/:org not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsUpdateRequest,
          res as OrgsUpdateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/cache/usage',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetActionsCacheUsageForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/actions/cache/usage not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActionsGetActionsCacheUsageForOrgRequest,
          res as ActionsGetActionsCacheUsageForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/cache/usage-by-repository',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetActionsCacheUsageByRepoForOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/cache/usage-by-repository not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetActionsCacheUsageByRepoForOrgRequest,
          res as ActionsGetActionsCacheUsageByRepoForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/permissions',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsGetGithubActionsPermissionsOrganization'];

      if (!handler) {
        return next(new Error('/orgs/:org/actions/permissions not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActionsGetGithubActionsPermissionsOrganizationRequest,
          res as ActionsGetGithubActionsPermissionsOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/actions/permissions',

    validate({
      body: {
        type: 'object',
        properties: {
          enabled_repositories: { $ref: '#/definitions/enabled-repositories' },
          allowed_actions: { $ref: '#/definitions/allowed-actions' }
        },
        required: ['enabled_repositories'],
        definitions: {
          'enabled-repositories': {
            type: 'string',
            description:
              'The policy that controls the repositories in the organization that are allowed to run GitHub Actions.',
            enum: ['all', 'none', 'selected'],
            title: 'enabled-repositories'
          },
          'allowed-actions': {
            type: 'string',
            description:
              'The permissions policy that controls the actions and reusable workflows that are allowed to run.',
            enum: ['all', 'local_only', 'selected'],
            title: 'allowed-actions'
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsSetGithubActionsPermissionsOrganization'];

      if (!handler) {
        return next(new Error('/orgs/:org/actions/permissions not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActionsSetGithubActionsPermissionsOrganizationRequest,
          res as ActionsSetGithubActionsPermissionsOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/permissions/repositories',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'actionsListSelectedRepositoriesEnabledGithubActionsOrganization'
        ];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/permissions/repositories not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest,
          res as ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/actions/permissions/repositories',

    validate({
      body: {
        type: 'object',
        properties: {
          selected_repository_ids: {
            description: 'List of repository IDs to enable for GitHub Actions.',
            type: 'array',
            items: {
              type: 'integer',
              description: 'Unique identifier of the repository.'
            }
          }
        },
        required: ['selected_repository_ids']
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'actionsSetSelectedRepositoriesEnabledGithubActionsOrganization'
        ];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/permissions/repositories not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest,
          res as ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/actions/permissions/repositories/:repository_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          repository_id: { type: 'integer' }
        },
        required: ['org', 'repository_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsEnableSelectedRepositoryGithubActionsOrganization'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/permissions/repositories/:repository_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsEnableSelectedRepositoryGithubActionsOrganizationRequest,
          res as ActionsEnableSelectedRepositoryGithubActionsOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/actions/permissions/repositories/:repository_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          repository_id: { type: 'integer' }
        },
        required: ['org', 'repository_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsDisableSelectedRepositoryGithubActionsOrganization'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/permissions/repositories/:repository_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDisableSelectedRepositoryGithubActionsOrganizationRequest,
          res as ActionsDisableSelectedRepositoryGithubActionsOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/permissions/selected-actions',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetAllowedActionsOrganization'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/permissions/selected-actions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetAllowedActionsOrganizationRequest,
          res as ActionsGetAllowedActionsOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/actions/permissions/selected-actions',

    validate({
      body: {
        $ref: '#/definitions/selected-actions',
        definitions: {
          'selected-actions': {
            type: 'object',
            properties: {
              github_owned_allowed: {
                type: 'boolean',
                description:
                  'Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.'
              },
              verified_allowed: {
                type: 'boolean',
                description:
                  'Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators.'
              },
              patterns_allowed: {
                type: 'array',
                description:
                  'Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`."',
                items: { type: 'string' }
              }
            },
            title: 'selected-actions'
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsSetAllowedActionsOrganization'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/permissions/selected-actions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsSetAllowedActionsOrganizationRequest,
          res as ActionsSetAllowedActionsOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/permissions/workflow',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'actionsGetGithubActionsDefaultWorkflowPermissionsOrganization'
        ];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/permissions/workflow not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest,
          res as ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/actions/permissions/workflow',

    validate({
      body: {
        $ref: '#/definitions/actions-set-default-workflow-permissions',
        definitions: {
          'actions-set-default-workflow-permissions': {
            type: 'object',
            properties: {
              default_workflow_permissions: {
                $ref: '#/definitions/actions-default-workflow-permissions'
              },
              can_approve_pull_request_reviews: {
                $ref: '#/definitions/actions-can-approve-pull-request-reviews'
              }
            },
            title: 'actions-set-default-workflow-permissions'
          },
          'actions-default-workflow-permissions': {
            type: 'string',
            description:
              'The default workflow permissions granted to the GITHUB_TOKEN when running workflows.',
            enum: ['read', 'write'],
            title: 'actions-default-workflow-permissions'
          },
          'actions-can-approve-pull-request-reviews': {
            type: 'boolean',
            description:
              'Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.',
            title: 'actions-can-approve-pull-request-reviews'
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'actionsSetGithubActionsDefaultWorkflowPermissionsOrganization'
        ];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/permissions/workflow not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest,
          res as ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/runner-groups',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 },
          visible_to_repository: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListSelfHostedRunnerGroupsForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/actions/runner-groups not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActionsListSelfHostedRunnerGroupsForOrgRequest,
          res as ActionsListSelfHostedRunnerGroupsForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/actions/runner-groups',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { description: 'Name of the runner group.', type: 'string' },
          visibility: {
            description:
              'Visibility of a runner group. You can select all repositories, select individual repositories, or limit access to private repositories.',
            type: 'string',
            enum: ['selected', 'all', 'private'],
            default: 'all'
          },
          selected_repository_ids: {
            description:
              'List of repository IDs that can access the runner group.',
            type: 'array',
            items: {
              type: 'integer',
              description: 'Unique identifier of the repository.'
            }
          },
          runners: {
            description: 'List of runner IDs to add to the runner group.',
            type: 'array',
            items: {
              type: 'integer',
              description: 'Unique identifier of the runner.'
            }
          },
          allows_public_repositories: {
            description:
              'Whether the runner group can be used by `public` repositories.',
            type: 'boolean',
            default: false
          },
          restricted_to_workflows: {
            description:
              'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.',
            type: 'boolean',
            default: false
          },
          selected_workflows: {
            description:
              'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.',
            type: 'array',
            items: {
              type: 'string',
              description:
                'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.',
              example: 'octo-org/octo-repo/.github/workflows/deploy.yaml@main'
            }
          }
        },
        required: ['name']
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsCreateSelfHostedRunnerGroupForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/actions/runner-groups not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActionsCreateSelfHostedRunnerGroupForOrgRequest,
          res as ActionsCreateSelfHostedRunnerGroupForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/runner-groups/:runner_group_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['org', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetSelfHostedRunnerGroupForOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/runner-groups/:runner_group_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetSelfHostedRunnerGroupForOrgRequest,
          res as ActionsGetSelfHostedRunnerGroupForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/orgs/:org/actions/runner-groups/:runner_group_id',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { description: 'Name of the runner group.', type: 'string' },
          visibility: {
            description:
              'Visibility of a runner group. You can select all repositories, select individual repositories, or all private repositories.',
            type: 'string',
            enum: ['selected', 'all', 'private']
          },
          allows_public_repositories: {
            description:
              'Whether the runner group can be used by `public` repositories.',
            type: 'boolean',
            default: false
          },
          restricted_to_workflows: {
            description:
              'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.',
            type: 'boolean',
            default: false
          },
          selected_workflows: {
            description:
              'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.',
            type: 'array',
            items: {
              type: 'string',
              description:
                'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.',
              example: 'octo-org/octo-repo/.github/workflows/deploy.yaml@main'
            }
          }
        },
        required: ['name']
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['org', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsUpdateSelfHostedRunnerGroupForOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/runner-groups/:runner_group_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsUpdateSelfHostedRunnerGroupForOrgRequest,
          res as ActionsUpdateSelfHostedRunnerGroupForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/actions/runner-groups/:runner_group_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['org', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDeleteSelfHostedRunnerGroupFromOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/runner-groups/:runner_group_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDeleteSelfHostedRunnerGroupFromOrgRequest,
          res as ActionsDeleteSelfHostedRunnerGroupFromOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/runner-groups/:runner_group_id/repositories',

    validate({
      query: {
        type: 'object',
        properties: {
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['org', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsListRepoAccessToSelfHostedRunnerGroupInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/runner-groups/:runner_group_id/repositories not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest,
          res as ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/actions/runner-groups/:runner_group_id/repositories',

    validate({
      body: {
        type: 'object',
        properties: {
          selected_repository_ids: {
            description:
              'List of repository IDs that can access the runner group.',
            type: 'array',
            items: {
              type: 'integer',
              description: 'Unique identifier of the repository.'
            }
          }
        },
        required: ['selected_repository_ids']
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['org', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsSetRepoAccessToSelfHostedRunnerGroupInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/runner-groups/:runner_group_id/repositories not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest,
          res as ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/actions/runner-groups/:runner_group_id/repositories/:repository_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          runner_group_id: { type: 'integer' },
          repository_id: { type: 'integer' }
        },
        required: ['org', 'runner_group_id', 'repository_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/runner-groups/:runner_group_id/repositories/:repository_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest,
          res as ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/runner-groups/:runner_group_id/runners',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['org', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListSelfHostedRunnersInGroupForOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/runner-groups/:runner_group_id/runners not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListSelfHostedRunnersInGroupForOrgRequest,
          res as ActionsListSelfHostedRunnersInGroupForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/actions/runner-groups/:runner_group_id/runners',

    validate({
      body: {
        type: 'object',
        properties: {
          runners: {
            description: 'List of runner IDs to add to the runner group.',
            type: 'array',
            items: {
              type: 'integer',
              description: 'Unique identifier of the runner.'
            }
          }
        },
        required: ['runners']
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          runner_group_id: { type: 'integer' }
        },
        required: ['org', 'runner_group_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsSetSelfHostedRunnersInGroupForOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/runner-groups/:runner_group_id/runners not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsSetSelfHostedRunnersInGroupForOrgRequest,
          res as ActionsSetSelfHostedRunnersInGroupForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/actions/runner-groups/:runner_group_id/runners/:runner_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          runner_group_id: { type: 'integer' },
          runner_id: { type: 'integer' }
        },
        required: ['org', 'runner_group_id', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsAddSelfHostedRunnerToGroupForOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/runner-groups/:runner_group_id/runners/:runner_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsAddSelfHostedRunnerToGroupForOrgRequest,
          res as ActionsAddSelfHostedRunnerToGroupForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/actions/runner-groups/:runner_group_id/runners/:runner_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          runner_group_id: { type: 'integer' },
          runner_id: { type: 'integer' }
        },
        required: ['org', 'runner_group_id', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsRemoveSelfHostedRunnerFromGroupForOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/runner-groups/:runner_group_id/runners/:runner_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsRemoveSelfHostedRunnerFromGroupForOrgRequest,
          res as ActionsRemoveSelfHostedRunnerFromGroupForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/runners',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListSelfHostedRunnersForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/actions/runners not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActionsListSelfHostedRunnersForOrgRequest,
          res as ActionsListSelfHostedRunnersForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/runners/downloads',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListRunnerApplicationsForOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/runners/downloads not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListRunnerApplicationsForOrgRequest,
          res as ActionsListRunnerApplicationsForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/actions/runners/registration-token',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsCreateRegistrationTokenForOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/runners/registration-token not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsCreateRegistrationTokenForOrgRequest,
          res as ActionsCreateRegistrationTokenForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/actions/runners/remove-token',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsCreateRemoveTokenForOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/runners/remove-token not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsCreateRemoveTokenForOrgRequest,
          res as ActionsCreateRemoveTokenForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/runners/:runner_id',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, runner_id: { type: 'integer' } },
        required: ['org', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetSelfHostedRunnerForOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/runners/:runner_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetSelfHostedRunnerForOrgRequest,
          res as ActionsGetSelfHostedRunnerForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/actions/runners/:runner_id',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, runner_id: { type: 'integer' } },
        required: ['org', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDeleteSelfHostedRunnerFromOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/runners/:runner_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDeleteSelfHostedRunnerFromOrgRequest,
          res as ActionsDeleteSelfHostedRunnerFromOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/runners/:runner_id/labels',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, runner_id: { type: 'integer' } },
        required: ['org', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListLabelsForSelfHostedRunnerForOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/runners/:runner_id/labels not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListLabelsForSelfHostedRunnerForOrgRequest,
          res as ActionsListLabelsForSelfHostedRunnerForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/actions/runners/:runner_id/labels',

    validate({
      body: {
        type: 'object',
        required: ['labels'],
        properties: {
          labels: {
            type: 'array',
            minItems: 1,
            maxItems: 100,
            description: 'The names of the custom labels to add to the runner.',
            items: { type: 'string' }
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' }, runner_id: { type: 'integer' } },
        required: ['org', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsAddCustomLabelsToSelfHostedRunnerForOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/runners/:runner_id/labels not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest,
          res as ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/actions/runners/:runner_id/labels',

    validate({
      body: {
        type: 'object',
        required: ['labels'],
        properties: {
          labels: {
            type: 'array',
            minItems: 0,
            maxItems: 100,
            description:
              'The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.',
            items: { type: 'string' }
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' }, runner_id: { type: 'integer' } },
        required: ['org', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsSetCustomLabelsForSelfHostedRunnerForOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/runners/:runner_id/labels not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest,
          res as ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/actions/runners/:runner_id/labels',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, runner_id: { type: 'integer' } },
        required: ['org', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/runners/:runner_id/labels not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest,
          res as ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/actions/runners/:runner_id/labels/:name',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          runner_id: { type: 'integer' },
          name: { type: 'string' }
        },
        required: ['org', 'runner_id', 'name']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsRemoveCustomLabelFromSelfHostedRunnerForOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/runners/:runner_id/labels/:name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest,
          res as ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/secrets',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListOrgSecrets'];

      if (!handler) {
        return next(new Error('/orgs/:org/actions/secrets not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActionsListOrgSecretsRequest,
          res as ActionsListOrgSecretsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/secrets/public-key',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetOrgPublicKey'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/secrets/public-key not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetOrgPublicKeyRequest,
          res as ActionsGetOrgPublicKeyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetOrgSecret'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/secrets/:secret_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetOrgSecretRequest,
          res as ActionsGetOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/actions/secrets/:secret_name',

    validate({
      body: {
        type: 'object',
        properties: {
          encrypted_value: {
            type: 'string',
            description:
              'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/reference/actions#get-an-organization-public-key) endpoint.',
            pattern:
              '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          },
          key_id: {
            type: 'string',
            description: 'ID of the key you used to encrypt the secret.'
          },
          visibility: {
            type: 'string',
            description:
              'Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.',
            enum: ['all', 'private', 'selected']
          },
          selected_repository_ids: {
            type: 'array',
            description:
              'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/reference/actions#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/reference/actions#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/reference/actions#remove-selected-repository-from-an-organization-secret) endpoints.',
            items: { type: 'integer' }
          }
        },
        required: ['visibility']
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsCreateOrUpdateOrgSecret'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/secrets/:secret_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsCreateOrUpdateOrgSecretRequest,
          res as ActionsCreateOrUpdateOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/actions/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDeleteOrgSecret'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/actions/secrets/:secret_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDeleteOrgSecretRequest,
          res as ActionsDeleteOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/actions/secrets/:secret_name/repositories',

    validate({
      query: {
        type: 'object',
        properties: {
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListSelectedReposForOrgSecret'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/secrets/:secret_name/repositories not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListSelectedReposForOrgSecretRequest,
          res as ActionsListSelectedReposForOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/actions/secrets/:secret_name/repositories',

    validate({
      body: {
        type: 'object',
        properties: {
          selected_repository_ids: {
            type: 'array',
            description:
              'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Add selected repository to an organization secret](https://docs.github.com/rest/actions/secrets#add-selected-repository-to-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/reference/actions#remove-selected-repository-from-an-organization-secret) endpoints.',
            items: { type: 'integer' }
          }
        },
        required: ['selected_repository_ids']
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsSetSelectedReposForOrgSecret'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/secrets/:secret_name/repositories not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsSetSelectedReposForOrgSecretRequest,
          res as ActionsSetSelectedReposForOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/actions/secrets/:secret_name/repositories/:repository_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' },
          repository_id: { type: 'integer' }
        },
        required: ['org', 'secret_name', 'repository_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsAddSelectedRepoToOrgSecret'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/secrets/:secret_name/repositories/:repository_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsAddSelectedRepoToOrgSecretRequest,
          res as ActionsAddSelectedRepoToOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/actions/secrets/:secret_name/repositories/:repository_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' },
          repository_id: { type: 'integer' }
        },
        required: ['org', 'secret_name', 'repository_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsRemoveSelectedRepoFromOrgSecret'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/actions/secrets/:secret_name/repositories/:repository_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsRemoveSelectedRepoFromOrgSecretRequest,
          res as ActionsRemoveSelectedRepoFromOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/blocks',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListBlockedUsers'];

      if (!handler) {
        return next(new Error('/orgs/:org/blocks not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsListBlockedUsersRequest,
          res as OrgsListBlockedUsersResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/blocks/:username',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsCheckBlockedUser'];

      if (!handler) {
        return next(new Error('/orgs/:org/blocks/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsCheckBlockedUserRequest,
          res as OrgsCheckBlockedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/blocks/:username',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsBlockUser'];

      if (!handler) {
        return next(new Error('/orgs/:org/blocks/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsBlockUserRequest,
          res as OrgsBlockUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/blocks/:username',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsUnblockUser'];

      if (!handler) {
        return next(new Error('/orgs/:org/blocks/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsUnblockUserRequest,
          res as OrgsUnblockUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/code-scanning/alerts',

    validate({
      query: {
        type: 'object',
        properties: {
          tool_name: { $ref: '#/definitions/code-scanning-analysis-tool-name' },
          tool_guid: { $ref: '#/definitions/code-scanning-analysis-tool-guid' },
          before: { type: 'string' },
          after: { type: 'string' },
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          state: { $ref: '#/definitions/code-scanning-alert-state' },
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          }
        },
        required: [],
        definitions: {
          'code-scanning-analysis-tool-name': {
            type: 'string',
            description:
              'The name of the tool used to generate the code scanning analysis.',
            title: 'code-scanning-analysis-tool-name'
          },
          'code-scanning-analysis-tool-guid': {
            nullable: true,
            type: 'string',
            description:
              'The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.',
            title: 'code-scanning-analysis-tool-guid'
          },
          'code-scanning-alert-state': {
            type: 'string',
            description: 'State of a code scanning alert.',
            enum: ['open', 'closed', 'dismissed', 'fixed'],
            title: 'code-scanning-alert-state'
          }
        }
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codeScanningListAlertsForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/code-scanning/alerts not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodeScanningListAlertsForOrgRequest,
          res as CodeScanningListAlertsForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/codespaces',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesListInOrganization'];

      if (!handler) {
        return next(new Error('/orgs/:org/codespaces not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodespacesListInOrganizationRequest,
          res as CodespacesListInOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/codespaces/billing',

    validate({
      body: {
        type: 'object',
        properties: {
          visibility: {
            type: 'string',
            description:
              'Which users can access codespaces in the organization. `disabled` means that no users can access codespaces in the organization.',
            enum: [
              'disabled',
              'selected_members',
              'all_members',
              'all_members_and_outside_collaborators'
            ]
          },
          selected_usernames: {
            type: 'array',
            description:
              'The usernames of the organization members who should be granted access to codespaces in the organization. Required when `visibility` is `selected_members`.',
            items: { type: 'string' }
          }
        },
        required: ['visibility']
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesSetCodespacesBilling'];

      if (!handler) {
        return next(new Error('/orgs/:org/codespaces/billing not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodespacesSetCodespacesBillingRequest,
          res as CodespacesSetCodespacesBillingResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/codespaces/secrets',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesListOrgSecrets'];

      if (!handler) {
        return next(new Error('/orgs/:org/codespaces/secrets not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodespacesListOrgSecretsRequest,
          res as CodespacesListOrgSecretsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/codespaces/secrets/public-key',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesGetOrgPublicKey'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/codespaces/secrets/public-key not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesGetOrgPublicKeyRequest,
          res as CodespacesGetOrgPublicKeyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/codespaces/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesGetOrgSecret'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/codespaces/secrets/:secret_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesGetOrgSecretRequest,
          res as CodespacesGetOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/codespaces/secrets/:secret_name',

    validate({
      body: {
        type: 'object',
        properties: {
          encrypted_value: {
            type: 'string',
            description:
              'The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/reference/codespaces#get-an-organization-public-key) endpoint.',
            pattern:
              '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          },
          key_id: {
            type: 'string',
            description: 'The ID of the key you used to encrypt the secret.'
          },
          visibility: {
            type: 'string',
            description:
              'Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.',
            enum: ['all', 'private', 'selected']
          },
          selected_repository_ids: {
            type: 'array',
            description:
              'An array of repository IDs that can access the organization secret. You can only provide a list of repository IDs when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/reference/codespaces#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/reference/codespaces#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/reference/codespaces#remove-selected-repository-from-an-organization-secret) endpoints.',
            items: { type: 'integer' }
          }
        },
        required: ['visibility']
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesCreateOrUpdateOrgSecret'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/codespaces/secrets/:secret_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesCreateOrUpdateOrgSecretRequest,
          res as CodespacesCreateOrUpdateOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/codespaces/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesDeleteOrgSecret'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/codespaces/secrets/:secret_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesDeleteOrgSecretRequest,
          res as CodespacesDeleteOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/codespaces/secrets/:secret_name/repositories',

    validate({
      query: {
        type: 'object',
        properties: {
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesListSelectedReposForOrgSecret'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/codespaces/secrets/:secret_name/repositories not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesListSelectedReposForOrgSecretRequest,
          res as CodespacesListSelectedReposForOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/codespaces/secrets/:secret_name/repositories',

    validate({
      body: {
        type: 'object',
        properties: {
          selected_repository_ids: {
            type: 'array',
            description:
              'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/reference/codespaces#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/reference/codespaces#remove-selected-repository-from-an-organization-secret) endpoints.',
            items: { type: 'integer' }
          }
        },
        required: ['selected_repository_ids']
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesSetSelectedReposForOrgSecret'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/codespaces/secrets/:secret_name/repositories not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesSetSelectedReposForOrgSecretRequest,
          res as CodespacesSetSelectedReposForOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/codespaces/secrets/:secret_name/repositories/:repository_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' },
          repository_id: { type: 'integer' }
        },
        required: ['org', 'secret_name', 'repository_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesAddSelectedRepoToOrgSecret'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/codespaces/secrets/:secret_name/repositories/:repository_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesAddSelectedRepoToOrgSecretRequest,
          res as CodespacesAddSelectedRepoToOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/codespaces/secrets/:secret_name/repositories/:repository_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' },
          repository_id: { type: 'integer' }
        },
        required: ['org', 'secret_name', 'repository_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesRemoveSelectedRepoFromOrgSecret'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/codespaces/secrets/:secret_name/repositories/:repository_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesRemoveSelectedRepoFromOrgSecretRequest,
          res as CodespacesRemoveSelectedRepoFromOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/custom_roles',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { type: 'string', description: 'The name of the custom role.' },
          description: {
            type: 'string',
            description:
              'A short description about the intended usage of this role or what permissions it grants.'
          },
          base_role: {
            type: 'string',
            enum: ['read', 'triage', 'write', 'maintain'],
            description:
              'The system role from which this role inherits permissions.'
          },
          permissions: {
            type: 'array',
            description:
              'A list of additional permissions included in this role.',
            items: { type: 'string' }
          }
        },
        required: ['name', 'base_role', 'permissions']
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsCreateCustomRole'];

      if (!handler) {
        return next(new Error('/orgs/:org/custom_roles not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsCreateCustomRoleRequest,
          res as OrgsCreateCustomRoleResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/custom_roles/:role_id',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, role_id: { type: 'integer' } },
        required: ['org', 'role_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsGetCustomRole'];

      if (!handler) {
        return next(new Error('/orgs/:org/custom_roles/:role_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsGetCustomRoleRequest,
          res as OrgsGetCustomRoleResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/orgs/:org/custom_roles/:role_id',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { type: 'string', description: 'The name of the custom role.' },
          description: {
            type: 'string',
            description:
              'A short description about who this role is for or what permissions it grants.'
          },
          base_role: {
            type: 'string',
            enum: ['read', 'triage', 'write', 'maintain'],
            description:
              'The system role from which this role inherits permissions.'
          },
          permissions: {
            type: 'array',
            description:
              'A list of additional permissions included in this role. If specified, these permissions will replace any currently set on the role.',
            items: { type: 'string' }
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' }, role_id: { type: 'integer' } },
        required: ['org', 'role_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsUpdateCustomRole'];

      if (!handler) {
        return next(new Error('/orgs/:org/custom_roles/:role_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsUpdateCustomRoleRequest,
          res as OrgsUpdateCustomRoleResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/custom_roles/:role_id',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, role_id: { type: 'integer' } },
        required: ['org', 'role_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsDeleteCustomRole'];

      if (!handler) {
        return next(new Error('/orgs/:org/custom_roles/:role_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsDeleteCustomRoleRequest,
          res as OrgsDeleteCustomRoleResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/dependabot/alerts',

    validate({
      query: {
        type: 'object',
        properties: {
          state: { type: 'string' },
          severity: { type: 'string' },
          ecosystem: { type: 'string' },
          package: { type: 'string' },
          scope: { type: 'string', enum: ['development', 'runtime'] },
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          before: { type: 'string' },
          after: { type: 'string' },
          first: { type: 'integer', minimum: 1, maximum: 100, default: 30 },
          last: { type: 'integer', minimum: 1, maximum: 100 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotListAlertsForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/dependabot/alerts not handled'));
      }

      try {
        await handler(
          (req as unknown) as DependabotListAlertsForOrgRequest,
          res as DependabotListAlertsForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/dependabot/secrets',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotListOrgSecrets'];

      if (!handler) {
        return next(new Error('/orgs/:org/dependabot/secrets not handled'));
      }

      try {
        await handler(
          (req as unknown) as DependabotListOrgSecretsRequest,
          res as DependabotListOrgSecretsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/dependabot/secrets/public-key',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotGetOrgPublicKey'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/dependabot/secrets/public-key not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotGetOrgPublicKeyRequest,
          res as DependabotGetOrgPublicKeyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/dependabot/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotGetOrgSecret'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/dependabot/secrets/:secret_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotGetOrgSecretRequest,
          res as DependabotGetOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/dependabot/secrets/:secret_name',

    validate({
      body: {
        type: 'object',
        properties: {
          encrypted_value: {
            type: 'string',
            description:
              'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/reference/dependabot#get-an-organization-public-key) endpoint.',
            pattern:
              '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          },
          key_id: {
            type: 'string',
            description: 'ID of the key you used to encrypt the secret.'
          },
          visibility: {
            type: 'string',
            description:
              'Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.',
            enum: ['all', 'private', 'selected']
          },
          selected_repository_ids: {
            type: 'array',
            description:
              'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/reference/dependabot#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/reference/dependabot#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/reference/dependabot#remove-selected-repository-from-an-organization-secret) endpoints.',
            items: { type: 'string' }
          }
        },
        required: ['visibility']
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotCreateOrUpdateOrgSecret'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/dependabot/secrets/:secret_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotCreateOrUpdateOrgSecretRequest,
          res as DependabotCreateOrUpdateOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/dependabot/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotDeleteOrgSecret'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/dependabot/secrets/:secret_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotDeleteOrgSecretRequest,
          res as DependabotDeleteOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/dependabot/secrets/:secret_name/repositories',

    validate({
      query: {
        type: 'object',
        properties: {
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotListSelectedReposForOrgSecret'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/dependabot/secrets/:secret_name/repositories not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotListSelectedReposForOrgSecretRequest,
          res as DependabotListSelectedReposForOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/dependabot/secrets/:secret_name/repositories',

    validate({
      body: {
        type: 'object',
        properties: {
          selected_repository_ids: {
            type: 'array',
            description:
              'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/reference/dependabot#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/reference/dependabot#remove-selected-repository-from-an-organization-secret) endpoints.',
            items: { type: 'integer' }
          }
        },
        required: ['selected_repository_ids']
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['org', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotSetSelectedReposForOrgSecret'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/dependabot/secrets/:secret_name/repositories not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotSetSelectedReposForOrgSecretRequest,
          res as DependabotSetSelectedReposForOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/dependabot/secrets/:secret_name/repositories/:repository_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' },
          repository_id: { type: 'integer' }
        },
        required: ['org', 'secret_name', 'repository_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotAddSelectedRepoToOrgSecret'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/dependabot/secrets/:secret_name/repositories/:repository_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotAddSelectedRepoToOrgSecretRequest,
          res as DependabotAddSelectedRepoToOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/dependabot/secrets/:secret_name/repositories/:repository_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          secret_name: { type: 'string' },
          repository_id: { type: 'integer' }
        },
        required: ['org', 'secret_name', 'repository_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotRemoveSelectedRepoFromOrgSecret'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/dependabot/secrets/:secret_name/repositories/:repository_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotRemoveSelectedRepoFromOrgSecretRequest,
          res as DependabotRemoveSelectedRepoFromOrgSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/events',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListPublicOrgEvents'];

      if (!handler) {
        return next(new Error('/orgs/:org/events not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListPublicOrgEventsRequest,
          res as ActivityListPublicOrgEventsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/failed_invitations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListFailedInvitations'];

      if (!handler) {
        return next(new Error('/orgs/:org/failed_invitations not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsListFailedInvitationsRequest,
          res as OrgsListFailedInvitationsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/fine_grained_permissions',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListFineGrainedPermissions'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/fine_grained_permissions not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsListFineGrainedPermissionsRequest,
          res as OrgsListFineGrainedPermissionsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/hooks',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListWebhooks'];

      if (!handler) {
        return next(new Error('/orgs/:org/hooks not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsListWebhooksRequest,
          res as OrgsListWebhooksResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/hooks',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { type: 'string', description: 'Must be passed as "web".' },
          config: {
            type: 'object',
            description:
              'Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#create-hook-config-params).',
            properties: {
              url: { $ref: '#/definitions/webhook-config-url' },
              content_type: {
                $ref: '#/definitions/webhook-config-content-type'
              },
              secret: { $ref: '#/definitions/webhook-config-secret' },
              insecure_ssl: {
                $ref: '#/definitions/webhook-config-insecure-ssl'
              },
              username: { type: 'string', example: '"kdaigle"' },
              password: { type: 'string', example: '"password"' }
            },
            required: ['url']
          },
          events: {
            type: 'array',
            description:
              'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. Set to `["*"]` to receive all possible events.',
            default: ['push'],
            items: { type: 'string' }
          },
          active: {
            type: 'boolean',
            description:
              'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.',
            default: true
          }
        },
        required: ['name', 'config'],
        definitions: {
          'webhook-config-url': {
            type: 'string',
            description: 'The URL to which the payloads will be delivered.',
            example: 'https://example.com/webhook',
            format: 'uri',
            title: 'webhook-config-url'
          },
          'webhook-config-content-type': {
            type: 'string',
            description:
              'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
            example: '"json"',
            title: 'webhook-config-content-type'
          },
          'webhook-config-secret': {
            type: 'string',
            description:
              'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
            example: '"********"',
            title: 'webhook-config-secret'
          },
          'webhook-config-insecure-ssl': {
            oneOf: [
              {
                type: 'string',
                description:
                  'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                example: '"0"'
              },
              { type: 'number' }
            ],
            title: 'webhook-config-insecure-ssl'
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsCreateWebhook'];

      if (!handler) {
        return next(new Error('/orgs/:org/hooks not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsCreateWebhookRequest,
          res as OrgsCreateWebhookResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/hooks/:hook_id',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
        required: ['org', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsGetWebhook'];

      if (!handler) {
        return next(new Error('/orgs/:org/hooks/:hook_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsGetWebhookRequest,
          res as OrgsGetWebhookResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/orgs/:org/hooks/:hook_id',

    validate({
      body: {
        type: 'object',
        properties: {
          config: {
            type: 'object',
            description:
              'Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#update-hook-config-params).',
            properties: {
              url: { $ref: '#/definitions/webhook-config-url' },
              content_type: {
                $ref: '#/definitions/webhook-config-content-type'
              },
              secret: { $ref: '#/definitions/webhook-config-secret' },
              insecure_ssl: {
                $ref: '#/definitions/webhook-config-insecure-ssl'
              }
            },
            required: ['url']
          },
          events: {
            type: 'array',
            description:
              'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.',
            default: ['push'],
            items: { type: 'string' }
          },
          active: {
            type: 'boolean',
            description:
              'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.',
            default: true
          },
          name: { type: 'string', example: '"web"' }
        },
        definitions: {
          'webhook-config-url': {
            type: 'string',
            description: 'The URL to which the payloads will be delivered.',
            example: 'https://example.com/webhook',
            format: 'uri',
            title: 'webhook-config-url'
          },
          'webhook-config-content-type': {
            type: 'string',
            description:
              'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
            example: '"json"',
            title: 'webhook-config-content-type'
          },
          'webhook-config-secret': {
            type: 'string',
            description:
              'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
            example: '"********"',
            title: 'webhook-config-secret'
          },
          'webhook-config-insecure-ssl': {
            oneOf: [
              {
                type: 'string',
                description:
                  'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                example: '"0"'
              },
              { type: 'number' }
            ],
            title: 'webhook-config-insecure-ssl'
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
        required: ['org', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsUpdateWebhook'];

      if (!handler) {
        return next(new Error('/orgs/:org/hooks/:hook_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsUpdateWebhookRequest,
          res as OrgsUpdateWebhookResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/hooks/:hook_id',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
        required: ['org', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsDeleteWebhook'];

      if (!handler) {
        return next(new Error('/orgs/:org/hooks/:hook_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsDeleteWebhookRequest,
          res as OrgsDeleteWebhookResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/hooks/:hook_id/config',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
        required: ['org', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsGetWebhookConfigForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/hooks/:hook_id/config not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsGetWebhookConfigForOrgRequest,
          res as OrgsGetWebhookConfigForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/orgs/:org/hooks/:hook_id/config',

    validate({
      body: {
        type: 'object',
        properties: {
          url: { $ref: '#/definitions/webhook-config-url' },
          content_type: { $ref: '#/definitions/webhook-config-content-type' },
          secret: { $ref: '#/definitions/webhook-config-secret' },
          insecure_ssl: { $ref: '#/definitions/webhook-config-insecure-ssl' }
        },
        definitions: {
          'webhook-config-url': {
            type: 'string',
            description: 'The URL to which the payloads will be delivered.',
            example: 'https://example.com/webhook',
            format: 'uri',
            title: 'webhook-config-url'
          },
          'webhook-config-content-type': {
            type: 'string',
            description:
              'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
            example: '"json"',
            title: 'webhook-config-content-type'
          },
          'webhook-config-secret': {
            type: 'string',
            description:
              'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
            example: '"********"',
            title: 'webhook-config-secret'
          },
          'webhook-config-insecure-ssl': {
            oneOf: [
              {
                type: 'string',
                description:
                  'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                example: '"0"'
              },
              { type: 'number' }
            ],
            title: 'webhook-config-insecure-ssl'
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
        required: ['org', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsUpdateWebhookConfigForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/hooks/:hook_id/config not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsUpdateWebhookConfigForOrgRequest,
          res as OrgsUpdateWebhookConfigForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/hooks/:hook_id/deliveries',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          cursor: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
        required: ['org', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListWebhookDeliveries'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/hooks/:hook_id/deliveries not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsListWebhookDeliveriesRequest,
          res as OrgsListWebhookDeliveriesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/hooks/:hook_id/deliveries/:delivery_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          hook_id: { type: 'integer' },
          delivery_id: { type: 'integer' }
        },
        required: ['org', 'hook_id', 'delivery_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsGetWebhookDelivery'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/hooks/:hook_id/deliveries/:delivery_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsGetWebhookDeliveryRequest,
          res as OrgsGetWebhookDeliveryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/hooks/:hook_id/deliveries/:delivery_id/attempts',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          hook_id: { type: 'integer' },
          delivery_id: { type: 'integer' }
        },
        required: ['org', 'hook_id', 'delivery_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsRedeliverWebhookDelivery'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/hooks/:hook_id/deliveries/:delivery_id/attempts not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsRedeliverWebhookDeliveryRequest,
          res as OrgsRedeliverWebhookDeliveryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/hooks/:hook_id/pings',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
        required: ['org', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsPingWebhook'];

      if (!handler) {
        return next(new Error('/orgs/:org/hooks/:hook_id/pings not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsPingWebhookRequest,
          res as OrgsPingWebhookResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/installation',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsGetOrgInstallation'];

      if (!handler) {
        return next(new Error('/orgs/:org/installation not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsGetOrgInstallationRequest,
          res as AppsGetOrgInstallationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/installations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListAppInstallations'];

      if (!handler) {
        return next(new Error('/orgs/:org/installations not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsListAppInstallationsRequest,
          res as OrgsListAppInstallationsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/interaction-limits',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['interactionsGetRestrictionsForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/interaction-limits not handled'));
      }

      try {
        await handler(
          (req as unknown) as InteractionsGetRestrictionsForOrgRequest,
          res as InteractionsGetRestrictionsForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/interaction-limits',

    validate({
      body: {
        $ref: '#/definitions/interaction-limit',
        definitions: {
          'interaction-limit': {
            title: 'Interaction Restrictions',
            description:
              'Limit interactions to a specific type of user for a specified duration',
            type: 'object',
            properties: {
              limit: { $ref: '#/definitions/interaction-group' },
              expiry: { $ref: '#/definitions/interaction-expiry' }
            },
            required: ['limit']
          },
          'interaction-group': {
            type: 'string',
            description:
              'The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.',
            example: 'collaborators_only',
            enum: ['existing_users', 'contributors_only', 'collaborators_only'],
            title: 'interaction-group'
          },
          'interaction-expiry': {
            type: 'string',
            description:
              'The duration of the interaction restriction. Default: `one_day`.',
            example: 'one_month',
            enum: [
              'one_day',
              'three_days',
              'one_week',
              'one_month',
              'six_months'
            ],
            title: 'interaction-expiry'
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['interactionsSetRestrictionsForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/interaction-limits not handled'));
      }

      try {
        await handler(
          (req as unknown) as InteractionsSetRestrictionsForOrgRequest,
          res as InteractionsSetRestrictionsForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/interaction-limits',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['interactionsRemoveRestrictionsForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/interaction-limits not handled'));
      }

      try {
        await handler(
          (req as unknown) as InteractionsRemoveRestrictionsForOrgRequest,
          res as InteractionsRemoveRestrictionsForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/invitations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListPendingInvitations'];

      if (!handler) {
        return next(new Error('/orgs/:org/invitations not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsListPendingInvitationsRequest,
          res as OrgsListPendingInvitationsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/invitations',

    validate({
      body: {
        type: 'object',
        properties: {
          invitee_id: {
            type: 'integer',
            description:
              '**Required unless you provide `email`**. GitHub user ID for the person you are inviting.'
          },
          email: {
            type: 'string',
            description:
              '**Required unless you provide `invitee_id`**. Email address of the person you are inviting, which can be an existing GitHub user.'
          },
          role: {
            type: 'string',
            description:
              'The role for the new member. \n\\* `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.  \n\\* `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.  \n\\* `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization.',
            enum: ['admin', 'direct_member', 'billing_manager'],
            default: 'direct_member'
          },
          team_ids: {
            type: 'array',
            description:
              'Specify IDs for the teams you want to invite new members to.',
            items: { type: 'integer' }
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsCreateInvitation'];

      if (!handler) {
        return next(new Error('/orgs/:org/invitations not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsCreateInvitationRequest,
          res as OrgsCreateInvitationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/invitations/:invitation_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          invitation_id: { type: 'integer' }
        },
        required: ['org', 'invitation_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsCancelInvitation'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/invitations/:invitation_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsCancelInvitationRequest,
          res as OrgsCancelInvitationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/invitations/:invitation_id/teams',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          invitation_id: { type: 'integer' }
        },
        required: ['org', 'invitation_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListInvitationTeams'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/invitations/:invitation_id/teams not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsListInvitationTeamsRequest,
          res as OrgsListInvitationTeamsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/issues',

    validate({
      query: {
        type: 'object',
        properties: {
          filter: {
            type: 'string',
            enum: [
              'assigned',
              'created',
              'mentioned',
              'subscribed',
              'repos',
              'all'
            ],
            default: 'assigned'
          },
          state: {
            type: 'string',
            enum: ['open', 'closed', 'all'],
            default: 'open'
          },
          labels: { type: 'string' },
          sort: {
            type: 'string',
            enum: ['created', 'updated', 'comments'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          since: { type: 'string', format: 'date-time' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesListForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/issues not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesListForOrgRequest,
          res as IssuesListForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/members',

    validate({
      query: {
        type: 'object',
        properties: {
          filter: {
            type: 'string',
            enum: ['2fa_disabled', 'all'],
            default: 'all'
          },
          role: {
            type: 'string',
            enum: ['all', 'admin', 'member'],
            default: 'all'
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListMembers'];

      if (!handler) {
        return next(new Error('/orgs/:org/members not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsListMembersRequest,
          res as OrgsListMembersResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/members/:username',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsCheckMembershipForUser'];

      if (!handler) {
        return next(new Error('/orgs/:org/members/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsCheckMembershipForUserRequest,
          res as OrgsCheckMembershipForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/members/:username',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsRemoveMember'];

      if (!handler) {
        return next(new Error('/orgs/:org/members/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsRemoveMemberRequest,
          res as OrgsRemoveMemberResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/members/:username/codespaces',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesGetCodespacesForUserInOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/members/:username/codespaces not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesGetCodespacesForUserInOrgRequest,
          res as CodespacesGetCodespacesForUserInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/members/:username/codespaces/:codespace_name',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          username: { type: 'string' },
          codespace_name: { type: 'string' }
        },
        required: ['org', 'username', 'codespace_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesDeleteFromOrganization'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/members/:username/codespaces/:codespace_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesDeleteFromOrganizationRequest,
          res as CodespacesDeleteFromOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/members/:username/codespaces/:codespace_name/stop',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          username: { type: 'string' },
          codespace_name: { type: 'string' }
        },
        required: ['org', 'username', 'codespace_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesStopInOrganization'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/members/:username/codespaces/:codespace_name/stop not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesStopInOrganizationRequest,
          res as CodespacesStopInOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/memberships/:username',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsGetMembershipForUser'];

      if (!handler) {
        return next(new Error('/orgs/:org/memberships/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsGetMembershipForUserRequest,
          res as OrgsGetMembershipForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/memberships/:username',

    validate({
      body: {
        type: 'object',
        properties: {
          role: {
            type: 'string',
            description:
              'The role to give the user in the organization. Can be one of:  \n\\* `admin` - The user will become an owner of the organization.  \n\\* `member` - The user will become a non-owner member of the organization.',
            enum: ['admin', 'member'],
            default: 'member'
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsSetMembershipForUser'];

      if (!handler) {
        return next(new Error('/orgs/:org/memberships/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsSetMembershipForUserRequest,
          res as OrgsSetMembershipForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/memberships/:username',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsRemoveMembershipForUser'];

      if (!handler) {
        return next(new Error('/orgs/:org/memberships/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsRemoveMembershipForUserRequest,
          res as OrgsRemoveMembershipForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/migrations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 },
          exclude: {
            anyOf: [
              {
                type: 'array',
                items: {
                  description:
                    'Allowed values that can be passed to the exclude param.',
                  enum: ['repositories'],
                  example: 'repositories',
                  type: 'string'
                }
              },
              {
                description:
                  'Allowed values that can be passed to the exclude param.',
                enum: ['repositories'],
                example: 'repositories',
                type: 'string'
              }
            ]
          }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsListForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/migrations not handled'));
      }

      try {
        await handler(
          (req as unknown) as MigrationsListForOrgRequest,
          res as MigrationsListForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/migrations',

    validate({
      body: {
        type: 'object',
        properties: {
          repositories: {
            type: 'array',
            description:
              'A list of arrays indicating which repositories should be migrated.',
            items: { type: 'string' }
          },
          lock_repositories: {
            type: 'boolean',
            example: true,
            description:
              'Indicates whether repositories should be locked (to prevent manipulation) while migrating data.',
            default: false
          },
          exclude_metadata: {
            type: 'boolean',
            description:
              'Indicates whether metadata should be excluded and only git source should be included for the migration.',
            default: false
          },
          exclude_git_data: {
            type: 'boolean',
            description:
              'Indicates whether the repository git data should be excluded from the migration.',
            default: false
          },
          exclude_attachments: {
            type: 'boolean',
            example: true,
            description:
              'Indicates whether attachments should be excluded from the migration (to reduce migration archive file size).',
            default: false
          },
          exclude_releases: {
            type: 'boolean',
            example: true,
            description:
              'Indicates whether releases should be excluded from the migration (to reduce migration archive file size).',
            default: false
          },
          exclude_owner_projects: {
            type: 'boolean',
            example: true,
            description:
              'Indicates whether projects owned by the organization or users should be excluded. from the migration.',
            default: false
          },
          org_metadata_only: {
            type: 'boolean',
            example: true,
            description:
              'Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).',
            default: false
          },
          exclude: {
            type: 'array',
            description:
              'Exclude related items from being returned in the response in order to improve performance of the request. The array can include any of: `"repositories"`.',
            items: { type: 'string', enum: ['repositories'] }
          }
        },
        required: ['repositories']
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsStartForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/migrations not handled'));
      }

      try {
        await handler(
          (req as unknown) as MigrationsStartForOrgRequest,
          res as MigrationsStartForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/migrations/:migration_id',

    validate({
      query: {
        type: 'object',
        properties: {
          exclude: {
            anyOf: [
              {
                type: 'array',
                items: {
                  description:
                    'Allowed values that can be passed to the exclude param.',
                  enum: ['repositories'],
                  example: 'repositories',
                  type: 'string'
                }
              },
              {
                description:
                  'Allowed values that can be passed to the exclude param.',
                enum: ['repositories'],
                example: 'repositories',
                type: 'string'
              }
            ]
          }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          migration_id: { type: 'integer' }
        },
        required: ['org', 'migration_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsGetStatusForOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/migrations/:migration_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as MigrationsGetStatusForOrgRequest,
          res as MigrationsGetStatusForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/migrations/:migration_id/archive',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          migration_id: { type: 'integer' }
        },
        required: ['org', 'migration_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsDownloadArchiveForOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/migrations/:migration_id/archive not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as MigrationsDownloadArchiveForOrgRequest,
          res as MigrationsDownloadArchiveForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/migrations/:migration_id/archive',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          migration_id: { type: 'integer' }
        },
        required: ['org', 'migration_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsDeleteArchiveForOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/migrations/:migration_id/archive not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as MigrationsDeleteArchiveForOrgRequest,
          res as MigrationsDeleteArchiveForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/migrations/:migration_id/repos/:repo_name/lock',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          migration_id: { type: 'integer' },
          repo_name: { type: 'string' }
        },
        required: ['org', 'migration_id', 'repo_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsUnlockRepoForOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/migrations/:migration_id/repos/:repo_name/lock not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as MigrationsUnlockRepoForOrgRequest,
          res as MigrationsUnlockRepoForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/migrations/:migration_id/repositories',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          migration_id: { type: 'integer' }
        },
        required: ['org', 'migration_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsListReposForOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/migrations/:migration_id/repositories not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as MigrationsListReposForOrgRequest,
          res as MigrationsListReposForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/outside_collaborators',

    validate({
      query: {
        type: 'object',
        properties: {
          filter: {
            type: 'string',
            enum: ['2fa_disabled', 'all'],
            default: 'all'
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListOutsideCollaborators'];

      if (!handler) {
        return next(new Error('/orgs/:org/outside_collaborators not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsListOutsideCollaboratorsRequest,
          res as OrgsListOutsideCollaboratorsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/outside_collaborators/:username',

    validate({
      body: {
        type: 'object',
        properties: {
          async: {
            type: 'boolean',
            description:
              'When set to `true`, the request will be performed asynchronously. Returns a 202 status code when the job is successfully queued.',
            default: false
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsConvertMemberToOutsideCollaborator'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/outside_collaborators/:username not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsConvertMemberToOutsideCollaboratorRequest,
          res as OrgsConvertMemberToOutsideCollaboratorResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/outside_collaborators/:username',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsRemoveOutsideCollaborator'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/outside_collaborators/:username not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsRemoveOutsideCollaboratorRequest,
          res as OrgsRemoveOutsideCollaboratorResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/packages',

    validate({
      query: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          visibility: {
            type: 'string',
            enum: ['public', 'private', 'internal']
          }
        },
        required: ['package_type']
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesListPackagesForOrganization'];

      if (!handler) {
        return next(new Error('/orgs/:org/packages not handled'));
      }

      try {
        await handler(
          (req as unknown) as PackagesListPackagesForOrganizationRequest,
          res as PackagesListPackagesForOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/packages/:package_type/:package_name',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          org: { type: 'string' }
        },
        required: ['package_type', 'package_name', 'org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesGetPackageForOrganization'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/packages/:package_type/:package_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesGetPackageForOrganizationRequest,
          res as PackagesGetPackageForOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/packages/:package_type/:package_name',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          org: { type: 'string' }
        },
        required: ['package_type', 'package_name', 'org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesDeletePackageForOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/packages/:package_type/:package_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesDeletePackageForOrgRequest,
          res as PackagesDeletePackageForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/packages/:package_type/:package_name/restore',

    validate({
      query: {
        type: 'object',
        properties: { token: { type: 'string' } },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          org: { type: 'string' }
        },
        required: ['package_type', 'package_name', 'org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesRestorePackageForOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/packages/:package_type/:package_name/restore not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesRestorePackageForOrgRequest,
          res as PackagesRestorePackageForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/packages/:package_type/:package_name/versions',

    validate({
      query: {
        type: 'object',
        properties: {
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 },
          state: {
            type: 'string',
            enum: ['active', 'deleted'],
            default: 'active'
          }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          org: { type: 'string' }
        },
        required: ['package_type', 'package_name', 'org']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['packagesGetAllPackageVersionsForPackageOwnedByOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/packages/:package_type/:package_name/versions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesGetAllPackageVersionsForPackageOwnedByOrgRequest,
          res as PackagesGetAllPackageVersionsForPackageOwnedByOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          org: { type: 'string' },
          package_version_id: { type: 'integer' }
        },
        required: ['package_type', 'package_name', 'org', 'package_version_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesGetPackageVersionForOrganization'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesGetPackageVersionForOrganizationRequest,
          res as PackagesGetPackageVersionForOrganizationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          org: { type: 'string' },
          package_version_id: { type: 'integer' }
        },
        required: ['package_type', 'package_name', 'org', 'package_version_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesDeletePackageVersionForOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesDeletePackageVersionForOrgRequest,
          res as PackagesDeletePackageVersionForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id/restore',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          org: { type: 'string' },
          package_version_id: { type: 'integer' }
        },
        required: ['package_type', 'package_name', 'org', 'package_version_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesRestorePackageVersionForOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id/restore not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesRestorePackageVersionForOrgRequest,
          res as PackagesRestorePackageVersionForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/projects',

    validate({
      query: {
        type: 'object',
        properties: {
          state: {
            type: 'string',
            enum: ['open', 'closed', 'all'],
            default: 'open'
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsListForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/projects not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsListForOrgRequest,
          res as ProjectsListForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/projects',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { type: 'string', description: 'The name of the project.' },
          body: {
            type: 'string',
            description: 'The description of the project.'
          }
        },
        required: ['name']
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsCreateForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/projects not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsCreateForOrgRequest,
          res as ProjectsCreateForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/public_members',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListPublicMembers'];

      if (!handler) {
        return next(new Error('/orgs/:org/public_members not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsListPublicMembersRequest,
          res as OrgsListPublicMembersResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/public_members/:username',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsCheckPublicMembershipForUser'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/public_members/:username not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsCheckPublicMembershipForUserRequest,
          res as OrgsCheckPublicMembershipForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/public_members/:username',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsSetPublicMembershipForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/public_members/:username not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsSetPublicMembershipForAuthenticatedUserRequest,
          res as OrgsSetPublicMembershipForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/public_members/:username',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, username: { type: 'string' } },
        required: ['org', 'username']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['orgsRemovePublicMembershipForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/public_members/:username not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsRemovePublicMembershipForAuthenticatedUserRequest,
          res as OrgsRemovePublicMembershipForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/repos',

    validate({
      query: {
        type: 'object',
        properties: {
          type: {
            type: 'string',
            enum: [
              'all',
              'public',
              'private',
              'forks',
              'sources',
              'member',
              'internal'
            ]
          },
          sort: {
            type: 'string',
            enum: ['created', 'updated', 'pushed', 'full_name'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'] },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/repos not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListForOrgRequest,
          res as ReposListForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/repos',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { type: 'string', description: 'The name of the repository.' },
          description: {
            type: 'string',
            description: 'A short description of the repository.'
          },
          homepage: {
            type: 'string',
            description: 'A URL with more information about the repository.'
          },
          private: {
            type: 'boolean',
            description: 'Whether the repository is private.',
            default: false
          },
          visibility: {
            type: 'string',
            description:
              'Can be `public` or `private`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `visibility` can also be `internal`. Note: For GitHub Enterprise Server and GitHub AE, this endpoint will only list repositories available to all users on the enterprise. For more information, see "[Creating an internal repository](https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)" in the GitHub Help documentation.',
            enum: ['public', 'private', 'internal']
          },
          has_issues: {
            type: 'boolean',
            description:
              'Either `true` to enable issues for this repository or `false` to disable them.',
            default: true
          },
          has_projects: {
            type: 'boolean',
            description:
              "Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.",
            default: true
          },
          has_wiki: {
            type: 'boolean',
            description:
              'Either `true` to enable the wiki for this repository or `false` to disable it.',
            default: true
          },
          is_template: {
            type: 'boolean',
            description:
              'Either `true` to make this repo available as a template repository or `false` to prevent it.',
            default: false
          },
          team_id: {
            type: 'integer',
            description:
              'The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.'
          },
          auto_init: {
            type: 'boolean',
            description:
              'Pass `true` to create an initial commit with empty README.',
            default: false
          },
          gitignore_template: {
            type: 'string',
            description:
              'Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell".'
          },
          license_template: {
            type: 'string',
            description:
              'Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0".'
          },
          allow_squash_merge: {
            type: 'boolean',
            description:
              'Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.',
            default: true
          },
          allow_merge_commit: {
            type: 'boolean',
            description:
              'Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.',
            default: true
          },
          allow_rebase_merge: {
            type: 'boolean',
            description:
              'Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.',
            default: true
          },
          allow_auto_merge: {
            type: 'boolean',
            description:
              'Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.',
            default: false
          },
          delete_branch_on_merge: {
            type: 'boolean',
            description:
              'Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.',
            default: false
          },
          use_squash_pr_title_as_default: {
            type: 'boolean',
            description:
              'Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property has been deprecated. Please use `squash_merge_commit_title` instead.',
            default: false,
            deprecated: true
          },
          squash_merge_commit_title: {
            type: 'string',
            enum: ['PR_TITLE', 'COMMIT_OR_PR_TITLE'],
            description:
              "The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
          },
          squash_merge_commit_message: {
            type: 'string',
            enum: ['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'],
            description:
              "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
          },
          merge_commit_title: {
            type: 'string',
            enum: ['PR_TITLE', 'MERGE_MESSAGE'],
            description:
              "The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
          },
          merge_commit_message: {
            type: 'string',
            enum: ['PR_BODY', 'PR_TITLE', 'BLANK'],
            description:
              "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
          }
        },
        required: ['name']
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateInOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/repos not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposCreateInOrgRequest,
          res as ReposCreateInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/secret-scanning/alerts',

    validate({
      query: {
        type: 'object',
        properties: {
          state: { type: 'string', enum: ['open', 'resolved'] },
          secret_type: { type: 'string' },
          resolution: { type: 'string' },
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 },
          before: { type: 'string' },
          after: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['secretScanningListAlertsForOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/secret-scanning/alerts not handled'));
      }

      try {
        await handler(
          (req as unknown) as SecretScanningListAlertsForOrgRequest,
          res as SecretScanningListAlertsForOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/security-managers',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListSecurityManagerTeams'];

      if (!handler) {
        return next(new Error('/orgs/:org/security-managers not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsListSecurityManagerTeamsRequest,
          res as OrgsListSecurityManagerTeamsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/security-managers/teams/:team_slug',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, team_slug: { type: 'string' } },
        required: ['org', 'team_slug']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsAddSecurityManagerTeam'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/security-managers/teams/:team_slug not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsAddSecurityManagerTeamRequest,
          res as OrgsAddSecurityManagerTeamResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/security-managers/teams/:team_slug',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, team_slug: { type: 'string' } },
        required: ['org', 'team_slug']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsRemoveSecurityManagerTeam'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/security-managers/teams/:team_slug not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsRemoveSecurityManagerTeamRequest,
          res as OrgsRemoveSecurityManagerTeamResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/settings/billing/actions',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['billingGetGithubActionsBillingOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/settings/billing/actions not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as BillingGetGithubActionsBillingOrgRequest,
          res as BillingGetGithubActionsBillingOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/settings/billing/advanced-security',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['billingGetGithubAdvancedSecurityBillingOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/settings/billing/advanced-security not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as BillingGetGithubAdvancedSecurityBillingOrgRequest,
          res as BillingGetGithubAdvancedSecurityBillingOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/settings/billing/packages',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['billingGetGithubPackagesBillingOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/settings/billing/packages not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as BillingGetGithubPackagesBillingOrgRequest,
          res as BillingGetGithubPackagesBillingOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/settings/billing/shared-storage',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['billingGetSharedStorageBillingOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/settings/billing/shared-storage not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as BillingGetSharedStorageBillingOrgRequest,
          res as BillingGetSharedStorageBillingOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsList'];

      if (!handler) {
        return next(new Error('/orgs/:org/teams not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsListRequest,
          res as TeamsListResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/teams',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { type: 'string', description: 'The name of the team.' },
          description: {
            type: 'string',
            description: 'The description of the team.'
          },
          maintainers: {
            type: 'array',
            description:
              'List GitHub IDs for organization members who will become team maintainers.',
            items: { type: 'string' }
          },
          repo_names: {
            type: 'array',
            description:
              'The full name (e.g., "organization-name/repository-name") of repositories to add the team to.',
            items: { type: 'string' }
          },
          privacy: {
            type: 'string',
            description:
              'The level of privacy this team should have. The options are:  \n**For a non-nested team:**  \n\\* `secret` - only visible to organization owners and members of this team.  \n\\* `closed` - visible to all members of this organization.  \nDefault: `secret`  \n**For a parent or child team:**  \n\\* `closed` - visible to all members of this organization.  \nDefault for child team: `closed`',
            enum: ['secret', 'closed']
          },
          permission: {
            type: 'string',
            description:
              '**Deprecated**. The permission that new repositories will be added to the team with when none is specified.',
            enum: ['pull', 'push'],
            default: 'pull'
          },
          parent_team_id: {
            type: 'integer',
            description: 'The ID of a team to set as the parent team.'
          }
        },
        required: ['name']
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsCreate'];

      if (!handler) {
        return next(new Error('/orgs/:org/teams not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsCreateRequest,
          res as TeamsCreateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, team_slug: { type: 'string' } },
        required: ['org', 'team_slug']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsGetByName'];

      if (!handler) {
        return next(new Error('/orgs/:org/teams/:team_slug not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsGetByNameRequest,
          res as TeamsGetByNameResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/orgs/:org/teams/:team_slug',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { type: 'string', description: 'The name of the team.' },
          description: {
            type: 'string',
            description: 'The description of the team.'
          },
          privacy: {
            type: 'string',
            description:
              'The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. When a team is nested, the `privacy` for parent teams cannot be `secret`. The options are:  \n**For a non-nested team:**  \n\\* `secret` - only visible to organization owners and members of this team.  \n\\* `closed` - visible to all members of this organization.  \n**For a parent or child team:**  \n\\* `closed` - visible to all members of this organization.',
            enum: ['secret', 'closed']
          },
          permission: {
            type: 'string',
            description:
              '**Deprecated**. The permission that new repositories will be added to the team with when none is specified.',
            enum: ['pull', 'push', 'admin'],
            default: 'pull'
          },
          parent_team_id: {
            type: 'integer',
            description: 'The ID of a team to set as the parent team.',
            nullable: true
          }
        }
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' }, team_slug: { type: 'string' } },
        required: ['org', 'team_slug']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsUpdateInOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/teams/:team_slug not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsUpdateInOrgRequest,
          res as TeamsUpdateInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/teams/:team_slug',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, team_slug: { type: 'string' } },
        required: ['org', 'team_slug']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsDeleteInOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/teams/:team_slug not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsDeleteInOrgRequest,
          res as TeamsDeleteInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/discussions',

    validate({
      query: {
        type: 'object',
        properties: {
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 },
          pinned: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, team_slug: { type: 'string' } },
        required: ['org', 'team_slug']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListDiscussionsInOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/teams/:team_slug/discussions not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsListDiscussionsInOrgRequest,
          res as TeamsListDiscussionsInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/teams/:team_slug/discussions',

    validate({
      body: {
        type: 'object',
        properties: {
          title: {
            type: 'string',
            description: "The discussion post's title."
          },
          body: {
            type: 'string',
            description: "The discussion post's body text."
          },
          private: {
            type: 'boolean',
            description:
              'Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.',
            default: false
          }
        },
        required: ['title', 'body']
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' }, team_slug: { type: 'string' } },
        required: ['org', 'team_slug']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsCreateDiscussionInOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/teams/:team_slug/discussions not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsCreateDiscussionInOrgRequest,
          res as TeamsCreateDiscussionInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsGetDiscussionInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsGetDiscussionInOrgRequest,
          res as TeamsGetDiscussionInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number',

    validate({
      body: {
        type: 'object',
        properties: {
          title: {
            type: 'string',
            description: "The discussion post's title."
          },
          body: {
            type: 'string',
            description: "The discussion post's body text."
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsUpdateDiscussionInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsUpdateDiscussionInOrgRequest,
          res as TeamsUpdateDiscussionInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsDeleteDiscussionInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsDeleteDiscussionInOrgRequest,
          res as TeamsDeleteDiscussionInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments',

    validate({
      query: {
        type: 'object',
        properties: {
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListDiscussionCommentsInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsListDiscussionCommentsInOrgRequest,
          res as TeamsListDiscussionCommentsInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments',

    validate({
      body: {
        type: 'object',
        properties: {
          body: {
            type: 'string',
            description: "The discussion comment's body text."
          }
        },
        required: ['body']
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsCreateDiscussionCommentInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsCreateDiscussionCommentInOrgRequest,
          res as TeamsCreateDiscussionCommentInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' },
          comment_number: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'discussion_number', 'comment_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsGetDiscussionCommentInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsGetDiscussionCommentInOrgRequest,
          res as TeamsGetDiscussionCommentInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number',

    validate({
      body: {
        type: 'object',
        properties: {
          body: {
            type: 'string',
            description: "The discussion comment's body text."
          }
        },
        required: ['body']
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' },
          comment_number: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'discussion_number', 'comment_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsUpdateDiscussionCommentInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsUpdateDiscussionCommentInOrgRequest,
          res as TeamsUpdateDiscussionCommentInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' },
          comment_number: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'discussion_number', 'comment_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsDeleteDiscussionCommentInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsDeleteDiscussionCommentInOrgRequest,
          res as TeamsDeleteDiscussionCommentInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions',

    validate({
      query: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' },
          comment_number: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'discussion_number', 'comment_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsListForTeamDiscussionCommentInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsListForTeamDiscussionCommentInOrgRequest,
          res as ReactionsListForTeamDiscussionCommentInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions',

    validate({
      body: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            description:
              'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion comment.',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          }
        },
        required: ['content']
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' },
          comment_number: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'discussion_number', 'comment_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsCreateForTeamDiscussionCommentInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsCreateForTeamDiscussionCommentInOrgRequest,
          res as ReactionsCreateForTeamDiscussionCommentInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' },
          comment_number: { type: 'integer' },
          reaction_id: { type: 'integer' }
        },
        required: [
          'org',
          'team_slug',
          'discussion_number',
          'comment_number',
          'reaction_id'
        ]
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsDeleteForTeamDiscussionComment'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsDeleteForTeamDiscussionCommentRequest,
          res as ReactionsDeleteForTeamDiscussionCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions',

    validate({
      query: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsListForTeamDiscussionInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsListForTeamDiscussionInOrgRequest,
          res as ReactionsListForTeamDiscussionInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions',

    validate({
      body: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            description:
              'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion.',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          }
        },
        required: ['content']
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsCreateForTeamDiscussionInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsCreateForTeamDiscussionInOrgRequest,
          res as ReactionsCreateForTeamDiscussionInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions/:reaction_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          discussion_number: { type: 'integer' },
          reaction_id: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'discussion_number', 'reaction_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsDeleteForTeamDiscussion'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions/:reaction_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsDeleteForTeamDiscussionRequest,
          res as ReactionsDeleteForTeamDiscussionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/invitations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, team_slug: { type: 'string' } },
        required: ['org', 'team_slug']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListPendingInvitationsInOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/teams/:team_slug/invitations not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsListPendingInvitationsInOrgRequest,
          res as TeamsListPendingInvitationsInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/members',

    validate({
      query: {
        type: 'object',
        properties: {
          role: {
            type: 'string',
            enum: ['member', 'maintainer', 'all'],
            default: 'all'
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, team_slug: { type: 'string' } },
        required: ['org', 'team_slug']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListMembersInOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/teams/:team_slug/members not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsListMembersInOrgRequest,
          res as TeamsListMembersInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/memberships/:username',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          username: { type: 'string' }
        },
        required: ['org', 'team_slug', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsGetMembershipForUserInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/memberships/:username not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsGetMembershipForUserInOrgRequest,
          res as TeamsGetMembershipForUserInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/teams/:team_slug/memberships/:username',

    validate({
      body: {
        type: 'object',
        properties: {
          role: {
            type: 'string',
            description: 'The role that this user should have in the team.',
            enum: ['member', 'maintainer'],
            default: 'member'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          username: { type: 'string' }
        },
        required: ['org', 'team_slug', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsAddOrUpdateMembershipForUserInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/memberships/:username not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsAddOrUpdateMembershipForUserInOrgRequest,
          res as TeamsAddOrUpdateMembershipForUserInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/teams/:team_slug/memberships/:username',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          username: { type: 'string' }
        },
        required: ['org', 'team_slug', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsRemoveMembershipForUserInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/memberships/:username not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsRemoveMembershipForUserInOrgRequest,
          res as TeamsRemoveMembershipForUserInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/projects',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, team_slug: { type: 'string' } },
        required: ['org', 'team_slug']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListProjectsInOrg'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/teams/:team_slug/projects not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsListProjectsInOrgRequest,
          res as TeamsListProjectsInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/projects/:project_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          project_id: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'project_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsCheckPermissionsForProjectInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/projects/:project_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsCheckPermissionsForProjectInOrgRequest,
          res as TeamsCheckPermissionsForProjectInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/teams/:team_slug/projects/:project_id',

    validate({
      body: {
        type: 'object',
        properties: {
          permission: {
            type: 'string',
            description:
              'The permission to grant to the team for this project. Default: the team\'s `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you\'ll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."',
            enum: ['read', 'write', 'admin']
          }
        },
        nullable: true
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          project_id: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'project_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsAddOrUpdateProjectPermissionsInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/projects/:project_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsAddOrUpdateProjectPermissionsInOrgRequest,
          res as TeamsAddOrUpdateProjectPermissionsInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/teams/:team_slug/projects/:project_id',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          project_id: { type: 'integer' }
        },
        required: ['org', 'team_slug', 'project_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsRemoveProjectInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/projects/:project_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsRemoveProjectInOrgRequest,
          res as TeamsRemoveProjectInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/repos',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, team_slug: { type: 'string' } },
        required: ['org', 'team_slug']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListReposInOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/teams/:team_slug/repos not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsListReposInOrgRequest,
          res as TeamsListReposInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/repos/:owner/:repo',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          owner: { type: 'string' },
          repo: { type: 'string' }
        },
        required: ['org', 'team_slug', 'owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsCheckPermissionsForRepoInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/repos/:owner/:repo not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsCheckPermissionsForRepoInOrgRequest,
          res as TeamsCheckPermissionsForRepoInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/orgs/:org/teams/:team_slug/repos/:owner/:repo',

    validate({
      body: {
        type: 'object',
        properties: {
          permission: {
            type: 'string',
            description:
              "The permission to grant the team on this repository. We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.",
            default: 'push'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          owner: { type: 'string' },
          repo: { type: 'string' }
        },
        required: ['org', 'team_slug', 'owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsAddOrUpdateRepoPermissionsInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/repos/:owner/:repo not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsAddOrUpdateRepoPermissionsInOrgRequest,
          res as TeamsAddOrUpdateRepoPermissionsInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/orgs/:org/teams/:team_slug/repos/:owner/:repo',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          team_slug: { type: 'string' },
          owner: { type: 'string' },
          repo: { type: 'string' }
        },
        required: ['org', 'team_slug', 'owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsRemoveRepoInOrg'];

      if (!handler) {
        return next(
          new Error(
            '/orgs/:org/teams/:team_slug/repos/:owner/:repo not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsRemoveRepoInOrgRequest,
          res as TeamsRemoveRepoInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/orgs/:org/teams/:team_slug/teams',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { org: { type: 'string' }, team_slug: { type: 'string' } },
        required: ['org', 'team_slug']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListChildInOrg'];

      if (!handler) {
        return next(new Error('/orgs/:org/teams/:team_slug/teams not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsListChildInOrgRequest,
          res as TeamsListChildInOrgResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/orgs/:org/:security_product/:enablement',

    validate({
      params: {
        type: 'object',
        properties: {
          org: { type: 'string' },
          security_product: {
            type: 'string',
            enum: [
              'dependency_graph',
              'dependabot_alerts',
              'dependabot_security_updates',
              'advanced_security',
              'secret_scanning',
              'secret_scanning_push_protection'
            ]
          },
          enablement: { type: 'string', enum: ['enable_all', 'disable_all'] }
        },
        required: ['org', 'security_product', 'enablement']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['orgsEnableOrDisableSecurityProductOnAllOrgRepos'];

      if (!handler) {
        return next(
          new Error('/orgs/:org/:security_product/:enablement not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as OrgsEnableOrDisableSecurityProductOnAllOrgReposRequest,
          res as OrgsEnableOrDisableSecurityProductOnAllOrgReposResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/projects/columns/cards/:card_id',

    validate({
      params: {
        type: 'object',
        properties: { card_id: { type: 'integer' } },
        required: ['card_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsGetCard'];

      if (!handler) {
        return next(new Error('/projects/columns/cards/:card_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsGetCardRequest,
          res as ProjectsGetCardResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/projects/columns/cards/:card_id',

    validate({
      body: {
        type: 'object',
        properties: {
          note: {
            description: "The project card's note",
            example: 'Update all gems',
            type: 'string',
            nullable: true
          },
          archived: {
            description: 'Whether or not the card is archived',
            example: false,
            type: 'boolean'
          }
        }
      },

      params: {
        type: 'object',
        properties: { card_id: { type: 'integer' } },
        required: ['card_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsUpdateCard'];

      if (!handler) {
        return next(new Error('/projects/columns/cards/:card_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsUpdateCardRequest,
          res as ProjectsUpdateCardResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/projects/columns/cards/:card_id',

    validate({
      params: {
        type: 'object',
        properties: { card_id: { type: 'integer' } },
        required: ['card_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsDeleteCard'];

      if (!handler) {
        return next(new Error('/projects/columns/cards/:card_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsDeleteCardRequest,
          res as ProjectsDeleteCardResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/projects/columns/cards/:card_id/moves',

    validate({
      body: {
        properties: {
          position: {
            description:
              'The position of the card in a column. Can be one of: `top`, `bottom`, or `after:<card_id>` to place after the specified card.',
            example: 'bottom',
            type: 'string',
            pattern: '^(?:top|bottom|after:\\d+)$'
          },
          column_id: {
            description:
              'The unique identifier of the column the card should be moved to',
            example: 42,
            type: 'integer'
          }
        },
        required: ['position'],
        type: 'object'
      },

      params: {
        type: 'object',
        properties: { card_id: { type: 'integer' } },
        required: ['card_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsMoveCard'];

      if (!handler) {
        return next(
          new Error('/projects/columns/cards/:card_id/moves not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ProjectsMoveCardRequest,
          res as ProjectsMoveCardResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/projects/columns/:column_id',

    validate({
      params: {
        type: 'object',
        properties: { column_id: { type: 'integer' } },
        required: ['column_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsGetColumn'];

      if (!handler) {
        return next(new Error('/projects/columns/:column_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsGetColumnRequest,
          res as ProjectsGetColumnResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/projects/columns/:column_id',

    validate({
      body: {
        properties: {
          name: {
            description: 'Name of the project column',
            example: 'Remaining tasks',
            type: 'string'
          }
        },
        required: ['name'],
        type: 'object'
      },

      params: {
        type: 'object',
        properties: { column_id: { type: 'integer' } },
        required: ['column_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsUpdateColumn'];

      if (!handler) {
        return next(new Error('/projects/columns/:column_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsUpdateColumnRequest,
          res as ProjectsUpdateColumnResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/projects/columns/:column_id',

    validate({
      params: {
        type: 'object',
        properties: { column_id: { type: 'integer' } },
        required: ['column_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsDeleteColumn'];

      if (!handler) {
        return next(new Error('/projects/columns/:column_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsDeleteColumnRequest,
          res as ProjectsDeleteColumnResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/projects/columns/:column_id/cards',

    validate({
      query: {
        type: 'object',
        properties: {
          archived_state: {
            type: 'string',
            enum: ['all', 'archived', 'not_archived'],
            default: 'not_archived'
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { column_id: { type: 'integer' } },
        required: ['column_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsListCards'];

      if (!handler) {
        return next(
          new Error('/projects/columns/:column_id/cards not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ProjectsListCardsRequest,
          res as ProjectsListCardsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/projects/columns/:column_id/cards',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              note: {
                description: "The project card's note",
                example: 'Update all gems',
                type: 'string',
                nullable: true
              }
            },
            required: ['note']
          },
          {
            type: 'object',
            properties: {
              content_id: {
                description:
                  'The unique identifier of the content associated with the card',
                example: 42,
                type: 'integer'
              },
              content_type: {
                description: 'The piece of content associated with the card',
                example: 'PullRequest',
                type: 'string'
              }
            },
            required: ['content_id', 'content_type']
          }
        ]
      },

      params: {
        type: 'object',
        properties: { column_id: { type: 'integer' } },
        required: ['column_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsCreateCard'];

      if (!handler) {
        return next(
          new Error('/projects/columns/:column_id/cards not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ProjectsCreateCardRequest,
          res as ProjectsCreateCardResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/projects/columns/:column_id/moves',

    validate({
      body: {
        properties: {
          position: {
            description:
              'The position of the column in a project. Can be one of: `first`, `last`, or `after:<column_id>` to place after the specified column.',
            example: 'last',
            type: 'string',
            pattern: '^(?:first|last|after:\\d+)$'
          }
        },
        required: ['position'],
        type: 'object'
      },

      params: {
        type: 'object',
        properties: { column_id: { type: 'integer' } },
        required: ['column_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsMoveColumn'];

      if (!handler) {
        return next(
          new Error('/projects/columns/:column_id/moves not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ProjectsMoveColumnRequest,
          res as ProjectsMoveColumnResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/projects/:project_id',

    validate({
      params: {
        type: 'object',
        properties: { project_id: { type: 'integer' } },
        required: ['project_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsGet'];

      if (!handler) {
        return next(new Error('/projects/:project_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsGetRequest,
          res as ProjectsGetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/projects/:project_id',

    validate({
      body: {
        properties: {
          name: {
            description: 'Name of the project',
            example: 'Week One Sprint',
            type: 'string'
          },
          body: {
            description: 'Body of the project',
            example:
              'This project represents the sprint of the first week in January',
            type: 'string',
            nullable: true
          },
          state: {
            description: "State of the project; either 'open' or 'closed'",
            example: 'open',
            type: 'string'
          },
          organization_permission: {
            description:
              'The baseline permission that all organization members have on this project',
            type: 'string',
            enum: ['read', 'write', 'admin', 'none']
          },
          private: {
            description: 'Whether or not this project can be seen by everyone.',
            type: 'boolean'
          }
        },
        type: 'object'
      },

      params: {
        type: 'object',
        properties: { project_id: { type: 'integer' } },
        required: ['project_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsUpdate'];

      if (!handler) {
        return next(new Error('/projects/:project_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsUpdateRequest,
          res as ProjectsUpdateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/projects/:project_id',

    validate({
      params: {
        type: 'object',
        properties: { project_id: { type: 'integer' } },
        required: ['project_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsDelete'];

      if (!handler) {
        return next(new Error('/projects/:project_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsDeleteRequest,
          res as ProjectsDeleteResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/projects/:project_id/collaborators',

    validate({
      query: {
        type: 'object',
        properties: {
          affiliation: {
            type: 'string',
            enum: ['outside', 'direct', 'all'],
            default: 'all'
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { project_id: { type: 'integer' } },
        required: ['project_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsListCollaborators'];

      if (!handler) {
        return next(
          new Error('/projects/:project_id/collaborators not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ProjectsListCollaboratorsRequest,
          res as ProjectsListCollaboratorsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/projects/:project_id/collaborators/:username',

    validate({
      body: {
        type: 'object',
        properties: {
          permission: {
            description: 'The permission to grant the collaborator.',
            enum: ['read', 'write', 'admin'],
            default: 'write',
            example: 'write',
            type: 'string'
          }
        },
        nullable: true
      },

      params: {
        type: 'object',
        properties: {
          project_id: { type: 'integer' },
          username: { type: 'string' }
        },
        required: ['project_id', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsAddCollaborator'];

      if (!handler) {
        return next(
          new Error('/projects/:project_id/collaborators/:username not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ProjectsAddCollaboratorRequest,
          res as ProjectsAddCollaboratorResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/projects/:project_id/collaborators/:username',

    validate({
      params: {
        type: 'object',
        properties: {
          project_id: { type: 'integer' },
          username: { type: 'string' }
        },
        required: ['project_id', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsRemoveCollaborator'];

      if (!handler) {
        return next(
          new Error('/projects/:project_id/collaborators/:username not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ProjectsRemoveCollaboratorRequest,
          res as ProjectsRemoveCollaboratorResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/projects/:project_id/collaborators/:username/permission',

    validate({
      params: {
        type: 'object',
        properties: {
          project_id: { type: 'integer' },
          username: { type: 'string' }
        },
        required: ['project_id', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsGetPermissionForUser'];

      if (!handler) {
        return next(
          new Error(
            '/projects/:project_id/collaborators/:username/permission not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ProjectsGetPermissionForUserRequest,
          res as ProjectsGetPermissionForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/projects/:project_id/columns',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { project_id: { type: 'integer' } },
        required: ['project_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsListColumns'];

      if (!handler) {
        return next(new Error('/projects/:project_id/columns not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsListColumnsRequest,
          res as ProjectsListColumnsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/projects/:project_id/columns',

    validate({
      body: {
        properties: {
          name: {
            description: 'Name of the project column',
            example: 'Remaining tasks',
            type: 'string'
          }
        },
        required: ['name'],
        type: 'object'
      },

      params: {
        type: 'object',
        properties: { project_id: { type: 'integer' } },
        required: ['project_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsCreateColumn'];

      if (!handler) {
        return next(new Error('/projects/:project_id/columns not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsCreateColumnRequest,
          res as ProjectsCreateColumnResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/rate_limit',

    async (req, res, next) => {
      const handler = handlers['rateLimitGet'];

      if (!handler) {
        return next(new Error('/rate_limit not handled'));
      }

      try {
        await handler(
          (req as unknown) as RateLimitGetRequest,
          res as RateLimitGetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGet'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposGetRequest,
          res as ReposGetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { type: 'string', description: 'The name of the repository.' },
          description: {
            type: 'string',
            description: 'A short description of the repository.'
          },
          homepage: {
            type: 'string',
            description: 'A URL with more information about the repository.'
          },
          private: {
            type: 'boolean',
            description:
              'Either `true` to make the repository private or `false` to make it public. Default: `false`.  \n**Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private.',
            default: false
          },
          visibility: {
            type: 'string',
            description:
              'Can be `public` or `private`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `visibility` can also be `internal`."',
            enum: ['public', 'private', 'internal']
          },
          security_and_analysis: {
            type: 'object',
            description:
              'Specify which security and analysis features to enable or disable for the repository.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nFor example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request:\n`{ "security_and_analysis": {"advanced_security": { "status": "enabled" } } }`.\n\nYou can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.',
            nullable: true,
            properties: {
              advanced_security: {
                type: 'object',
                description:
                  'Use the `status` property to enable or disable GitHub Advanced Security for this repository. For more information, see "[About GitHub Advanced Security](/github/getting-started-with-github/learning-about-github/about-github-advanced-security)."',
                properties: {
                  status: {
                    type: 'string',
                    description: 'Can be `enabled` or `disabled`.'
                  }
                }
              },
              secret_scanning: {
                type: 'object',
                description:
                  'Use the `status` property to enable or disable secret scanning for this repository. For more information, see "[About secret scanning](/code-security/secret-security/about-secret-scanning)."',
                properties: {
                  status: {
                    type: 'string',
                    description: 'Can be `enabled` or `disabled`.'
                  }
                }
              },
              secret_scanning_push_protection: {
                type: 'object',
                description:
                  'Use the `status` property to enable or disable secret scanning push protection for this repository. For more information, see "[Protecting pushes with secret scanning](/code-security/secret-scanning/protecting-pushes-with-secret-scanning)."',
                properties: {
                  status: {
                    type: 'string',
                    description: 'Can be `enabled` or `disabled`.'
                  }
                }
              }
            }
          },
          has_issues: {
            type: 'boolean',
            description:
              'Either `true` to enable issues for this repository or `false` to disable them.',
            default: true
          },
          has_projects: {
            type: 'boolean',
            description:
              "Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.",
            default: true
          },
          has_wiki: {
            type: 'boolean',
            description:
              'Either `true` to enable the wiki for this repository or `false` to disable it.',
            default: true
          },
          is_template: {
            type: 'boolean',
            description:
              'Either `true` to make this repo available as a template repository or `false` to prevent it.',
            default: false
          },
          default_branch: {
            type: 'string',
            description: 'Updates the default branch for this repository.'
          },
          allow_squash_merge: {
            type: 'boolean',
            description:
              'Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.',
            default: true
          },
          allow_merge_commit: {
            type: 'boolean',
            description:
              'Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.',
            default: true
          },
          allow_rebase_merge: {
            type: 'boolean',
            description:
              'Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.',
            default: true
          },
          allow_auto_merge: {
            type: 'boolean',
            description:
              'Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.',
            default: false
          },
          delete_branch_on_merge: {
            type: 'boolean',
            description:
              'Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.',
            default: false
          },
          allow_update_branch: {
            type: 'boolean',
            description:
              'Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise.',
            default: false
          },
          use_squash_pr_title_as_default: {
            type: 'boolean',
            description:
              'Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property has been deprecated. Please use `squash_merge_commit_title` instead.',
            default: false,
            deprecated: true
          },
          squash_merge_commit_title: {
            type: 'string',
            enum: ['PR_TITLE', 'COMMIT_OR_PR_TITLE'],
            description:
              "The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
          },
          squash_merge_commit_message: {
            type: 'string',
            enum: ['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'],
            description:
              "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
          },
          merge_commit_title: {
            type: 'string',
            enum: ['PR_TITLE', 'MERGE_MESSAGE'],
            description:
              "The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
          },
          merge_commit_message: {
            type: 'string',
            enum: ['PR_BODY', 'PR_TITLE', 'BLANK'],
            description:
              "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
          },
          archived: {
            type: 'boolean',
            description:
              '`true` to archive this repository. **Note**: You cannot unarchive repositories through the API.',
            default: false
          },
          allow_forking: {
            type: 'boolean',
            description:
              'Either `true` to allow private forks, or `false` to prevent private forks.',
            default: false
          },
          web_commit_signoff_required: {
            type: 'boolean',
            description:
              'Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits.',
            default: false
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposUpdate'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposUpdateRequest,
          res as ReposUpdateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDelete'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteRequest,
          res as ReposDeleteResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/artifacts',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 },
          name: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListArtifactsForRepo'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/artifacts not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListArtifactsForRepoRequest,
          res as ActionsListArtifactsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/artifacts/:artifact_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          artifact_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'artifact_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetArtifact'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/artifacts/:artifact_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetArtifactRequest,
          res as ActionsGetArtifactResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/actions/artifacts/:artifact_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          artifact_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'artifact_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDeleteArtifact'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/artifacts/:artifact_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDeleteArtifactRequest,
          res as ActionsDeleteArtifactResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/artifacts/:artifact_id/:archive_format',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          artifact_id: { type: 'integer' },
          archive_format: { type: 'string' }
        },
        required: ['owner', 'repo', 'artifact_id', 'archive_format']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDownloadArtifact'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/artifacts/:artifact_id/:archive_format not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDownloadArtifactRequest,
          res as ActionsDownloadArtifactResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/cache/usage',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetActionsCacheUsage'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/cache/usage not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetActionsCacheUsageRequest,
          res as ActionsGetActionsCacheUsageResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/caches',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 },
          ref: { $ref: '#/definitions/code-scanning-ref' },
          key: { type: 'string' },
          sort: {
            type: 'string',
            enum: ['created_at', 'last_accessed_at', 'size_in_bytes'],
            default: 'last_accessed_at'
          },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' }
        },
        required: [],
        definitions: {
          'code-scanning-ref': {
            type: 'string',
            description:
              'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.',
            title: 'code-scanning-ref'
          }
        }
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetActionsCacheList'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/caches not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetActionsCacheListRequest,
          res as ActionsGetActionsCacheListResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/actions/caches',

    validate({
      query: {
        type: 'object',
        properties: {
          key: { type: 'string' },
          ref: { $ref: '#/definitions/code-scanning-ref' }
        },
        required: ['key'],
        definitions: {
          'code-scanning-ref': {
            type: 'string',
            description:
              'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.',
            title: 'code-scanning-ref'
          }
        }
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDeleteActionsCacheByKey'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/caches not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDeleteActionsCacheByKeyRequest,
          res as ActionsDeleteActionsCacheByKeyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/actions/caches/:cache_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          cache_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'cache_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDeleteActionsCacheById'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/caches/:cache_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDeleteActionsCacheByIdRequest,
          res as ActionsDeleteActionsCacheByIdResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/jobs/:job_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          job_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'job_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetJobForWorkflowRun'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/jobs/:job_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetJobForWorkflowRunRequest,
          res as ActionsGetJobForWorkflowRunResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/jobs/:job_id/logs',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          job_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'job_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDownloadJobLogsForWorkflowRun'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/jobs/:job_id/logs not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDownloadJobLogsForWorkflowRunRequest,
          res as ActionsDownloadJobLogsForWorkflowRunResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/actions/jobs/:job_id/rerun',

    validate({
      body: {
        type: 'object',
        nullable: true,
        properties: {
          enable_debug_logging: {
            type: 'boolean',
            default: false,
            description: 'Whether to enable debug logging for the re-run.'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          job_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'job_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsReRunJobForWorkflowRun'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/jobs/:job_id/rerun not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsReRunJobForWorkflowRunRequest,
          res as ActionsReRunJobForWorkflowRunResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/permissions',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetGithubActionsPermissionsRepository'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/permissions not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetGithubActionsPermissionsRepositoryRequest,
          res as ActionsGetGithubActionsPermissionsRepositoryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/actions/permissions',

    validate({
      body: {
        type: 'object',
        properties: {
          enabled: { $ref: '#/definitions/actions-enabled' },
          allowed_actions: { $ref: '#/definitions/allowed-actions' }
        },
        required: ['enabled'],
        definitions: {
          'actions-enabled': {
            type: 'boolean',
            description: 'Whether GitHub Actions is enabled on the repository.',
            title: 'actions-enabled'
          },
          'allowed-actions': {
            type: 'string',
            description:
              'The permissions policy that controls the actions and reusable workflows that are allowed to run.',
            enum: ['all', 'local_only', 'selected'],
            title: 'allowed-actions'
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsSetGithubActionsPermissionsRepository'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/permissions not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsSetGithubActionsPermissionsRepositoryRequest,
          res as ActionsSetGithubActionsPermissionsRepositoryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/permissions/access',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetWorkflowAccessToRepository'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/permissions/access not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetWorkflowAccessToRepositoryRequest,
          res as ActionsGetWorkflowAccessToRepositoryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/actions/permissions/access',

    validate({
      body: {
        $ref: '#/definitions/actions-workflow-access-to-repository',
        definitions: {
          'actions-workflow-access-to-repository': {
            type: 'object',
            properties: {
              access_level: {
                type: 'string',
                description:
                  'Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the\nrepository. `none` means access is only possible from workflows in this repository.',
                enum: ['none', 'organization', 'enterprise']
              }
            },
            required: ['access_level'],
            title: 'actions-workflow-access-to-repository'
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsSetWorkflowAccessToRepository'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/permissions/access not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsSetWorkflowAccessToRepositoryRequest,
          res as ActionsSetWorkflowAccessToRepositoryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/permissions/selected-actions',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetAllowedActionsRepository'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/permissions/selected-actions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetAllowedActionsRepositoryRequest,
          res as ActionsGetAllowedActionsRepositoryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/actions/permissions/selected-actions',

    validate({
      body: {
        $ref: '#/definitions/selected-actions',
        definitions: {
          'selected-actions': {
            type: 'object',
            properties: {
              github_owned_allowed: {
                type: 'boolean',
                description:
                  'Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.'
              },
              verified_allowed: {
                type: 'boolean',
                description:
                  'Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators.'
              },
              patterns_allowed: {
                type: 'array',
                description:
                  'Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`."',
                items: { type: 'string' }
              }
            },
            title: 'selected-actions'
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsSetAllowedActionsRepository'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/permissions/selected-actions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsSetAllowedActionsRepositoryRequest,
          res as ActionsSetAllowedActionsRepositoryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/permissions/workflow',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsGetGithubActionsDefaultWorkflowPermissionsRepository'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/permissions/workflow not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest,
          res as ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/actions/permissions/workflow',

    validate({
      body: {
        $ref: '#/definitions/actions-set-default-workflow-permissions',
        definitions: {
          'actions-set-default-workflow-permissions': {
            type: 'object',
            properties: {
              default_workflow_permissions: {
                $ref: '#/definitions/actions-default-workflow-permissions'
              },
              can_approve_pull_request_reviews: {
                $ref: '#/definitions/actions-can-approve-pull-request-reviews'
              }
            },
            title: 'actions-set-default-workflow-permissions'
          },
          'actions-default-workflow-permissions': {
            type: 'string',
            description:
              'The default workflow permissions granted to the GITHUB_TOKEN when running workflows.',
            enum: ['read', 'write'],
            title: 'actions-default-workflow-permissions'
          },
          'actions-can-approve-pull-request-reviews': {
            type: 'boolean',
            description:
              'Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.',
            title: 'actions-can-approve-pull-request-reviews'
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsSetGithubActionsDefaultWorkflowPermissionsRepository'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/permissions/workflow not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest,
          res as ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runners',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListSelfHostedRunnersForRepo'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/runners not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListSelfHostedRunnersForRepoRequest,
          res as ActionsListSelfHostedRunnersForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runners/downloads',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListRunnerApplicationsForRepo'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/runners/downloads not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListRunnerApplicationsForRepoRequest,
          res as ActionsListRunnerApplicationsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/actions/runners/registration-token',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsCreateRegistrationTokenForRepo'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runners/registration-token not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsCreateRegistrationTokenForRepoRequest,
          res as ActionsCreateRegistrationTokenForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/actions/runners/remove-token',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsCreateRemoveTokenForRepo'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runners/remove-token not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsCreateRemoveTokenForRepoRequest,
          res as ActionsCreateRemoveTokenForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runners/:runner_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          runner_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetSelfHostedRunnerForRepo'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runners/:runner_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetSelfHostedRunnerForRepoRequest,
          res as ActionsGetSelfHostedRunnerForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/actions/runners/:runner_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          runner_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDeleteSelfHostedRunnerFromRepo'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runners/:runner_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDeleteSelfHostedRunnerFromRepoRequest,
          res as ActionsDeleteSelfHostedRunnerFromRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runners/:runner_id/labels',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          runner_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListLabelsForSelfHostedRunnerForRepo'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runners/:runner_id/labels not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListLabelsForSelfHostedRunnerForRepoRequest,
          res as ActionsListLabelsForSelfHostedRunnerForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/actions/runners/:runner_id/labels',

    validate({
      body: {
        type: 'object',
        required: ['labels'],
        properties: {
          labels: {
            type: 'array',
            minItems: 1,
            maxItems: 100,
            description: 'The names of the custom labels to add to the runner.',
            items: { type: 'string' }
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          runner_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsAddCustomLabelsToSelfHostedRunnerForRepo'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runners/:runner_id/labels not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest,
          res as ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/actions/runners/:runner_id/labels',

    validate({
      body: {
        type: 'object',
        required: ['labels'],
        properties: {
          labels: {
            type: 'array',
            minItems: 0,
            maxItems: 100,
            description:
              'The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.',
            items: { type: 'string' }
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          runner_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsSetCustomLabelsForSelfHostedRunnerForRepo'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runners/:runner_id/labels not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest,
          res as ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/actions/runners/:runner_id/labels',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          runner_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'runner_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runners/:runner_id/labels not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest,
          res as ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/actions/runners/:runner_id/labels/:name',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          runner_id: { type: 'integer' },
          name: { type: 'string' }
        },
        required: ['owner', 'repo', 'runner_id', 'name']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['actionsRemoveCustomLabelFromSelfHostedRunnerForRepo'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runners/:runner_id/labels/:name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest,
          res as ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runs',

    validate({
      query: {
        type: 'object',
        properties: {
          actor: { type: 'string' },
          branch: { type: 'string' },
          event: { type: 'string' },
          status: {
            type: 'string',
            enum: [
              'completed',
              'action_required',
              'cancelled',
              'failure',
              'neutral',
              'skipped',
              'stale',
              'success',
              'timed_out',
              'in_progress',
              'queued',
              'requested',
              'waiting'
            ]
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 },
          created: { type: 'string', format: 'date-time' },
          exclude_pull_requests: { type: 'boolean', default: false },
          check_suite_id: { type: 'integer' },
          head_sha: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListWorkflowRunsForRepo'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/actions/runs not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActionsListWorkflowRunsForRepoRequest,
          res as ActionsListWorkflowRunsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runs/:run_id',

    validate({
      query: {
        type: 'object',
        properties: {
          exclude_pull_requests: { type: 'boolean', default: false }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetWorkflowRun'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/runs/:run_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetWorkflowRunRequest,
          res as ActionsGetWorkflowRunResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/actions/runs/:run_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDeleteWorkflowRun'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/runs/:run_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDeleteWorkflowRunRequest,
          res as ActionsDeleteWorkflowRunResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runs/:run_id/approvals',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetReviewsForRun'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runs/:run_id/approvals not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetReviewsForRunRequest,
          res as ActionsGetReviewsForRunResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/actions/runs/:run_id/approve',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsApproveWorkflowRun'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runs/:run_id/approve not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsApproveWorkflowRunRequest,
          res as ActionsApproveWorkflowRunResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runs/:run_id/artifacts',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListWorkflowRunArtifacts'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runs/:run_id/artifacts not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListWorkflowRunArtifactsRequest,
          res as ActionsListWorkflowRunArtifactsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number',

    validate({
      query: {
        type: 'object',
        properties: {
          exclude_pull_requests: { type: 'boolean', default: false }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' },
          attempt_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id', 'attempt_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetWorkflowRunAttempt'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetWorkflowRunAttemptRequest,
          res as ActionsGetWorkflowRunAttemptResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number/jobs',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' },
          attempt_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id', 'attempt_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListJobsForWorkflowRunAttempt'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number/jobs not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListJobsForWorkflowRunAttemptRequest,
          res as ActionsListJobsForWorkflowRunAttemptResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number/logs',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' },
          attempt_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id', 'attempt_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDownloadWorkflowRunAttemptLogs'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number/logs not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDownloadWorkflowRunAttemptLogsRequest,
          res as ActionsDownloadWorkflowRunAttemptLogsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/actions/runs/:run_id/cancel',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsCancelWorkflowRun'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runs/:run_id/cancel not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsCancelWorkflowRunRequest,
          res as ActionsCancelWorkflowRunResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runs/:run_id/jobs',

    validate({
      query: {
        type: 'object',
        properties: {
          filter: {
            type: 'string',
            enum: ['latest', 'all'],
            default: 'latest'
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListJobsForWorkflowRun'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/runs/:run_id/jobs not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListJobsForWorkflowRunRequest,
          res as ActionsListJobsForWorkflowRunResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runs/:run_id/logs',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDownloadWorkflowRunLogs'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/runs/:run_id/logs not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDownloadWorkflowRunLogsRequest,
          res as ActionsDownloadWorkflowRunLogsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/actions/runs/:run_id/logs',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDeleteWorkflowRunLogs'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/runs/:run_id/logs not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDeleteWorkflowRunLogsRequest,
          res as ActionsDeleteWorkflowRunLogsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runs/:run_id/pending_deployments',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetPendingDeploymentsForRun'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runs/:run_id/pending_deployments not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetPendingDeploymentsForRunRequest,
          res as ActionsGetPendingDeploymentsForRunResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/actions/runs/:run_id/pending_deployments',

    validate({
      body: {
        type: 'object',
        properties: {
          environment_ids: {
            type: 'array',
            description: 'The list of environment ids to approve or reject',
            example: [161171787, 161171795],
            items: { type: 'integer', example: 161171787 }
          },
          state: {
            type: 'string',
            description:
              'Whether to approve or reject deployment to the specified environments.',
            enum: ['approved', 'rejected'],
            example: 'approved'
          },
          comment: {
            type: 'string',
            description: 'A comment to accompany the deployment review',
            example: 'Ship it!'
          }
        },
        required: ['environment_ids', 'state', 'comment']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsReviewPendingDeploymentsForRun'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runs/:run_id/pending_deployments not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsReviewPendingDeploymentsForRunRequest,
          res as ActionsReviewPendingDeploymentsForRunResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/actions/runs/:run_id/rerun',

    validate({
      body: {
        type: 'object',
        nullable: true,
        properties: {
          enable_debug_logging: {
            type: 'boolean',
            default: false,
            description: 'Whether to enable debug logging for the re-run.'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsReRunWorkflow'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runs/:run_id/rerun not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsReRunWorkflowRequest,
          res as ActionsReRunWorkflowResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/actions/runs/:run_id/rerun-failed-jobs',

    validate({
      body: {
        type: 'object',
        nullable: true,
        properties: {
          enable_debug_logging: {
            type: 'boolean',
            default: false,
            description: 'Whether to enable debug logging for the re-run.'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsReRunWorkflowFailedJobs'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runs/:run_id/rerun-failed-jobs not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsReRunWorkflowFailedJobsRequest,
          res as ActionsReRunWorkflowFailedJobsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/runs/:run_id/timing',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetWorkflowRunUsage'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/runs/:run_id/timing not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetWorkflowRunUsageRequest,
          res as ActionsGetWorkflowRunUsageResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/secrets',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListRepoSecrets'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/secrets not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListRepoSecretsRequest,
          res as ActionsListRepoSecretsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/secrets/public-key',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetRepoPublicKey'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/secrets/public-key not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetRepoPublicKeyRequest,
          res as ActionsGetRepoPublicKeyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetRepoSecret'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/secrets/:secret_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetRepoSecretRequest,
          res as ActionsGetRepoSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/actions/secrets/:secret_name',

    validate({
      body: {
        type: 'object',
        properties: {
          encrypted_value: {
            type: 'string',
            description:
              'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/reference/actions#get-a-repository-public-key) endpoint.',
            pattern:
              '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          },
          key_id: {
            type: 'string',
            description: 'ID of the key you used to encrypt the secret.'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsCreateOrUpdateRepoSecret'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/secrets/:secret_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsCreateOrUpdateRepoSecretRequest,
          res as ActionsCreateOrUpdateRepoSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/actions/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDeleteRepoSecret'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/secrets/:secret_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDeleteRepoSecretRequest,
          res as ActionsDeleteRepoSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/workflows',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListRepoWorkflows'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/actions/workflows not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListRepoWorkflowsRequest,
          res as ActionsListRepoWorkflowsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/workflows/:workflow_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          workflow_id: { oneOf: [{ type: 'integer' }, { type: 'string' }] }
        },
        required: ['owner', 'repo', 'workflow_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetWorkflow'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/workflows/:workflow_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetWorkflowRequest,
          res as ActionsGetWorkflowResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/actions/workflows/:workflow_id/disable',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          workflow_id: { oneOf: [{ type: 'integer' }, { type: 'string' }] }
        },
        required: ['owner', 'repo', 'workflow_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDisableWorkflow'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/workflows/:workflow_id/disable not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDisableWorkflowRequest,
          res as ActionsDisableWorkflowResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/actions/workflows/:workflow_id/dispatches',

    validate({
      body: {
        type: 'object',
        properties: {
          ref: {
            type: 'string',
            description:
              'The git reference for the workflow. The reference can be a branch or tag name.'
          },
          inputs: {
            type: 'object',
            description:
              'Input keys and values configured in the workflow file. The maximum number of properties is 10. Any default properties configured in the workflow file will be used when `inputs` are omitted.',
            additionalProperties: { type: 'string' },
            maxProperties: 10
          }
        },
        required: ['ref']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          workflow_id: { oneOf: [{ type: 'integer' }, { type: 'string' }] }
        },
        required: ['owner', 'repo', 'workflow_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsCreateWorkflowDispatch'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/workflows/:workflow_id/dispatches not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsCreateWorkflowDispatchRequest,
          res as ActionsCreateWorkflowDispatchResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/actions/workflows/:workflow_id/enable',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          workflow_id: { oneOf: [{ type: 'integer' }, { type: 'string' }] }
        },
        required: ['owner', 'repo', 'workflow_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsEnableWorkflow'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/workflows/:workflow_id/enable not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsEnableWorkflowRequest,
          res as ActionsEnableWorkflowResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/workflows/:workflow_id/runs',

    validate({
      query: {
        type: 'object',
        properties: {
          actor: { type: 'string' },
          branch: { type: 'string' },
          event: { type: 'string' },
          status: {
            type: 'string',
            enum: [
              'completed',
              'action_required',
              'cancelled',
              'failure',
              'neutral',
              'skipped',
              'stale',
              'success',
              'timed_out',
              'in_progress',
              'queued',
              'requested',
              'waiting'
            ]
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 },
          created: { type: 'string', format: 'date-time' },
          exclude_pull_requests: { type: 'boolean', default: false },
          check_suite_id: { type: 'integer' },
          head_sha: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          workflow_id: { oneOf: [{ type: 'integer' }, { type: 'string' }] }
        },
        required: ['owner', 'repo', 'workflow_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListWorkflowRuns'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/workflows/:workflow_id/runs not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListWorkflowRunsRequest,
          res as ActionsListWorkflowRunsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/actions/workflows/:workflow_id/timing',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          workflow_id: { oneOf: [{ type: 'integer' }, { type: 'string' }] }
        },
        required: ['owner', 'repo', 'workflow_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetWorkflowUsage'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/actions/workflows/:workflow_id/timing not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetWorkflowUsageRequest,
          res as ActionsGetWorkflowUsageResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/assignees',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesListAssignees'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/assignees not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesListAssigneesRequest,
          res as IssuesListAssigneesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/assignees/:assignee',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          assignee: { type: 'string' }
        },
        required: ['owner', 'repo', 'assignee']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesCheckUserCanBeAssigned'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/assignees/:assignee not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesCheckUserCanBeAssignedRequest,
          res as IssuesCheckUserCanBeAssignedResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/autolinks',

    validate({
      query: {
        type: 'object',
        properties: { page: { type: 'integer', default: 1 } },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListAutolinks'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/autolinks not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListAutolinksRequest,
          res as ReposListAutolinksResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/autolinks',

    validate({
      body: {
        type: 'object',
        properties: {
          key_prefix: {
            type: 'string',
            description:
              'This prefix appended by certain characters will generate a link any time it is found in an issue, pull request, or commit.'
          },
          url_template: {
            type: 'string',
            description:
              'The URL must contain `<num>` for the reference number. `<num>` matches different characters depending on the value of `is_alphanumeric`.'
          },
          is_alphanumeric: {
            type: 'boolean',
            default: 'true',
            description:
              'Whether this autolink reference matches alphanumeric characters. If true, the `<num>` parameter of the `url_template` matches alphanumeric characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this autolink reference only matches numeric characters.'
          }
        },
        required: ['key_prefix', 'url_template']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateAutolink'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/autolinks not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposCreateAutolinkRequest,
          res as ReposCreateAutolinkResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/autolinks/:autolink_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          autolink_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'autolink_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetAutolink'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/autolinks/:autolink_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetAutolinkRequest,
          res as ReposGetAutolinkResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/autolinks/:autolink_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          autolink_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'autolink_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteAutolink'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/autolinks/:autolink_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteAutolinkRequest,
          res as ReposDeleteAutolinkResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/automated-security-fixes',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposEnableAutomatedSecurityFixes'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/automated-security-fixes not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposEnableAutomatedSecurityFixesRequest,
          res as ReposEnableAutomatedSecurityFixesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/automated-security-fixes',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDisableAutomatedSecurityFixes'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/automated-security-fixes not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDisableAutomatedSecurityFixesRequest,
          res as ReposDisableAutomatedSecurityFixesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/branches',

    validate({
      query: {
        type: 'object',
        properties: {
          protected: { type: 'boolean' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListBranches'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/branches not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListBranchesRequest,
          res as ReposListBranchesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/branches/:branch',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetBranch'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/branches/:branch not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetBranchRequest,
          res as ReposGetBranchResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/branches/:branch/protection',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetBranchProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetBranchProtectionRequest,
          res as ReposGetBranchProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/branches/:branch/protection',

    validate({
      body: {
        type: 'object',
        properties: {
          required_status_checks: {
            type: 'object',
            description:
              'Require status checks to pass before merging. Set to `null` to disable.',
            nullable: true,
            properties: {
              strict: {
                type: 'boolean',
                description: 'Require branches to be up to date before merging.'
              },
              contexts: {
                type: 'array',
                deprecated: true,
                description:
                  '**Deprecated**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.\n',
                items: { type: 'string' }
              },
              checks: {
                type: 'array',
                description:
                  'The list of status checks to require in order to merge into this branch.',
                items: {
                  type: 'object',
                  required: ['context'],
                  properties: {
                    context: {
                      type: 'string',
                      description: 'The name of the required check'
                    },
                    app_id: {
                      type: 'integer',
                      description:
                        'The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.'
                    }
                  }
                }
              }
            },
            required: ['strict', 'contexts']
          },
          enforce_admins: {
            type: 'boolean',
            description:
              'Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable.',
            nullable: true
          },
          required_pull_request_reviews: {
            type: 'object',
            description:
              'Require at least one approving review on a pull request, before merging. Set to `null` to disable.',
            nullable: true,
            properties: {
              dismissal_restrictions: {
                type: 'object',
                description:
                  'Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.',
                properties: {
                  users: {
                    type: 'array',
                    description:
                      'The list of user `login`s with dismissal access',
                    items: { type: 'string' }
                  },
                  teams: {
                    type: 'array',
                    description:
                      'The list of team `slug`s with dismissal access',
                    items: { type: 'string' }
                  },
                  apps: {
                    type: 'array',
                    description:
                      'The list of app `slug`s with dismissal access',
                    items: { type: 'string' }
                  }
                }
              },
              dismiss_stale_reviews: {
                type: 'boolean',
                description:
                  'Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.'
              },
              require_code_owner_reviews: {
                type: 'boolean',
                description:
                  'Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) review them.'
              },
              required_approving_review_count: {
                type: 'integer',
                description:
                  'Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.'
              },
              require_last_push_approval: {
                type: 'boolean',
                description:
                  'Whether someone other than the person who last pushed to the branch must approve this pull request. Default: `false`.',
                default: false
              },
              bypass_pull_request_allowances: {
                type: 'object',
                description:
                  'Allow specific users, teams, or apps to bypass pull request requirements.',
                properties: {
                  users: {
                    type: 'array',
                    description:
                      'The list of user `login`s allowed to bypass pull request requirements.',
                    items: { type: 'string' }
                  },
                  teams: {
                    type: 'array',
                    description:
                      'The list of team `slug`s allowed to bypass pull request requirements.',
                    items: { type: 'string' }
                  },
                  apps: {
                    type: 'array',
                    description:
                      'The list of app `slug`s allowed to bypass pull request requirements.',
                    items: { type: 'string' }
                  }
                }
              }
            }
          },
          restrictions: {
            type: 'object',
            description:
              'Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.',
            nullable: true,
            properties: {
              users: {
                type: 'array',
                description: 'The list of user `login`s with push access',
                items: { type: 'string' }
              },
              teams: {
                type: 'array',
                description: 'The list of team `slug`s with push access',
                items: { type: 'string' }
              },
              apps: {
                type: 'array',
                description: 'The list of app `slug`s with push access',
                items: { type: 'string' }
              }
            },
            required: ['users', 'teams']
          },
          required_linear_history: {
            type: 'boolean',
            description:
              'Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see "[Requiring a linear commit history](https://docs.github.com/github/administering-a-repository/requiring-a-linear-commit-history)" in the GitHub Help documentation.'
          },
          allow_force_pushes: {
            type: 'boolean',
            description:
              'Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation."',
            nullable: true
          },
          allow_deletions: {
            type: 'boolean',
            description:
              'Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation.'
          },
          block_creations: {
            type: 'boolean',
            description:
              'If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`.'
          },
          required_conversation_resolution: {
            type: 'boolean',
            description:
              'Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`.'
          },
          lock_branch: {
            type: 'boolean',
            description:
              'Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. Default: `false`.',
            default: false
          },
          allow_fork_syncing: {
            type: 'boolean',
            description:
              'Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing. Default: `false`.',
            default: false
          }
        },
        required: [
          'required_status_checks',
          'enforce_admins',
          'required_pull_request_reviews',
          'restrictions'
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposUpdateBranchProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposUpdateBranchProtectionRequest,
          res as ReposUpdateBranchProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/branches/:branch/protection',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteBranchProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteBranchProtectionRequest,
          res as ReposDeleteBranchProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/branches/:branch/protection/enforce_admins',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetAdminBranchProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/enforce_admins not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetAdminBranchProtectionRequest,
          res as ReposGetAdminBranchProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/branches/:branch/protection/enforce_admins',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposSetAdminBranchProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/enforce_admins not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposSetAdminBranchProtectionRequest,
          res as ReposSetAdminBranchProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/branches/:branch/protection/enforce_admins',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteAdminBranchProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/enforce_admins not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteAdminBranchProtectionRequest,
          res as ReposDeleteAdminBranchProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetPullRequestReviewProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetPullRequestReviewProtectionRequest,
          res as ReposGetPullRequestReviewProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews',

    validate({
      body: {
        type: 'object',
        properties: {
          dismissal_restrictions: {
            type: 'object',
            description:
              'Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.',
            properties: {
              users: {
                type: 'array',
                description: 'The list of user `login`s with dismissal access',
                items: { type: 'string' }
              },
              teams: {
                type: 'array',
                description: 'The list of team `slug`s with dismissal access',
                items: { type: 'string' }
              },
              apps: {
                type: 'array',
                description: 'The list of app `slug`s with dismissal access',
                items: { type: 'string' }
              }
            }
          },
          dismiss_stale_reviews: {
            type: 'boolean',
            description:
              'Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.'
          },
          require_code_owner_reviews: {
            type: 'boolean',
            description:
              'Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) have reviewed.'
          },
          required_approving_review_count: {
            type: 'integer',
            description:
              'Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.'
          },
          require_last_push_approval: {
            type: 'boolean',
            description:
              'Whether someone other than the person who last pushed to the branch must approve this pull request. Default: `false`',
            default: false
          },
          bypass_pull_request_allowances: {
            type: 'object',
            description:
              'Allow specific users, teams, or apps to bypass pull request requirements.',
            properties: {
              users: {
                type: 'array',
                description:
                  'The list of user `login`s allowed to bypass pull request requirements.',
                items: { type: 'string' }
              },
              teams: {
                type: 'array',
                description:
                  'The list of team `slug`s allowed to bypass pull request requirements.',
                items: { type: 'string' }
              },
              apps: {
                type: 'array',
                description:
                  'The list of app `slug`s allowed to bypass pull request requirements.',
                items: { type: 'string' }
              }
            }
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposUpdatePullRequestReviewProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposUpdatePullRequestReviewProtectionRequest,
          res as ReposUpdatePullRequestReviewProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeletePullRequestReviewProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeletePullRequestReviewProtectionRequest,
          res as ReposDeletePullRequestReviewProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/branches/:branch/protection/required_signatures',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetCommitSignatureProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/required_signatures not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetCommitSignatureProtectionRequest,
          res as ReposGetCommitSignatureProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/branches/:branch/protection/required_signatures',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateCommitSignatureProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/required_signatures not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposCreateCommitSignatureProtectionRequest,
          res as ReposCreateCommitSignatureProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/branches/:branch/protection/required_signatures',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteCommitSignatureProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/required_signatures not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteCommitSignatureProtectionRequest,
          res as ReposDeleteCommitSignatureProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/branches/:branch/protection/required_status_checks',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetStatusChecksProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/required_status_checks not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetStatusChecksProtectionRequest,
          res as ReposGetStatusChecksProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/branches/:branch/protection/required_status_checks',

    validate({
      body: {
        type: 'object',
        properties: {
          strict: {
            type: 'boolean',
            description: 'Require branches to be up to date before merging.'
          },
          contexts: {
            type: 'array',
            deprecated: true,
            description:
              '**Deprecated**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.\n',
            items: { type: 'string' }
          },
          checks: {
            type: 'array',
            description:
              'The list of status checks to require in order to merge into this branch.',
            items: {
              type: 'object',
              required: ['context'],
              properties: {
                context: {
                  type: 'string',
                  description: 'The name of the required check'
                },
                app_id: {
                  type: 'integer',
                  description:
                    'The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.'
                }
              }
            }
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposUpdateStatusCheckProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/required_status_checks not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposUpdateStatusCheckProtectionRequest,
          res as ReposUpdateStatusCheckProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/branches/:branch/protection/required_status_checks',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposRemoveStatusCheckProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/required_status_checks not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposRemoveStatusCheckProtectionRequest,
          res as ReposRemoveStatusCheckProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetAllStatusCheckContexts'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetAllStatusCheckContextsRequest,
          res as ReposGetAllStatusCheckContextsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              contexts: {
                type: 'array',
                description: 'The name of the status checks',
                items: { type: 'string' }
              }
            },
            required: ['contexts'],
            example: { contexts: ['contexts'] }
          },
          {
            type: 'array',
            description: 'The name of the status checks',
            items: { type: 'string' }
          }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposAddStatusCheckContexts'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposAddStatusCheckContextsRequest,
          res as ReposAddStatusCheckContextsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              contexts: {
                type: 'array',
                description: 'The name of the status checks',
                items: { type: 'string' }
              }
            },
            required: ['contexts'],
            example: { contexts: ['contexts'] }
          },
          {
            type: 'array',
            description: 'The name of the status checks',
            items: { type: 'string' }
          }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposSetStatusCheckContexts'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposSetStatusCheckContextsRequest,
          res as ReposSetStatusCheckContextsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              contexts: {
                type: 'array',
                description: 'The name of the status checks',
                items: { type: 'string' }
              }
            },
            required: ['contexts'],
            example: { contexts: ['contexts'] }
          },
          {
            type: 'array',
            description: 'The name of the status checks',
            items: { type: 'string' }
          }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposRemoveStatusCheckContexts'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposRemoveStatusCheckContextsRequest,
          res as ReposRemoveStatusCheckContextsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetAccessRestrictions'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetAccessRestrictionsRequest,
          res as ReposGetAccessRestrictionsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteAccessRestrictions'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteAccessRestrictionsRequest,
          res as ReposDeleteAccessRestrictionsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions/apps',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetAppsWithAccessToProtectedBranch'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions/apps not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetAppsWithAccessToProtectedBranchRequest,
          res as ReposGetAppsWithAccessToProtectedBranchResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions/apps',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              apps: {
                type: 'array',
                description: 'apps parameter',
                items: { type: 'string' }
              }
            },
            required: ['apps'],
            example: { apps: ['my-app'] }
          },
          { type: 'array', items: { type: 'string' } }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposAddAppAccessRestrictions'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions/apps not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposAddAppAccessRestrictionsRequest,
          res as ReposAddAppAccessRestrictionsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions/apps',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              apps: {
                type: 'array',
                description: 'apps parameter',
                items: { type: 'string' }
              }
            },
            required: ['apps'],
            example: { apps: ['my-app'] }
          },
          { type: 'array', items: { type: 'string' } }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposSetAppAccessRestrictions'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions/apps not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposSetAppAccessRestrictionsRequest,
          res as ReposSetAppAccessRestrictionsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions/apps',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              apps: {
                type: 'array',
                description: 'apps parameter',
                items: { type: 'string' }
              }
            },
            required: ['apps'],
            example: { apps: ['my-app'] }
          },
          { type: 'array', items: { type: 'string' } }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposRemoveAppAccessRestrictions'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions/apps not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposRemoveAppAccessRestrictionsRequest,
          res as ReposRemoveAppAccessRestrictionsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions/teams',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetTeamsWithAccessToProtectedBranch'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions/teams not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetTeamsWithAccessToProtectedBranchRequest,
          res as ReposGetTeamsWithAccessToProtectedBranchResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions/teams',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              teams: {
                type: 'array',
                description: 'The slug values for teams',
                items: { type: 'string' }
              }
            },
            required: ['teams'],
            example: { teams: ['my-team'] }
          },
          {
            type: 'array',
            description: 'The slug values for teams',
            items: { type: 'string' }
          }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposAddTeamAccessRestrictions'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions/teams not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposAddTeamAccessRestrictionsRequest,
          res as ReposAddTeamAccessRestrictionsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions/teams',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              teams: {
                type: 'array',
                description: 'The slug values for teams',
                items: { type: 'string' }
              }
            },
            required: ['teams'],
            example: { teams: ['justice-league'] }
          },
          {
            type: 'array',
            description: 'The slug values for teams',
            items: { type: 'string' }
          }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposSetTeamAccessRestrictions'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions/teams not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposSetTeamAccessRestrictionsRequest,
          res as ReposSetTeamAccessRestrictionsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions/teams',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              teams: {
                type: 'array',
                description: 'The slug values for teams',
                items: { type: 'string' }
              }
            },
            required: ['teams'],
            example: { teams: ['my-team'] }
          },
          {
            type: 'array',
            description: 'The slug values for teams',
            items: { type: 'string' }
          }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposRemoveTeamAccessRestrictions'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions/teams not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposRemoveTeamAccessRestrictionsRequest,
          res as ReposRemoveTeamAccessRestrictionsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions/users',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetUsersWithAccessToProtectedBranch'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions/users not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetUsersWithAccessToProtectedBranchRequest,
          res as ReposGetUsersWithAccessToProtectedBranchResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions/users',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              users: {
                type: 'array',
                description: 'The username for users',
                items: { type: 'string' }
              }
            },
            required: ['users'],
            example: { users: ['mona'] }
          },
          { type: 'array', items: { type: 'string' } }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposAddUserAccessRestrictions'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions/users not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposAddUserAccessRestrictionsRequest,
          res as ReposAddUserAccessRestrictionsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions/users',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              users: {
                type: 'array',
                description: 'The username for users',
                items: { type: 'string' }
              }
            },
            required: ['users'],
            example: { users: ['mona'] }
          },
          { type: 'array', items: { type: 'string' } }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposSetUserAccessRestrictions'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions/users not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposSetUserAccessRestrictionsRequest,
          res as ReposSetUserAccessRestrictionsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/branches/:branch/protection/restrictions/users',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              users: {
                type: 'array',
                description: 'The username for users',
                items: { type: 'string' }
              }
            },
            required: ['users'],
            example: { users: ['mona'] }
          },
          { type: 'array', items: { type: 'string' } }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposRemoveUserAccessRestrictions'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/branches/:branch/protection/restrictions/users not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposRemoveUserAccessRestrictionsRequest,
          res as ReposRemoveUserAccessRestrictionsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/branches/:branch/rename',

    validate({
      body: {
        type: 'object',
        properties: {
          new_name: {
            type: 'string',
            description: 'The new name of the branch.'
          }
        },
        required: ['new_name']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          branch: { type: 'string' }
        },
        required: ['owner', 'repo', 'branch']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposRenameBranch'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/branches/:branch/rename not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposRenameBranchRequest,
          res as ReposRenameBranchResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/check-runs',

    validate({
      body: {
        type: 'object',
        properties: {
          name: {
            type: 'string',
            description: 'The name of the check. For example, "code-coverage".'
          },
          head_sha: { type: 'string', description: 'The SHA of the commit.' },
          details_url: {
            type: 'string',
            description:
              "The URL of the integrator's site that has the full details of the check. If the integrator does not provide this, then the homepage of the GitHub app is used."
          },
          external_id: {
            type: 'string',
            description: "A reference for the run on the integrator's system."
          },
          status: {
            type: 'string',
            description: 'The current status.',
            enum: ['queued', 'in_progress', 'completed'],
            default: 'queued'
          },
          started_at: {
            type: 'string',
            format: 'date-time',
            description:
              'The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
          },
          conclusion: {
            type: 'string',
            description:
              '**Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. \n**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.',
            enum: [
              'action_required',
              'cancelled',
              'failure',
              'neutral',
              'success',
              'skipped',
              'stale',
              'timed_out'
            ]
          },
          completed_at: {
            type: 'string',
            format: 'date-time',
            description:
              'The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
          },
          output: {
            type: 'object',
            description:
              'Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.',
            properties: {
              title: {
                type: 'string',
                description: 'The title of the check run.'
              },
              summary: {
                type: 'string',
                maxLength: 65535,
                description:
                  'The summary of the check run. This parameter supports Markdown. **Maximum length**: 65535 characters.'
              },
              text: {
                type: 'string',
                maxLength: 65535,
                description:
                  'The details of the check run. This parameter supports Markdown. **Maximum length**: 65535 characters.'
              },
              annotations: {
                type: 'array',
                description:
                  'Adds information from your analysis to specific lines of code. Annotations are visible on GitHub in the **Checks** and **Files changed** tab of the pull request. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/rest/reference/checks#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. For details about how you can view annotations on GitHub, see "[About status checks](https://docs.github.com/articles/about-status-checks#checks)".',
                maxItems: 50,
                items: {
                  type: 'object',
                  properties: {
                    path: {
                      type: 'string',
                      description:
                        'The path of the file to add an annotation to. For example, `assets/css/main.css`.'
                    },
                    start_line: {
                      type: 'integer',
                      description:
                        'The start line of the annotation. Line numbers start at 1.'
                    },
                    end_line: {
                      type: 'integer',
                      description: 'The end line of the annotation.'
                    },
                    start_column: {
                      type: 'integer',
                      description:
                        'The start column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values. Column numbers start at 1.'
                    },
                    end_column: {
                      type: 'integer',
                      description:
                        'The end column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values.'
                    },
                    annotation_level: {
                      type: 'string',
                      description: 'The level of the annotation.',
                      enum: ['notice', 'warning', 'failure']
                    },
                    message: {
                      type: 'string',
                      description:
                        'A short description of the feedback for these lines of code. The maximum size is 64 KB.'
                    },
                    title: {
                      type: 'string',
                      description:
                        'The title that represents the annotation. The maximum size is 255 characters.'
                    },
                    raw_details: {
                      type: 'string',
                      description:
                        'Details about this annotation. The maximum size is 64 KB.'
                    }
                  },
                  required: [
                    'path',
                    'start_line',
                    'end_line',
                    'annotation_level',
                    'message'
                  ]
                }
              },
              images: {
                type: 'array',
                description:
                  'Adds images to the output displayed in the GitHub pull request UI.',
                items: {
                  type: 'object',
                  properties: {
                    alt: {
                      type: 'string',
                      description: 'The alternative text for the image.'
                    },
                    image_url: {
                      type: 'string',
                      description: 'The full URL of the image.'
                    },
                    caption: {
                      type: 'string',
                      description: 'A short image description.'
                    }
                  },
                  required: ['alt', 'image_url']
                }
              }
            },
            required: ['title', 'summary']
          },
          actions: {
            type: 'array',
            description:
              'Displays a button on GitHub that can be clicked to alert your app to do additional tasks. For example, a code linting app can display a button that automatically fixes detected errors. The button created in this object is displayed after the check run completes. When a user clicks the button, GitHub sends the [`check_run.requested_action` webhook](https://docs.github.com/webhooks/event-payloads/#check_run) to your app. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/rest/reference/checks#check-runs-and-requested-actions)."',
            maxItems: 3,
            items: {
              type: 'object',
              properties: {
                label: {
                  type: 'string',
                  maxLength: 20,
                  description:
                    'The text to be displayed on a button in the web UI. The maximum size is 20 characters.'
                },
                description: {
                  type: 'string',
                  maxLength: 40,
                  description:
                    'A short explanation of what this action would do. The maximum size is 40 characters.'
                },
                identifier: {
                  type: 'string',
                  maxLength: 20,
                  description:
                    "A reference for the action on the integrator's system. The maximum size is 20 characters."
                }
              },
              required: ['label', 'description', 'identifier']
            }
          }
        },
        required: ['name', 'head_sha'],
        oneOf: [
          {
            properties: { status: { enum: ['completed'] } },
            required: ['status', 'conclusion'],
            additionalProperties: true
          },
          {
            properties: { status: { enum: ['queued', 'in_progress'] } },
            additionalProperties: true
          }
        ]
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['checksCreate'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/check-runs not handled'));
      }

      try {
        await handler(
          (req as unknown) as ChecksCreateRequest,
          res as ChecksCreateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/check-runs/:check_run_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          check_run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'check_run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['checksGet'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/check-runs/:check_run_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ChecksGetRequest,
          res as ChecksGetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/check-runs/:check_run_id',

    validate({
      body: {
        type: 'object',
        properties: {
          name: {
            type: 'string',
            description: 'The name of the check. For example, "code-coverage".'
          },
          details_url: {
            type: 'string',
            description:
              "The URL of the integrator's site that has the full details of the check."
          },
          external_id: {
            type: 'string',
            description: "A reference for the run on the integrator's system."
          },
          started_at: {
            type: 'string',
            format: 'date-time',
            description:
              'This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
          },
          status: {
            type: 'string',
            description: 'The current status.',
            enum: ['queued', 'in_progress', 'completed']
          },
          conclusion: {
            type: 'string',
            description:
              '**Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. \n**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.',
            enum: [
              'action_required',
              'cancelled',
              'failure',
              'neutral',
              'success',
              'skipped',
              'stale',
              'timed_out'
            ]
          },
          completed_at: {
            type: 'string',
            format: 'date-time',
            description:
              'The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
          },
          output: {
            type: 'object',
            description:
              'Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.',
            properties: {
              title: { type: 'string', description: '**Required**.' },
              summary: {
                type: 'string',
                description: 'Can contain Markdown.',
                maxLength: 65535
              },
              text: {
                type: 'string',
                description: 'Can contain Markdown.',
                maxLength: 65535
              },
              annotations: {
                type: 'array',
                description:
                  'Adds information from your analysis to specific lines of code. Annotations are visible in GitHub\'s pull request UI. Annotations are visible in GitHub\'s pull request UI. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/rest/reference/checks#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. For details about annotations in the UI, see "[About status checks](https://docs.github.com/articles/about-status-checks#checks)".',
                maxItems: 50,
                items: {
                  type: 'object',
                  properties: {
                    path: {
                      type: 'string',
                      description:
                        'The path of the file to add an annotation to. For example, `assets/css/main.css`.'
                    },
                    start_line: {
                      type: 'integer',
                      description:
                        'The start line of the annotation. Line numbers start at 1.'
                    },
                    end_line: {
                      type: 'integer',
                      description: 'The end line of the annotation.'
                    },
                    start_column: {
                      type: 'integer',
                      description:
                        'The start column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values. Column numbers start at 1.'
                    },
                    end_column: {
                      type: 'integer',
                      description:
                        'The end column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values.'
                    },
                    annotation_level: {
                      type: 'string',
                      description: 'The level of the annotation.',
                      enum: ['notice', 'warning', 'failure']
                    },
                    message: {
                      type: 'string',
                      description:
                        'A short description of the feedback for these lines of code. The maximum size is 64 KB.'
                    },
                    title: {
                      type: 'string',
                      description:
                        'The title that represents the annotation. The maximum size is 255 characters.'
                    },
                    raw_details: {
                      type: 'string',
                      description:
                        'Details about this annotation. The maximum size is 64 KB.'
                    }
                  },
                  required: [
                    'path',
                    'start_line',
                    'end_line',
                    'annotation_level',
                    'message'
                  ]
                }
              },
              images: {
                type: 'array',
                description:
                  'Adds images to the output displayed in the GitHub pull request UI.',
                items: {
                  type: 'object',
                  properties: {
                    alt: {
                      type: 'string',
                      description: 'The alternative text for the image.'
                    },
                    image_url: {
                      type: 'string',
                      description: 'The full URL of the image.'
                    },
                    caption: {
                      type: 'string',
                      description: 'A short image description.'
                    }
                  },
                  required: ['alt', 'image_url']
                }
              }
            },
            required: ['summary']
          },
          actions: {
            type: 'array',
            description:
              'Possible further actions the integrator can perform, which a user may trigger. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. See the [`actions` object](https://docs.github.com/rest/reference/checks#actions-object) description. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/rest/reference/checks#check-runs-and-requested-actions)."',
            maxItems: 3,
            items: {
              type: 'object',
              properties: {
                label: {
                  type: 'string',
                  maxLength: 20,
                  description:
                    'The text to be displayed on a button in the web UI. The maximum size is 20 characters.'
                },
                description: {
                  type: 'string',
                  maxLength: 40,
                  description:
                    'A short explanation of what this action would do. The maximum size is 40 characters.'
                },
                identifier: {
                  type: 'string',
                  maxLength: 20,
                  description:
                    "A reference for the action on the integrator's system. The maximum size is 20 characters."
                }
              },
              required: ['label', 'description', 'identifier']
            }
          }
        },
        anyOf: [
          {
            properties: { status: { enum: ['completed'] } },
            required: ['conclusion'],
            additionalProperties: true
          },
          {
            properties: { status: { enum: ['queued', 'in_progress'] } },
            additionalProperties: true
          }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          check_run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'check_run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['checksUpdate'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/check-runs/:check_run_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ChecksUpdateRequest,
          res as ChecksUpdateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/check-runs/:check_run_id/annotations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          check_run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'check_run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['checksListAnnotations'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/check-runs/:check_run_id/annotations not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ChecksListAnnotationsRequest,
          res as ChecksListAnnotationsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/check-runs/:check_run_id/rerequest',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          check_run_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'check_run_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['checksRerequestRun'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/check-runs/:check_run_id/rerequest not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ChecksRerequestRunRequest,
          res as ChecksRerequestRunResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/check-suites',

    validate({
      body: {
        type: 'object',
        properties: {
          head_sha: {
            type: 'string',
            description: 'The sha of the head commit.'
          }
        },
        required: ['head_sha']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['checksCreateSuite'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/check-suites not handled'));
      }

      try {
        await handler(
          (req as unknown) as ChecksCreateSuiteRequest,
          res as ChecksCreateSuiteResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/check-suites/preferences',

    validate({
      body: {
        type: 'object',
        properties: {
          auto_trigger_checks: {
            type: 'array',
            description:
              'Enables or disables automatic creation of CheckSuite events upon pushes to the repository. Enabled by default.',
            items: {
              type: 'object',
              properties: {
                app_id: {
                  type: 'integer',
                  description: 'The `id` of the GitHub App.'
                },
                setting: {
                  type: 'boolean',
                  description:
                    'Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository, or `false` to disable them.',
                  default: true
                }
              },
              required: ['app_id', 'setting']
            }
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['checksSetSuitesPreferences'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/check-suites/preferences not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ChecksSetSuitesPreferencesRequest,
          res as ChecksSetSuitesPreferencesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/check-suites/:check_suite_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          check_suite_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'check_suite_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['checksGetSuite'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/check-suites/:check_suite_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ChecksGetSuiteRequest,
          res as ChecksGetSuiteResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/check-suites/:check_suite_id/check-runs',

    validate({
      query: {
        type: 'object',
        properties: {
          check_name: { type: 'string' },
          status: {
            type: 'string',
            enum: ['queued', 'in_progress', 'completed']
          },
          filter: {
            type: 'string',
            enum: ['latest', 'all'],
            default: 'latest'
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          check_suite_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'check_suite_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['checksListForSuite'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/check-suites/:check_suite_id/check-runs not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ChecksListForSuiteRequest,
          res as ChecksListForSuiteResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/check-suites/:check_suite_id/rerequest',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          check_suite_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'check_suite_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['checksRerequestSuite'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/check-suites/:check_suite_id/rerequest not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ChecksRerequestSuiteRequest,
          res as ChecksRerequestSuiteResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/code-scanning/alerts',

    validate({
      query: {
        type: 'object',
        properties: {
          tool_name: { $ref: '#/definitions/code-scanning-analysis-tool-name' },
          tool_guid: { $ref: '#/definitions/code-scanning-analysis-tool-guid' },
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 },
          ref: { $ref: '#/definitions/code-scanning-ref' },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          },
          state: { $ref: '#/definitions/code-scanning-alert-state' }
        },
        required: [],
        definitions: {
          'code-scanning-analysis-tool-name': {
            type: 'string',
            description:
              'The name of the tool used to generate the code scanning analysis.',
            title: 'code-scanning-analysis-tool-name'
          },
          'code-scanning-analysis-tool-guid': {
            nullable: true,
            type: 'string',
            description:
              'The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.',
            title: 'code-scanning-analysis-tool-guid'
          },
          'code-scanning-ref': {
            type: 'string',
            description:
              'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.',
            title: 'code-scanning-ref'
          },
          'code-scanning-alert-state': {
            type: 'string',
            description: 'State of a code scanning alert.',
            enum: ['open', 'closed', 'dismissed', 'fixed'],
            title: 'code-scanning-alert-state'
          }
        }
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codeScanningListAlertsForRepo'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/code-scanning/alerts not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodeScanningListAlertsForRepoRequest,
          res as CodeScanningListAlertsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/code-scanning/alerts/:alert_number',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          alert_number: { $ref: '#/definitions/alert-number' }
        },
        required: ['owner', 'repo', 'alert_number'],
        definitions: {
          'alert-number': {
            type: 'integer',
            description: 'The security alert number.',
            readOnly: true,
            title: 'alert-number'
          }
        }
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codeScanningGetAlert'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/code-scanning/alerts/:alert_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodeScanningGetAlertRequest,
          res as CodeScanningGetAlertResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/code-scanning/alerts/:alert_number',

    validate({
      body: {
        type: 'object',
        properties: {
          state: { $ref: '#/definitions/code-scanning-alert-set-state' },
          dismissed_reason: {
            $ref: '#/definitions/code-scanning-alert-dismissed-reason'
          },
          dismissed_comment: {
            $ref: '#/definitions/code-scanning-alert-dismissed-comment'
          }
        },
        required: ['state'],
        definitions: {
          'code-scanning-alert-set-state': {
            description:
              'Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`.',
            type: 'string',
            enum: ['open', 'dismissed'],
            title: 'code-scanning-alert-set-state'
          },
          'code-scanning-alert-dismissed-reason': {
            type: 'string',
            description:
              '**Required when the state is dismissed.** The reason for dismissing or closing the alert.',
            nullable: true,
            enum: [null, 'false positive', "won't fix", 'used in tests'],
            title: 'code-scanning-alert-dismissed-reason'
          },
          'code-scanning-alert-dismissed-comment': {
            type: 'string',
            description:
              'The dismissal comment associated with the dismissal of the alert.',
            nullable: true,
            maxLength: 280,
            title: 'code-scanning-alert-dismissed-comment'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          alert_number: { $ref: '#/definitions/alert-number' }
        },
        required: ['owner', 'repo', 'alert_number'],
        definitions: {
          'alert-number': {
            type: 'integer',
            description: 'The security alert number.',
            readOnly: true,
            title: 'alert-number'
          }
        }
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codeScanningUpdateAlert'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/code-scanning/alerts/:alert_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodeScanningUpdateAlertRequest,
          res as CodeScanningUpdateAlertResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/code-scanning/alerts/:alert_number/instances',

    validate({
      query: {
        type: 'object',
        properties: {
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 },
          ref: { $ref: '#/definitions/code-scanning-ref' }
        },
        required: [],
        definitions: {
          'code-scanning-ref': {
            type: 'string',
            description:
              'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.',
            title: 'code-scanning-ref'
          }
        }
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          alert_number: { $ref: '#/definitions/alert-number' }
        },
        required: ['owner', 'repo', 'alert_number'],
        definitions: {
          'alert-number': {
            type: 'integer',
            description: 'The security alert number.',
            readOnly: true,
            title: 'alert-number'
          }
        }
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codeScanningListAlertInstances'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/code-scanning/alerts/:alert_number/instances not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodeScanningListAlertInstancesRequest,
          res as CodeScanningListAlertInstancesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/code-scanning/analyses',

    validate({
      query: {
        type: 'object',
        properties: {
          tool_name: { $ref: '#/definitions/code-scanning-analysis-tool-name' },
          tool_guid: { $ref: '#/definitions/code-scanning-analysis-tool-guid' },
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 },
          ref: { $ref: '#/definitions/code-scanning-ref' },
          sarif_id: { $ref: '#/definitions/code-scanning-analysis-sarif-id' },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          sort: { type: 'string', enum: ['created'], default: 'created' }
        },
        required: [],
        definitions: {
          'code-scanning-analysis-tool-name': {
            type: 'string',
            description:
              'The name of the tool used to generate the code scanning analysis.',
            title: 'code-scanning-analysis-tool-name'
          },
          'code-scanning-analysis-tool-guid': {
            nullable: true,
            type: 'string',
            description:
              'The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.',
            title: 'code-scanning-analysis-tool-guid'
          },
          'code-scanning-ref': {
            type: 'string',
            description:
              'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.',
            title: 'code-scanning-ref'
          },
          'code-scanning-analysis-sarif-id': {
            type: 'string',
            description: 'An identifier for the upload.',
            example: '6c81cd8e-b078-4ac3-a3be-1dad7dbd0b53',
            title: 'code-scanning-analysis-sarif-id'
          }
        }
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codeScanningListRecentAnalyses'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/code-scanning/analyses not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodeScanningListRecentAnalysesRequest,
          res as CodeScanningListRecentAnalysesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/code-scanning/analyses/:analysis_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          analysis_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'analysis_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codeScanningGetAnalysis'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/code-scanning/analyses/:analysis_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodeScanningGetAnalysisRequest,
          res as CodeScanningGetAnalysisResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/code-scanning/analyses/:analysis_id',

    validate({
      query: {
        type: 'object',
        properties: { confirm_delete: { type: 'string', nullable: true } },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          analysis_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'analysis_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codeScanningDeleteAnalysis'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/code-scanning/analyses/:analysis_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodeScanningDeleteAnalysisRequest,
          res as CodeScanningDeleteAnalysisResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/code-scanning/codeql/databases',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codeScanningListCodeqlDatabases'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/code-scanning/codeql/databases not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodeScanningListCodeqlDatabasesRequest,
          res as CodeScanningListCodeqlDatabasesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/code-scanning/codeql/databases/:language',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          language: { type: 'string' }
        },
        required: ['owner', 'repo', 'language']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codeScanningGetCodeqlDatabase'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/code-scanning/codeql/databases/:language not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodeScanningGetCodeqlDatabaseRequest,
          res as CodeScanningGetCodeqlDatabaseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/code-scanning/sarifs',

    validate({
      body: {
        type: 'object',
        properties: {
          commit_sha: {
            $ref: '#/definitions/code-scanning-analysis-commit-sha'
          },
          ref: { $ref: '#/definitions/code-scanning-ref' },
          sarif: { $ref: '#/definitions/code-scanning-analysis-sarif-file' },
          checkout_uri: {
            description:
              'The base directory used in the analysis, as it appears in the SARIF file.\nThis property is used to convert file paths from absolute to relative, so that alerts can be mapped to their correct location in the repository.',
            example: 'file:///github/workspace/',
            type: 'string',
            format: 'uri'
          },
          started_at: {
            description:
              'The time that the analysis run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.',
            format: 'date-time',
            type: 'string'
          },
          tool_name: {
            description:
              'The name of the tool used to generate the code scanning analysis. If this parameter is not used, the tool name defaults to "API". If the uploaded SARIF contains a tool GUID, this will be available for filtering using the `tool_guid` parameter of operations such as `GET /repos/{owner}/{repo}/code-scanning/alerts`.',
            type: 'string'
          },
          validate: {
            description:
              'Whether the SARIF file will be validated according to the code scanning specifications.\nThis parameter is intended to help integrators ensure that the uploaded SARIF files are correctly rendered by code scanning.',
            type: 'boolean'
          }
        },
        required: ['commit_sha', 'ref', 'sarif'],
        definitions: {
          'code-scanning-analysis-commit-sha': {
            description:
              'The SHA of the commit to which the analysis you are uploading relates.',
            type: 'string',
            minLength: 40,
            maxLength: 40,
            pattern: '^[0-9a-fA-F]+$',
            title: 'code-scanning-analysis-commit-sha'
          },
          'code-scanning-ref': {
            type: 'string',
            description:
              'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.',
            title: 'code-scanning-ref'
          },
          'code-scanning-analysis-sarif-file': {
            description:
              'A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see "[SARIF support for code scanning](https://docs.github.com/code-security/secure-coding/sarif-support-for-code-scanning)."',
            type: 'string',
            title: 'code-scanning-analysis-sarif-file'
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codeScanningUploadSarif'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/code-scanning/sarifs not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodeScanningUploadSarifRequest,
          res as CodeScanningUploadSarifResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/code-scanning/sarifs/:sarif_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          sarif_id: { type: 'string' }
        },
        required: ['owner', 'repo', 'sarif_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codeScanningGetSarif'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/code-scanning/sarifs/:sarif_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodeScanningGetSarifRequest,
          res as CodeScanningGetSarifResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/codeowners/errors',

    validate({
      query: {
        type: 'object',
        properties: { ref: { type: 'string' } },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCodeownersErrors'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/codeowners/errors not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposCodeownersErrorsRequest,
          res as ReposCodeownersErrorsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/codespaces',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['codespacesListInRepositoryForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/codespaces not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodespacesListInRepositoryForAuthenticatedUserRequest,
          res as CodespacesListInRepositoryForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/codespaces',

    validate({
      body: {
        type: 'object',
        nullable: true,
        properties: {
          ref: {
            description: 'Git ref (typically a branch name) for this codespace',
            type: 'string'
          },
          location: {
            description:
              'Location for this codespace. Assigned by IP if not provided',
            type: 'string'
          },
          client_ip: {
            description:
              'IP for location auto-detection when proxying a request',
            type: 'string'
          },
          machine: {
            description: 'Machine type to use for this codespace',
            type: 'string'
          },
          devcontainer_path: {
            description:
              'Path to devcontainer.json config to use for this codespace',
            type: 'string'
          },
          multi_repo_permissions_opt_out: {
            description:
              'Whether to authorize requested permissions from devcontainer.json',
            type: 'boolean'
          },
          working_directory: {
            description: 'Working directory for this codespace',
            type: 'string'
          },
          idle_timeout_minutes: {
            description:
              'Time in minutes before codespace stops from inactivity',
            type: 'integer'
          },
          display_name: {
            description: 'Display name for this codespace',
            type: 'string'
          },
          retention_period_minutes: {
            description:
              'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).',
            type: 'integer'
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesCreateWithRepoForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/codespaces not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodespacesCreateWithRepoForAuthenticatedUserRequest,
          res as CodespacesCreateWithRepoForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/codespaces/devcontainers',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['codespacesListDevcontainersInRepositoryForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/codespaces/devcontainers not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequest,
          res as CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/codespaces/machines',

    validate({
      query: {
        type: 'object',
        properties: {
          location: { type: 'string', example: 'WestUs2' },
          client_ip: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesRepoMachinesForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/codespaces/machines not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesRepoMachinesForAuthenticatedUserRequest,
          res as CodespacesRepoMachinesForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/codespaces/new',

    validate({
      query: {
        type: 'object',
        properties: {
          ref: { type: 'string', example: 'main' },
          client_ip: { type: 'string', example: '1.2.3.4' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['codespacesPreFlightWithRepoForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/codespaces/new not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesPreFlightWithRepoForAuthenticatedUserRequest,
          res as CodespacesPreFlightWithRepoForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/codespaces/secrets',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesListRepoSecrets'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/codespaces/secrets not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesListRepoSecretsRequest,
          res as CodespacesListRepoSecretsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/codespaces/secrets/public-key',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesGetRepoPublicKey'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/codespaces/secrets/public-key not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesGetRepoPublicKeyRequest,
          res as CodespacesGetRepoPublicKeyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/codespaces/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesGetRepoSecret'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/codespaces/secrets/:secret_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesGetRepoSecretRequest,
          res as CodespacesGetRepoSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/codespaces/secrets/:secret_name',

    validate({
      body: {
        type: 'object',
        properties: {
          encrypted_value: {
            type: 'string',
            description:
              'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/reference/codespaces#get-a-repository-public-key) endpoint.',
            pattern:
              '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          },
          key_id: {
            type: 'string',
            description: 'ID of the key you used to encrypt the secret.'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesCreateOrUpdateRepoSecret'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/codespaces/secrets/:secret_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesCreateOrUpdateRepoSecretRequest,
          res as CodespacesCreateOrUpdateRepoSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/codespaces/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesDeleteRepoSecret'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/codespaces/secrets/:secret_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesDeleteRepoSecretRequest,
          res as CodespacesDeleteRepoSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/collaborators',

    validate({
      query: {
        type: 'object',
        properties: {
          affiliation: {
            type: 'string',
            enum: ['outside', 'direct', 'all'],
            default: 'all'
          },
          permission: {
            type: 'string',
            enum: ['pull', 'triage', 'push', 'maintain', 'admin']
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListCollaborators'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/collaborators not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListCollaboratorsRequest,
          res as ReposListCollaboratorsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/collaborators/:username',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          username: { type: 'string' }
        },
        required: ['owner', 'repo', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCheckCollaborator'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/collaborators/:username not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposCheckCollaboratorRequest,
          res as ReposCheckCollaboratorResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/collaborators/:username',

    validate({
      body: {
        type: 'object',
        properties: {
          permission: {
            type: 'string',
            description:
              'The permission to grant the collaborator. **Only valid on organization-owned repositories.** We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any.',
            default: 'push'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          username: { type: 'string' }
        },
        required: ['owner', 'repo', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposAddCollaborator'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/collaborators/:username not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposAddCollaboratorRequest,
          res as ReposAddCollaboratorResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/collaborators/:username',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          username: { type: 'string' }
        },
        required: ['owner', 'repo', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposRemoveCollaborator'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/collaborators/:username not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposRemoveCollaboratorRequest,
          res as ReposRemoveCollaboratorResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/collaborators/:username/permission',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          username: { type: 'string' }
        },
        required: ['owner', 'repo', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetCollaboratorPermissionLevel'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/collaborators/:username/permission not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetCollaboratorPermissionLevelRequest,
          res as ReposGetCollaboratorPermissionLevelResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/comments',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListCommitCommentsForRepo'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/comments not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListCommitCommentsForRepoRequest,
          res as ReposListCommitCommentsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/comments/:comment_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetCommitComment'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/comments/:comment_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetCommitCommentRequest,
          res as ReposGetCommitCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/comments/:comment_id',

    validate({
      body: {
        type: 'object',
        properties: {
          body: { type: 'string', description: 'The contents of the comment' }
        },
        required: ['body']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposUpdateCommitComment'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/comments/:comment_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposUpdateCommitCommentRequest,
          res as ReposUpdateCommitCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/comments/:comment_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteCommitComment'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/comments/:comment_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteCommitCommentRequest,
          res as ReposDeleteCommitCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/comments/:comment_id/reactions',

    validate({
      query: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsListForCommitComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/comments/:comment_id/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsListForCommitCommentRequest,
          res as ReactionsListForCommitCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/comments/:comment_id/reactions',

    validate({
      body: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            description:
              'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the commit comment.',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          }
        },
        required: ['content']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsCreateForCommitComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/comments/:comment_id/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsCreateForCommitCommentRequest,
          res as ReactionsCreateForCommitCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/comments/:comment_id/reactions/:reaction_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' },
          reaction_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id', 'reaction_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsDeleteForCommitComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/comments/:comment_id/reactions/:reaction_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsDeleteForCommitCommentRequest,
          res as ReactionsDeleteForCommitCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/commits',

    validate({
      query: {
        type: 'object',
        properties: {
          sha: { type: 'string' },
          path: { type: 'string' },
          author: { type: 'string' },
          since: { type: 'string', format: 'date-time' },
          until: { type: 'string', format: 'date-time' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListCommits'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/commits not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListCommitsRequest,
          res as ReposListCommitsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/commits/:commit_sha/branches-where-head',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          commit_sha: { type: 'string' }
        },
        required: ['owner', 'repo', 'commit_sha']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListBranchesForHeadCommit'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/commits/:commit_sha/branches-where-head not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposListBranchesForHeadCommitRequest,
          res as ReposListBranchesForHeadCommitResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/commits/:commit_sha/comments',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          commit_sha: { type: 'string' }
        },
        required: ['owner', 'repo', 'commit_sha']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListCommentsForCommit'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/commits/:commit_sha/comments not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposListCommentsForCommitRequest,
          res as ReposListCommentsForCommitResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/commits/:commit_sha/comments',

    validate({
      body: {
        type: 'object',
        properties: {
          body: { type: 'string', description: 'The contents of the comment.' },
          path: {
            type: 'string',
            description: 'Relative path of the file to comment on.'
          },
          position: {
            type: 'integer',
            description: 'Line index in the diff to comment on.'
          },
          line: {
            type: 'integer',
            description:
              '**Deprecated**. Use **position** parameter instead. Line number in the file to comment on.'
          }
        },
        required: ['body']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          commit_sha: { type: 'string' }
        },
        required: ['owner', 'repo', 'commit_sha']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateCommitComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/commits/:commit_sha/comments not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposCreateCommitCommentRequest,
          res as ReposCreateCommitCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/commits/:commit_sha/pulls',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          commit_sha: { type: 'string' }
        },
        required: ['owner', 'repo', 'commit_sha']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListPullRequestsAssociatedWithCommit'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/commits/:commit_sha/pulls not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposListPullRequestsAssociatedWithCommitRequest,
          res as ReposListPullRequestsAssociatedWithCommitResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/commits/:ref',

    validate({
      query: {
        type: 'object',
        properties: {
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          ref: { type: 'string' }
        },
        required: ['owner', 'repo', 'ref']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetCommit'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/commits/:ref not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposGetCommitRequest,
          res as ReposGetCommitResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/commits/:ref/check-runs',

    validate({
      query: {
        type: 'object',
        properties: {
          check_name: { type: 'string' },
          status: {
            type: 'string',
            enum: ['queued', 'in_progress', 'completed']
          },
          filter: {
            type: 'string',
            enum: ['latest', 'all'],
            default: 'latest'
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 },
          app_id: { type: 'integer' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          ref: { type: 'string' }
        },
        required: ['owner', 'repo', 'ref']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['checksListForRef'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/commits/:ref/check-runs not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ChecksListForRefRequest,
          res as ChecksListForRefResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/commits/:ref/check-suites',

    validate({
      query: {
        type: 'object',
        properties: {
          app_id: { type: 'integer' },
          check_name: { type: 'string' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          ref: { type: 'string' }
        },
        required: ['owner', 'repo', 'ref']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['checksListSuitesForRef'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/commits/:ref/check-suites not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ChecksListSuitesForRefRequest,
          res as ChecksListSuitesForRefResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/commits/:ref/status',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          ref: { type: 'string' }
        },
        required: ['owner', 'repo', 'ref']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetCombinedStatusForRef'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/commits/:ref/status not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetCombinedStatusForRefRequest,
          res as ReposGetCombinedStatusForRefResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/commits/:ref/statuses',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          ref: { type: 'string' }
        },
        required: ['owner', 'repo', 'ref']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListCommitStatusesForRef'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/commits/:ref/statuses not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposListCommitStatusesForRefRequest,
          res as ReposListCommitStatusesForRefResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/community/profile',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetCommunityProfileMetrics'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/community/profile not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetCommunityProfileMetricsRequest,
          res as ReposGetCommunityProfileMetricsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/compare/:basehead',

    validate({
      query: {
        type: 'object',
        properties: {
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          basehead: { type: 'string' }
        },
        required: ['owner', 'repo', 'basehead']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCompareCommits'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/compare/:basehead not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposCompareCommitsRequest,
          res as ReposCompareCommitsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/contents/:path',

    validate({
      query: {
        type: 'object',
        properties: { ref: { type: 'string' } },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          path: { type: 'string' }
        },
        required: ['owner', 'repo', 'path']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetContent'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/contents/:path not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetContentRequest,
          res as ReposGetContentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/contents/:path',

    validate({
      body: {
        type: 'object',
        properties: {
          message: { type: 'string', description: 'The commit message.' },
          content: {
            type: 'string',
            description: 'The new file content, using Base64 encoding.'
          },
          sha: {
            type: 'string',
            description:
              '**Required if you are updating a file**. The blob SHA of the file being replaced.'
          },
          branch: {
            type: 'string',
            description:
              'The branch name. Default: the repository’s default branch (usually `master`)'
          },
          committer: {
            type: 'object',
            description:
              'The person that committed the file. Default: the authenticated user.',
            properties: {
              name: {
                type: 'string',
                description:
                  "The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted."
              },
              email: {
                type: 'string',
                description:
                  "The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted."
              },
              date: { type: 'string', example: '"2013-01-05T13:13:22+05:00"' }
            },
            required: ['name', 'email']
          },
          author: {
            type: 'object',
            description:
              'The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.',
            properties: {
              name: {
                type: 'string',
                description:
                  "The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted."
              },
              email: {
                type: 'string',
                description:
                  "The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted."
              },
              date: { type: 'string', example: '"2013-01-15T17:13:22+05:00"' }
            },
            required: ['name', 'email']
          }
        },
        required: ['message', 'content']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          path: { type: 'string' }
        },
        required: ['owner', 'repo', 'path']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateOrUpdateFileContents'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/contents/:path not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposCreateOrUpdateFileContentsRequest,
          res as ReposCreateOrUpdateFileContentsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/contents/:path',

    validate({
      body: {
        type: 'object',
        properties: {
          message: { type: 'string', description: 'The commit message.' },
          sha: {
            type: 'string',
            description: 'The blob SHA of the file being deleted.'
          },
          branch: {
            type: 'string',
            description:
              'The branch name. Default: the repository’s default branch (usually `master`)'
          },
          committer: {
            type: 'object',
            description: 'object containing information about the committer.',
            properties: {
              name: {
                type: 'string',
                description:
                  'The name of the author (or committer) of the commit'
              },
              email: {
                type: 'string',
                description:
                  'The email of the author (or committer) of the commit'
              }
            }
          },
          author: {
            type: 'object',
            description: 'object containing information about the author.',
            properties: {
              name: {
                type: 'string',
                description:
                  'The name of the author (or committer) of the commit'
              },
              email: {
                type: 'string',
                description:
                  'The email of the author (or committer) of the commit'
              }
            }
          }
        },
        required: ['message', 'sha']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          path: { type: 'string' }
        },
        required: ['owner', 'repo', 'path']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteFile'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/contents/:path not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteFileRequest,
          res as ReposDeleteFileResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/contributors',

    validate({
      query: {
        type: 'object',
        properties: {
          anon: { type: 'string' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListContributors'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/contributors not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListContributorsRequest,
          res as ReposListContributorsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/dependabot/alerts',

    validate({
      query: {
        type: 'object',
        properties: {
          state: { type: 'string' },
          severity: { type: 'string' },
          ecosystem: { type: 'string' },
          package: { type: 'string' },
          manifest: { type: 'string' },
          scope: { type: 'string', enum: ['development', 'runtime'] },
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 },
          before: { type: 'string' },
          after: { type: 'string' },
          first: { type: 'integer', minimum: 1, maximum: 100, default: 30 },
          last: { type: 'integer', minimum: 1, maximum: 100 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotListAlertsForRepo'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/dependabot/alerts not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotListAlertsForRepoRequest,
          res as DependabotListAlertsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/dependabot/alerts/:alert_number',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          alert_number: { $ref: '#/definitions/alert-number' }
        },
        required: ['owner', 'repo', 'alert_number'],
        definitions: {
          'alert-number': {
            type: 'integer',
            description: 'The security alert number.',
            readOnly: true,
            title: 'alert-number'
          }
        }
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotGetAlert'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/dependabot/alerts/:alert_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotGetAlertRequest,
          res as DependabotGetAlertResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/dependabot/alerts/:alert_number',

    validate({
      body: {
        type: 'object',
        properties: {
          state: {
            type: 'string',
            description:
              'The state of the Dependabot alert.\nA `dismissed_reason` must be provided when setting the state to `dismissed`.',
            enum: ['dismissed', 'open']
          },
          dismissed_reason: {
            type: 'string',
            description:
              '**Required when `state` is `dismissed`.** A reason for dismissing the alert.',
            enum: [
              'fix_started',
              'inaccurate',
              'no_bandwidth',
              'not_used',
              'tolerable_risk'
            ]
          },
          dismissed_comment: {
            type: 'string',
            description:
              'An optional comment associated with dismissing the alert.',
            maxLength: 280
          }
        },
        required: ['state'],
        additionalProperties: false
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          alert_number: { $ref: '#/definitions/alert-number' }
        },
        required: ['owner', 'repo', 'alert_number'],
        definitions: {
          'alert-number': {
            type: 'integer',
            description: 'The security alert number.',
            readOnly: true,
            title: 'alert-number'
          }
        }
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotUpdateAlert'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/dependabot/alerts/:alert_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotUpdateAlertRequest,
          res as DependabotUpdateAlertResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/dependabot/secrets',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotListRepoSecrets'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/dependabot/secrets not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotListRepoSecretsRequest,
          res as DependabotListRepoSecretsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/dependabot/secrets/public-key',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotGetRepoPublicKey'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/dependabot/secrets/public-key not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotGetRepoPublicKeyRequest,
          res as DependabotGetRepoPublicKeyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/dependabot/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotGetRepoSecret'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/dependabot/secrets/:secret_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotGetRepoSecretRequest,
          res as DependabotGetRepoSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/dependabot/secrets/:secret_name',

    validate({
      body: {
        type: 'object',
        properties: {
          encrypted_value: {
            type: 'string',
            description:
              'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/reference/dependabot#get-a-repository-public-key) endpoint.',
            pattern:
              '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          },
          key_id: {
            type: 'string',
            description: 'ID of the key you used to encrypt the secret.'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotCreateOrUpdateRepoSecret'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/dependabot/secrets/:secret_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotCreateOrUpdateRepoSecretRequest,
          res as DependabotCreateOrUpdateRepoSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/dependabot/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependabotDeleteRepoSecret'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/dependabot/secrets/:secret_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as DependabotDeleteRepoSecretRequest,
          res as DependabotDeleteRepoSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/dependency-graph/compare/:basehead',

    validate({
      query: {
        type: 'object',
        properties: { name: { type: 'string' } },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          basehead: { type: 'string' }
        },
        required: ['owner', 'repo', 'basehead']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependencyGraphDiffRange'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/dependency-graph/compare/:basehead not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as DependencyGraphDiffRangeRequest,
          res as DependencyGraphDiffRangeResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/dependency-graph/snapshots',

    validate({
      body: {
        $ref: '#/definitions/snapshot',
        definitions: {
          snapshot: {
            title: 'snapshot',
            description:
              "Create a new snapshot of a repository's dependencies.",
            type: 'object',
            properties: {
              version: {
                description:
                  'The version of the repository snapshot submission.',
                type: 'integer'
              },
              job: {
                type: 'object',
                properties: {
                  id: {
                    type: 'string',
                    description: 'The external ID of the job.',
                    example: '5622a2b0-63f6-4732-8c34-a1ab27e102a11'
                  },
                  correlator: {
                    type: 'string',
                    description:
                      'Correlator provides a key that is used to group snapshots submitted over time. Only the "latest" submitted snapshot for a given combination of `job.correlator` and `detector.name` will be considered when calculating a repository\'s current dependencies. Correlator should be as unique as it takes to distinguish all detection runs for a given "wave" of CI workflow you run. If you\'re using GitHub Actions, a good default value for this could be the environment variables GITHUB_WORKFLOW and GITHUB_JOB concatenated together. If you\'re using a build matrix, then you\'ll also need to add additional key(s) to distinguish between each submission inside a matrix variation.',
                    example: 'yourworkflowname_yourjobname'
                  },
                  html_url: {
                    type: 'string',
                    description: 'The url for the job.',
                    example: 'http://example.com/build'
                  }
                },
                required: ['id', 'correlator'],
                additionalProperties: false
              },
              sha: {
                description:
                  'The commit SHA associated with this dependency snapshot.',
                type: 'string',
                example: 'ddc951f4b1293222421f2c8df679786153acf689',
                minLength: 40
              },
              ref: {
                description:
                  'The repository branch that triggered this snapshot.',
                type: 'string',
                pattern: '^refs/',
                example: 'refs/heads/main'
              },
              detector: {
                type: 'object',
                description: 'A description of the detector used.',
                properties: {
                  name: {
                    type: 'string',
                    description: 'The name of the detector used.',
                    example: 'docker buildtime detector'
                  },
                  version: {
                    type: 'string',
                    description: 'The version of the detector used.',
                    example: '1.0.0'
                  },
                  url: {
                    type: 'string',
                    description: 'The url of the detector used.',
                    example: 'http://example.com/docker-buildtimer-detector'
                  }
                },
                required: ['name', 'version', 'url'],
                additionalProperties: false
              },
              metadata: { $ref: '#/definitions/metadata' },
              manifests: {
                type: 'object',
                description:
                  'A collection of package manifests, which are a collection of related dependencies declared in a file or representing a logical group of dependencies.',
                additionalProperties: { $ref: '#/definitions/manifest' }
              },
              scanned: {
                type: 'string',
                format: 'date-time',
                description: 'The time at which the snapshot was scanned.',
                example: '2020-06-13T14:52:50-05:00'
              }
            },
            required: ['detector', 'version', 'ref', 'sha', 'job', 'scanned'],
            additionalProperties: false
          },
          metadata: {
            title: 'metadata',
            description:
              'User-defined metadata to store domain-specific information limited to 8 keys with scalar values.',
            type: 'object',
            maxProperties: 8,
            additionalProperties: {
              nullable: true,
              anyOf: [
                { type: 'string' },
                { type: 'number' },
                { type: 'boolean' }
              ]
            }
          },
          manifest: {
            type: 'object',
            properties: {
              name: {
                type: 'string',
                description: 'The name of the manifest.',
                example: 'package-lock.json'
              },
              file: {
                type: 'object',
                properties: {
                  source_location: {
                    type: 'string',
                    description:
                      'The path of the manifest file relative to the root of the Git repository.',
                    example: '/src/build/package-lock.json'
                  }
                },
                additionalProperties: false
              },
              metadata: { $ref: '#/definitions/metadata' },
              resolved: {
                type: 'object',
                description: 'A collection of resolved package dependencies.',
                additionalProperties: { $ref: '#/definitions/dependency' }
              }
            },
            required: ['name'],
            additionalProperties: false,
            title: 'manifest'
          },
          dependency: {
            type: 'object',
            properties: {
              package_url: {
                type: 'string',
                description:
                  'Package-url (PURL) of dependency. See https://github.com/package-url/purl-spec for more details.',
                example: 'pkg:/npm/%40actions/http-client@1.0.11',
                pattern: '^pkg'
              },
              metadata: { $ref: '#/definitions/metadata' },
              relationship: {
                type: 'string',
                description:
                  'A notation of whether a dependency is requested directly by this manifest or is a dependency of another dependency.',
                example: 'direct',
                enum: ['direct', 'indirect']
              },
              scope: {
                type: 'string',
                description:
                  'A notation of whether the dependency is required for the primary build artifact (runtime) or is only used for development. Future versions of this specification may allow for more granular scopes.',
                example: 'runtime',
                enum: ['runtime', 'development']
              },
              dependencies: {
                type: 'array',
                description:
                  'Array of package-url (PURLs) of direct child dependencies.',
                example: '@actions/http-client',
                items: { type: 'string' }
              }
            },
            additionalProperties: false,
            title: 'dependency'
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['dependencyGraphCreateRepositorySnapshot'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/dependency-graph/snapshots not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as DependencyGraphCreateRepositorySnapshotRequest,
          res as DependencyGraphCreateRepositorySnapshotResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/deployments',

    validate({
      query: {
        type: 'object',
        properties: {
          sha: { type: 'string', default: 'none' },
          ref: { type: 'string', default: 'none' },
          task: { type: 'string', default: 'none' },
          environment: { type: 'string', default: 'none', nullable: true },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListDeployments'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/deployments not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListDeploymentsRequest,
          res as ReposListDeploymentsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/deployments',

    validate({
      body: {
        type: 'object',
        properties: {
          ref: {
            type: 'string',
            description: 'The ref to deploy. This can be a branch, tag, or SHA.'
          },
          task: {
            type: 'string',
            description:
              'Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).',
            default: 'deploy'
          },
          auto_merge: {
            type: 'boolean',
            description:
              "Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch.",
            default: true
          },
          required_contexts: {
            type: 'array',
            description:
              'The [status](https://docs.github.com/rest/commits/statuses) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts.',
            items: { type: 'string' }
          },
          payload: {
            oneOf: [
              { type: 'object', additionalProperties: true },
              {
                type: 'string',
                description:
                  'JSON payload with extra information about the deployment.',
                default: ''
              }
            ]
          },
          environment: {
            type: 'string',
            description:
              'Name for the target deployment environment (e.g., `production`, `staging`, `qa`).',
            default: 'production'
          },
          description: {
            type: 'string',
            description: 'Short description of the deployment.',
            default: '',
            nullable: true
          },
          transient_environment: {
            type: 'boolean',
            description:
              'Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`',
            default: false
          },
          production_environment: {
            type: 'boolean',
            description:
              'Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.'
          }
        },
        required: ['ref']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateDeployment'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/deployments not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposCreateDeploymentRequest,
          res as ReposCreateDeploymentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/deployments/:deployment_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          deployment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'deployment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetDeployment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/deployments/:deployment_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetDeploymentRequest,
          res as ReposGetDeploymentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/deployments/:deployment_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          deployment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'deployment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteDeployment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/deployments/:deployment_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteDeploymentRequest,
          res as ReposDeleteDeploymentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/deployments/:deployment_id/statuses',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          deployment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'deployment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListDeploymentStatuses'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/deployments/:deployment_id/statuses not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposListDeploymentStatusesRequest,
          res as ReposListDeploymentStatusesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/deployments/:deployment_id/statuses',

    validate({
      body: {
        type: 'object',
        properties: {
          state: {
            type: 'string',
            description:
              'The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.',
            enum: [
              'error',
              'failure',
              'inactive',
              'in_progress',
              'queued',
              'pending',
              'success'
            ]
          },
          target_url: {
            type: 'string',
            description:
              "The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment. **Note:** It's recommended to use the `log_url` parameter, which replaces `target_url`.",
            default: ''
          },
          log_url: {
            type: 'string',
            description:
              'The full URL of the deployment\'s output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `""`',
            default: ''
          },
          description: {
            type: 'string',
            description:
              'A short description of the status. The maximum description length is 140 characters.',
            default: ''
          },
          environment: {
            type: 'string',
            description:
              'Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`.',
            enum: ['production', 'staging', 'qa']
          },
          environment_url: {
            type: 'string',
            description:
              'Sets the URL for accessing your environment. Default: `""`',
            default: ''
          },
          auto_inactive: {
            type: 'boolean',
            description:
              "Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`"
          }
        },
        required: ['state']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          deployment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'deployment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateDeploymentStatus'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/deployments/:deployment_id/statuses not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposCreateDeploymentStatusRequest,
          res as ReposCreateDeploymentStatusResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/deployments/:deployment_id/statuses/:status_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          deployment_id: { type: 'integer' },
          status_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'deployment_id', 'status_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetDeploymentStatus'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/deployments/:deployment_id/statuses/:status_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetDeploymentStatusRequest,
          res as ReposGetDeploymentStatusResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/dispatches',

    validate({
      body: {
        type: 'object',
        required: ['event_type'],
        properties: {
          event_type: {
            type: 'string',
            description:
              'A custom webhook event name. Must be 100 characters or fewer.',
            minLength: 1,
            maxLength: 100
          },
          client_payload: {
            type: 'object',
            description:
              'JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10.',
            additionalProperties: true,
            maxProperties: 10
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateDispatchEvent'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/dispatches not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposCreateDispatchEventRequest,
          res as ReposCreateDispatchEventResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/environments',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetAllEnvironments'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/environments not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposGetAllEnvironmentsRequest,
          res as ReposGetAllEnvironmentsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/environments/:environment_name',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          environment_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'environment_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetEnvironment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/environments/:environment_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetEnvironmentRequest,
          res as ReposGetEnvironmentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/environments/:environment_name',

    validate({
      body: {
        type: 'object',
        nullable: true,
        properties: {
          wait_timer: { $ref: '#/definitions/wait-timer' },
          reviewers: {
            type: 'array',
            nullable: true,
            description:
              'The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.',
            items: {
              type: 'object',
              properties: {
                type: { $ref: '#/definitions/deployment-reviewer-type' },
                id: {
                  type: 'integer',
                  description:
                    'The id of the user or team who can review the deployment',
                  example: 4532992
                }
              }
            }
          },
          deployment_branch_policy: {
            $ref: '#/definitions/deployment-branch-policy-settings'
          }
        },
        additionalProperties: false,
        definitions: {
          'wait-timer': {
            type: 'integer',
            example: 30,
            description:
              'The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).',
            title: 'wait-timer'
          },
          'deployment-reviewer-type': {
            type: 'string',
            description: 'The type of reviewer.',
            enum: ['User', 'Team'],
            example: 'User',
            title: 'deployment-reviewer-type'
          },
          'deployment-branch-policy-settings': {
            type: 'object',
            description:
              'The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.',
            properties: {
              protected_branches: {
                type: 'boolean',
                description:
                  'Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`.'
              },
              custom_branch_policies: {
                type: 'boolean',
                description:
                  'Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`.'
              }
            },
            nullable: true,
            required: ['protected_branches', 'custom_branch_policies'],
            title: 'deployment-branch-policy-settings'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          environment_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'environment_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateOrUpdateEnvironment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/environments/:environment_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposCreateOrUpdateEnvironmentRequest,
          res as ReposCreateOrUpdateEnvironmentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/environments/:environment_name',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          environment_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'environment_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteAnEnvironment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/environments/:environment_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteAnEnvironmentRequest,
          res as ReposDeleteAnEnvironmentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          environment_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'environment_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListDeploymentBranchPolicies'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposListDeploymentBranchPoliciesRequest,
          res as ReposListDeploymentBranchPoliciesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies',

    validate({
      body: {
        $ref: '#/definitions/deployment-branch-policy-name-pattern',
        definitions: {
          'deployment-branch-policy-name-pattern': {
            title: 'Deployment branch policy name pattern',
            type: 'object',
            properties: {
              name: {
                description:
                  'The name pattern that branches must match in order to deploy to the environment.\n\nWildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.\nFor more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).',
                type: 'string',
                example: 'release/*'
              }
            },
            required: ['name']
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          environment_name: { type: 'string' }
        },
        required: ['owner', 'repo', 'environment_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateDeploymentBranchPolicy'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposCreateDeploymentBranchPolicyRequest,
          res as ReposCreateDeploymentBranchPolicyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          environment_name: { type: 'string' },
          branch_policy_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'environment_name', 'branch_policy_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetDeploymentBranchPolicy'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetDeploymentBranchPolicyRequest,
          res as ReposGetDeploymentBranchPolicyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id',

    validate({
      body: {
        $ref: '#/definitions/deployment-branch-policy-name-pattern',
        definitions: {
          'deployment-branch-policy-name-pattern': {
            title: 'Deployment branch policy name pattern',
            type: 'object',
            properties: {
              name: {
                description:
                  'The name pattern that branches must match in order to deploy to the environment.\n\nWildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.\nFor more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).',
                type: 'string',
                example: 'release/*'
              }
            },
            required: ['name']
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          environment_name: { type: 'string' },
          branch_policy_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'environment_name', 'branch_policy_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposUpdateDeploymentBranchPolicy'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposUpdateDeploymentBranchPolicyRequest,
          res as ReposUpdateDeploymentBranchPolicyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          environment_name: { type: 'string' },
          branch_policy_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'environment_name', 'branch_policy_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteDeploymentBranchPolicy'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteDeploymentBranchPolicyRequest,
          res as ReposDeleteDeploymentBranchPolicyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/events',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListRepoEvents'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/events not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListRepoEventsRequest,
          res as ActivityListRepoEventsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/forks',

    validate({
      query: {
        type: 'object',
        properties: {
          sort: {
            type: 'string',
            enum: ['newest', 'oldest', 'stargazers', 'watchers'],
            default: 'newest'
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListForks'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/forks not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListForksRequest,
          res as ReposListForksResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/forks',

    validate({
      body: {
        type: 'object',
        nullable: true,
        properties: {
          organization: {
            type: 'string',
            description:
              'Optional parameter to specify the organization name if forking into an organization.'
          },
          name: {
            type: 'string',
            description:
              'When forking from an existing repository, a new name for the fork.'
          },
          default_branch_only: {
            type: 'boolean',
            description:
              'When forking from an existing repository, fork with only the default branch.'
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateFork'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/forks not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposCreateForkRequest,
          res as ReposCreateForkResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/git/blobs',

    validate({
      body: {
        type: 'object',
        properties: {
          content: { type: 'string', description: "The new blob's content." },
          encoding: {
            type: 'string',
            description:
              'The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.',
            default: 'utf-8'
          }
        },
        required: ['content']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitCreateBlob'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/git/blobs not handled'));
      }

      try {
        await handler(
          (req as unknown) as GitCreateBlobRequest,
          res as GitCreateBlobResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/git/blobs/:file_sha',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          file_sha: { type: 'string' }
        },
        required: ['owner', 'repo', 'file_sha']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitGetBlob'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/git/blobs/:file_sha not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as GitGetBlobRequest,
          res as GitGetBlobResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/git/commits',

    validate({
      body: {
        type: 'object',
        properties: {
          message: { type: 'string', description: 'The commit message' },
          tree: {
            type: 'string',
            description: 'The SHA of the tree object this commit points to'
          },
          parents: {
            type: 'array',
            description:
              'The SHAs of the commits that were the parents of this commit. If omitted or empty, the commit will be written as a root commit. For a single parent, an array of one SHA should be provided; for a merge commit, an array of more than one should be provided.',
            items: { type: 'string' }
          },
          author: {
            type: 'object',
            description:
              'Information about the author of the commit. By default, the `author` will be the authenticated user and the current date. See the `author` and `committer` object below for details.',
            properties: {
              name: {
                type: 'string',
                description:
                  'The name of the author (or committer) of the commit'
              },
              email: {
                type: 'string',
                description:
                  'The email of the author (or committer) of the commit'
              },
              date: {
                type: 'string',
                format: 'date-time',
                description:
                  'Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
              }
            },
            required: ['name', 'email']
          },
          committer: {
            type: 'object',
            description:
              'Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.',
            properties: {
              name: {
                type: 'string',
                description:
                  'The name of the author (or committer) of the commit'
              },
              email: {
                type: 'string',
                description:
                  'The email of the author (or committer) of the commit'
              },
              date: {
                type: 'string',
                format: 'date-time',
                description:
                  'Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
              }
            }
          },
          signature: {
            type: 'string',
            description:
              'The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the commit. GitHub adds the signature to the `gpgsig` header of the created commit. For a commit signature to be verifiable by Git or GitHub, it must be an ASCII-armored detached PGP signature over the string commit as it would be written to the object database. To pass a `signature` parameter, you need to first manually create a valid PGP signature, which can be complicated. You may find it easier to [use the command line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create signed commits.'
          }
        },
        required: ['message', 'tree']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitCreateCommit'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/git/commits not handled'));
      }

      try {
        await handler(
          (req as unknown) as GitCreateCommitRequest,
          res as GitCreateCommitResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/git/commits/:commit_sha',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          commit_sha: { type: 'string' }
        },
        required: ['owner', 'repo', 'commit_sha']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitGetCommit'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/git/commits/:commit_sha not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as GitGetCommitRequest,
          res as GitGetCommitResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/git/matching-refs/:ref',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          ref: { type: 'string' }
        },
        required: ['owner', 'repo', 'ref']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitListMatchingRefs'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/git/matching-refs/:ref not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as GitListMatchingRefsRequest,
          res as GitListMatchingRefsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/git/ref/:ref',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          ref: { type: 'string' }
        },
        required: ['owner', 'repo', 'ref']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitGetRef'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/git/ref/:ref not handled'));
      }

      try {
        await handler(
          (req as unknown) as GitGetRefRequest,
          res as GitGetRefResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/git/refs',

    validate({
      body: {
        type: 'object',
        properties: {
          ref: {
            type: 'string',
            description:
              "The name of the fully qualified reference (ie: `refs/heads/master`). If it doesn't start with 'refs' and have at least two slashes, it will be rejected."
          },
          sha: {
            type: 'string',
            description: 'The SHA1 value for this reference.'
          },
          key: { type: 'string', example: '"refs/heads/newbranch"' }
        },
        required: ['ref', 'sha']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitCreateRef'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/git/refs not handled'));
      }

      try {
        await handler(
          (req as unknown) as GitCreateRefRequest,
          res as GitCreateRefResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/git/refs/:ref',

    validate({
      body: {
        type: 'object',
        properties: {
          sha: {
            type: 'string',
            description: 'The SHA1 value to set this reference to'
          },
          force: {
            type: 'boolean',
            description:
              "Indicates whether to force the update or to make sure the update is a fast-forward update. Leaving this out or setting it to `false` will make sure you're not overwriting work.",
            default: false
          }
        },
        required: ['sha']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          ref: { type: 'string' }
        },
        required: ['owner', 'repo', 'ref']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitUpdateRef'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/git/refs/:ref not handled'));
      }

      try {
        await handler(
          (req as unknown) as GitUpdateRefRequest,
          res as GitUpdateRefResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/git/refs/:ref',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          ref: { type: 'string' }
        },
        required: ['owner', 'repo', 'ref']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitDeleteRef'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/git/refs/:ref not handled'));
      }

      try {
        await handler(
          (req as unknown) as GitDeleteRefRequest,
          res as GitDeleteRefResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/git/tags',

    validate({
      body: {
        type: 'object',
        properties: {
          tag: {
            type: 'string',
            description:
              'The tag\'s name. This is typically a version (e.g., "v0.0.1").'
          },
          message: { type: 'string', description: 'The tag message.' },
          object: {
            type: 'string',
            description: 'The SHA of the git object this is tagging.'
          },
          type: {
            type: 'string',
            description:
              "The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`.",
            enum: ['commit', 'tree', 'blob']
          },
          tagger: {
            type: 'object',
            description:
              'An object with information about the individual creating the tag.',
            properties: {
              name: {
                type: 'string',
                description: 'The name of the author of the tag'
              },
              email: {
                type: 'string',
                description: 'The email of the author of the tag'
              },
              date: {
                type: 'string',
                format: 'date-time',
                description:
                  'When this object was tagged. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
              }
            },
            required: ['name', 'email']
          }
        },
        required: ['tag', 'message', 'object', 'type']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitCreateTag'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/git/tags not handled'));
      }

      try {
        await handler(
          (req as unknown) as GitCreateTagRequest,
          res as GitCreateTagResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/git/tags/:tag_sha',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          tag_sha: { type: 'string' }
        },
        required: ['owner', 'repo', 'tag_sha']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitGetTag'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/git/tags/:tag_sha not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as GitGetTagRequest,
          res as GitGetTagResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/git/trees',

    validate({
      body: {
        type: 'object',
        properties: {
          tree: {
            type: 'array',
            description:
              'Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure.',
            items: {
              type: 'object',
              properties: {
                path: {
                  type: 'string',
                  description: 'The file referenced in the tree.'
                },
                mode: {
                  type: 'string',
                  description:
                    'The file mode; one of `100644` for file (blob), `100755` for executable (blob), `040000` for subdirectory (tree), `160000` for submodule (commit), or `120000` for a blob that specifies the path of a symlink.',
                  enum: ['100644', '100755', '040000', '160000', '120000']
                },
                type: {
                  type: 'string',
                  description: 'Either `blob`, `tree`, or `commit`.',
                  enum: ['blob', 'tree', 'commit']
                },
                sha: {
                  type: 'string',
                  description:
                    'The SHA1 checksum ID of the object in the tree. Also called `tree.sha`. If the value is `null` then the file will be deleted.  \n  \n**Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.',
                  nullable: true
                },
                content: {
                  type: 'string',
                  description:
                    'The content you want this file to have. GitHub will write this blob out and use that SHA for this entry. Use either this, or `tree.sha`.  \n  \n**Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.'
                }
              }
            }
          },
          base_tree: {
            type: 'string',
            description:
              "The SHA1 of an existing Git tree object which will be used as the base for the new tree. If provided, a new Git tree object will be created from entries in the Git tree object pointed to by `base_tree` and entries defined in the `tree` parameter. Entries defined in the `tree` parameter will overwrite items from `base_tree` with the same `path`. If you're creating new changes on a branch, then normally you'd set `base_tree` to the SHA1 of the Git tree object of the current latest commit on the branch you're working on.\nIf not provided, GitHub will create a new Git tree object from only the entries defined in the `tree` parameter. If you create a new commit pointing to such a tree, then all files which were a part of the parent commit's tree and were not defined in the `tree` parameter will be listed as deleted by the new commit.\n"
          }
        },
        required: ['tree']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitCreateTree'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/git/trees not handled'));
      }

      try {
        await handler(
          (req as unknown) as GitCreateTreeRequest,
          res as GitCreateTreeResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/git/trees/:tree_sha',

    validate({
      query: {
        type: 'object',
        properties: { recursive: { type: 'string' } },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          tree_sha: { type: 'string' }
        },
        required: ['owner', 'repo', 'tree_sha']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gitGetTree'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/git/trees/:tree_sha not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as GitGetTreeRequest,
          res as GitGetTreeResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/hooks',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListWebhooks'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/hooks not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListWebhooksRequest,
          res as ReposListWebhooksResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/hooks',

    validate({
      body: {
        type: 'object',
        nullable: true,
        properties: {
          name: {
            type: 'string',
            description:
              'Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`.'
          },
          config: {
            type: 'object',
            description:
              'Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).',
            properties: {
              url: { $ref: '#/definitions/webhook-config-url' },
              content_type: {
                $ref: '#/definitions/webhook-config-content-type'
              },
              secret: { $ref: '#/definitions/webhook-config-secret' },
              insecure_ssl: {
                $ref: '#/definitions/webhook-config-insecure-ssl'
              },
              token: { type: 'string', example: '"abc"' },
              digest: { type: 'string', example: '"sha256"' }
            }
          },
          events: {
            type: 'array',
            description:
              'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.',
            default: ['push'],
            items: { type: 'string' }
          },
          active: {
            type: 'boolean',
            description:
              'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.',
            default: true
          }
        },
        additionalProperties: false,
        definitions: {
          'webhook-config-url': {
            type: 'string',
            description: 'The URL to which the payloads will be delivered.',
            example: 'https://example.com/webhook',
            format: 'uri',
            title: 'webhook-config-url'
          },
          'webhook-config-content-type': {
            type: 'string',
            description:
              'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
            example: '"json"',
            title: 'webhook-config-content-type'
          },
          'webhook-config-secret': {
            type: 'string',
            description:
              'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
            example: '"********"',
            title: 'webhook-config-secret'
          },
          'webhook-config-insecure-ssl': {
            oneOf: [
              {
                type: 'string',
                description:
                  'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                example: '"0"'
              },
              { type: 'number' }
            ],
            title: 'webhook-config-insecure-ssl'
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateWebhook'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/hooks not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposCreateWebhookRequest,
          res as ReposCreateWebhookResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/hooks/:hook_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          hook_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetWebhook'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/hooks/:hook_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetWebhookRequest,
          res as ReposGetWebhookResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/hooks/:hook_id',

    validate({
      body: {
        type: 'object',
        properties: {
          config: {
            type: 'object',
            description:
              'Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).',
            properties: {
              url: { $ref: '#/definitions/webhook-config-url' },
              content_type: {
                $ref: '#/definitions/webhook-config-content-type'
              },
              secret: { $ref: '#/definitions/webhook-config-secret' },
              insecure_ssl: {
                $ref: '#/definitions/webhook-config-insecure-ssl'
              },
              address: { type: 'string', example: '"bar@example.com"' },
              room: { type: 'string', example: '"The Serious Room"' }
            },
            required: ['url']
          },
          events: {
            type: 'array',
            description:
              'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events.',
            default: ['push'],
            items: { type: 'string' }
          },
          add_events: {
            type: 'array',
            description:
              'Determines a list of events to be added to the list of events that the Hook triggers for.',
            items: { type: 'string' }
          },
          remove_events: {
            type: 'array',
            description:
              'Determines a list of events to be removed from the list of events that the Hook triggers for.',
            items: { type: 'string' }
          },
          active: {
            type: 'boolean',
            description:
              'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.',
            default: true
          }
        },
        definitions: {
          'webhook-config-url': {
            type: 'string',
            description: 'The URL to which the payloads will be delivered.',
            example: 'https://example.com/webhook',
            format: 'uri',
            title: 'webhook-config-url'
          },
          'webhook-config-content-type': {
            type: 'string',
            description:
              'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
            example: '"json"',
            title: 'webhook-config-content-type'
          },
          'webhook-config-secret': {
            type: 'string',
            description:
              'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
            example: '"********"',
            title: 'webhook-config-secret'
          },
          'webhook-config-insecure-ssl': {
            oneOf: [
              {
                type: 'string',
                description:
                  'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                example: '"0"'
              },
              { type: 'number' }
            ],
            title: 'webhook-config-insecure-ssl'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          hook_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposUpdateWebhook'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/hooks/:hook_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposUpdateWebhookRequest,
          res as ReposUpdateWebhookResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/hooks/:hook_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          hook_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteWebhook'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/hooks/:hook_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteWebhookRequest,
          res as ReposDeleteWebhookResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/hooks/:hook_id/config',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          hook_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetWebhookConfigForRepo'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/hooks/:hook_id/config not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetWebhookConfigForRepoRequest,
          res as ReposGetWebhookConfigForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/hooks/:hook_id/config',

    validate({
      body: {
        type: 'object',
        additionalProperties: false,
        properties: {
          url: { $ref: '#/definitions/webhook-config-url' },
          content_type: { $ref: '#/definitions/webhook-config-content-type' },
          secret: { $ref: '#/definitions/webhook-config-secret' },
          insecure_ssl: { $ref: '#/definitions/webhook-config-insecure-ssl' }
        },
        definitions: {
          'webhook-config-url': {
            type: 'string',
            description: 'The URL to which the payloads will be delivered.',
            example: 'https://example.com/webhook',
            format: 'uri',
            title: 'webhook-config-url'
          },
          'webhook-config-content-type': {
            type: 'string',
            description:
              'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
            example: '"json"',
            title: 'webhook-config-content-type'
          },
          'webhook-config-secret': {
            type: 'string',
            description:
              'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
            example: '"********"',
            title: 'webhook-config-secret'
          },
          'webhook-config-insecure-ssl': {
            oneOf: [
              {
                type: 'string',
                description:
                  'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                example: '"0"'
              },
              { type: 'number' }
            ],
            title: 'webhook-config-insecure-ssl'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          hook_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposUpdateWebhookConfigForRepo'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/hooks/:hook_id/config not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposUpdateWebhookConfigForRepoRequest,
          res as ReposUpdateWebhookConfigForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/hooks/:hook_id/deliveries',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          cursor: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          hook_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListWebhookDeliveries'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/hooks/:hook_id/deliveries not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposListWebhookDeliveriesRequest,
          res as ReposListWebhookDeliveriesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/hooks/:hook_id/deliveries/:delivery_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          hook_id: { type: 'integer' },
          delivery_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'hook_id', 'delivery_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetWebhookDelivery'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/hooks/:hook_id/deliveries/:delivery_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetWebhookDeliveryRequest,
          res as ReposGetWebhookDeliveryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/hooks/:hook_id/deliveries/:delivery_id/attempts',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          hook_id: { type: 'integer' },
          delivery_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'hook_id', 'delivery_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposRedeliverWebhookDelivery'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/hooks/:hook_id/deliveries/:delivery_id/attempts not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposRedeliverWebhookDeliveryRequest,
          res as ReposRedeliverWebhookDeliveryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/hooks/:hook_id/pings',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          hook_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposPingWebhook'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/hooks/:hook_id/pings not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposPingWebhookRequest,
          res as ReposPingWebhookResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/hooks/:hook_id/tests',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          hook_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'hook_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposTestPushWebhook'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/hooks/:hook_id/tests not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposTestPushWebhookRequest,
          res as ReposTestPushWebhookResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/import',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsGetImportStatus'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/import not handled'));
      }

      try {
        await handler(
          (req as unknown) as MigrationsGetImportStatusRequest,
          res as MigrationsGetImportStatusResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/import',

    validate({
      body: {
        type: 'object',
        properties: {
          vcs_url: {
            type: 'string',
            description: 'The URL of the originating repository.'
          },
          vcs: {
            type: 'string',
            description:
              'The originating VCS type. Without this parameter, the import job will take additional time to detect the VCS type before beginning the import. This detection step will be reflected in the response.',
            enum: ['subversion', 'git', 'mercurial', 'tfvc']
          },
          vcs_username: {
            type: 'string',
            description:
              'If authentication is required, the username to provide to `vcs_url`.'
          },
          vcs_password: {
            type: 'string',
            description:
              'If authentication is required, the password to provide to `vcs_url`.'
          },
          tfvc_project: {
            type: 'string',
            description:
              'For a tfvc import, the name of the project that is being imported.'
          }
        },
        required: ['vcs_url']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsStartImport'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/import not handled'));
      }

      try {
        await handler(
          (req as unknown) as MigrationsStartImportRequest,
          res as MigrationsStartImportResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/import',

    validate({
      body: {
        type: 'object',
        properties: {
          vcs_username: {
            type: 'string',
            description:
              'The username to provide to the originating repository.'
          },
          vcs_password: {
            type: 'string',
            description:
              'The password to provide to the originating repository.'
          },
          vcs: {
            type: 'string',
            description:
              'The type of version control system you are migrating from.',
            enum: ['subversion', 'tfvc', 'git', 'mercurial'],
            example: '"git"'
          },
          tfvc_project: {
            type: 'string',
            description:
              'For a tfvc import, the name of the project that is being imported.',
            example: '"project1"'
          }
        },
        nullable: true
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsUpdateImport'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/import not handled'));
      }

      try {
        await handler(
          (req as unknown) as MigrationsUpdateImportRequest,
          res as MigrationsUpdateImportResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/import',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsCancelImport'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/import not handled'));
      }

      try {
        await handler(
          (req as unknown) as MigrationsCancelImportRequest,
          res as MigrationsCancelImportResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/import/authors',

    validate({
      query: {
        type: 'object',
        properties: { since: { type: 'integer' } },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsGetCommitAuthors'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/import/authors not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as MigrationsGetCommitAuthorsRequest,
          res as MigrationsGetCommitAuthorsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/import/authors/:author_id',

    validate({
      body: {
        type: 'object',
        properties: {
          email: { type: 'string', description: 'The new Git author email.' },
          name: { type: 'string', description: 'The new Git author name.' }
        },
        additionalProperties: false
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          author_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'author_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsMapCommitAuthor'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/import/authors/:author_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as MigrationsMapCommitAuthorRequest,
          res as MigrationsMapCommitAuthorResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/import/large_files',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsGetLargeFiles'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/import/large_files not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as MigrationsGetLargeFilesRequest,
          res as MigrationsGetLargeFilesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/import/lfs',

    validate({
      body: {
        type: 'object',
        properties: {
          use_lfs: {
            type: 'string',
            description:
              'Whether to store large files during the import. `opt_in` means large files will be stored using Git LFS. `opt_out` means large files will be removed during the import.',
            enum: ['opt_in', 'opt_out']
          }
        },
        required: ['use_lfs']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsSetLfsPreference'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/import/lfs not handled'));
      }

      try {
        await handler(
          (req as unknown) as MigrationsSetLfsPreferenceRequest,
          res as MigrationsSetLfsPreferenceResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/installation',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsGetRepoInstallation'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/installation not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsGetRepoInstallationRequest,
          res as AppsGetRepoInstallationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/interaction-limits',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['interactionsGetRestrictionsForRepo'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/interaction-limits not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as InteractionsGetRestrictionsForRepoRequest,
          res as InteractionsGetRestrictionsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/interaction-limits',

    validate({
      body: {
        $ref: '#/definitions/interaction-limit',
        definitions: {
          'interaction-limit': {
            title: 'Interaction Restrictions',
            description:
              'Limit interactions to a specific type of user for a specified duration',
            type: 'object',
            properties: {
              limit: { $ref: '#/definitions/interaction-group' },
              expiry: { $ref: '#/definitions/interaction-expiry' }
            },
            required: ['limit']
          },
          'interaction-group': {
            type: 'string',
            description:
              'The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.',
            example: 'collaborators_only',
            enum: ['existing_users', 'contributors_only', 'collaborators_only'],
            title: 'interaction-group'
          },
          'interaction-expiry': {
            type: 'string',
            description:
              'The duration of the interaction restriction. Default: `one_day`.',
            example: 'one_month',
            enum: [
              'one_day',
              'three_days',
              'one_week',
              'one_month',
              'six_months'
            ],
            title: 'interaction-expiry'
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['interactionsSetRestrictionsForRepo'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/interaction-limits not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as InteractionsSetRestrictionsForRepoRequest,
          res as InteractionsSetRestrictionsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/interaction-limits',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['interactionsRemoveRestrictionsForRepo'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/interaction-limits not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as InteractionsRemoveRestrictionsForRepoRequest,
          res as InteractionsRemoveRestrictionsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/invitations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListInvitations'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/invitations not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListInvitationsRequest,
          res as ReposListInvitationsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/invitations/:invitation_id',

    validate({
      body: {
        type: 'object',
        properties: {
          permissions: {
            type: 'string',
            description:
              'The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.',
            enum: ['read', 'write', 'maintain', 'triage', 'admin']
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          invitation_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'invitation_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposUpdateInvitation'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/invitations/:invitation_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposUpdateInvitationRequest,
          res as ReposUpdateInvitationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/invitations/:invitation_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          invitation_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'invitation_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteInvitation'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/invitations/:invitation_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteInvitationRequest,
          res as ReposDeleteInvitationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/issues',

    validate({
      query: {
        type: 'object',
        properties: {
          milestone: { type: 'string' },
          state: {
            type: 'string',
            enum: ['open', 'closed', 'all'],
            default: 'open'
          },
          assignee: { type: 'string' },
          creator: { type: 'string' },
          mentioned: { type: 'string' },
          labels: { type: 'string' },
          sort: {
            type: 'string',
            enum: ['created', 'updated', 'comments'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          since: { type: 'string', format: 'date-time' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesListForRepo'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/issues not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesListForRepoRequest,
          res as IssuesListForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/issues',

    validate({
      body: {
        type: 'object',
        properties: {
          title: {
            oneOf: [{ type: 'string' }, { type: 'integer' }],
            description: 'The title of the issue.'
          },
          body: { type: 'string', description: 'The contents of the issue.' },
          assignee: {
            type: 'string',
            description:
              'Login for the user that this issue should be assigned to. _NOTE: Only users with push access can set the assignee for new issues. The assignee is silently dropped otherwise. **This field is deprecated.**_',
            nullable: true
          },
          milestone: {
            oneOf: [
              { type: 'string' },
              {
                type: 'integer',
                description:
                  'The `number` of the milestone to associate this issue with. _NOTE: Only users with push access can set the milestone for new issues. The milestone is silently dropped otherwise._'
              }
            ],
            nullable: true
          },
          labels: {
            type: 'array',
            description:
              'Labels to associate with this issue. _NOTE: Only users with push access can set labels for new issues. Labels are silently dropped otherwise._',
            items: {
              oneOf: [
                { type: 'string' },
                {
                  type: 'object',
                  properties: {
                    id: { type: 'integer' },
                    name: { type: 'string' },
                    description: { type: 'string', nullable: true },
                    color: { type: 'string', nullable: true }
                  }
                }
              ]
            }
          },
          assignees: {
            type: 'array',
            description:
              'Logins for Users to assign to this issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._',
            items: { type: 'string' }
          }
        },
        required: ['title']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesCreate'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/issues not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesCreateRequest,
          res as IssuesCreateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/issues/comments',

    validate({
      query: {
        type: 'object',
        properties: {
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'] },
          since: { type: 'string', format: 'date-time' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesListCommentsForRepo'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/issues/comments not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesListCommentsForRepoRequest,
          res as IssuesListCommentsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/issues/comments/:comment_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesGetComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/comments/:comment_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesGetCommentRequest,
          res as IssuesGetCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/issues/comments/:comment_id',

    validate({
      body: {
        type: 'object',
        properties: {
          body: { type: 'string', description: 'The contents of the comment.' }
        },
        required: ['body']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesUpdateComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/comments/:comment_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesUpdateCommentRequest,
          res as IssuesUpdateCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/issues/comments/:comment_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesDeleteComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/comments/:comment_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesDeleteCommentRequest,
          res as IssuesDeleteCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/issues/comments/:comment_id/reactions',

    validate({
      query: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsListForIssueComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/comments/:comment_id/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsListForIssueCommentRequest,
          res as ReactionsListForIssueCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/issues/comments/:comment_id/reactions',

    validate({
      body: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            description:
              'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the issue comment.',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          }
        },
        required: ['content']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsCreateForIssueComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/comments/:comment_id/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsCreateForIssueCommentRequest,
          res as ReactionsCreateForIssueCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/issues/comments/:comment_id/reactions/:reaction_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' },
          reaction_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id', 'reaction_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsDeleteForIssueComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/comments/:comment_id/reactions/:reaction_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsDeleteForIssueCommentRequest,
          res as ReactionsDeleteForIssueCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/issues/events',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesListEventsForRepo'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/issues/events not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesListEventsForRepoRequest,
          res as IssuesListEventsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/issues/events/:event_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          event_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'event_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesGetEvent'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/issues/events/:event_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesGetEventRequest,
          res as IssuesGetEventResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/issues/:issue_number',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesGet'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/issues/:issue_number not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesGetRequest,
          res as IssuesGetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/issues/:issue_number',

    validate({
      body: {
        type: 'object',
        properties: {
          title: {
            oneOf: [{ type: 'string' }, { type: 'integer' }],
            description: 'The title of the issue.',
            nullable: true
          },
          body: {
            type: 'string',
            description: 'The contents of the issue.',
            nullable: true
          },
          assignee: {
            type: 'string',
            nullable: true,
            description:
              'Login for the user that this issue should be assigned to. **This field is deprecated.**'
          },
          state: {
            type: 'string',
            description: 'State of the issue. Either `open` or `closed`.',
            enum: ['open', 'closed']
          },
          state_reason: {
            type: 'string',
            enum: ['completed', 'not_planned', 'reopened'],
            nullable: true,
            description: 'The reason for the current state',
            example: 'not_planned'
          },
          milestone: {
            oneOf: [
              { type: 'string' },
              {
                type: 'integer',
                description:
                  'The `number` of the milestone to associate this issue with or `null` to remove current. _NOTE: Only users with push access can set the milestone for issues. The milestone is silently dropped otherwise._'
              }
            ],
            nullable: true
          },
          labels: {
            type: 'array',
            description:
              'Labels to associate with this issue. Pass one or more Labels to _replace_ the set of Labels on this Issue. Send an empty array (`[]`) to clear all Labels from the Issue. _NOTE: Only users with push access can set labels for issues. Labels are silently dropped otherwise._',
            items: {
              oneOf: [
                { type: 'string' },
                {
                  type: 'object',
                  properties: {
                    id: { type: 'integer' },
                    name: { type: 'string' },
                    description: { type: 'string', nullable: true },
                    color: { type: 'string', nullable: true }
                  }
                }
              ]
            }
          },
          assignees: {
            type: 'array',
            description:
              'Logins for Users to assign to this issue. Pass one or more user logins to _replace_ the set of assignees on this Issue. Send an empty array (`[]`) to clear all assignees from the Issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._',
            items: { type: 'string' }
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesUpdate'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/issues/:issue_number not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesUpdateRequest,
          res as IssuesUpdateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/issues/:issue_number/assignees',

    validate({
      body: {
        type: 'object',
        properties: {
          assignees: {
            type: 'array',
            description:
              'Usernames of people to assign this issue to. _NOTE: Only users with push access can add assignees to an issue. Assignees are silently ignored otherwise._',
            items: { type: 'string' }
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesAddAssignees'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/assignees not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesAddAssigneesRequest,
          res as IssuesAddAssigneesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/issues/:issue_number/assignees',

    validate({
      body: {
        type: 'object',
        properties: {
          assignees: {
            type: 'array',
            description:
              'Usernames of assignees to remove from an issue. _NOTE: Only users with push access can remove assignees from an issue. Assignees are silently ignored otherwise._',
            items: { type: 'string' }
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesRemoveAssignees'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/assignees not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesRemoveAssigneesRequest,
          res as IssuesRemoveAssigneesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/issues/:issue_number/comments',

    validate({
      query: {
        type: 'object',
        properties: {
          since: { type: 'string', format: 'date-time' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesListComments'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/comments not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesListCommentsRequest,
          res as IssuesListCommentsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/issues/:issue_number/comments',

    validate({
      body: {
        type: 'object',
        properties: {
          body: { type: 'string', description: 'The contents of the comment.' }
        },
        required: ['body']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesCreateComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/comments not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesCreateCommentRequest,
          res as IssuesCreateCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/issues/:issue_number/events',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesListEvents'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/events not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesListEventsRequest,
          res as IssuesListEventsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/issues/:issue_number/labels',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesListLabelsOnIssue'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/labels not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesListLabelsOnIssueRequest,
          res as IssuesListLabelsOnIssueResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/issues/:issue_number/labels',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              labels: {
                type: 'array',
                minItems: 1,
                description:
                  'The names of the labels to add to the issue\'s existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also replace all of the labels for an issue. For more information, see "[Set labels for an issue](https://docs.github.com/rest/reference/issues#set-labels-for-an-issue)."',
                items: { type: 'string' }
              }
            }
          },
          { type: 'array', minItems: 1, items: { type: 'string' } },
          {
            type: 'object',
            properties: {
              labels: {
                type: 'array',
                minItems: 1,
                items: {
                  type: 'object',
                  properties: { name: { type: 'string' } },
                  required: ['name']
                }
              }
            }
          },
          {
            type: 'array',
            minItems: 1,
            items: {
              type: 'object',
              properties: { name: { type: 'string' } },
              required: ['name']
            }
          },
          { type: 'string' }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesAddLabels'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/labels not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesAddLabelsRequest,
          res as IssuesAddLabelsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/issues/:issue_number/labels',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              labels: {
                type: 'array',
                minItems: 1,
                description:
                  'The names of the labels to set for the issue. The labels you set replace any existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also add labels to the existing labels for an issue. For more information, see "[Add labels to an issue](https://docs.github.com/rest/reference/issues#add-labels-to-an-issue)."',
                items: { type: 'string' }
              }
            }
          },
          { type: 'array', minItems: 1, items: { type: 'string' } },
          {
            type: 'object',
            properties: {
              labels: {
                type: 'array',
                minItems: 1,
                items: {
                  type: 'object',
                  properties: { name: { type: 'string' } },
                  required: ['name']
                }
              }
            }
          },
          {
            type: 'array',
            minItems: 1,
            items: {
              type: 'object',
              properties: { name: { type: 'string' } },
              required: ['name']
            }
          },
          { type: 'string' }
        ]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesSetLabels'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/labels not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesSetLabelsRequest,
          res as IssuesSetLabelsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/issues/:issue_number/labels',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesRemoveAllLabels'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/labels not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesRemoveAllLabelsRequest,
          res as IssuesRemoveAllLabelsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/issues/:issue_number/labels/:name',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' },
          name: { type: 'string' }
        },
        required: ['owner', 'repo', 'issue_number', 'name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesRemoveLabel'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/labels/:name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesRemoveLabelRequest,
          res as IssuesRemoveLabelResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/issues/:issue_number/lock',

    validate({
      body: {
        type: 'object',
        nullable: true,
        properties: {
          lock_reason: {
            type: 'string',
            description:
              "The reason for locking the issue or pull request conversation. Lock will fail if you don't use one of these reasons:  \n\\* `off-topic`  \n\\* `too heated`  \n\\* `resolved`  \n\\* `spam`",
            enum: ['off-topic', 'too heated', 'resolved', 'spam']
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesLock'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/issues/:issue_number/lock not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesLockRequest,
          res as IssuesLockResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/issues/:issue_number/lock',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesUnlock'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/issues/:issue_number/lock not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesUnlockRequest,
          res as IssuesUnlockResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/issues/:issue_number/reactions',

    validate({
      query: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsListForIssue'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsListForIssueRequest,
          res as ReactionsListForIssueResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/issues/:issue_number/reactions',

    validate({
      body: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            description:
              'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the issue.',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          }
        },
        required: ['content']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsCreateForIssue'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsCreateForIssueRequest,
          res as ReactionsCreateForIssueResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/issues/:issue_number/reactions/:reaction_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' },
          reaction_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number', 'reaction_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsDeleteForIssue'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/reactions/:reaction_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsDeleteForIssueRequest,
          res as ReactionsDeleteForIssueResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/issues/:issue_number/timeline',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          issue_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'issue_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesListEventsForTimeline'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/issues/:issue_number/timeline not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesListEventsForTimelineRequest,
          res as IssuesListEventsForTimelineResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/keys',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListDeployKeys'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/keys not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListDeployKeysRequest,
          res as ReposListDeployKeysResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/keys',

    validate({
      body: {
        type: 'object',
        properties: {
          title: { type: 'string', description: 'A name for the key.' },
          key: { type: 'string', description: 'The contents of the key.' },
          read_only: {
            type: 'boolean',
            description:
              'If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.  \n  \nDeploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see "[Repository permission levels for an organization](https://docs.github.com/articles/repository-permission-levels-for-an-organization/)" and "[Permission levels for a user account repository](https://docs.github.com/articles/permission-levels-for-a-user-account-repository/)."'
          }
        },
        required: ['key']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateDeployKey'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/keys not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposCreateDeployKeyRequest,
          res as ReposCreateDeployKeyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/keys/:key_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          key_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'key_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetDeployKey'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/keys/:key_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposGetDeployKeyRequest,
          res as ReposGetDeployKeyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/keys/:key_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          key_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'key_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteDeployKey'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/keys/:key_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteDeployKeyRequest,
          res as ReposDeleteDeployKeyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/labels',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesListLabelsForRepo'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/labels not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesListLabelsForRepoRequest,
          res as IssuesListLabelsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/labels',

    validate({
      body: {
        type: 'object',
        properties: {
          name: {
            type: 'string',
            description:
              'The name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."'
          },
          color: {
            type: 'string',
            description:
              'The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.'
          },
          description: {
            type: 'string',
            description:
              'A short description of the label. Must be 100 characters or fewer.'
          }
        },
        required: ['name']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesCreateLabel'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/labels not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesCreateLabelRequest,
          res as IssuesCreateLabelResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/labels/:name',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          name: { type: 'string' }
        },
        required: ['owner', 'repo', 'name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesGetLabel'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/labels/:name not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesGetLabelRequest,
          res as IssuesGetLabelResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/labels/:name',

    validate({
      body: {
        type: 'object',
        properties: {
          new_name: {
            type: 'string',
            description:
              'The new name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."'
          },
          color: {
            type: 'string',
            description:
              'The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.'
          },
          description: {
            type: 'string',
            description:
              'A short description of the label. Must be 100 characters or fewer.'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          name: { type: 'string' }
        },
        required: ['owner', 'repo', 'name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesUpdateLabel'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/labels/:name not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesUpdateLabelRequest,
          res as IssuesUpdateLabelResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/labels/:name',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          name: { type: 'string' }
        },
        required: ['owner', 'repo', 'name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesDeleteLabel'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/labels/:name not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesDeleteLabelRequest,
          res as IssuesDeleteLabelResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/languages',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListLanguages'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/languages not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListLanguagesRequest,
          res as ReposListLanguagesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/lfs',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposEnableLfsForRepo'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/lfs not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposEnableLfsForRepoRequest,
          res as ReposEnableLfsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/lfs',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDisableLfsForRepo'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/lfs not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposDisableLfsForRepoRequest,
          res as ReposDisableLfsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/license',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['licensesGetForRepo'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/license not handled'));
      }

      try {
        await handler(
          (req as unknown) as LicensesGetForRepoRequest,
          res as LicensesGetForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/merge-upstream',

    validate({
      body: {
        type: 'object',
        properties: {
          branch: {
            type: 'string',
            description:
              'The name of the branch which should be updated to match upstream.'
          }
        },
        required: ['branch']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposMergeUpstream'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/merge-upstream not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposMergeUpstreamRequest,
          res as ReposMergeUpstreamResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/merges',

    validate({
      body: {
        type: 'object',
        properties: {
          base: {
            type: 'string',
            description:
              'The name of the base branch that the head will be merged into.'
          },
          head: {
            type: 'string',
            description:
              'The head to merge. This can be a branch name or a commit SHA1.'
          },
          commit_message: {
            type: 'string',
            description:
              'Commit message to use for the merge commit. If omitted, a default message will be used.'
          }
        },
        required: ['base', 'head']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposMerge'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/merges not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposMergeRequest,
          res as ReposMergeResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/milestones',

    validate({
      query: {
        type: 'object',
        properties: {
          state: {
            type: 'string',
            enum: ['open', 'closed', 'all'],
            default: 'open'
          },
          sort: {
            type: 'string',
            enum: ['due_on', 'completeness'],
            default: 'due_on'
          },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'asc' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesListMilestones'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/milestones not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesListMilestonesRequest,
          res as IssuesListMilestonesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/milestones',

    validate({
      body: {
        type: 'object',
        properties: {
          title: { type: 'string', description: 'The title of the milestone.' },
          state: {
            type: 'string',
            description:
              'The state of the milestone. Either `open` or `closed`.',
            enum: ['open', 'closed'],
            default: 'open'
          },
          description: {
            type: 'string',
            description: 'A description of the milestone.'
          },
          due_on: {
            type: 'string',
            format: 'date-time',
            description:
              'The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
          }
        },
        required: ['title']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesCreateMilestone'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/milestones not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesCreateMilestoneRequest,
          res as IssuesCreateMilestoneResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/milestones/:milestone_number',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          milestone_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'milestone_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesGetMilestone'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/milestones/:milestone_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesGetMilestoneRequest,
          res as IssuesGetMilestoneResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/milestones/:milestone_number',

    validate({
      body: {
        type: 'object',
        properties: {
          title: { type: 'string', description: 'The title of the milestone.' },
          state: {
            type: 'string',
            description:
              'The state of the milestone. Either `open` or `closed`.',
            enum: ['open', 'closed'],
            default: 'open'
          },
          description: {
            type: 'string',
            description: 'A description of the milestone.'
          },
          due_on: {
            type: 'string',
            format: 'date-time',
            description:
              'The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          milestone_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'milestone_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesUpdateMilestone'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/milestones/:milestone_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesUpdateMilestoneRequest,
          res as IssuesUpdateMilestoneResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/milestones/:milestone_number',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          milestone_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'milestone_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesDeleteMilestone'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/milestones/:milestone_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesDeleteMilestoneRequest,
          res as IssuesDeleteMilestoneResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/milestones/:milestone_number/labels',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          milestone_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'milestone_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesListLabelsForMilestone'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/milestones/:milestone_number/labels not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as IssuesListLabelsForMilestoneRequest,
          res as IssuesListLabelsForMilestoneResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/notifications',

    validate({
      query: {
        type: 'object',
        properties: {
          all: { type: 'boolean', default: false },
          participating: { type: 'boolean', default: false },
          since: { type: 'string', format: 'date-time' },
          before: { type: 'string', format: 'date-time' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['activityListRepoNotificationsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/notifications not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListRepoNotificationsForAuthenticatedUserRequest,
          res as ActivityListRepoNotificationsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/notifications',

    validate({
      body: {
        type: 'object',
        properties: {
          last_read_at: {
            type: 'string',
            format: 'date-time',
            description:
              'Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.'
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityMarkRepoNotificationsAsRead'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/notifications not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityMarkRepoNotificationsAsReadRequest,
          res as ActivityMarkRepoNotificationsAsReadResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pages',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetPages'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/pages not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposGetPagesRequest,
          res as ReposGetPagesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/pages',

    validate({
      body: {
        type: 'object',
        description:
          'The source branch and directory used to publish your Pages site.',
        nullable: true,
        properties: {
          build_type: {
            type: 'string',
            description:
              'The process in which the Page will be built. Possible values are `"legacy"` and `"workflow"`.',
            enum: ['legacy', 'workflow']
          },
          source: {
            type: 'object',
            description:
              'The source branch and directory used to publish your Pages site.',
            properties: {
              branch: {
                type: 'string',
                description:
                  "The repository branch used to publish your site's source files."
              },
              path: {
                type: 'string',
                description:
                  'The repository directory that includes the source files for the Pages site. Allowed paths are `/` or `/docs`. Default: `/`',
                enum: ['/', '/docs'],
                default: '/'
              }
            },
            required: ['branch']
          }
        },
        anyOf: [{ required: ['source'] }, { required: ['build_type'] }]
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreatePagesSite'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/pages not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposCreatePagesSiteRequest,
          res as ReposCreatePagesSiteResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/pages',

    validate({
      body: {
        type: 'object',
        properties: {
          cname: {
            type: 'string',
            description:
              'Specify a custom domain for the repository. Sending a `null` value will remove the custom domain. For more about custom domains, see "[Using a custom domain with GitHub Pages](https://docs.github.com/articles/using-a-custom-domain-with-github-pages/)."',
            nullable: true
          },
          https_enforced: {
            type: 'boolean',
            description:
              'Specify whether HTTPS should be enforced for the repository.'
          },
          public: {
            type: 'boolean',
            description:
              'Configures access controls for the GitHub Pages site. If public is set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site. This includes anyone in your Enterprise if the repository is set to `internal` visibility. This feature is only available to repositories in an organization on an Enterprise plan.'
          },
          build_type: {
            type: 'string',
            description:
              'The process by which the GitHub Pages site will be built. `workflow` means that the site is built by a custom GitHub Actions workflow. `legacy` means that the site is built by GitHub when changes are pushed to a specific branch.',
            enum: ['legacy', 'workflow']
          },
          source: {
            anyOf: [
              {
                type: 'string',
                description:
                  'Update the source for the repository. Must include the branch name, and may optionally specify the subdirectory `/docs`. Possible values are `"gh-pages"`, `"master"`, and `"master /docs"`.',
                enum: ['gh-pages', 'master', 'master /docs']
              },
              {
                type: 'object',
                description:
                  'Update the source for the repository. Must include the branch name and path.',
                properties: {
                  branch: {
                    type: 'string',
                    description:
                      "The repository branch used to publish your site's source files."
                  },
                  path: {
                    type: 'string',
                    description:
                      'The repository directory that includes the source files for the Pages site. Allowed paths are `/` or `/docs`.',
                    enum: ['/', '/docs']
                  }
                },
                required: ['branch', 'path']
              }
            ]
          }
        },
        anyOf: [
          { required: ['build_type'] },
          { required: ['source'] },
          { required: ['cname'] },
          { required: ['public'] },
          { required: ['https_enforced'] }
        ]
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposUpdateInformationAboutPagesSite'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/pages not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposUpdateInformationAboutPagesSiteRequest,
          res as ReposUpdateInformationAboutPagesSiteResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/pages',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeletePagesSite'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/pages not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposDeletePagesSiteRequest,
          res as ReposDeletePagesSiteResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pages/builds',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListPagesBuilds'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/pages/builds not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListPagesBuildsRequest,
          res as ReposListPagesBuildsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/pages/builds',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposRequestPagesBuild'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/pages/builds not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposRequestPagesBuildRequest,
          res as ReposRequestPagesBuildResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pages/builds/latest',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetLatestPagesBuild'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/pages/builds/latest not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetLatestPagesBuildRequest,
          res as ReposGetLatestPagesBuildResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pages/builds/:build_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          build_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'build_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetPagesBuild'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/pages/builds/:build_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetPagesBuildRequest,
          res as ReposGetPagesBuildResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/pages/deployment',

    validate({
      body: {
        type: 'object',
        description: 'The object used to create GitHub Pages deployment',
        properties: {
          artifact_url: {
            type: 'string',
            description:
              'The URL of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository.'
          },
          environment: {
            type: 'string',
            description:
              'The target environment for this GitHub Pages deployment.',
            default: 'github-pages'
          },
          pages_build_version: {
            type: 'string',
            description:
              'A unique string that represents the version of the build for this deployment.',
            default: 'GITHUB_SHA'
          },
          oidc_token: {
            type: 'string',
            description:
              'The OIDC token issued by GitHub Actions certifying the origin of the deployment.'
          }
        },
        required: ['artifact_url', 'pages_build_version', 'oidc_token']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreatePagesDeployment'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/pages/deployment not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposCreatePagesDeploymentRequest,
          res as ReposCreatePagesDeploymentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pages/health',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetPagesHealthCheck'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/pages/health not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposGetPagesHealthCheckRequest,
          res as ReposGetPagesHealthCheckResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/projects',

    validate({
      query: {
        type: 'object',
        properties: {
          state: {
            type: 'string',
            enum: ['open', 'closed', 'all'],
            default: 'open'
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsListForRepo'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/projects not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsListForRepoRequest,
          res as ProjectsListForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/projects',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { type: 'string', description: 'The name of the project.' },
          body: {
            type: 'string',
            description: 'The description of the project.'
          }
        },
        required: ['name']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsCreateForRepo'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/projects not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsCreateForRepoRequest,
          res as ProjectsCreateForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pulls',

    validate({
      query: {
        type: 'object',
        properties: {
          state: {
            type: 'string',
            enum: ['open', 'closed', 'all'],
            default: 'open'
          },
          head: { type: 'string' },
          base: { type: 'string' },
          sort: {
            type: 'string',
            enum: ['created', 'updated', 'popularity', 'long-running'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'] },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsList'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/pulls not handled'));
      }

      try {
        await handler(
          (req as unknown) as PullsListRequest,
          res as PullsListResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/pulls',

    validate({
      body: {
        type: 'object',
        properties: {
          title: {
            type: 'string',
            description:
              'The title of the new pull request. Required unless `issue` is specified.'
          },
          head: {
            type: 'string',
            description:
              'The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace `head` with a user like this: `username:branch`.'
          },
          base: {
            type: 'string',
            description:
              'The name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository.'
          },
          body: {
            type: 'string',
            description: 'The contents of the pull request.'
          },
          maintainer_can_modify: {
            type: 'boolean',
            description:
              'Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.'
          },
          draft: {
            type: 'boolean',
            description:
              'Indicates whether the pull request is a draft. See "[Draft Pull Requests](https://docs.github.com/en/articles/about-pull-requests#draft-pull-requests)" in the GitHub Help documentation to learn more.'
          },
          issue: {
            type: 'integer',
            example: 1,
            description:
              'An issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless `title` is specified.'
          }
        },
        required: ['head', 'base']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsCreate'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/pulls not handled'));
      }

      try {
        await handler(
          (req as unknown) as PullsCreateRequest,
          res as PullsCreateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pulls/comments',

    validate({
      query: {
        type: 'object',
        properties: {
          sort: { type: 'string', enum: ['created', 'updated', 'created_at'] },
          direction: { type: 'string', enum: ['asc', 'desc'] },
          since: { type: 'string', format: 'date-time' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsListReviewCommentsForRepo'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/pulls/comments not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as PullsListReviewCommentsForRepoRequest,
          res as PullsListReviewCommentsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pulls/comments/:comment_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsGetReviewComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/comments/:comment_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsGetReviewCommentRequest,
          res as PullsGetReviewCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/pulls/comments/:comment_id',

    validate({
      body: {
        type: 'object',
        properties: {
          body: {
            type: 'string',
            description: 'The text of the reply to the review comment.'
          }
        },
        required: ['body']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsUpdateReviewComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/comments/:comment_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsUpdateReviewCommentRequest,
          res as PullsUpdateReviewCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/pulls/comments/:comment_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsDeleteReviewComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/comments/:comment_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsDeleteReviewCommentRequest,
          res as PullsDeleteReviewCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pulls/comments/:comment_id/reactions',

    validate({
      query: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsListForPullRequestReviewComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/comments/:comment_id/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsListForPullRequestReviewCommentRequest,
          res as ReactionsListForPullRequestReviewCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/pulls/comments/:comment_id/reactions',

    validate({
      body: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            description:
              'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the pull request review comment.',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          }
        },
        required: ['content']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsCreateForPullRequestReviewComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/comments/:comment_id/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsCreateForPullRequestReviewCommentRequest,
          res as ReactionsCreateForPullRequestReviewCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/pulls/comments/:comment_id/reactions/:reaction_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          comment_id: { type: 'integer' },
          reaction_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'comment_id', 'reaction_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsDeleteForPullRequestComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/comments/:comment_id/reactions/:reaction_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsDeleteForPullRequestCommentRequest,
          res as ReactionsDeleteForPullRequestCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pulls/:pull_number',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsGet'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/pulls/:pull_number not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as PullsGetRequest,
          res as PullsGetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/pulls/:pull_number',

    validate({
      body: {
        type: 'object',
        properties: {
          title: {
            type: 'string',
            description: 'The title of the pull request.'
          },
          body: {
            type: 'string',
            description: 'The contents of the pull request.'
          },
          state: {
            type: 'string',
            description:
              'State of this Pull Request. Either `open` or `closed`.',
            enum: ['open', 'closed']
          },
          base: {
            type: 'string',
            description:
              'The name of the branch you want your changes pulled into. This should be an existing branch on the current repository. You cannot update the base branch on a pull request to point to another repository.'
          },
          maintainer_can_modify: {
            type: 'boolean',
            description:
              'Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsUpdate'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/pulls/:pull_number not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as PullsUpdateRequest,
          res as PullsUpdateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/pulls/:pull_number/codespaces',

    validate({
      body: {
        type: 'object',
        nullable: true,
        properties: {
          location: {
            description:
              'Location for this codespace. Assigned by IP if not provided',
            type: 'string'
          },
          client_ip: {
            description:
              'IP for location auto-detection when proxying a request',
            type: 'string'
          },
          machine: {
            description: 'Machine type to use for this codespace',
            type: 'string'
          },
          devcontainer_path: {
            description:
              'Path to devcontainer.json config to use for this codespace',
            type: 'string'
          },
          multi_repo_permissions_opt_out: {
            description:
              'Whether to authorize requested permissions from devcontainer.json',
            type: 'boolean'
          },
          working_directory: {
            description: 'Working directory for this codespace',
            type: 'string'
          },
          idle_timeout_minutes: {
            description:
              'Time in minutes before codespace stops from inactivity',
            type: 'integer'
          },
          display_name: {
            description: 'Display name for this codespace',
            type: 'string'
          },
          retention_period_minutes: {
            description:
              'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).',
            type: 'integer'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesCreateWithPrForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/codespaces not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesCreateWithPrForAuthenticatedUserRequest,
          res as CodespacesCreateWithPrForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pulls/:pull_number/comments',

    validate({
      query: {
        type: 'object',
        properties: {
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'] },
          since: { type: 'string', format: 'date-time' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsListReviewComments'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/comments not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsListReviewCommentsRequest,
          res as PullsListReviewCommentsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/pulls/:pull_number/comments',

    validate({
      body: {
        type: 'object',
        properties: {
          body: {
            type: 'string',
            description: 'The text of the review comment.'
          },
          commit_id: {
            type: 'string',
            description:
              'The SHA of the commit needing a comment. Not using the latest commit SHA may render your comment outdated if a subsequent commit modifies the line you specify as the `position`.'
          },
          path: {
            type: 'string',
            description:
              'The relative path to the file that necessitates a comment.'
          },
          position: {
            type: 'integer',
            description:
              '**This parameter is deprecated. Use `line` instead**. The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. For help finding the position value, read the note above.',
            deprecated: true,
            'x-github': { deprecationDate: '2022-11-01' }
          },
          side: {
            type: 'string',
            description:
              'In a split diff view, the side of the diff that the pull request\'s changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see "[Diff view options](https://docs.github.com/en/articles/about-comparing-branches-in-pull-requests#diff-view-options)" in the GitHub Help documentation.',
            enum: ['LEFT', 'RIGHT']
          },
          line: {
            type: 'integer',
            description:
              'The line of the blob in the pull request diff that the comment applies to. For a multi-line comment, the last line of the range that your comment applies to.'
          },
          start_line: {
            type: 'integer',
            description:
              '**Required when using multi-line comments unless using `in_reply_to`**. The `start_line` is the first line in the pull request diff that your multi-line comment applies to. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation.'
          },
          start_side: {
            type: 'string',
            description:
              '**Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation. See `side` in this table for additional context.',
            enum: ['LEFT', 'RIGHT', 'side']
          },
          in_reply_to: {
            type: 'integer',
            example: 2,
            description:
              'The ID of the review comment to reply to. To find the ID of a review comment with ["List review comments on a pull request"](#list-review-comments-on-a-pull-request). When specified, all parameters other than `body` in the request body are ignored.'
          }
        },
        required: ['body', 'commit_id', 'path', 'line']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsCreateReviewComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/comments not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsCreateReviewCommentRequest,
          res as PullsCreateReviewCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/pulls/:pull_number/comments/:comment_id/replies',

    validate({
      body: {
        type: 'object',
        properties: {
          body: {
            type: 'string',
            description: 'The text of the review comment.'
          }
        },
        required: ['body']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' },
          comment_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number', 'comment_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsCreateReplyForReviewComment'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/comments/:comment_id/replies not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsCreateReplyForReviewCommentRequest,
          res as PullsCreateReplyForReviewCommentResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pulls/:pull_number/commits',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsListCommits'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/commits not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsListCommitsRequest,
          res as PullsListCommitsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pulls/:pull_number/files',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsListFiles'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/pulls/:pull_number/files not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as PullsListFilesRequest,
          res as PullsListFilesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pulls/:pull_number/merge',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsCheckIfMerged'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/pulls/:pull_number/merge not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as PullsCheckIfMergedRequest,
          res as PullsCheckIfMergedResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/pulls/:pull_number/merge',

    validate({
      body: {
        type: 'object',
        nullable: true,
        properties: {
          commit_title: {
            type: 'string',
            description: 'Title for the automatic commit message.'
          },
          commit_message: {
            type: 'string',
            description: 'Extra detail to append to automatic commit message.'
          },
          sha: {
            type: 'string',
            description: 'SHA that pull request head must match to allow merge.'
          },
          merge_method: {
            type: 'string',
            description: 'The merge method to use.',
            enum: ['merge', 'squash', 'rebase']
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsMerge'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/pulls/:pull_number/merge not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as PullsMergeRequest,
          res as PullsMergeResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pulls/:pull_number/requested_reviewers',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsListRequestedReviewers'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/requested_reviewers not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsListRequestedReviewersRequest,
          res as PullsListRequestedReviewersResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/pulls/:pull_number/requested_reviewers',

    validate({
      body: {
        type: 'object',
        properties: {
          reviewers: {
            type: 'array',
            description: 'An array of user `login`s that will be requested.',
            items: { type: 'string' }
          },
          team_reviewers: {
            type: 'array',
            description: 'An array of team `slug`s that will be requested.',
            items: { type: 'string' }
          }
        },
        anyOf: [{ required: ['reviewers'] }, { required: ['team_reviewers'] }]
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsRequestReviewers'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/requested_reviewers not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsRequestReviewersRequest,
          res as PullsRequestReviewersResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/pulls/:pull_number/requested_reviewers',

    validate({
      body: {
        type: 'object',
        properties: {
          reviewers: {
            type: 'array',
            description: 'An array of user `login`s that will be removed.',
            items: { type: 'string' }
          },
          team_reviewers: {
            type: 'array',
            description: 'An array of team `slug`s that will be removed.',
            items: { type: 'string' }
          }
        },
        required: ['reviewers']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsRemoveRequestedReviewers'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/requested_reviewers not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsRemoveRequestedReviewersRequest,
          res as PullsRemoveRequestedReviewersResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pulls/:pull_number/reviews',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsListReviews'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/reviews not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsListReviewsRequest,
          res as PullsListReviewsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/pulls/:pull_number/reviews',

    validate({
      body: {
        type: 'object',
        properties: {
          commit_id: {
            type: 'string',
            description:
              'The SHA of the commit that needs a review. Not using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the `position`. Defaults to the most recent commit in the pull request when you do not specify a value.'
          },
          body: {
            type: 'string',
            description:
              '**Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event` parameter. The body text of the pull request review.'
          },
          event: {
            type: 'string',
            description:
              'The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/rest/pulls#submit-a-review-for-a-pull-request) when you are ready.',
            enum: ['APPROVE', 'REQUEST_CHANGES', 'COMMENT']
          },
          comments: {
            type: 'array',
            description:
              'Use the following table to specify the location, destination, and contents of the draft review comment.',
            items: {
              type: 'object',
              properties: {
                path: {
                  type: 'string',
                  description:
                    'The relative path to the file that necessitates a review comment.'
                },
                position: {
                  type: 'integer',
                  description:
                    'The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. For help finding the position value, read the note below.'
                },
                body: {
                  type: 'string',
                  description: 'Text of the review comment.'
                },
                line: { type: 'integer', example: 28 },
                side: { type: 'string', example: 'RIGHT' },
                start_line: { type: 'integer', example: 26 },
                start_side: { type: 'string', example: 'LEFT' }
              },
              required: ['path', 'body']
            }
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsCreateReview'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/reviews not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsCreateReviewRequest,
          res as PullsCreateReviewResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' },
          review_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number', 'review_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsGetReview'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsGetReviewRequest,
          res as PullsGetReviewResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id',

    validate({
      body: {
        type: 'object',
        properties: {
          body: {
            type: 'string',
            description: 'The body text of the pull request review.'
          }
        },
        required: ['body']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' },
          review_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number', 'review_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsUpdateReview'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsUpdateReviewRequest,
          res as PullsUpdateReviewResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' },
          review_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number', 'review_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsDeletePendingReview'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsDeletePendingReviewRequest,
          res as PullsDeletePendingReviewResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/comments',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' },
          review_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number', 'review_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsListCommentsForReview'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/comments not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsListCommentsForReviewRequest,
          res as PullsListCommentsForReviewResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/dismissals',

    validate({
      body: {
        type: 'object',
        properties: {
          message: {
            type: 'string',
            description: 'The message for the pull request review dismissal'
          },
          event: { type: 'string', example: '"DISMISS"', enum: ['DISMISS'] }
        },
        required: ['message']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' },
          review_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number', 'review_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsDismissReview'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/dismissals not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsDismissReviewRequest,
          res as PullsDismissReviewResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/events',

    validate({
      body: {
        type: 'object',
        properties: {
          body: {
            type: 'string',
            description: 'The body text of the pull request review'
          },
          event: {
            type: 'string',
            description:
              'The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.',
            enum: ['APPROVE', 'REQUEST_CHANGES', 'COMMENT']
          }
        },
        required: ['event']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' },
          review_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number', 'review_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsSubmitReview'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/events not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsSubmitReviewRequest,
          res as PullsSubmitReviewResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/pulls/:pull_number/update-branch',

    validate({
      body: {
        type: 'object',
        nullable: true,
        properties: {
          expected_head_sha: {
            type: 'string',
            description:
              "The expected SHA of the pull request's HEAD ref. This is the most recent commit on the pull request's branch. If the expected SHA does not match the pull request's HEAD, you will receive a `422 Unprocessable Entity` status. You can use the \"[List commits](https://docs.github.com/rest/reference/repos#list-commits)\" endpoint to find the most recent commit SHA. Default: SHA of the pull request's current HEAD ref."
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          pull_number: { type: 'integer' }
        },
        required: ['owner', 'repo', 'pull_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['pullsUpdateBranch'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/pulls/:pull_number/update-branch not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PullsUpdateBranchRequest,
          res as PullsUpdateBranchResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/readme',

    validate({
      query: {
        type: 'object',
        properties: { ref: { type: 'string' } },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetReadme'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/readme not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposGetReadmeRequest,
          res as ReposGetReadmeResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/readme/:dir',

    validate({
      query: {
        type: 'object',
        properties: { ref: { type: 'string' } },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          dir: { type: 'string' }
        },
        required: ['owner', 'repo', 'dir']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetReadmeInDirectory'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/readme/:dir not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposGetReadmeInDirectoryRequest,
          res as ReposGetReadmeInDirectoryResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/releases',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListReleases'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/releases not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListReleasesRequest,
          res as ReposListReleasesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/releases',

    validate({
      body: {
        type: 'object',
        properties: {
          tag_name: { type: 'string', description: 'The name of the tag.' },
          target_commitish: {
            type: 'string',
            description:
              "Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch (usually `master`)."
          },
          name: { type: 'string', description: 'The name of the release.' },
          body: {
            type: 'string',
            description: 'Text describing the contents of the tag.'
          },
          draft: {
            type: 'boolean',
            description:
              '`true` to create a draft (unpublished) release, `false` to create a published one.',
            default: false
          },
          prerelease: {
            type: 'boolean',
            description:
              '`true` to identify the release as a prerelease. `false` to identify the release as a full release.',
            default: false
          },
          discussion_category_name: {
            type: 'string',
            description:
              'If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."'
          },
          generate_release_notes: {
            type: 'boolean',
            description:
              'Whether to automatically generate the name and body for this release. If `name` is specified, the specified name will be used; otherwise, a name will be automatically generated. If `body` is specified, the body will be pre-pended to the automatically generated notes.',
            default: false
          }
        },
        required: ['tag_name']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateRelease'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/releases not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposCreateReleaseRequest,
          res as ReposCreateReleaseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/releases/assets/:asset_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          asset_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'asset_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetReleaseAsset'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/releases/assets/:asset_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetReleaseAssetRequest,
          res as ReposGetReleaseAssetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/releases/assets/:asset_id',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { type: 'string', description: 'The file name of the asset.' },
          label: {
            type: 'string',
            description:
              'An alternate short description of the asset. Used in place of the filename.'
          },
          state: { type: 'string', example: '"uploaded"' }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          asset_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'asset_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposUpdateReleaseAsset'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/releases/assets/:asset_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposUpdateReleaseAssetRequest,
          res as ReposUpdateReleaseAssetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/releases/assets/:asset_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          asset_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'asset_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteReleaseAsset'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/releases/assets/:asset_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteReleaseAssetRequest,
          res as ReposDeleteReleaseAssetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/releases/generate-notes',

    validate({
      body: {
        type: 'object',
        properties: {
          tag_name: {
            type: 'string',
            description:
              'The tag name for the release. This can be an existing tag or a new one.'
          },
          target_commitish: {
            type: 'string',
            description:
              "Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists."
          },
          previous_tag_name: {
            type: 'string',
            description:
              'The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release.'
          },
          configuration_file_path: {
            type: 'string',
            description:
              "Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used."
          }
        },
        required: ['tag_name']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGenerateReleaseNotes'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/releases/generate-notes not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGenerateReleaseNotesRequest,
          res as ReposGenerateReleaseNotesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/releases/latest',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetLatestRelease'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/releases/latest not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetLatestReleaseRequest,
          res as ReposGetLatestReleaseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/releases/tags/:tag',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          tag: { type: 'string' }
        },
        required: ['owner', 'repo', 'tag']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetReleaseByTag'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/releases/tags/:tag not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetReleaseByTagRequest,
          res as ReposGetReleaseByTagResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/releases/:release_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          release_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'release_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetRelease'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/releases/:release_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetReleaseRequest,
          res as ReposGetReleaseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/releases/:release_id',

    validate({
      body: {
        type: 'object',
        properties: {
          tag_name: { type: 'string', description: 'The name of the tag.' },
          target_commitish: {
            type: 'string',
            description:
              "Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch (usually `master`)."
          },
          name: { type: 'string', description: 'The name of the release.' },
          body: {
            type: 'string',
            description: 'Text describing the contents of the tag.'
          },
          draft: {
            type: 'boolean',
            description:
              '`true` makes the release a draft, and `false` publishes the release.'
          },
          prerelease: {
            type: 'boolean',
            description:
              '`true` to identify the release as a prerelease, `false` to identify the release as a full release.'
          },
          discussion_category_name: {
            type: 'string',
            description:
              'If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. If there is already a discussion linked to the release, this parameter is ignored. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          release_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'release_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposUpdateRelease'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/releases/:release_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposUpdateReleaseRequest,
          res as ReposUpdateReleaseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/releases/:release_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          release_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'release_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteRelease'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/releases/:release_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteReleaseRequest,
          res as ReposDeleteReleaseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/releases/:release_id/assets',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          release_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'release_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListReleaseAssets'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/releases/:release_id/assets not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposListReleaseAssetsRequest,
          res as ReposListReleaseAssetsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/releases/:release_id/assets',

    validate({
      query: {
        type: 'object',
        properties: { name: { type: 'string' }, label: { type: 'string' } },
        required: ['name']
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          release_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'release_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposUploadReleaseAsset'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/releases/:release_id/assets not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposUploadReleaseAssetRequest,
          res as ReposUploadReleaseAssetResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/releases/:release_id/reactions',

    validate({
      query: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            enum: ['+1', 'laugh', 'heart', 'hooray', 'rocket', 'eyes']
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          release_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'release_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsListForRelease'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/releases/:release_id/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsListForReleaseRequest,
          res as ReactionsListForReleaseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/releases/:release_id/reactions',

    validate({
      body: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            description:
              'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the release.',
            enum: ['+1', 'laugh', 'heart', 'hooray', 'rocket', 'eyes']
          }
        },
        required: ['content']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          release_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'release_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsCreateForRelease'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/releases/:release_id/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsCreateForReleaseRequest,
          res as ReactionsCreateForReleaseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/releases/:release_id/reactions/:reaction_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          release_id: { type: 'integer' },
          reaction_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'release_id', 'reaction_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsDeleteForRelease'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/releases/:release_id/reactions/:reaction_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsDeleteForReleaseRequest,
          res as ReactionsDeleteForReleaseResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/secret-scanning/alerts',

    validate({
      query: {
        type: 'object',
        properties: {
          state: { type: 'string', enum: ['open', 'resolved'] },
          secret_type: { type: 'string' },
          resolution: { type: 'string' },
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 },
          before: { type: 'string' },
          after: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['secretScanningListAlertsForRepo'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/secret-scanning/alerts not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as SecretScanningListAlertsForRepoRequest,
          res as SecretScanningListAlertsForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/secret-scanning/alerts/:alert_number',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          alert_number: { $ref: '#/definitions/alert-number' }
        },
        required: ['owner', 'repo', 'alert_number'],
        definitions: {
          'alert-number': {
            type: 'integer',
            description: 'The security alert number.',
            readOnly: true,
            title: 'alert-number'
          }
        }
      }
    }),

    async (req, res, next) => {
      const handler = handlers['secretScanningGetAlert'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/secret-scanning/alerts/:alert_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as SecretScanningGetAlertRequest,
          res as SecretScanningGetAlertResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/repos/:owner/:repo/secret-scanning/alerts/:alert_number',

    validate({
      body: {
        type: 'object',
        properties: {
          state: { $ref: '#/definitions/secret-scanning-alert-state' },
          resolution: {
            $ref: '#/definitions/secret-scanning-alert-resolution'
          },
          resolution_comment: {
            $ref: '#/definitions/secret-scanning-alert-resolution-comment'
          }
        },
        required: ['state'],
        definitions: {
          'secret-scanning-alert-state': {
            description:
              'Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.',
            type: 'string',
            enum: ['open', 'resolved'],
            title: 'secret-scanning-alert-state'
          },
          'secret-scanning-alert-resolution': {
            type: 'string',
            description:
              '**Required when the `state` is `resolved`.** The reason for resolving the alert.',
            nullable: true,
            enum: [
              null,
              'false_positive',
              'wont_fix',
              'revoked',
              'used_in_tests'
            ],
            title: 'secret-scanning-alert-resolution'
          },
          'secret-scanning-alert-resolution-comment': {
            description:
              'An optional comment when closing an alert. Cannot be updated or deleted. Must be `null` when changing `state` to `open`.',
            type: 'string',
            nullable: true,
            title: 'secret-scanning-alert-resolution-comment'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          alert_number: { $ref: '#/definitions/alert-number' }
        },
        required: ['owner', 'repo', 'alert_number'],
        definitions: {
          'alert-number': {
            type: 'integer',
            description: 'The security alert number.',
            readOnly: true,
            title: 'alert-number'
          }
        }
      }
    }),

    async (req, res, next) => {
      const handler = handlers['secretScanningUpdateAlert'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/secret-scanning/alerts/:alert_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as SecretScanningUpdateAlertRequest,
          res as SecretScanningUpdateAlertResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/secret-scanning/alerts/:alert_number/locations',

    validate({
      query: {
        type: 'object',
        properties: {
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          alert_number: { $ref: '#/definitions/alert-number' }
        },
        required: ['owner', 'repo', 'alert_number'],
        definitions: {
          'alert-number': {
            type: 'integer',
            description: 'The security alert number.',
            readOnly: true,
            title: 'alert-number'
          }
        }
      }
    }),

    async (req, res, next) => {
      const handler = handlers['secretScanningListLocationsForAlert'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/secret-scanning/alerts/:alert_number/locations not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as SecretScanningListLocationsForAlertRequest,
          res as SecretScanningListLocationsForAlertResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/stargazers',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListStargazersForRepo'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/stargazers not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListStargazersForRepoRequest,
          res as ActivityListStargazersForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/stats/code_frequency',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetCodeFrequencyStats'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/stats/code_frequency not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetCodeFrequencyStatsRequest,
          res as ReposGetCodeFrequencyStatsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/stats/commit_activity',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetCommitActivityStats'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/stats/commit_activity not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetCommitActivityStatsRequest,
          res as ReposGetCommitActivityStatsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/stats/contributors',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetContributorsStats'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/stats/contributors not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetContributorsStatsRequest,
          res as ReposGetContributorsStatsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/stats/participation',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetParticipationStats'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/stats/participation not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetParticipationStatsRequest,
          res as ReposGetParticipationStatsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/stats/punch_card',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetPunchCardStats'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/stats/punch_card not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetPunchCardStatsRequest,
          res as ReposGetPunchCardStatsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/statuses/:sha',

    validate({
      body: {
        type: 'object',
        properties: {
          state: {
            type: 'string',
            description: 'The state of the status.',
            enum: ['error', 'failure', 'pending', 'success']
          },
          target_url: {
            type: 'string',
            nullable: true,
            description:
              'The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.  \nFor example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:  \n`http://ci.example.com/user/repo/build/sha`'
          },
          description: {
            type: 'string',
            nullable: true,
            description: 'A short description of the status.'
          },
          context: {
            type: 'string',
            description:
              'A string label to differentiate this status from the status of other systems. This field is case-insensitive.',
            default: 'default'
          }
        },
        required: ['state']
      },

      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          sha: { type: 'string' }
        },
        required: ['owner', 'repo', 'sha']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateCommitStatus'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/statuses/:sha not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposCreateCommitStatusRequest,
          res as ReposCreateCommitStatusResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/subscribers',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListWatchersForRepo'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/subscribers not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListWatchersForRepoRequest,
          res as ActivityListWatchersForRepoResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/subscription',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityGetRepoSubscription'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/subscription not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityGetRepoSubscriptionRequest,
          res as ActivityGetRepoSubscriptionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/subscription',

    validate({
      body: {
        type: 'object',
        properties: {
          subscribed: {
            type: 'boolean',
            description:
              'Determines if notifications should be received from this repository.'
          },
          ignored: {
            type: 'boolean',
            description:
              'Determines if all notifications should be blocked from this repository.'
          }
        }
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activitySetRepoSubscription'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/subscription not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivitySetRepoSubscriptionRequest,
          res as ActivitySetRepoSubscriptionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/subscription',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityDeleteRepoSubscription'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/subscription not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityDeleteRepoSubscriptionRequest,
          res as ActivityDeleteRepoSubscriptionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/tags',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListTags'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/tags not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListTagsRequest,
          res as ReposListTagsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/tags/protection',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListTagProtection'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/tags/protection not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposListTagProtectionRequest,
          res as ReposListTagProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/tags/protection',

    validate({
      body: {
        type: 'object',
        properties: {
          pattern: {
            type: 'string',
            description:
              'An optional glob pattern to match against when enforcing tag protection.'
          }
        },
        required: ['pattern']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateTagProtection'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/tags/protection not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposCreateTagProtectionRequest,
          res as ReposCreateTagProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/tags/protection/:tag_protection_id',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          tag_protection_id: { type: 'integer' }
        },
        required: ['owner', 'repo', 'tag_protection_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeleteTagProtection'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:owner/:repo/tags/protection/:tag_protection_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeleteTagProtectionRequest,
          res as ReposDeleteTagProtectionResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/tarball/:ref',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          ref: { type: 'string' }
        },
        required: ['owner', 'repo', 'ref']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDownloadTarballArchive'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/tarball/:ref not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposDownloadTarballArchiveRequest,
          res as ReposDownloadTarballArchiveResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/teams',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListTeams'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/teams not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListTeamsRequest,
          res as ReposListTeamsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/topics',

    validate({
      query: {
        type: 'object',
        properties: {
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetAllTopics'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/topics not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposGetAllTopicsRequest,
          res as ReposGetAllTopicsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/topics',

    validate({
      body: {
        type: 'object',
        properties: {
          names: {
            type: 'array',
            description:
              'An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` cannot contain uppercase letters.',
            items: { type: 'string' }
          }
        },
        required: ['names']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposReplaceAllTopics'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/topics not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposReplaceAllTopicsRequest,
          res as ReposReplaceAllTopicsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/traffic/clones',

    validate({
      query: {
        type: 'object',
        properties: {
          per: { type: 'string', enum: ['', 'day', 'week'], default: 'day' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetClones'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/traffic/clones not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetClonesRequest,
          res as ReposGetClonesResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/traffic/popular/paths',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetTopPaths'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/traffic/popular/paths not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetTopPathsRequest,
          res as ReposGetTopPathsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/traffic/popular/referrers',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetTopReferrers'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/traffic/popular/referrers not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposGetTopReferrersRequest,
          res as ReposGetTopReferrersResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/traffic/views',

    validate({
      query: {
        type: 'object',
        properties: {
          per: { type: 'string', enum: ['', 'day', 'week'], default: 'day' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposGetViews'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/traffic/views not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposGetViewsRequest,
          res as ReposGetViewsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:owner/:repo/transfer',

    validate({
      body: {
        type: 'object',
        properties: {
          new_owner: {
            type: 'string',
            description:
              'The username or organization name the repository will be transferred to.'
          },
          team_ids: {
            type: 'array',
            description:
              'ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.',
            items: { type: 'integer' }
          }
        },
        required: ['new_owner']
      },

      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposTransfer'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/transfer not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposTransferRequest,
          res as ReposTransferResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/vulnerability-alerts',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCheckVulnerabilityAlerts'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/vulnerability-alerts not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposCheckVulnerabilityAlertsRequest,
          res as ReposCheckVulnerabilityAlertsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repos/:owner/:repo/vulnerability-alerts',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposEnableVulnerabilityAlerts'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/vulnerability-alerts not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposEnableVulnerabilityAlertsRequest,
          res as ReposEnableVulnerabilityAlertsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repos/:owner/:repo/vulnerability-alerts',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDisableVulnerabilityAlerts'];

      if (!handler) {
        return next(
          new Error('/repos/:owner/:repo/vulnerability-alerts not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDisableVulnerabilityAlertsRequest,
          res as ReposDisableVulnerabilityAlertsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repos/:owner/:repo/zipball/:ref',

    validate({
      params: {
        type: 'object',
        properties: {
          owner: { type: 'string' },
          repo: { type: 'string' },
          ref: { type: 'string' }
        },
        required: ['owner', 'repo', 'ref']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDownloadZipballArchive'];

      if (!handler) {
        return next(new Error('/repos/:owner/:repo/zipball/:ref not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposDownloadZipballArchiveRequest,
          res as ReposDownloadZipballArchiveResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/repos/:template_owner/:template_repo/generate',

    validate({
      body: {
        type: 'object',
        properties: {
          owner: {
            type: 'string',
            description:
              'The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization.'
          },
          name: {
            type: 'string',
            description: 'The name of the new repository.'
          },
          description: {
            type: 'string',
            description: 'A short description of the new repository.'
          },
          include_all_branches: {
            type: 'boolean',
            description:
              'Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`.',
            default: false
          },
          private: {
            type: 'boolean',
            description:
              'Either `true` to create a new private repository or `false` to create a new public one.',
            default: false
          }
        },
        required: ['name']
      },

      params: {
        type: 'object',
        properties: {
          template_owner: { type: 'string' },
          template_repo: { type: 'string' }
        },
        required: ['template_owner', 'template_repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateUsingTemplate'];

      if (!handler) {
        return next(
          new Error(
            '/repos/:template_owner/:template_repo/generate not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReposCreateUsingTemplateRequest,
          res as ReposCreateUsingTemplateResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repositories',

    validate({
      query: {
        type: 'object',
        properties: { since: { type: 'integer' } },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListPublic'];

      if (!handler) {
        return next(new Error('/repositories not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListPublicRequest,
          res as ReposListPublicResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repositories/:repository_id/environments/:environment_name/secrets',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          repository_id: { type: 'integer' },
          environment_name: { type: 'string' }
        },
        required: ['repository_id', 'environment_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsListEnvironmentSecrets'];

      if (!handler) {
        return next(
          new Error(
            '/repositories/:repository_id/environments/:environment_name/secrets not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsListEnvironmentSecretsRequest,
          res as ActionsListEnvironmentSecretsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repositories/:repository_id/environments/:environment_name/secrets/public-key',

    validate({
      params: {
        type: 'object',
        properties: {
          repository_id: { type: 'integer' },
          environment_name: { type: 'string' }
        },
        required: ['repository_id', 'environment_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetEnvironmentPublicKey'];

      if (!handler) {
        return next(
          new Error(
            '/repositories/:repository_id/environments/:environment_name/secrets/public-key not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetEnvironmentPublicKeyRequest,
          res as ActionsGetEnvironmentPublicKeyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/repositories/:repository_id/environments/:environment_name/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          repository_id: { type: 'integer' },
          environment_name: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['repository_id', 'environment_name', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsGetEnvironmentSecret'];

      if (!handler) {
        return next(
          new Error(
            '/repositories/:repository_id/environments/:environment_name/secrets/:secret_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsGetEnvironmentSecretRequest,
          res as ActionsGetEnvironmentSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/repositories/:repository_id/environments/:environment_name/secrets/:secret_name',

    validate({
      body: {
        type: 'object',
        properties: {
          encrypted_value: {
            type: 'string',
            description:
              'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an environment public key](https://docs.github.com/rest/reference/actions#get-an-environment-public-key) endpoint.',
            pattern:
              '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          },
          key_id: {
            type: 'string',
            description: 'ID of the key you used to encrypt the secret.'
          }
        },
        required: ['encrypted_value', 'key_id']
      },

      params: {
        type: 'object',
        properties: {
          repository_id: { type: 'integer' },
          environment_name: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['repository_id', 'environment_name', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsCreateOrUpdateEnvironmentSecret'];

      if (!handler) {
        return next(
          new Error(
            '/repositories/:repository_id/environments/:environment_name/secrets/:secret_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsCreateOrUpdateEnvironmentSecretRequest,
          res as ActionsCreateOrUpdateEnvironmentSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/repositories/:repository_id/environments/:environment_name/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: {
          repository_id: { type: 'integer' },
          environment_name: { type: 'string' },
          secret_name: { type: 'string' }
        },
        required: ['repository_id', 'environment_name', 'secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['actionsDeleteEnvironmentSecret'];

      if (!handler) {
        return next(
          new Error(
            '/repositories/:repository_id/environments/:environment_name/secrets/:secret_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ActionsDeleteEnvironmentSecretRequest,
          res as ActionsDeleteEnvironmentSecretResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/search/code',

    validate({
      query: {
        type: 'object',
        properties: {
          q: { type: 'string' },
          sort: { type: 'string', enum: ['indexed'] },
          order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: ['q']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['searchCode'];

      if (!handler) {
        return next(new Error('/search/code not handled'));
      }

      try {
        await handler(
          (req as unknown) as SearchCodeRequest,
          res as SearchCodeResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/search/commits',

    validate({
      query: {
        type: 'object',
        properties: {
          q: { type: 'string' },
          sort: { type: 'string', enum: ['author-date', 'committer-date'] },
          order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: ['q']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['searchCommits'];

      if (!handler) {
        return next(new Error('/search/commits not handled'));
      }

      try {
        await handler(
          (req as unknown) as SearchCommitsRequest,
          res as SearchCommitsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/search/issues',

    validate({
      query: {
        type: 'object',
        properties: {
          q: { type: 'string' },
          sort: {
            type: 'string',
            enum: [
              'comments',
              'reactions',
              'reactions-+1',
              'reactions--1',
              'reactions-smile',
              'reactions-thinking_face',
              'reactions-heart',
              'reactions-tada',
              'interactions',
              'created',
              'updated'
            ]
          },
          order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: ['q']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['searchIssuesAndPullRequests'];

      if (!handler) {
        return next(new Error('/search/issues not handled'));
      }

      try {
        await handler(
          (req as unknown) as SearchIssuesAndPullRequestsRequest,
          res as SearchIssuesAndPullRequestsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/search/labels',

    validate({
      query: {
        type: 'object',
        properties: {
          repository_id: { type: 'integer' },
          q: { type: 'string' },
          sort: { type: 'string', enum: ['created', 'updated'] },
          order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: ['repository_id', 'q']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['searchLabels'];

      if (!handler) {
        return next(new Error('/search/labels not handled'));
      }

      try {
        await handler(
          (req as unknown) as SearchLabelsRequest,
          res as SearchLabelsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/search/repositories',

    validate({
      query: {
        type: 'object',
        properties: {
          q: { type: 'string' },
          sort: {
            type: 'string',
            enum: ['stars', 'forks', 'help-wanted-issues', 'updated']
          },
          order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: ['q']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['searchRepos'];

      if (!handler) {
        return next(new Error('/search/repositories not handled'));
      }

      try {
        await handler(
          (req as unknown) as SearchReposRequest,
          res as SearchReposResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/search/topics',

    validate({
      query: {
        type: 'object',
        properties: {
          q: { type: 'string' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: ['q']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['searchTopics'];

      if (!handler) {
        return next(new Error('/search/topics not handled'));
      }

      try {
        await handler(
          (req as unknown) as SearchTopicsRequest,
          res as SearchTopicsResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/search/users',

    validate({
      query: {
        type: 'object',
        properties: {
          q: { type: 'string' },
          sort: {
            type: 'string',
            enum: ['followers', 'repositories', 'joined']
          },
          order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: ['q']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['searchUsers'];

      if (!handler) {
        return next(new Error('/search/users not handled'));
      }

      try {
        await handler(
          (req as unknown) as SearchUsersRequest,
          res as SearchUsersResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id',

    validate({
      params: {
        type: 'object',
        properties: { team_id: { type: 'integer' } },
        required: ['team_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsGetLegacy'];

      if (!handler) {
        return next(new Error('/teams/:team_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsGetLegacyRequest,
          res as TeamsGetLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/teams/:team_id',

    validate({
      body: {
        type: 'object',
        properties: {
          name: { type: 'string', description: 'The name of the team.' },
          description: {
            type: 'string',
            description: 'The description of the team.'
          },
          privacy: {
            type: 'string',
            description:
              'The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. The options are:  \n**For a non-nested team:**  \n\\* `secret` - only visible to organization owners and members of this team.  \n\\* `closed` - visible to all members of this organization.  \n**For a parent or child team:**  \n\\* `closed` - visible to all members of this organization.',
            enum: ['secret', 'closed']
          },
          permission: {
            type: 'string',
            description:
              '**Deprecated**. The permission that new repositories will be added to the team with when none is specified.',
            enum: ['pull', 'push', 'admin'],
            default: 'pull'
          },
          parent_team_id: {
            type: 'integer',
            description: 'The ID of a team to set as the parent team.',
            nullable: true
          }
        },
        required: ['name']
      },

      params: {
        type: 'object',
        properties: { team_id: { type: 'integer' } },
        required: ['team_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsUpdateLegacy'];

      if (!handler) {
        return next(new Error('/teams/:team_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsUpdateLegacyRequest,
          res as TeamsUpdateLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/teams/:team_id',

    validate({
      params: {
        type: 'object',
        properties: { team_id: { type: 'integer' } },
        required: ['team_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsDeleteLegacy'];

      if (!handler) {
        return next(new Error('/teams/:team_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsDeleteLegacyRequest,
          res as TeamsDeleteLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/discussions',

    validate({
      query: {
        type: 'object',
        properties: {
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { team_id: { type: 'integer' } },
        required: ['team_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListDiscussionsLegacy'];

      if (!handler) {
        return next(new Error('/teams/:team_id/discussions not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsListDiscussionsLegacyRequest,
          res as TeamsListDiscussionsLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/teams/:team_id/discussions',

    validate({
      body: {
        type: 'object',
        properties: {
          title: {
            type: 'string',
            description: "The discussion post's title."
          },
          body: {
            type: 'string',
            description: "The discussion post's body text."
          },
          private: {
            type: 'boolean',
            description:
              'Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.',
            default: false
          }
        },
        required: ['title', 'body']
      },

      params: {
        type: 'object',
        properties: { team_id: { type: 'integer' } },
        required: ['team_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsCreateDiscussionLegacy'];

      if (!handler) {
        return next(new Error('/teams/:team_id/discussions not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsCreateDiscussionLegacyRequest,
          res as TeamsCreateDiscussionLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/discussions/:discussion_number',

    validate({
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          discussion_number: { type: 'integer' }
        },
        required: ['team_id', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsGetDiscussionLegacy'];

      if (!handler) {
        return next(
          new Error(
            '/teams/:team_id/discussions/:discussion_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsGetDiscussionLegacyRequest,
          res as TeamsGetDiscussionLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/teams/:team_id/discussions/:discussion_number',

    validate({
      body: {
        type: 'object',
        properties: {
          title: {
            type: 'string',
            description: "The discussion post's title."
          },
          body: {
            type: 'string',
            description: "The discussion post's body text."
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          discussion_number: { type: 'integer' }
        },
        required: ['team_id', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsUpdateDiscussionLegacy'];

      if (!handler) {
        return next(
          new Error(
            '/teams/:team_id/discussions/:discussion_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsUpdateDiscussionLegacyRequest,
          res as TeamsUpdateDiscussionLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/teams/:team_id/discussions/:discussion_number',

    validate({
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          discussion_number: { type: 'integer' }
        },
        required: ['team_id', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsDeleteDiscussionLegacy'];

      if (!handler) {
        return next(
          new Error(
            '/teams/:team_id/discussions/:discussion_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsDeleteDiscussionLegacyRequest,
          res as TeamsDeleteDiscussionLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/discussions/:discussion_number/comments',

    validate({
      query: {
        type: 'object',
        properties: {
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          discussion_number: { type: 'integer' }
        },
        required: ['team_id', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListDiscussionCommentsLegacy'];

      if (!handler) {
        return next(
          new Error(
            '/teams/:team_id/discussions/:discussion_number/comments not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsListDiscussionCommentsLegacyRequest,
          res as TeamsListDiscussionCommentsLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/teams/:team_id/discussions/:discussion_number/comments',

    validate({
      body: {
        type: 'object',
        properties: {
          body: {
            type: 'string',
            description: "The discussion comment's body text."
          }
        },
        required: ['body']
      },

      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          discussion_number: { type: 'integer' }
        },
        required: ['team_id', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsCreateDiscussionCommentLegacy'];

      if (!handler) {
        return next(
          new Error(
            '/teams/:team_id/discussions/:discussion_number/comments not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsCreateDiscussionCommentLegacyRequest,
          res as TeamsCreateDiscussionCommentLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/discussions/:discussion_number/comments/:comment_number',

    validate({
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          discussion_number: { type: 'integer' },
          comment_number: { type: 'integer' }
        },
        required: ['team_id', 'discussion_number', 'comment_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsGetDiscussionCommentLegacy'];

      if (!handler) {
        return next(
          new Error(
            '/teams/:team_id/discussions/:discussion_number/comments/:comment_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsGetDiscussionCommentLegacyRequest,
          res as TeamsGetDiscussionCommentLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/teams/:team_id/discussions/:discussion_number/comments/:comment_number',

    validate({
      body: {
        type: 'object',
        properties: {
          body: {
            type: 'string',
            description: "The discussion comment's body text."
          }
        },
        required: ['body']
      },

      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          discussion_number: { type: 'integer' },
          comment_number: { type: 'integer' }
        },
        required: ['team_id', 'discussion_number', 'comment_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsUpdateDiscussionCommentLegacy'];

      if (!handler) {
        return next(
          new Error(
            '/teams/:team_id/discussions/:discussion_number/comments/:comment_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsUpdateDiscussionCommentLegacyRequest,
          res as TeamsUpdateDiscussionCommentLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/teams/:team_id/discussions/:discussion_number/comments/:comment_number',

    validate({
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          discussion_number: { type: 'integer' },
          comment_number: { type: 'integer' }
        },
        required: ['team_id', 'discussion_number', 'comment_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsDeleteDiscussionCommentLegacy'];

      if (!handler) {
        return next(
          new Error(
            '/teams/:team_id/discussions/:discussion_number/comments/:comment_number not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsDeleteDiscussionCommentLegacyRequest,
          res as TeamsDeleteDiscussionCommentLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions',

    validate({
      query: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          discussion_number: { type: 'integer' },
          comment_number: { type: 'integer' }
        },
        required: ['team_id', 'discussion_number', 'comment_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsListForTeamDiscussionCommentLegacy'];

      if (!handler) {
        return next(
          new Error(
            '/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsListForTeamDiscussionCommentLegacyRequest,
          res as ReactionsListForTeamDiscussionCommentLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions',

    validate({
      body: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            description:
              'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion comment.',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          }
        },
        required: ['content']
      },

      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          discussion_number: { type: 'integer' },
          comment_number: { type: 'integer' }
        },
        required: ['team_id', 'discussion_number', 'comment_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsCreateForTeamDiscussionCommentLegacy'];

      if (!handler) {
        return next(
          new Error(
            '/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsCreateForTeamDiscussionCommentLegacyRequest,
          res as ReactionsCreateForTeamDiscussionCommentLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/discussions/:discussion_number/reactions',

    validate({
      query: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          discussion_number: { type: 'integer' }
        },
        required: ['team_id', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsListForTeamDiscussionLegacy'];

      if (!handler) {
        return next(
          new Error(
            '/teams/:team_id/discussions/:discussion_number/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsListForTeamDiscussionLegacyRequest,
          res as ReactionsListForTeamDiscussionLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/teams/:team_id/discussions/:discussion_number/reactions',

    validate({
      body: {
        type: 'object',
        properties: {
          content: {
            type: 'string',
            description:
              'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion.',
            enum: [
              '+1',
              '-1',
              'laugh',
              'confused',
              'heart',
              'hooray',
              'rocket',
              'eyes'
            ]
          }
        },
        required: ['content']
      },

      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          discussion_number: { type: 'integer' }
        },
        required: ['team_id', 'discussion_number']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reactionsCreateForTeamDiscussionLegacy'];

      if (!handler) {
        return next(
          new Error(
            '/teams/:team_id/discussions/:discussion_number/reactions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as ReactionsCreateForTeamDiscussionLegacyRequest,
          res as ReactionsCreateForTeamDiscussionLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/invitations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { team_id: { type: 'integer' } },
        required: ['team_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListPendingInvitationsLegacy'];

      if (!handler) {
        return next(new Error('/teams/:team_id/invitations not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsListPendingInvitationsLegacyRequest,
          res as TeamsListPendingInvitationsLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/members',

    validate({
      query: {
        type: 'object',
        properties: {
          role: {
            type: 'string',
            enum: ['member', 'maintainer', 'all'],
            default: 'all'
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { team_id: { type: 'integer' } },
        required: ['team_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListMembersLegacy'];

      if (!handler) {
        return next(new Error('/teams/:team_id/members not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsListMembersLegacyRequest,
          res as TeamsListMembersLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/members/:username',

    validate({
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          username: { type: 'string' }
        },
        required: ['team_id', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsGetMemberLegacy'];

      if (!handler) {
        return next(new Error('/teams/:team_id/members/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsGetMemberLegacyRequest,
          res as TeamsGetMemberLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/teams/:team_id/members/:username',

    validate({
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          username: { type: 'string' }
        },
        required: ['team_id', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsAddMemberLegacy'];

      if (!handler) {
        return next(new Error('/teams/:team_id/members/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsAddMemberLegacyRequest,
          res as TeamsAddMemberLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/teams/:team_id/members/:username',

    validate({
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          username: { type: 'string' }
        },
        required: ['team_id', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsRemoveMemberLegacy'];

      if (!handler) {
        return next(new Error('/teams/:team_id/members/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsRemoveMemberLegacyRequest,
          res as TeamsRemoveMemberLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/memberships/:username',

    validate({
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          username: { type: 'string' }
        },
        required: ['team_id', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsGetMembershipForUserLegacy'];

      if (!handler) {
        return next(
          new Error('/teams/:team_id/memberships/:username not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsGetMembershipForUserLegacyRequest,
          res as TeamsGetMembershipForUserLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/teams/:team_id/memberships/:username',

    validate({
      body: {
        type: 'object',
        properties: {
          role: {
            type: 'string',
            description: 'The role that this user should have in the team.',
            enum: ['member', 'maintainer'],
            default: 'member'
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          username: { type: 'string' }
        },
        required: ['team_id', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsAddOrUpdateMembershipForUserLegacy'];

      if (!handler) {
        return next(
          new Error('/teams/:team_id/memberships/:username not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsAddOrUpdateMembershipForUserLegacyRequest,
          res as TeamsAddOrUpdateMembershipForUserLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/teams/:team_id/memberships/:username',

    validate({
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          username: { type: 'string' }
        },
        required: ['team_id', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsRemoveMembershipForUserLegacy'];

      if (!handler) {
        return next(
          new Error('/teams/:team_id/memberships/:username not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsRemoveMembershipForUserLegacyRequest,
          res as TeamsRemoveMembershipForUserLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/projects',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { team_id: { type: 'integer' } },
        required: ['team_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListProjectsLegacy'];

      if (!handler) {
        return next(new Error('/teams/:team_id/projects not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsListProjectsLegacyRequest,
          res as TeamsListProjectsLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/projects/:project_id',

    validate({
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          project_id: { type: 'integer' }
        },
        required: ['team_id', 'project_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsCheckPermissionsForProjectLegacy'];

      if (!handler) {
        return next(
          new Error('/teams/:team_id/projects/:project_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsCheckPermissionsForProjectLegacyRequest,
          res as TeamsCheckPermissionsForProjectLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/teams/:team_id/projects/:project_id',

    validate({
      body: {
        type: 'object',
        properties: {
          permission: {
            type: 'string',
            description:
              'The permission to grant to the team for this project. Default: the team\'s `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you\'ll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."',
            enum: ['read', 'write', 'admin']
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          project_id: { type: 'integer' }
        },
        required: ['team_id', 'project_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsAddOrUpdateProjectPermissionsLegacy'];

      if (!handler) {
        return next(
          new Error('/teams/:team_id/projects/:project_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsAddOrUpdateProjectPermissionsLegacyRequest,
          res as TeamsAddOrUpdateProjectPermissionsLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/teams/:team_id/projects/:project_id',

    validate({
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          project_id: { type: 'integer' }
        },
        required: ['team_id', 'project_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsRemoveProjectLegacy'];

      if (!handler) {
        return next(
          new Error('/teams/:team_id/projects/:project_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsRemoveProjectLegacyRequest,
          res as TeamsRemoveProjectLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/repos',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { team_id: { type: 'integer' } },
        required: ['team_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListReposLegacy'];

      if (!handler) {
        return next(new Error('/teams/:team_id/repos not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsListReposLegacyRequest,
          res as TeamsListReposLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/repos/:owner/:repo',

    validate({
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          owner: { type: 'string' },
          repo: { type: 'string' }
        },
        required: ['team_id', 'owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsCheckPermissionsForRepoLegacy'];

      if (!handler) {
        return next(
          new Error('/teams/:team_id/repos/:owner/:repo not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsCheckPermissionsForRepoLegacyRequest,
          res as TeamsCheckPermissionsForRepoLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/teams/:team_id/repos/:owner/:repo',

    validate({
      body: {
        type: 'object',
        properties: {
          permission: {
            type: 'string',
            description:
              "The permission to grant the team on this repository. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.",
            enum: ['pull', 'push', 'admin']
          }
        }
      },

      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          owner: { type: 'string' },
          repo: { type: 'string' }
        },
        required: ['team_id', 'owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsAddOrUpdateRepoPermissionsLegacy'];

      if (!handler) {
        return next(
          new Error('/teams/:team_id/repos/:owner/:repo not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsAddOrUpdateRepoPermissionsLegacyRequest,
          res as TeamsAddOrUpdateRepoPermissionsLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/teams/:team_id/repos/:owner/:repo',

    validate({
      params: {
        type: 'object',
        properties: {
          team_id: { type: 'integer' },
          owner: { type: 'string' },
          repo: { type: 'string' }
        },
        required: ['team_id', 'owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsRemoveRepoLegacy'];

      if (!handler) {
        return next(
          new Error('/teams/:team_id/repos/:owner/:repo not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as TeamsRemoveRepoLegacyRequest,
          res as TeamsRemoveRepoLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/teams/:team_id/teams',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { team_id: { type: 'integer' } },
        required: ['team_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListChildLegacy'];

      if (!handler) {
        return next(new Error('/teams/:team_id/teams not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsListChildLegacyRequest,
          res as TeamsListChildLegacyResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user',

    async (req, res, next) => {
      const handler = handlers['usersGetAuthenticated'];

      if (!handler) {
        return next(new Error('/user not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersGetAuthenticatedRequest,
          res as UsersGetAuthenticatedResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/user',

    validate({
      body: {
        type: 'object',
        properties: {
          name: {
            description: 'The new name of the user.',
            type: 'string',
            example: 'Omar Jahandar'
          },
          email: {
            description: 'The publicly visible email address of the user.',
            type: 'string',
            example: 'omar@example.com'
          },
          blog: {
            description: 'The new blog URL of the user.',
            type: 'string',
            example: 'blog.example.com'
          },
          twitter_username: {
            description: 'The new Twitter username of the user.',
            type: 'string',
            example: 'therealomarj',
            nullable: true
          },
          company: {
            description: 'The new company of the user.',
            type: 'string',
            example: 'Acme corporation'
          },
          location: {
            description: 'The new location of the user.',
            type: 'string',
            example: 'Berlin, Germany'
          },
          hireable: {
            description: 'The new hiring availability of the user.',
            type: 'boolean'
          },
          bio: {
            description: 'The new short biography of the user.',
            type: 'string'
          }
        }
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersUpdateAuthenticated'];

      if (!handler) {
        return next(new Error('/user not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersUpdateAuthenticatedRequest,
          res as UsersUpdateAuthenticatedResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/blocks',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersListBlockedByAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/blocks not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListBlockedByAuthenticatedUserRequest,
          res as UsersListBlockedByAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/blocks/:username',

    validate({
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersCheckBlocked'];

      if (!handler) {
        return next(new Error('/user/blocks/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersCheckBlockedRequest,
          res as UsersCheckBlockedResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/user/blocks/:username',

    validate({
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersBlock'];

      if (!handler) {
        return next(new Error('/user/blocks/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersBlockRequest,
          res as UsersBlockResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/blocks/:username',

    validate({
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersUnblock'];

      if (!handler) {
        return next(new Error('/user/blocks/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersUnblockRequest,
          res as UsersUnblockResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/codespaces',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 },
          repository_id: { type: 'integer' }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesListForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/codespaces not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodespacesListForAuthenticatedUserRequest,
          res as CodespacesListForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/user/codespaces',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            required: ['repository_id'],
            properties: {
              repository_id: {
                description: 'Repository id for this codespace',
                type: 'integer'
              },
              ref: {
                description:
                  'Git ref (typically a branch name) for this codespace',
                type: 'string'
              },
              location: {
                description:
                  'Location for this codespace. Assigned by IP if not provided',
                type: 'string'
              },
              client_ip: {
                description:
                  'IP for location auto-detection when proxying a request',
                type: 'string'
              },
              machine: {
                description: 'Machine type to use for this codespace',
                type: 'string'
              },
              devcontainer_path: {
                description:
                  'Path to devcontainer.json config to use for this codespace',
                type: 'string'
              },
              multi_repo_permissions_opt_out: {
                description:
                  'Whether to authorize requested permissions from devcontainer.json',
                type: 'boolean'
              },
              working_directory: {
                description: 'Working directory for this codespace',
                type: 'string'
              },
              idle_timeout_minutes: {
                description:
                  'Time in minutes before codespace stops from inactivity',
                type: 'integer'
              },
              display_name: {
                description: 'Display name for this codespace',
                type: 'string'
              },
              retention_period_minutes: {
                description:
                  'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).',
                type: 'integer'
              }
            }
          },
          {
            type: 'object',
            required: ['pull_request'],
            properties: {
              pull_request: {
                required: ['pull_request_number', 'repository_id'],
                description: 'Pull request number for this codespace',
                type: 'object',
                properties: {
                  pull_request_number: {
                    description: 'Pull request number',
                    type: 'integer'
                  },
                  repository_id: {
                    description: 'Repository id for this codespace',
                    type: 'integer'
                  }
                }
              },
              location: {
                description:
                  'Location for this codespace. Assigned by IP if not provided',
                type: 'string'
              },
              machine: {
                description: 'Machine type to use for this codespace',
                type: 'string'
              },
              devcontainer_path: {
                description:
                  'Path to devcontainer.json config to use for this codespace',
                type: 'string'
              },
              working_directory: {
                description: 'Working directory for this codespace',
                type: 'string'
              },
              idle_timeout_minutes: {
                description:
                  'Time in minutes before codespace stops from inactivity',
                type: 'integer'
              }
            }
          }
        ]
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesCreateForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/codespaces not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodespacesCreateForAuthenticatedUserRequest,
          res as CodespacesCreateForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/codespaces/secrets',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesListSecretsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/codespaces/secrets not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodespacesListSecretsForAuthenticatedUserRequest,
          res as CodespacesListSecretsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/codespaces/secrets/public-key',

    async (req, res, next) => {
      const handler = handlers['codespacesGetPublicKeyForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/codespaces/secrets/public-key not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesGetPublicKeyForAuthenticatedUserRequest,
          res as CodespacesGetPublicKeyForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/codespaces/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: { secret_name: { type: 'string' } },
        required: ['secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesGetSecretForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/codespaces/secrets/:secret_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesGetSecretForAuthenticatedUserRequest,
          res as CodespacesGetSecretForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/user/codespaces/secrets/:secret_name',

    validate({
      body: {
        type: 'object',
        properties: {
          encrypted_value: {
            type: 'string',
            description:
              'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get the public key for the authenticated user](https://docs.github.com/rest/reference/codespaces#get-the-public-key-for-the-authenticated-user) endpoint.',
            pattern:
              '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
          },
          key_id: {
            type: 'string',
            description: 'ID of the key you used to encrypt the secret.'
          },
          selected_repository_ids: {
            type: 'array',
            description:
              'An array of repository ids that can access the user secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/reference/codespaces#list-selected-repositories-for-a-user-secret), [Set selected repositories for a user secret](https://docs.github.com/rest/reference/codespaces#set-selected-repositories-for-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/reference/codespaces#remove-a-selected-repository-from-a-user-secret) endpoints.',
            items: { type: 'string' }
          }
        },
        required: ['key_id']
      },

      params: {
        type: 'object',
        properties: { secret_name: { type: 'string' } },
        required: ['secret_name']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['codespacesCreateOrUpdateSecretForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/codespaces/secrets/:secret_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesCreateOrUpdateSecretForAuthenticatedUserRequest,
          res as CodespacesCreateOrUpdateSecretForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/codespaces/secrets/:secret_name',

    validate({
      params: {
        type: 'object',
        properties: { secret_name: { type: 'string' } },
        required: ['secret_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesDeleteSecretForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/codespaces/secrets/:secret_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesDeleteSecretForAuthenticatedUserRequest,
          res as CodespacesDeleteSecretForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/codespaces/secrets/:secret_name/repositories',

    validate({
      params: {
        type: 'object',
        properties: { secret_name: { type: 'string' } },
        required: ['secret_name']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['codespacesListRepositoriesForSecretForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/user/codespaces/secrets/:secret_name/repositories not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesListRepositoriesForSecretForAuthenticatedUserRequest,
          res as CodespacesListRepositoriesForSecretForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/user/codespaces/secrets/:secret_name/repositories',

    validate({
      body: {
        type: 'object',
        properties: {
          selected_repository_ids: {
            type: 'array',
            description:
              'An array of repository ids for which a codespace can access the secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/reference/codespaces#list-selected-repositories-for-a-user-secret), [Add a selected repository to a user secret](https://docs.github.com/rest/reference/codespaces#add-a-selected-repository-to-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/reference/codespaces#remove-a-selected-repository-from-a-user-secret) endpoints.',
            items: { type: 'integer' }
          }
        },
        required: ['selected_repository_ids']
      },

      params: {
        type: 'object',
        properties: { secret_name: { type: 'string' } },
        required: ['secret_name']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['codespacesSetRepositoriesForSecretForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/user/codespaces/secrets/:secret_name/repositories not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesSetRepositoriesForSecretForAuthenticatedUserRequest,
          res as CodespacesSetRepositoriesForSecretForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/user/codespaces/secrets/:secret_name/repositories/:repository_id',

    validate({
      params: {
        type: 'object',
        properties: {
          secret_name: { type: 'string' },
          repository_id: { type: 'integer' }
        },
        required: ['secret_name', 'repository_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['codespacesAddRepositoryForSecretForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/user/codespaces/secrets/:secret_name/repositories/:repository_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesAddRepositoryForSecretForAuthenticatedUserRequest,
          res as CodespacesAddRepositoryForSecretForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/codespaces/secrets/:secret_name/repositories/:repository_id',

    validate({
      params: {
        type: 'object',
        properties: {
          secret_name: { type: 'string' },
          repository_id: { type: 'integer' }
        },
        required: ['secret_name', 'repository_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['codespacesRemoveRepositoryForSecretForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/user/codespaces/secrets/:secret_name/repositories/:repository_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesRemoveRepositoryForSecretForAuthenticatedUserRequest,
          res as CodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/codespaces/:codespace_name',

    validate({
      params: {
        type: 'object',
        properties: { codespace_name: { type: 'string' } },
        required: ['codespace_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesGetForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/codespaces/:codespace_name not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodespacesGetForAuthenticatedUserRequest,
          res as CodespacesGetForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/user/codespaces/:codespace_name',

    validate({
      body: {
        type: 'object',
        properties: {
          machine: {
            description: 'A valid machine to transition this codespace to.',
            type: 'string'
          },
          display_name: {
            description: 'Display name for this codespace',
            type: 'string'
          },
          recent_folders: {
            description:
              'Recently opened folders inside the codespace. It is currently used by the clients to determine the folder path to load the codespace in.',
            type: 'array',
            items: { type: 'string' }
          }
        }
      },

      params: {
        type: 'object',
        properties: { codespace_name: { type: 'string' } },
        required: ['codespace_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesUpdateForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/codespaces/:codespace_name not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodespacesUpdateForAuthenticatedUserRequest,
          res as CodespacesUpdateForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/codespaces/:codespace_name',

    validate({
      params: {
        type: 'object',
        properties: { codespace_name: { type: 'string' } },
        required: ['codespace_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesDeleteForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/codespaces/:codespace_name not handled'));
      }

      try {
        await handler(
          (req as unknown) as CodespacesDeleteForAuthenticatedUserRequest,
          res as CodespacesDeleteForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/user/codespaces/:codespace_name/exports',

    validate({
      params: {
        type: 'object',
        properties: { codespace_name: { type: 'string' } },
        required: ['codespace_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesExportForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/codespaces/:codespace_name/exports not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesExportForAuthenticatedUserRequest,
          res as CodespacesExportForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/codespaces/:codespace_name/exports/:export_id',

    validate({
      params: {
        type: 'object',
        properties: {
          codespace_name: { type: 'string' },
          export_id: { type: 'string' }
        },
        required: ['codespace_name', 'export_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['codespacesGetExportDetailsForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/user/codespaces/:codespace_name/exports/:export_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesGetExportDetailsForAuthenticatedUserRequest,
          res as CodespacesGetExportDetailsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/codespaces/:codespace_name/machines',

    validate({
      params: {
        type: 'object',
        properties: { codespace_name: { type: 'string' } },
        required: ['codespace_name']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['codespacesCodespaceMachinesForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/codespaces/:codespace_name/machines not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesCodespaceMachinesForAuthenticatedUserRequest,
          res as CodespacesCodespaceMachinesForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/user/codespaces/:codespace_name/start',

    validate({
      params: {
        type: 'object',
        properties: { codespace_name: { type: 'string' } },
        required: ['codespace_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesStartForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/codespaces/:codespace_name/start not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesStartForAuthenticatedUserRequest,
          res as CodespacesStartForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/user/codespaces/:codespace_name/stop',

    validate({
      params: {
        type: 'object',
        properties: { codespace_name: { type: 'string' } },
        required: ['codespace_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['codespacesStopForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/codespaces/:codespace_name/stop not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as CodespacesStopForAuthenticatedUserRequest,
          res as CodespacesStopForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/user/email/visibility',

    validate({
      body: {
        properties: {
          visibility: {
            description: 'Denotes whether an email is publicly visible.',
            type: 'string',
            enum: ['public', 'private']
          }
        },
        required: ['visibility'],
        type: 'object'
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['usersSetPrimaryEmailVisibilityForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/email/visibility not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequest,
          res as UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/emails',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersListEmailsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/emails not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListEmailsForAuthenticatedUserRequest,
          res as UsersListEmailsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/user/emails',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            properties: {
              emails: {
                description:
                  'Adds one or more email addresses to your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.',
                type: 'array',
                items: {
                  type: 'string',
                  example: 'username@example.com',
                  minItems: 1
                },
                example: []
              }
            },
            required: ['emails'],
            example: { emails: ['octocat@github.com', 'mona@github.com'] }
          },
          {
            type: 'array',
            items: {
              type: 'string',
              example: 'username@example.com',
              minItems: 1
            }
          },
          { type: 'string' }
        ]
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersAddEmailForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/emails not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersAddEmailForAuthenticatedUserRequest,
          res as UsersAddEmailForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/emails',

    validate({
      body: {
        oneOf: [
          {
            type: 'object',
            description:
              'Deletes one or more email addresses from your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.',
            properties: {
              emails: {
                description:
                  'Email addresses associated with the GitHub user account.',
                type: 'array',
                items: {
                  type: 'string',
                  example: 'username@example.com',
                  minItems: 1
                }
              }
            },
            example: { emails: ['octocat@github.com', 'mona@github.com'] },
            required: ['emails']
          },
          {
            type: 'array',
            items: {
              type: 'string',
              example: 'username@example.com',
              minItems: 1
            }
          },
          { type: 'string' }
        ]
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersDeleteEmailForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/emails not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersDeleteEmailForAuthenticatedUserRequest,
          res as UsersDeleteEmailForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/followers',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersListFollowersForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/followers not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListFollowersForAuthenticatedUserRequest,
          res as UsersListFollowersForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/following',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersListFollowedByAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/following not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListFollowedByAuthenticatedUserRequest,
          res as UsersListFollowedByAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/following/:username',

    validate({
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersCheckPersonIsFollowedByAuthenticated'];

      if (!handler) {
        return next(new Error('/user/following/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersCheckPersonIsFollowedByAuthenticatedRequest,
          res as UsersCheckPersonIsFollowedByAuthenticatedResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/user/following/:username',

    validate({
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersFollow'];

      if (!handler) {
        return next(new Error('/user/following/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersFollowRequest,
          res as UsersFollowResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/following/:username',

    validate({
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersUnfollow'];

      if (!handler) {
        return next(new Error('/user/following/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersUnfollowRequest,
          res as UsersUnfollowResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/gpg_keys',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersListGpgKeysForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/gpg_keys not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListGpgKeysForAuthenticatedUserRequest,
          res as UsersListGpgKeysForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/user/gpg_keys',

    validate({
      body: {
        properties: {
          name: {
            description: 'A descriptive name for the new key.',
            type: 'string'
          },
          armored_public_key: {
            description: 'A GPG key in ASCII-armored format.',
            type: 'string'
          }
        },
        type: 'object',
        required: ['armored_public_key']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersCreateGpgKeyForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/gpg_keys not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersCreateGpgKeyForAuthenticatedUserRequest,
          res as UsersCreateGpgKeyForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/gpg_keys/:gpg_key_id',

    validate({
      params: {
        type: 'object',
        properties: { gpg_key_id: { type: 'integer' } },
        required: ['gpg_key_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersGetGpgKeyForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/gpg_keys/:gpg_key_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersGetGpgKeyForAuthenticatedUserRequest,
          res as UsersGetGpgKeyForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/gpg_keys/:gpg_key_id',

    validate({
      params: {
        type: 'object',
        properties: { gpg_key_id: { type: 'integer' } },
        required: ['gpg_key_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersDeleteGpgKeyForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/gpg_keys/:gpg_key_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersDeleteGpgKeyForAuthenticatedUserRequest,
          res as UsersDeleteGpgKeyForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/installations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsListInstallationsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/installations not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsListInstallationsForAuthenticatedUserRequest,
          res as AppsListInstallationsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/installations/:installation_id/repositories',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { installation_id: { type: 'integer' } },
        required: ['installation_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsListInstallationReposForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/user/installations/:installation_id/repositories not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as AppsListInstallationReposForAuthenticatedUserRequest,
          res as AppsListInstallationReposForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/user/installations/:installation_id/repositories/:repository_id',

    validate({
      params: {
        type: 'object',
        properties: {
          installation_id: { type: 'integer' },
          repository_id: { type: 'integer' }
        },
        required: ['installation_id', 'repository_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsAddRepoToInstallationForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/user/installations/:installation_id/repositories/:repository_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as AppsAddRepoToInstallationForAuthenticatedUserRequest,
          res as AppsAddRepoToInstallationForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/installations/:installation_id/repositories/:repository_id',

    validate({
      params: {
        type: 'object',
        properties: {
          installation_id: { type: 'integer' },
          repository_id: { type: 'integer' }
        },
        required: ['installation_id', 'repository_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['appsRemoveRepoFromInstallationForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/user/installations/:installation_id/repositories/:repository_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as AppsRemoveRepoFromInstallationForAuthenticatedUserRequest,
          res as AppsRemoveRepoFromInstallationForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/interaction-limits',

    async (req, res, next) => {
      const handler =
        handlers['interactionsGetRestrictionsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/interaction-limits not handled'));
      }

      try {
        await handler(
          (req as unknown) as InteractionsGetRestrictionsForAuthenticatedUserRequest,
          res as InteractionsGetRestrictionsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/user/interaction-limits',

    validate({
      body: {
        $ref: '#/definitions/interaction-limit',
        definitions: {
          'interaction-limit': {
            title: 'Interaction Restrictions',
            description:
              'Limit interactions to a specific type of user for a specified duration',
            type: 'object',
            properties: {
              limit: { $ref: '#/definitions/interaction-group' },
              expiry: { $ref: '#/definitions/interaction-expiry' }
            },
            required: ['limit']
          },
          'interaction-group': {
            type: 'string',
            description:
              'The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.',
            example: 'collaborators_only',
            enum: ['existing_users', 'contributors_only', 'collaborators_only'],
            title: 'interaction-group'
          },
          'interaction-expiry': {
            type: 'string',
            description:
              'The duration of the interaction restriction. Default: `one_day`.',
            example: 'one_month',
            enum: [
              'one_day',
              'three_days',
              'one_week',
              'one_month',
              'six_months'
            ],
            title: 'interaction-expiry'
          }
        }
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['interactionsSetRestrictionsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/interaction-limits not handled'));
      }

      try {
        await handler(
          (req as unknown) as InteractionsSetRestrictionsForAuthenticatedUserRequest,
          res as InteractionsSetRestrictionsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/interaction-limits',

    async (req, res, next) => {
      const handler =
        handlers['interactionsRemoveRestrictionsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/interaction-limits not handled'));
      }

      try {
        await handler(
          (req as unknown) as InteractionsRemoveRestrictionsForAuthenticatedUserRequest,
          res as InteractionsRemoveRestrictionsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/issues',

    validate({
      query: {
        type: 'object',
        properties: {
          filter: {
            type: 'string',
            enum: [
              'assigned',
              'created',
              'mentioned',
              'subscribed',
              'repos',
              'all'
            ],
            default: 'assigned'
          },
          state: {
            type: 'string',
            enum: ['open', 'closed', 'all'],
            default: 'open'
          },
          labels: { type: 'string' },
          sort: {
            type: 'string',
            enum: ['created', 'updated', 'comments'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          since: { type: 'string', format: 'date-time' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['issuesListForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/issues not handled'));
      }

      try {
        await handler(
          (req as unknown) as IssuesListForAuthenticatedUserRequest,
          res as IssuesListForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/keys',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersListPublicSshKeysForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/keys not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListPublicSshKeysForAuthenticatedUserRequest,
          res as UsersListPublicSshKeysForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/user/keys',

    validate({
      body: {
        properties: {
          title: {
            description: 'A descriptive name for the new key.',
            type: 'string',
            example: 'Personal MacBook Air'
          },
          key: {
            description: 'The public SSH key to add to your GitHub account.',
            type: 'string',
            pattern: '^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) '
          }
        },
        required: ['key'],
        type: 'object'
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersCreatePublicSshKeyForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/keys not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersCreatePublicSshKeyForAuthenticatedUserRequest,
          res as UsersCreatePublicSshKeyForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/keys/:key_id',

    validate({
      params: {
        type: 'object',
        properties: { key_id: { type: 'integer' } },
        required: ['key_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersGetPublicSshKeyForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/keys/:key_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersGetPublicSshKeyForAuthenticatedUserRequest,
          res as UsersGetPublicSshKeyForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/keys/:key_id',

    validate({
      params: {
        type: 'object',
        properties: { key_id: { type: 'integer' } },
        required: ['key_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersDeletePublicSshKeyForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/keys/:key_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersDeletePublicSshKeyForAuthenticatedUserRequest,
          res as UsersDeletePublicSshKeyForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/marketplace_purchases',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsListSubscriptionsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/marketplace_purchases not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsListSubscriptionsForAuthenticatedUserRequest,
          res as AppsListSubscriptionsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/marketplace_purchases/stubbed',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['appsListSubscriptionsForAuthenticatedUserStubbed'];

      if (!handler) {
        return next(
          new Error('/user/marketplace_purchases/stubbed not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as AppsListSubscriptionsForAuthenticatedUserStubbedRequest,
          res as AppsListSubscriptionsForAuthenticatedUserStubbedResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/memberships/orgs',

    validate({
      query: {
        type: 'object',
        properties: {
          state: { type: 'string', enum: ['active', 'pending'] },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListMembershipsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/memberships/orgs not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsListMembershipsForAuthenticatedUserRequest,
          res as OrgsListMembershipsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/memberships/orgs/:org',

    validate({
      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsGetMembershipForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/memberships/orgs/:org not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsGetMembershipForAuthenticatedUserRequest,
          res as OrgsGetMembershipForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/user/memberships/orgs/:org',

    validate({
      body: {
        type: 'object',
        properties: {
          state: {
            type: 'string',
            description:
              'The state that the membership should be in. Only `"active"` will be accepted.',
            enum: ['active']
          }
        },
        required: ['state']
      },

      params: {
        type: 'object',
        properties: { org: { type: 'string' } },
        required: ['org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsUpdateMembershipForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/memberships/orgs/:org not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsUpdateMembershipForAuthenticatedUserRequest,
          res as OrgsUpdateMembershipForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/migrations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsListForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/migrations not handled'));
      }

      try {
        await handler(
          (req as unknown) as MigrationsListForAuthenticatedUserRequest,
          res as MigrationsListForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/user/migrations',

    validate({
      body: {
        properties: {
          lock_repositories: {
            description:
              'Lock the repositories being migrated at the start of the migration',
            example: true,
            readOnly: false,
            type: 'boolean'
          },
          exclude_metadata: {
            description:
              'Indicates whether metadata should be excluded and only git source should be included for the migration.',
            example: true,
            readOnly: false,
            type: 'boolean'
          },
          exclude_git_data: {
            description:
              'Indicates whether the repository git data should be excluded from the migration.',
            example: true,
            readOnly: false,
            type: 'boolean'
          },
          exclude_attachments: {
            description: 'Do not include attachments in the migration',
            example: true,
            readOnly: false,
            type: 'boolean'
          },
          exclude_releases: {
            description: 'Do not include releases in the migration',
            example: true,
            readOnly: false,
            type: 'boolean'
          },
          exclude_owner_projects: {
            description:
              'Indicates whether projects owned by the organization or users should be excluded.',
            example: true,
            readOnly: false,
            type: 'boolean'
          },
          org_metadata_only: {
            type: 'boolean',
            example: true,
            description:
              'Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).',
            default: false
          },
          exclude: {
            description:
              'Exclude attributes from the API response to improve performance',
            example: ['repositories'],
            readOnly: false,
            type: 'array',
            items: {
              description:
                'Allowed values that can be passed to the exclude param.',
              enum: ['repositories'],
              example: 'repositories',
              type: 'string'
            }
          },
          repositories: {
            type: 'array',
            items: {
              description: 'Repository path, owner and name',
              example: 'acme/widgets',
              type: 'string'
            }
          }
        },
        required: ['repositories'],
        type: 'object'
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsStartForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/migrations not handled'));
      }

      try {
        await handler(
          (req as unknown) as MigrationsStartForAuthenticatedUserRequest,
          res as MigrationsStartForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/migrations/:migration_id',

    validate({
      query: {
        type: 'object',
        properties: {
          exclude: {
            anyOf: [
              { type: 'array', items: { type: 'string' } },
              { type: 'string' }
            ]
          }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { migration_id: { type: 'integer' } },
        required: ['migration_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsGetStatusForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/migrations/:migration_id not handled'));
      }

      try {
        await handler(
          (req as unknown) as MigrationsGetStatusForAuthenticatedUserRequest,
          res as MigrationsGetStatusForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/migrations/:migration_id/archive',

    validate({
      params: {
        type: 'object',
        properties: { migration_id: { type: 'integer' } },
        required: ['migration_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsGetArchiveForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/migrations/:migration_id/archive not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as MigrationsGetArchiveForAuthenticatedUserRequest,
          res as MigrationsGetArchiveForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/migrations/:migration_id/archive',

    validate({
      params: {
        type: 'object',
        properties: { migration_id: { type: 'integer' } },
        required: ['migration_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsDeleteArchiveForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/migrations/:migration_id/archive not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as MigrationsDeleteArchiveForAuthenticatedUserRequest,
          res as MigrationsDeleteArchiveForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/migrations/:migration_id/repos/:repo_name/lock',

    validate({
      params: {
        type: 'object',
        properties: {
          migration_id: { type: 'integer' },
          repo_name: { type: 'string' }
        },
        required: ['migration_id', 'repo_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsUnlockRepoForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/user/migrations/:migration_id/repos/:repo_name/lock not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as MigrationsUnlockRepoForAuthenticatedUserRequest,
          res as MigrationsUnlockRepoForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/migrations/:migration_id/repositories',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { migration_id: { type: 'integer' } },
        required: ['migration_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['migrationsListReposForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/migrations/:migration_id/repositories not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as MigrationsListReposForAuthenticatedUserRequest,
          res as MigrationsListReposForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/orgs',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/orgs not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsListForAuthenticatedUserRequest,
          res as OrgsListForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/packages',

    validate({
      query: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          visibility: {
            type: 'string',
            enum: ['public', 'private', 'internal']
          }
        },
        required: ['package_type']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesListPackagesForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/packages not handled'));
      }

      try {
        await handler(
          (req as unknown) as PackagesListPackagesForAuthenticatedUserRequest,
          res as PackagesListPackagesForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/packages/:package_type/:package_name',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' }
        },
        required: ['package_type', 'package_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesGetPackageForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/packages/:package_type/:package_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesGetPackageForAuthenticatedUserRequest,
          res as PackagesGetPackageForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/packages/:package_type/:package_name',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' }
        },
        required: ['package_type', 'package_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesDeletePackageForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/packages/:package_type/:package_name not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesDeletePackageForAuthenticatedUserRequest,
          res as PackagesDeletePackageForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/user/packages/:package_type/:package_name/restore',

    validate({
      query: {
        type: 'object',
        properties: { token: { type: 'string' } },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' }
        },
        required: ['package_type', 'package_name']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesRestorePackageForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/user/packages/:package_type/:package_name/restore not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesRestorePackageForAuthenticatedUserRequest,
          res as PackagesRestorePackageForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/packages/:package_type/:package_name/versions',

    validate({
      query: {
        type: 'object',
        properties: {
          page: { type: 'integer', default: 1 },
          per_page: { type: 'integer', default: 30 },
          state: {
            type: 'string',
            enum: ['active', 'deleted'],
            default: 'active'
          }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' }
        },
        required: ['package_type', 'package_name']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers[
          'packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser'
        ];

      if (!handler) {
        return next(
          new Error(
            '/user/packages/:package_type/:package_name/versions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest,
          res as PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/packages/:package_type/:package_name/versions/:package_version_id',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          package_version_id: { type: 'integer' }
        },
        required: ['package_type', 'package_name', 'package_version_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesGetPackageVersionForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/user/packages/:package_type/:package_name/versions/:package_version_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesGetPackageVersionForAuthenticatedUserRequest,
          res as PackagesGetPackageVersionForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/packages/:package_type/:package_name/versions/:package_version_id',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          package_version_id: { type: 'integer' }
        },
        required: ['package_type', 'package_name', 'package_version_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['packagesDeletePackageVersionForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/user/packages/:package_type/:package_name/versions/:package_version_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesDeletePackageVersionForAuthenticatedUserRequest,
          res as PackagesDeletePackageVersionForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/user/packages/:package_type/:package_name/versions/:package_version_id/restore',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          package_version_id: { type: 'integer' }
        },
        required: ['package_type', 'package_name', 'package_version_id']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['packagesRestorePackageVersionForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error(
            '/user/packages/:package_type/:package_name/versions/:package_version_id/restore not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesRestorePackageVersionForAuthenticatedUserRequest,
          res as PackagesRestorePackageVersionForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/user/projects',

    validate({
      body: {
        properties: {
          name: {
            description: 'Name of the project',
            example: 'Week One Sprint',
            type: 'string'
          },
          body: {
            description: 'Body of the project',
            example:
              'This project represents the sprint of the first week in January',
            type: 'string',
            nullable: true
          }
        },
        required: ['name'],
        type: 'object'
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsCreateForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/projects not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsCreateForAuthenticatedUserRequest,
          res as ProjectsCreateForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/public_emails',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersListPublicEmailsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/public_emails not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListPublicEmailsForAuthenticatedUserRequest,
          res as UsersListPublicEmailsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/repos',

    validate({
      query: {
        type: 'object',
        properties: {
          visibility: {
            type: 'string',
            enum: ['all', 'public', 'private'],
            default: 'all'
          },
          affiliation: {
            type: 'string',
            default: 'owner,collaborator,organization_member'
          },
          type: {
            type: 'string',
            enum: ['all', 'owner', 'public', 'private', 'member'],
            default: 'all'
          },
          sort: {
            type: 'string',
            enum: ['created', 'updated', 'pushed', 'full_name'],
            default: 'full_name'
          },
          direction: { type: 'string', enum: ['asc', 'desc'] },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 },
          since: { type: 'string', format: 'date-time' },
          before: { type: 'string', format: 'date-time' }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/repos not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListForAuthenticatedUserRequest,
          res as ReposListForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/user/repos',

    validate({
      body: {
        properties: {
          name: {
            description: 'The name of the repository.',
            type: 'string',
            example: 'Team Environment'
          },
          description: {
            description: 'A short description of the repository.',
            type: 'string'
          },
          homepage: {
            description: 'A URL with more information about the repository.',
            type: 'string'
          },
          private: {
            description: 'Whether the repository is private.',
            default: false,
            type: 'boolean'
          },
          has_issues: {
            description: 'Whether issues are enabled.',
            default: true,
            type: 'boolean',
            example: true
          },
          has_projects: {
            description: 'Whether projects are enabled.',
            default: true,
            type: 'boolean',
            example: true
          },
          has_wiki: {
            description: 'Whether the wiki is enabled.',
            default: true,
            type: 'boolean',
            example: true
          },
          team_id: {
            description:
              'The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.',
            type: 'integer'
          },
          auto_init: {
            description:
              'Whether the repository is initialized with a minimal README.',
            default: false,
            type: 'boolean'
          },
          gitignore_template: {
            description:
              'The desired language or platform to apply to the .gitignore.',
            example: 'Haskell',
            type: 'string'
          },
          license_template: {
            description:
              'The license keyword of the open source license for this repository.',
            example: 'mit',
            type: 'string'
          },
          allow_squash_merge: {
            description: 'Whether to allow squash merges for pull requests.',
            default: true,
            type: 'boolean',
            example: true
          },
          allow_merge_commit: {
            description: 'Whether to allow merge commits for pull requests.',
            default: true,
            type: 'boolean',
            example: true
          },
          allow_rebase_merge: {
            description: 'Whether to allow rebase merges for pull requests.',
            default: true,
            type: 'boolean',
            example: true
          },
          allow_auto_merge: {
            description:
              'Whether to allow Auto-merge to be used on pull requests.',
            default: false,
            type: 'boolean',
            example: false
          },
          delete_branch_on_merge: {
            description:
              'Whether to delete head branches when pull requests are merged',
            default: false,
            type: 'boolean',
            example: false
          },
          squash_merge_commit_title: {
            type: 'string',
            enum: ['PR_TITLE', 'COMMIT_OR_PR_TITLE'],
            description:
              "The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
          },
          squash_merge_commit_message: {
            type: 'string',
            enum: ['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'],
            description:
              "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
          },
          merge_commit_title: {
            type: 'string',
            enum: ['PR_TITLE', 'MERGE_MESSAGE'],
            description:
              "The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
          },
          merge_commit_message: {
            type: 'string',
            enum: ['PR_BODY', 'PR_TITLE', 'BLANK'],
            description:
              "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
          },
          has_downloads: {
            description: 'Whether downloads are enabled.',
            default: true,
            type: 'boolean',
            example: true
          },
          is_template: {
            description:
              'Whether this repository acts as a template that can be used to generate new repositories.',
            default: false,
            type: 'boolean',
            example: true
          }
        },
        required: ['name'],
        type: 'object'
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposCreateForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/repos not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposCreateForAuthenticatedUserRequest,
          res as ReposCreateForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/repository_invitations',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListInvitationsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/repository_invitations not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListInvitationsForAuthenticatedUserRequest,
          res as ReposListInvitationsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.patch(
    '/user/repository_invitations/:invitation_id',

    validate({
      params: {
        type: 'object',
        properties: { invitation_id: { type: 'integer' } },
        required: ['invitation_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposAcceptInvitationForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/repository_invitations/:invitation_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposAcceptInvitationForAuthenticatedUserRequest,
          res as ReposAcceptInvitationForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/repository_invitations/:invitation_id',

    validate({
      params: {
        type: 'object',
        properties: { invitation_id: { type: 'integer' } },
        required: ['invitation_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposDeclineInvitationForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/repository_invitations/:invitation_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ReposDeclineInvitationForAuthenticatedUserRequest,
          res as ReposDeclineInvitationForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/ssh_signing_keys',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersListSshSigningKeysForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/ssh_signing_keys not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListSshSigningKeysForAuthenticatedUserRequest,
          res as UsersListSshSigningKeysForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/user/ssh_signing_keys',

    validate({
      body: {
        properties: {
          title: {
            description: 'A descriptive name for the new key.',
            type: 'string',
            example: 'Personal MacBook Air'
          },
          key: {
            description:
              'The public SSH key to add to your GitHub account. For more information, see "[Checking for existing SSH keys](https://docs.github.com/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys)."',
            type: 'string',
            pattern:
              '^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) |^(sk-ssh-ed25519|sk-ecdsa-sha2-nistp256)@openssh.com '
          }
        },
        required: ['key'],
        type: 'object'
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersCreateSshSigningKeyForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/ssh_signing_keys not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersCreateSshSigningKeyForAuthenticatedUserRequest,
          res as UsersCreateSshSigningKeyForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/ssh_signing_keys/:ssh_signing_key_id',

    validate({
      params: {
        type: 'object',
        properties: { ssh_signing_key_id: { type: 'integer' } },
        required: ['ssh_signing_key_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersGetSshSigningKeyForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/ssh_signing_keys/:ssh_signing_key_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as UsersGetSshSigningKeyForAuthenticatedUserRequest,
          res as UsersGetSshSigningKeyForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/ssh_signing_keys/:ssh_signing_key_id',

    validate({
      params: {
        type: 'object',
        properties: { ssh_signing_key_id: { type: 'integer' } },
        required: ['ssh_signing_key_id']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersDeleteSshSigningKeyForAuthenticatedUser'];

      if (!handler) {
        return next(
          new Error('/user/ssh_signing_keys/:ssh_signing_key_id not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as UsersDeleteSshSigningKeyForAuthenticatedUserRequest,
          res as UsersDeleteSshSigningKeyForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/starred',

    validate({
      query: {
        type: 'object',
        properties: {
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListReposStarredByAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/starred not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListReposStarredByAuthenticatedUserRequest,
          res as ActivityListReposStarredByAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/starred/:owner/:repo',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityCheckRepoIsStarredByAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/starred/:owner/:repo not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityCheckRepoIsStarredByAuthenticatedUserRequest,
          res as ActivityCheckRepoIsStarredByAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.put(
    '/user/starred/:owner/:repo',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityStarRepoForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/starred/:owner/:repo not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityStarRepoForAuthenticatedUserRequest,
          res as ActivityStarRepoForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/user/starred/:owner/:repo',

    validate({
      params: {
        type: 'object',
        properties: { owner: { type: 'string' }, repo: { type: 'string' } },
        required: ['owner', 'repo']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityUnstarRepoForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/starred/:owner/:repo not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityUnstarRepoForAuthenticatedUserRequest,
          res as ActivityUnstarRepoForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/subscriptions',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListWatchedReposForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/subscriptions not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListWatchedReposForAuthenticatedUserRequest,
          res as ActivityListWatchedReposForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/user/teams',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['teamsListForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/user/teams not handled'));
      }

      try {
        await handler(
          (req as unknown) as TeamsListForAuthenticatedUserRequest,
          res as TeamsListForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users',

    validate({
      query: {
        type: 'object',
        properties: {
          since: { type: 'integer' },
          per_page: { type: 'integer', default: 30 }
        },
        required: []
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersList'];

      if (!handler) {
        return next(new Error('/users not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListRequest,
          res as UsersListResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username',

    validate({
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersGetByUsername'];

      if (!handler) {
        return next(new Error('/users/:username not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersGetByUsernameRequest,
          res as UsersGetByUsernameResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/events',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListEventsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/users/:username/events not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListEventsForAuthenticatedUserRequest,
          res as ActivityListEventsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/events/orgs/:org',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' }, org: { type: 'string' } },
        required: ['username', 'org']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListOrgEventsForAuthenticatedUser'];

      if (!handler) {
        return next(new Error('/users/:username/events/orgs/:org not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListOrgEventsForAuthenticatedUserRequest,
          res as ActivityListOrgEventsForAuthenticatedUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/events/public',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListPublicEventsForUser'];

      if (!handler) {
        return next(new Error('/users/:username/events/public not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListPublicEventsForUserRequest,
          res as ActivityListPublicEventsForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/followers',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersListFollowersForUser'];

      if (!handler) {
        return next(new Error('/users/:username/followers not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListFollowersForUserRequest,
          res as UsersListFollowersForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/following',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersListFollowingForUser'];

      if (!handler) {
        return next(new Error('/users/:username/following not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListFollowingForUserRequest,
          res as UsersListFollowingForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/following/:target_user',

    validate({
      params: {
        type: 'object',
        properties: {
          username: { type: 'string' },
          target_user: { type: 'string' }
        },
        required: ['username', 'target_user']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersCheckFollowingForUser'];

      if (!handler) {
        return next(
          new Error('/users/:username/following/:target_user not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as UsersCheckFollowingForUserRequest,
          res as UsersCheckFollowingForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/gists',

    validate({
      query: {
        type: 'object',
        properties: {
          since: { type: 'string', format: 'date-time' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['gistsListForUser'];

      if (!handler) {
        return next(new Error('/users/:username/gists not handled'));
      }

      try {
        await handler(
          (req as unknown) as GistsListForUserRequest,
          res as GistsListForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/gpg_keys',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersListGpgKeysForUser'];

      if (!handler) {
        return next(new Error('/users/:username/gpg_keys not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListGpgKeysForUserRequest,
          res as UsersListGpgKeysForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/hovercard',

    validate({
      query: {
        type: 'object',
        properties: {
          subject_type: {
            type: 'string',
            enum: ['organization', 'repository', 'issue', 'pull_request']
          },
          subject_id: { type: 'string' }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersGetContextForUser'];

      if (!handler) {
        return next(new Error('/users/:username/hovercard not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersGetContextForUserRequest,
          res as UsersGetContextForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/installation',

    validate({
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['appsGetUserInstallation'];

      if (!handler) {
        return next(new Error('/users/:username/installation not handled'));
      }

      try {
        await handler(
          (req as unknown) as AppsGetUserInstallationRequest,
          res as AppsGetUserInstallationResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/keys',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersListPublicKeysForUser'];

      if (!handler) {
        return next(new Error('/users/:username/keys not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListPublicKeysForUserRequest,
          res as UsersListPublicKeysForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/orgs',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['orgsListForUser'];

      if (!handler) {
        return next(new Error('/users/:username/orgs not handled'));
      }

      try {
        await handler(
          (req as unknown) as OrgsListForUserRequest,
          res as OrgsListForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/packages',

    validate({
      query: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          visibility: {
            type: 'string',
            enum: ['public', 'private', 'internal']
          }
        },
        required: ['package_type']
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesListPackagesForUser'];

      if (!handler) {
        return next(new Error('/users/:username/packages not handled'));
      }

      try {
        await handler(
          (req as unknown) as PackagesListPackagesForUserRequest,
          res as PackagesListPackagesForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/packages/:package_type/:package_name',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          username: { type: 'string' }
        },
        required: ['package_type', 'package_name', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesGetPackageForUser'];

      if (!handler) {
        return next(
          new Error(
            '/users/:username/packages/:package_type/:package_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesGetPackageForUserRequest,
          res as PackagesGetPackageForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/users/:username/packages/:package_type/:package_name',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          username: { type: 'string' }
        },
        required: ['package_type', 'package_name', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesDeletePackageForUser'];

      if (!handler) {
        return next(
          new Error(
            '/users/:username/packages/:package_type/:package_name not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesDeletePackageForUserRequest,
          res as PackagesDeletePackageForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/users/:username/packages/:package_type/:package_name/restore',

    validate({
      query: {
        type: 'object',
        properties: { token: { type: 'string' } },
        required: []
      },
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          username: { type: 'string' }
        },
        required: ['package_type', 'package_name', 'username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesRestorePackageForUser'];

      if (!handler) {
        return next(
          new Error(
            '/users/:username/packages/:package_type/:package_name/restore not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesRestorePackageForUserRequest,
          res as PackagesRestorePackageForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/packages/:package_type/:package_name/versions',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          username: { type: 'string' }
        },
        required: ['package_type', 'package_name', 'username']
      }
    }),

    async (req, res, next) => {
      const handler =
        handlers['packagesGetAllPackageVersionsForPackageOwnedByUser'];

      if (!handler) {
        return next(
          new Error(
            '/users/:username/packages/:package_type/:package_name/versions not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesGetAllPackageVersionsForPackageOwnedByUserRequest,
          res as PackagesGetAllPackageVersionsForPackageOwnedByUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/packages/:package_type/:package_name/versions/:package_version_id',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          package_version_id: { type: 'integer' },
          username: { type: 'string' }
        },
        required: [
          'package_type',
          'package_name',
          'package_version_id',
          'username'
        ]
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesGetPackageVersionForUser'];

      if (!handler) {
        return next(
          new Error(
            '/users/:username/packages/:package_type/:package_name/versions/:package_version_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesGetPackageVersionForUserRequest,
          res as PackagesGetPackageVersionForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.delete(
    '/users/:username/packages/:package_type/:package_name/versions/:package_version_id',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          username: { type: 'string' },
          package_version_id: { type: 'integer' }
        },
        required: [
          'package_type',
          'package_name',
          'username',
          'package_version_id'
        ]
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesDeletePackageVersionForUser'];

      if (!handler) {
        return next(
          new Error(
            '/users/:username/packages/:package_type/:package_name/versions/:package_version_id not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesDeletePackageVersionForUserRequest,
          res as PackagesDeletePackageVersionForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.post(
    '/users/:username/packages/:package_type/:package_name/versions/:package_version_id/restore',

    validate({
      params: {
        type: 'object',
        properties: {
          package_type: {
            type: 'string',
            enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
          },
          package_name: { type: 'string' },
          username: { type: 'string' },
          package_version_id: { type: 'integer' }
        },
        required: [
          'package_type',
          'package_name',
          'username',
          'package_version_id'
        ]
      }
    }),

    async (req, res, next) => {
      const handler = handlers['packagesRestorePackageVersionForUser'];

      if (!handler) {
        return next(
          new Error(
            '/users/:username/packages/:package_type/:package_name/versions/:package_version_id/restore not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as PackagesRestorePackageVersionForUserRequest,
          res as PackagesRestorePackageVersionForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/projects',

    validate({
      query: {
        type: 'object',
        properties: {
          state: {
            type: 'string',
            enum: ['open', 'closed', 'all'],
            default: 'open'
          },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['projectsListForUser'];

      if (!handler) {
        return next(new Error('/users/:username/projects not handled'));
      }

      try {
        await handler(
          (req as unknown) as ProjectsListForUserRequest,
          res as ProjectsListForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/received_events',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListReceivedEventsForUser'];

      if (!handler) {
        return next(new Error('/users/:username/received_events not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListReceivedEventsForUserRequest,
          res as ActivityListReceivedEventsForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/received_events/public',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListReceivedPublicEventsForUser'];

      if (!handler) {
        return next(
          new Error('/users/:username/received_events/public not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as ActivityListReceivedPublicEventsForUserRequest,
          res as ActivityListReceivedPublicEventsForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/repos',

    validate({
      query: {
        type: 'object',
        properties: {
          type: {
            type: 'string',
            enum: ['all', 'owner', 'member'],
            default: 'owner'
          },
          sort: {
            type: 'string',
            enum: ['created', 'updated', 'pushed', 'full_name'],
            default: 'full_name'
          },
          direction: { type: 'string', enum: ['asc', 'desc'] },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['reposListForUser'];

      if (!handler) {
        return next(new Error('/users/:username/repos not handled'));
      }

      try {
        await handler(
          (req as unknown) as ReposListForUserRequest,
          res as ReposListForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/settings/billing/actions',

    validate({
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['billingGetGithubActionsBillingUser'];

      if (!handler) {
        return next(
          new Error('/users/:username/settings/billing/actions not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as BillingGetGithubActionsBillingUserRequest,
          res as BillingGetGithubActionsBillingUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/settings/billing/packages',

    validate({
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['billingGetGithubPackagesBillingUser'];

      if (!handler) {
        return next(
          new Error('/users/:username/settings/billing/packages not handled')
        );
      }

      try {
        await handler(
          (req as unknown) as BillingGetGithubPackagesBillingUserRequest,
          res as BillingGetGithubPackagesBillingUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/settings/billing/shared-storage',

    validate({
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['billingGetSharedStorageBillingUser'];

      if (!handler) {
        return next(
          new Error(
            '/users/:username/settings/billing/shared-storage not handled'
          )
        );
      }

      try {
        await handler(
          (req as unknown) as BillingGetSharedStorageBillingUserRequest,
          res as BillingGetSharedStorageBillingUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/ssh_signing_keys',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['usersListSshSigningKeysForUser'];

      if (!handler) {
        return next(new Error('/users/:username/ssh_signing_keys not handled'));
      }

      try {
        await handler(
          (req as unknown) as UsersListSshSigningKeysForUserRequest,
          res as UsersListSshSigningKeysForUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/starred',

    validate({
      query: {
        type: 'object',
        properties: {
          sort: {
            type: 'string',
            enum: ['created', 'updated'],
            default: 'created'
          },
          direction: { type: 'string', enum: ['asc', 'desc'], default: 'desc' },
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListReposStarredByUser'];

      if (!handler) {
        return next(new Error('/users/:username/starred not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListReposStarredByUserRequest,
          res as ActivityListReposStarredByUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/users/:username/subscriptions',

    validate({
      query: {
        type: 'object',
        properties: {
          per_page: { type: 'integer', default: 30 },
          page: { type: 'integer', default: 1 }
        },
        required: []
      },
      params: {
        type: 'object',
        properties: { username: { type: 'string' } },
        required: ['username']
      }
    }),

    async (req, res, next) => {
      const handler = handlers['activityListReposWatchedByUser'];

      if (!handler) {
        return next(new Error('/users/:username/subscriptions not handled'));
      }

      try {
        await handler(
          (req as unknown) as ActivityListReposWatchedByUserRequest,
          res as ActivityListReposWatchedByUserResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  router.get(
    '/zen',

    async (req, res, next) => {
      const handler = handlers['metaGetZen'];

      if (!handler) {
        return next(new Error('/zen not handled'));
      }

      try {
        await handler(
          (req as unknown) as MetaGetZenRequest,
          res as MetaGetZenResponse,
          next
        );
      } catch (e: unknown) {
        next(e);
      }
    }
  );

  app.use(router);

  const validationErrorHandler: ErrorRequestHandler = (
    error,
    _,
    response,
    next
  ) => {
    if (error instanceof ExpressJonValidator.ValidationError) {
      response.status(400).send({
        type: 'REQUEST_VALIDATION_FAILED',
        fields: error.validationErrors
      });
      next();
    } else {
      next(error);
    }
  };

  app.use(validationErrorHandler);
};
