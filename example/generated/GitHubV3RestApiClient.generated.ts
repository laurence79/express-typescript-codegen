import qs from 'qs';

export type Root = {
  readonly current_user_url: string;
  readonly current_user_authorizations_html_url: string;
  readonly authorizations_url: string;
  readonly code_search_url: string;
  readonly commit_search_url: string;
  readonly emails_url: string;
  readonly emojis_url: string;
  readonly events_url: string;
  readonly feeds_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly hub_url: string;
  readonly issue_search_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly label_search_url: string;
  readonly notifications_url: string;
  readonly organization_url: string;
  readonly organization_repositories_url: string;
  readonly organization_teams_url: string;
  readonly public_gists_url: string;
  readonly rate_limit_url: string;
  readonly repository_url: string;
  readonly repository_search_url: string;
  readonly current_user_repositories_url: string;
  readonly starred_url: string;
  readonly starred_gists_url: string;
  readonly topic_search_url?: string;
  readonly user_url: string;
  readonly user_organizations_url: string;
  readonly user_repositories_url: string;
  readonly user_search_url: string;
};

export type SimpleUser = {
  readonly name?: string | null;
  readonly email?: string | null;
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly site_admin: boolean;
  readonly starred_at?: string;
} | null;

export type GitHubApp = {
  readonly id: number;
  readonly slug?: string;
  readonly node_id: string;
  readonly owner: SimpleUser;
  readonly name: string;
  readonly description: string | null;
  readonly external_url: string;
  readonly html_url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly permissions: {
    readonly issues?: string;
    readonly checks?: string;
    readonly metadata?: string;
    readonly contents?: string;
    readonly deployments?: string;
  };
  readonly events: ReadonlyArray<string>;
  readonly installations_count?: number;
  readonly client_id?: string;
  readonly client_secret?: string;
  readonly webhook_secret?: string | null;
  readonly pem?: string;
};

export type BasicError = {
  readonly message?: string;
  readonly documentation_url?: string;
  readonly url?: string;
  readonly status?: string;
};

export type ValidationErrorSimple = {
  readonly message: string;
  readonly documentation_url: string;
  readonly errors?: ReadonlyArray<string>;
};

export type WebhookConfigUrl = string;

export type WebhookConfigContentType = string;

export type WebhookConfigSecret = string;

export type WebhookConfigInsecureSsl = string | number;

export type WebhookConfiguration = {
  readonly url?: WebhookConfigUrl;
  readonly content_type?: WebhookConfigContentType;
  readonly secret?: WebhookConfigSecret;
  readonly insecure_ssl?: WebhookConfigInsecureSsl;
};

export type SimpleWebhookDelivery = {
  readonly id: number;
  readonly guid: string;
  readonly delivered_at: string;
  readonly redelivery: boolean;
  readonly duration: number;
  readonly status: string;
  readonly status_code: number;
  readonly event: string;
  readonly action: string | null;
  readonly installation_id: number | null;
  readonly repository_id: number | null;
};

export type ValidationError = {
  readonly message: string;
  readonly documentation_url: string;
  readonly errors?: ReadonlyArray<{
    readonly resource?: string;
    readonly field?: string;
    readonly message?: string;
    readonly code: string;
    readonly index?: number;
    readonly value?:
      | string
      | null
      | number
      | null
      | ReadonlyArray<string>
      | null;
  }>;
};

export type WebhookDelivery = {
  readonly id: number;
  readonly guid: string;
  readonly delivered_at: string;
  readonly redelivery: boolean;
  readonly duration: number;
  readonly status: string;
  readonly status_code: number;
  readonly event: string;
  readonly action: string | null;
  readonly installation_id: number | null;
  readonly repository_id: number | null;
  readonly url?: string;
  readonly request: {
    readonly headers: unknown | null;
    readonly payload: unknown | null;
  };
  readonly response: {
    readonly headers: unknown | null;
    readonly payload: string | null;
  };
};

export type Enterprise = {
  readonly description?: string | null;
  readonly html_url: string;
  readonly website_url?: string | null;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly slug: string;
  readonly created_at: string | null;
  readonly updated_at: string | null;
  readonly avatar_url: string;
};

export type AppPermissions = {
  readonly actions?: 'read' | 'write';
  readonly administration?: 'read' | 'write';
  readonly checks?: 'read' | 'write';
  readonly contents?: 'read' | 'write';
  readonly deployments?: 'read' | 'write';
  readonly environments?: 'read' | 'write';
  readonly issues?: 'read' | 'write';
  readonly metadata?: 'read' | 'write';
  readonly packages?: 'read' | 'write';
  readonly pages?: 'read' | 'write';
  readonly pull_requests?: 'read' | 'write';
  readonly repository_announcement_banners?: 'read' | 'write';
  readonly repository_hooks?: 'read' | 'write';
  readonly repository_projects?: 'read' | 'write' | 'admin';
  readonly secret_scanning_alerts?: 'read' | 'write';
  readonly secrets?: 'read' | 'write';
  readonly security_events?: 'read' | 'write';
  readonly single_file?: 'read' | 'write';
  readonly statuses?: 'read' | 'write';
  readonly vulnerability_alerts?: 'read' | 'write';
  readonly workflows?: 'write';
  readonly members?: 'read' | 'write';
  readonly organization_administration?: 'read' | 'write';
  readonly organization_custom_roles?: 'read' | 'write';
  readonly organization_announcement_banners?: 'read' | 'write';
  readonly organization_hooks?: 'read' | 'write';
  readonly organization_plan?: 'read';
  readonly organization_projects?: 'read' | 'write' | 'admin';
  readonly organization_packages?: 'read' | 'write';
  readonly organization_secrets?: 'read' | 'write';
  readonly organization_self_hosted_runners?: 'read' | 'write';
  readonly organization_user_blocking?: 'read' | 'write';
  readonly team_discussions?: 'read' | 'write';
};

export type Installation = {
  readonly id: number;
  readonly account: SimpleUser | Enterprise | null;
  readonly repository_selection: 'all' | 'selected';
  readonly access_tokens_url: string;
  readonly repositories_url: string;
  readonly html_url: string;
  readonly app_id: number;
  readonly target_id: number;
  readonly target_type: string;
  readonly permissions: AppPermissions;
  readonly events: ReadonlyArray<string>;
  readonly created_at: string;
  readonly updated_at: string;
  readonly single_file_name: string | null;
  readonly has_multiple_single_files?: boolean;
  readonly single_file_paths?: ReadonlyArray<string>;
  readonly app_slug: string;
  readonly suspended_by: SimpleUser;
  readonly suspended_at: string | null;
  readonly contact_email?: string | null;
};

export type LicenseSimple = {
  readonly key: string;
  readonly name: string;
  readonly url: string | null;
  readonly spdx_id: string | null;
  readonly node_id: string;
  readonly html_url?: string;
} | null;

export type Repository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly license: LicenseSimple;
  readonly organization?: SimpleUser;
  readonly forks: number;
  readonly permissions?: {
    readonly admin: boolean;
    readonly pull: boolean;
    readonly triage?: boolean;
    readonly push: boolean;
    readonly maintain?: boolean;
  };
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly git_url: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly ssh_url: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly clone_url: string;
  readonly mirror_url: string | null;
  readonly hooks_url: string;
  readonly svn_url: string;
  readonly homepage: string | null;
  readonly language: string | null;
  readonly forks_count: number;
  readonly stargazers_count: number;
  readonly watchers_count: number;
  readonly size: number;
  readonly default_branch: string;
  readonly open_issues_count: number;
  readonly is_template?: boolean;
  readonly topics?: ReadonlyArray<string>;
  readonly has_issues: boolean;
  readonly has_projects: boolean;
  readonly has_wiki: boolean;
  readonly has_pages: boolean;
  readonly has_downloads: boolean;
  readonly archived: boolean;
  readonly disabled: boolean;
  readonly visibility?: string;
  readonly pushed_at: string | null;
  readonly created_at: string | null;
  readonly updated_at: string | null;
  readonly allow_rebase_merge?: boolean;
  readonly template_repository?: {
    readonly id?: number;
    readonly node_id?: string;
    readonly name?: string;
    readonly full_name?: string;
    readonly owner?: {
      readonly login?: string;
      readonly id?: number;
      readonly node_id?: string;
      readonly avatar_url?: string;
      readonly gravatar_id?: string;
      readonly url?: string;
      readonly html_url?: string;
      readonly followers_url?: string;
      readonly following_url?: string;
      readonly gists_url?: string;
      readonly starred_url?: string;
      readonly subscriptions_url?: string;
      readonly organizations_url?: string;
      readonly repos_url?: string;
      readonly events_url?: string;
      readonly received_events_url?: string;
      readonly type?: string;
      readonly site_admin?: boolean;
    };
    readonly private?: boolean;
    readonly html_url?: string;
    readonly description?: string;
    readonly fork?: boolean;
    readonly url?: string;
    readonly archive_url?: string;
    readonly assignees_url?: string;
    readonly blobs_url?: string;
    readonly branches_url?: string;
    readonly collaborators_url?: string;
    readonly comments_url?: string;
    readonly commits_url?: string;
    readonly compare_url?: string;
    readonly contents_url?: string;
    readonly contributors_url?: string;
    readonly deployments_url?: string;
    readonly downloads_url?: string;
    readonly events_url?: string;
    readonly forks_url?: string;
    readonly git_commits_url?: string;
    readonly git_refs_url?: string;
    readonly git_tags_url?: string;
    readonly git_url?: string;
    readonly issue_comment_url?: string;
    readonly issue_events_url?: string;
    readonly issues_url?: string;
    readonly keys_url?: string;
    readonly labels_url?: string;
    readonly languages_url?: string;
    readonly merges_url?: string;
    readonly milestones_url?: string;
    readonly notifications_url?: string;
    readonly pulls_url?: string;
    readonly releases_url?: string;
    readonly ssh_url?: string;
    readonly stargazers_url?: string;
    readonly statuses_url?: string;
    readonly subscribers_url?: string;
    readonly subscription_url?: string;
    readonly tags_url?: string;
    readonly teams_url?: string;
    readonly trees_url?: string;
    readonly clone_url?: string;
    readonly mirror_url?: string;
    readonly hooks_url?: string;
    readonly svn_url?: string;
    readonly homepage?: string;
    readonly language?: string;
    readonly forks_count?: number;
    readonly stargazers_count?: number;
    readonly watchers_count?: number;
    readonly size?: number;
    readonly default_branch?: string;
    readonly open_issues_count?: number;
    readonly is_template?: boolean;
    readonly topics?: ReadonlyArray<string>;
    readonly has_issues?: boolean;
    readonly has_projects?: boolean;
    readonly has_wiki?: boolean;
    readonly has_pages?: boolean;
    readonly has_downloads?: boolean;
    readonly archived?: boolean;
    readonly disabled?: boolean;
    readonly visibility?: string;
    readonly pushed_at?: string;
    readonly created_at?: string;
    readonly updated_at?: string;
    readonly permissions?: {
      readonly admin?: boolean;
      readonly maintain?: boolean;
      readonly push?: boolean;
      readonly triage?: boolean;
      readonly pull?: boolean;
    };
    readonly allow_rebase_merge?: boolean;
    readonly temp_clone_token?: string;
    readonly allow_squash_merge?: boolean;
    readonly allow_auto_merge?: boolean;
    readonly delete_branch_on_merge?: boolean;
    readonly allow_update_branch?: boolean;
    readonly use_squash_pr_title_as_default?: boolean;
    readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
    readonly squash_merge_commit_message?:
      | 'PR_BODY'
      | 'COMMIT_MESSAGES'
      | 'BLANK';
    readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
    readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
    readonly allow_merge_commit?: boolean;
    readonly subscribers_count?: number;
    readonly network_count?: number;
  } | null;
  readonly temp_clone_token?: string;
  readonly allow_squash_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_update_branch?: boolean;
  readonly use_squash_pr_title_as_default?: boolean;
  readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
  readonly squash_merge_commit_message?:
    | 'PR_BODY'
    | 'COMMIT_MESSAGES'
    | 'BLANK';
  readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
  readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
  readonly allow_merge_commit?: boolean;
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
  readonly subscribers_count?: number;
  readonly network_count?: number;
  readonly open_issues: number;
  readonly watchers: number;
  readonly master_branch?: string;
  readonly starred_at?: string;
  readonly anonymous_access_enabled?: boolean;
};

export type InstallationToken = {
  readonly token: string;
  readonly expires_at: string;
  readonly permissions?: AppPermissions;
  readonly repository_selection?: 'all' | 'selected';
  readonly repositories?: ReadonlyArray<Repository>;
  readonly single_file?: string;
  readonly has_multiple_single_files?: boolean;
  readonly single_file_paths?: ReadonlyArray<string>;
};

export type ScopedInstallation = {
  readonly permissions: AppPermissions;
  readonly repository_selection: 'all' | 'selected';
  readonly single_file_name: string | null;
  readonly has_multiple_single_files?: boolean;
  readonly single_file_paths?: ReadonlyArray<string>;
  readonly repositories_url: string;
  readonly account: SimpleUser;
} | null;

export type Authorization = {
  readonly id: number;
  readonly url: string;
  readonly scopes: ReadonlyArray<string> | null;
  readonly token: string;
  readonly token_last_eight: string | null;
  readonly hashed_token: string | null;
  readonly app: {
    readonly client_id: string;
    readonly name: string;
    readonly url: string;
  };
  readonly note: string | null;
  readonly note_url: string | null;
  readonly updated_at: string;
  readonly created_at: string;
  readonly fingerprint: string | null;
  readonly user?: SimpleUser;
  readonly installation?: ScopedInstallation;
  readonly expires_at: string | null;
};

export type CodeOfConduct = {
  readonly key: string;
  readonly name: string;
  readonly url: string;
  readonly body?: string;
  readonly html_url: string | null;
};

export type ServerStatisticsProxyEndpoint = ReadonlyArray<{
  readonly server_id?: string;
  readonly collection_date?: string;
  readonly schema_version?: string;
  readonly ghes_version?: string;
  readonly host_name?: string;
  readonly github_connect?: {
    readonly features_enabled?: ReadonlyArray<string>;
  };
  readonly ghe_stats?: {
    readonly comments?: {
      readonly total_commit_comments?: number;
      readonly total_gist_comments?: number;
      readonly total_issue_comments?: number;
      readonly total_pull_request_comments?: number;
    };
    readonly gists?: {
      readonly total_gists?: number;
      readonly private_gists?: number;
      readonly public_gists?: number;
    };
    readonly hooks?: {
      readonly total_hooks?: number;
      readonly active_hooks?: number;
      readonly inactive_hooks?: number;
    };
    readonly issues?: {
      readonly total_issues?: number;
      readonly open_issues?: number;
      readonly closed_issues?: number;
    };
    readonly milestones?: {
      readonly total_milestones?: number;
      readonly open_milestones?: number;
      readonly closed_milestones?: number;
    };
    readonly orgs?: {
      readonly total_orgs?: number;
      readonly disabled_orgs?: number;
      readonly total_teams?: number;
      readonly total_team_members?: number;
    };
    readonly pages?: { readonly total_pages?: number };
    readonly pulls?: {
      readonly total_pulls?: number;
      readonly merged_pulls?: number;
      readonly mergeable_pulls?: number;
      readonly unmergeable_pulls?: number;
    };
    readonly repos?: {
      readonly total_repos?: number;
      readonly root_repos?: number;
      readonly fork_repos?: number;
      readonly org_repos?: number;
      readonly total_pushes?: number;
      readonly total_wikis?: number;
    };
    readonly users?: {
      readonly total_users?: number;
      readonly admin_users?: number;
      readonly suspended_users?: number;
    };
  };
  readonly dormant_users?: {
    readonly total_dormant_users?: number;
    readonly dormancy_threshold?: string;
  };
}>;

export type ActionsCacheUsageOrgEnterprise = {
  readonly total_active_caches_count: number;
  readonly total_active_caches_size_in_bytes: number;
};

export type EnabledOrganizations = 'all' | 'none' | 'selected';

export type AllowedActions = 'all' | 'local_only' | 'selected';

export type SelectedActionsUrl = string;

export type ActionsEnterprisePermissions = {
  readonly enabled_organizations: EnabledOrganizations;
  readonly selected_organizations_url?: string;
  readonly allowed_actions?: AllowedActions;
  readonly selected_actions_url?: SelectedActionsUrl;
};

export type OrganizationSimple = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly hooks_url: string;
  readonly issues_url: string;
  readonly members_url: string;
  readonly public_members_url: string;
  readonly avatar_url: string;
  readonly description: string | null;
};

export type SelectedActions = {
  readonly github_owned_allowed?: boolean;
  readonly verified_allowed?: boolean;
  readonly patterns_allowed?: ReadonlyArray<string>;
};

export type ActionsDefaultWorkflowPermissions = 'read' | 'write';

export type ActionsCanApprovePullRequestReviews = boolean;

export type ActionsGetDefaultWorkflowPermissions = {
  readonly default_workflow_permissions: ActionsDefaultWorkflowPermissions;
  readonly can_approve_pull_request_reviews: ActionsCanApprovePullRequestReviews;
};

export type ActionsSetDefaultWorkflowPermissions = {
  readonly default_workflow_permissions?: ActionsDefaultWorkflowPermissions;
  readonly can_approve_pull_request_reviews?: ActionsCanApprovePullRequestReviews;
};

export type RunnerGroupsEnterprise = {
  readonly id: number;
  readonly name: string;
  readonly visibility: string;
  readonly default: boolean;
  readonly selected_organizations_url?: string;
  readonly runners_url: string;
  readonly allows_public_repositories: boolean;
  readonly workflow_restrictions_read_only?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type SelfHostedRunnerLabel = {
  readonly id?: number;
  readonly name: string;
  readonly type?: 'read-only' | 'custom';
};

export type SelfHostedRunners = {
  readonly id: number;
  readonly name: string;
  readonly os: string;
  readonly status: string;
  readonly busy: boolean;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type RunnerApplication = {
  readonly os: string;
  readonly architecture: string;
  readonly download_url: string;
  readonly filename: string;
  readonly temp_download_token?: string;
  readonly sha256_checksum?: string;
};

export type AuthenticationToken = {
  readonly token: string;
  readonly expires_at: string;
  readonly permissions?: unknown;
  readonly repositories?: ReadonlyArray<Repository>;
  readonly single_file?: string | null;
  readonly repository_selection?: 'all' | 'selected';
};

export type CodeScanningAnalysisToolName = string;

export type CodeScanningAnalysisToolGuid = string | null;

export type CodeScanningAlertState = 'open' | 'closed' | 'dismissed' | 'fixed';

export type AlertNumber = number;

export type AlertCreatedAt = string;

export type AlertUpdatedAt = string;

export type AlertUrl = string;

export type AlertHtmlUrl = string;

export type AlertInstancesUrl = string;

export type AlertFixedAt = string | null;

export type AlertDismissedAt = string | null;

export type CodeScanningAlertDismissedReason =
  | null
  | 'false positive'
  | "won't fix"
  | 'used in tests'
  | null;

export type CodeScanningAlertDismissedComment = string | null;

export type CodeScanningAlertRule = {
  readonly id?: string | null;
  readonly name?: string;
  readonly severity?: 'none' | 'note' | 'warning' | 'error' | null;
  readonly security_severity_level?:
    | 'low'
    | 'medium'
    | 'high'
    | 'critical'
    | null;
  readonly description?: string;
  readonly full_description?: string;
  readonly tags?: ReadonlyArray<string> | null;
  readonly help?: string | null;
  readonly help_uri?: string | null;
};

export type CodeScanningAnalysisToolVersion = string | null;

export type CodeScanningAnalysisTool = {
  readonly name?: CodeScanningAnalysisToolName;
  readonly version?: CodeScanningAnalysisToolVersion;
  readonly guid?: CodeScanningAnalysisToolGuid;
};

export type CodeScanningRef = string;

export type CodeScanningAnalysisAnalysisKey = string;

export type CodeScanningAlertEnvironment = string;

export type CodeScanningAnalysisCategory = string;

export type CodeScanningAlertLocation = {
  readonly path?: string;
  readonly start_line?: number;
  readonly end_line?: number;
  readonly start_column?: number;
  readonly end_column?: number;
};

export type CodeScanningAlertClassification =
  | 'source'
  | 'generated'
  | 'test'
  | 'library'
  | null;

export type CodeScanningAlertInstance = {
  readonly ref?: CodeScanningRef;
  readonly analysis_key?: CodeScanningAnalysisAnalysisKey;
  readonly environment?: CodeScanningAlertEnvironment;
  readonly category?: CodeScanningAnalysisCategory;
  readonly state?: CodeScanningAlertState;
  readonly commit_sha?: string;
  readonly message?: { readonly text?: string };
  readonly location?: CodeScanningAlertLocation;
  readonly html_url?: string;
  readonly classifications?: ReadonlyArray<CodeScanningAlertClassification>;
};

export type SimpleRepository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly hooks_url: string;
};

export type CodeScanningOrganizationAlertItems = {
  readonly number: AlertNumber;
  readonly created_at: AlertCreatedAt;
  readonly updated_at?: AlertUpdatedAt;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly instances_url: AlertInstancesUrl;
  readonly state: CodeScanningAlertState;
  readonly fixed_at?: AlertFixedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_reason: CodeScanningAlertDismissedReason;
  readonly dismissed_comment?: CodeScanningAlertDismissedComment;
  readonly rule: CodeScanningAlertRule;
  readonly tool: CodeScanningAnalysisTool;
  readonly most_recent_instance: CodeScanningAlertInstance;
  readonly repository: SimpleRepository;
};

export type NullableAlertUpdatedAt = string | null;

export type SecretScanningAlertState = 'open' | 'resolved';

export type SecretScanningAlertResolution =
  | null
  | 'false_positive'
  | 'wont_fix'
  | 'revoked'
  | 'used_in_tests'
  | null;

export type OrganizationSecretScanningAlert = {
  readonly number?: AlertNumber;
  readonly created_at?: AlertCreatedAt;
  readonly updated_at?: NullableAlertUpdatedAt;
  readonly url?: AlertUrl;
  readonly html_url?: AlertHtmlUrl;
  readonly locations_url?: string;
  readonly state?: SecretScanningAlertState;
  readonly resolution?: SecretScanningAlertResolution;
  readonly resolved_at?: string | null;
  readonly resolved_by?: SimpleUser;
  readonly secret_type?: string;
  readonly secret_type_display_name?: string;
  readonly secret?: string;
  readonly repository?: SimpleRepository;
  readonly push_protection_bypassed?: boolean | null;
  readonly push_protection_bypassed_by?: SimpleUser;
  readonly push_protection_bypassed_at?: string | null;
  readonly resolution_comment?: string | null;
};

export type AdvancedSecurityActiveCommittersUser = {
  readonly user_login: string;
  readonly last_pushed_date: string;
};

export type AdvancedSecurityActiveCommittersRepository = {
  readonly name: string;
  readonly advanced_security_committers: number;
  readonly advanced_security_committers_breakdown: ReadonlyArray<AdvancedSecurityActiveCommittersUser>;
};

export type AdvancedSecurityActiveCommitters = {
  readonly total_advanced_security_committers?: number;
  readonly total_count?: number;
  readonly repositories: ReadonlyArray<AdvancedSecurityActiveCommittersRepository>;
};

export type Actor = {
  readonly id: number;
  readonly login: string;
  readonly display_login?: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly avatar_url: string;
};

export type Milestone = {
  readonly url: string;
  readonly html_url: string;
  readonly labels_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly number: number;
  readonly state: 'open' | 'closed';
  readonly title: string;
  readonly description: string | null;
  readonly creator: SimpleUser;
  readonly open_issues: number;
  readonly closed_issues: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly closed_at: string | null;
  readonly due_on: string | null;
} | null;

export type AuthorAssociation =
  | 'COLLABORATOR'
  | 'CONTRIBUTOR'
  | 'FIRST_TIMER'
  | 'FIRST_TIME_CONTRIBUTOR'
  | 'MANNEQUIN'
  | 'MEMBER'
  | 'NONE'
  | 'OWNER';

export type ReactionRollup = {
  readonly url: string;
  readonly total_count: number;
  readonly '+1': number;
  readonly '-1': number;
  readonly laugh: number;
  readonly confused: number;
  readonly heart: number;
  readonly hooray: number;
  readonly eyes: number;
  readonly rocket: number;
};

export type Issue = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly repository_url: string;
  readonly labels_url: string;
  readonly comments_url: string;
  readonly events_url: string;
  readonly html_url: string;
  readonly number: number;
  readonly state: string;
  readonly state_reason?: 'completed' | 'reopened' | 'not_planned' | null;
  readonly title: string;
  readonly body?: string | null;
  readonly user: SimpleUser;
  readonly labels: ReadonlyArray<
    | string
    | {
        readonly id?: number;
        readonly node_id?: string;
        readonly url?: string;
        readonly name?: string;
        readonly description?: string | null;
        readonly color?: string | null;
        readonly default?: boolean;
      }
  >;
  readonly assignee: SimpleUser;
  readonly assignees?: ReadonlyArray<SimpleUser> | null;
  readonly milestone: Milestone;
  readonly locked: boolean;
  readonly active_lock_reason?: string | null;
  readonly comments: number;
  readonly pull_request?: {
    readonly merged_at?: string | null;
    readonly diff_url: string | null;
    readonly html_url: string | null;
    readonly patch_url: string | null;
    readonly url: string | null;
  };
  readonly closed_at: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly draft?: boolean;
  readonly closed_by?: SimpleUser;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly timeline_url?: string;
  readonly repository?: Repository;
  readonly performed_via_github_app?: GitHubApp;
  readonly author_association: AuthorAssociation;
  readonly reactions?: ReactionRollup;
};

export type IssueComment = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly body?: string;
  readonly body_text?: string;
  readonly body_html?: string;
  readonly html_url: string;
  readonly user: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly issue_url: string;
  readonly author_association: AuthorAssociation;
  readonly performed_via_github_app?: GitHubApp;
  readonly reactions?: ReactionRollup;
};

export type Event = {
  readonly id: string;
  readonly type: string | null;
  readonly actor: Actor;
  readonly repo: {
    readonly id: number;
    readonly name: string;
    readonly url: string;
  };
  readonly org?: Actor;
  readonly payload: {
    readonly action?: string;
    readonly issue?: Issue;
    readonly comment?: IssueComment;
    readonly pages?: ReadonlyArray<{
      readonly page_name?: string;
      readonly title?: string;
      readonly summary?: string | null;
      readonly action?: string;
      readonly sha?: string;
      readonly html_url?: string;
    }>;
  };
  readonly public: boolean;
  readonly created_at: string | null;
};

export type LinkWithType = { readonly href: string; readonly type: string };

export type Feed = {
  readonly timeline_url: string;
  readonly user_url: string;
  readonly current_user_public_url?: string;
  readonly current_user_url?: string;
  readonly current_user_actor_url?: string;
  readonly current_user_organization_url?: string;
  readonly current_user_organization_urls?: ReadonlyArray<string>;
  readonly security_advisories_url?: string;
  readonly _links: {
    readonly timeline: LinkWithType;
    readonly user: LinkWithType;
    readonly security_advisories?: LinkWithType;
    readonly current_user?: LinkWithType;
    readonly current_user_public?: LinkWithType;
    readonly current_user_actor?: LinkWithType;
    readonly current_user_organization?: LinkWithType;
    readonly current_user_organizations?: ReadonlyArray<LinkWithType>;
  };
};

export type BaseGist = {
  readonly url: string;
  readonly forks_url: string;
  readonly commits_url: string;
  readonly id: string;
  readonly node_id: string;
  readonly git_pull_url: string;
  readonly git_push_url: string;
  readonly html_url: string;
  readonly files: unknown;
  readonly public: boolean;
  readonly created_at: string;
  readonly updated_at: string;
  readonly description: string | null;
  readonly comments: number;
  readonly user: SimpleUser;
  readonly comments_url: string;
  readonly owner?: SimpleUser;
  readonly truncated?: boolean;
  readonly forks?: ReadonlyArray<unknown>;
  readonly history?: ReadonlyArray<unknown>;
};

export type PublicUser = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly site_admin: boolean;
  readonly name: string | null;
  readonly company: string | null;
  readonly blog: string | null;
  readonly location: string | null;
  readonly email: string | null;
  readonly hireable: boolean | null;
  readonly bio: string | null;
  readonly twitter_username?: string | null;
  readonly public_repos: number;
  readonly public_gists: number;
  readonly followers: number;
  readonly following: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly plan?: {
    readonly collaborators: number;
    readonly name: string;
    readonly space: number;
    readonly private_repos: number;
  };
  readonly suspended_at?: string | null;
  readonly private_gists?: number;
  readonly total_private_repos?: number;
  readonly owned_private_repos?: number;
  readonly disk_usage?: number;
  readonly collaborators?: number;
};

export type GistHistory = {
  readonly user?: SimpleUser;
  readonly version?: string;
  readonly committed_at?: string;
  readonly change_status?: {
    readonly total?: number;
    readonly additions?: number;
    readonly deletions?: number;
  };
  readonly url?: string;
};

export type Gist = {
  readonly url: string;
  readonly forks_url: string;
  readonly commits_url: string;
  readonly id: string;
  readonly node_id: string;
  readonly git_pull_url: string;
  readonly git_push_url: string;
  readonly html_url: string;
  readonly files: unknown;
  readonly public: boolean;
  readonly created_at: string;
  readonly updated_at: string;
  readonly description: string | null;
  readonly comments: number;
  readonly user: SimpleUser;
  readonly comments_url: string;
  readonly owner?: SimpleUser;
  readonly truncated?: boolean;
  readonly forks?: ReadonlyArray<unknown>;
  readonly history?: ReadonlyArray<unknown>;
} | null;

export type GistSimple = {
  readonly forks?: ReadonlyArray<{
    readonly id?: string;
    readonly url?: string;
    readonly user?: PublicUser;
    readonly created_at?: string;
    readonly updated_at?: string;
  }> | null;
  readonly history?: ReadonlyArray<GistHistory> | null;
  readonly fork_of?: Gist;
  readonly url?: string;
  readonly forks_url?: string;
  readonly commits_url?: string;
  readonly id?: string;
  readonly node_id?: string;
  readonly git_pull_url?: string;
  readonly git_push_url?: string;
  readonly html_url?: string;
  readonly files?: unknown;
  readonly public?: boolean;
  readonly created_at?: string;
  readonly updated_at?: string;
  readonly description?: string | null;
  readonly comments?: number;
  readonly user?: string | null;
  readonly comments_url?: string;
  readonly owner?: SimpleUser;
  readonly truncated?: boolean;
};

export type GistComment = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly body: string;
  readonly user: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly author_association: AuthorAssociation;
};

export type GistCommit = {
  readonly url: string;
  readonly version: string;
  readonly user: SimpleUser;
  readonly change_status: {
    readonly total?: number;
    readonly additions?: number;
    readonly deletions?: number;
  };
  readonly committed_at: string;
};

export type GitignoreTemplate = {
  readonly name: string;
  readonly source: string;
};

export type License = {
  readonly key: string;
  readonly name: string;
  readonly spdx_id: string | null;
  readonly url: string | null;
  readonly node_id: string;
  readonly html_url: string;
  readonly description: string;
  readonly implementation: string;
  readonly permissions: ReadonlyArray<string>;
  readonly conditions: ReadonlyArray<string>;
  readonly limitations: ReadonlyArray<string>;
  readonly body: string;
  readonly featured: boolean;
};

export type MarketplaceListingPlan = {
  readonly url: string;
  readonly accounts_url: string;
  readonly id: number;
  readonly number: number;
  readonly name: string;
  readonly description: string;
  readonly monthly_price_in_cents: number;
  readonly yearly_price_in_cents: number;
  readonly price_model: string;
  readonly has_free_trial: boolean;
  readonly unit_name: string | null;
  readonly state: string;
  readonly bullets: ReadonlyArray<string>;
};

export type MarketplacePurchase = {
  readonly url: string;
  readonly type: string;
  readonly id: number;
  readonly login: string;
  readonly organization_billing_email?: string;
  readonly email?: string | null;
  readonly marketplace_pending_change?: {
    readonly is_installed?: boolean;
    readonly effective_date?: string;
    readonly unit_count?: number | null;
    readonly id?: number;
    readonly plan?: MarketplaceListingPlan;
  } | null;
  readonly marketplace_purchase: {
    readonly billing_cycle?: string;
    readonly next_billing_date?: string | null;
    readonly is_installed?: boolean;
    readonly unit_count?: number | null;
    readonly on_free_trial?: boolean;
    readonly free_trial_ends_on?: string | null;
    readonly updated_at?: string;
    readonly plan?: MarketplaceListingPlan;
  };
};

export type ApiOverview = {
  readonly verifiable_password_authentication: boolean;
  readonly ssh_key_fingerprints?: {
    readonly SHA256_RSA?: string;
    readonly SHA256_DSA?: string;
    readonly SHA256_ECDSA?: string;
    readonly SHA256_ED25519?: string;
  };
  readonly ssh_keys?: ReadonlyArray<string>;
  readonly hooks?: ReadonlyArray<string>;
  readonly web?: ReadonlyArray<string>;
  readonly api?: ReadonlyArray<string>;
  readonly git?: ReadonlyArray<string>;
  readonly packages?: ReadonlyArray<string>;
  readonly pages?: ReadonlyArray<string>;
  readonly importer?: ReadonlyArray<string>;
  readonly actions?: ReadonlyArray<string>;
  readonly dependabot?: ReadonlyArray<string>;
};

export type MinimalRepository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly git_url?: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly ssh_url?: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly clone_url?: string;
  readonly mirror_url?: string | null;
  readonly hooks_url: string;
  readonly svn_url?: string;
  readonly homepage?: string | null;
  readonly language?: string | null;
  readonly forks_count?: number;
  readonly stargazers_count?: number;
  readonly watchers_count?: number;
  readonly size?: number;
  readonly default_branch?: string;
  readonly open_issues_count?: number;
  readonly is_template?: boolean;
  readonly topics?: ReadonlyArray<string>;
  readonly has_issues?: boolean;
  readonly has_projects?: boolean;
  readonly has_wiki?: boolean;
  readonly has_pages?: boolean;
  readonly has_downloads?: boolean;
  readonly archived?: boolean;
  readonly disabled?: boolean;
  readonly visibility?: string;
  readonly pushed_at?: string | null;
  readonly created_at?: string | null;
  readonly updated_at?: string | null;
  readonly permissions?: {
    readonly admin?: boolean;
    readonly maintain?: boolean;
    readonly push?: boolean;
    readonly triage?: boolean;
    readonly pull?: boolean;
  };
  readonly role_name?: string;
  readonly temp_clone_token?: string;
  readonly delete_branch_on_merge?: boolean;
  readonly subscribers_count?: number;
  readonly network_count?: number;
  readonly code_of_conduct?: CodeOfConduct;
  readonly license?: {
    readonly key?: string;
    readonly name?: string;
    readonly spdx_id?: string;
    readonly url?: string;
    readonly node_id?: string;
  } | null;
  readonly forks?: number;
  readonly open_issues?: number;
  readonly watchers?: number;
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
};

export type Thread = {
  readonly id: string;
  readonly repository: MinimalRepository;
  readonly subject: {
    readonly title: string;
    readonly url: string;
    readonly latest_comment_url: string;
    readonly type: string;
  };
  readonly reason: string;
  readonly unread: boolean;
  readonly updated_at: string;
  readonly last_read_at: string | null;
  readonly url: string;
  readonly subscription_url: string;
};

export type ThreadSubscription = {
  readonly subscribed: boolean;
  readonly ignored: boolean;
  readonly reason: string | null;
  readonly created_at: string | null;
  readonly url: string;
  readonly thread_url?: string;
  readonly repository_url?: string;
};

export type OrganizationCustomRepositoryRole = {
  readonly id: number;
  readonly name: string;
  readonly description?: string | null;
  readonly base_role?: 'read' | 'triage' | 'write' | 'maintain';
  readonly permissions?: ReadonlyArray<string>;
  readonly organization?: SimpleUser;
  readonly created_at?: string;
  readonly updated_at?: string;
};

export type OrganizationFull = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly hooks_url: string;
  readonly issues_url: string;
  readonly members_url: string;
  readonly public_members_url: string;
  readonly avatar_url: string;
  readonly description: string | null;
  readonly name?: string;
  readonly company?: string;
  readonly blog?: string;
  readonly location?: string;
  readonly email?: string;
  readonly twitter_username?: string | null;
  readonly is_verified?: boolean;
  readonly has_organization_projects: boolean;
  readonly has_repository_projects: boolean;
  readonly public_repos: number;
  readonly public_gists: number;
  readonly followers: number;
  readonly following: number;
  readonly html_url: string;
  readonly created_at: string;
  readonly type: string;
  readonly total_private_repos?: number;
  readonly owned_private_repos?: number;
  readonly private_gists?: number | null;
  readonly disk_usage?: number | null;
  readonly collaborators?: number | null;
  readonly billing_email?: string | null;
  readonly plan?: {
    readonly name: string;
    readonly space: number;
    readonly private_repos: number;
    readonly filled_seats?: number;
    readonly seats?: number;
  };
  readonly default_repository_permission?: string | null;
  readonly members_can_create_repositories?: boolean | null;
  readonly two_factor_requirement_enabled?: boolean | null;
  readonly members_allowed_repository_creation_type?: string;
  readonly members_can_create_public_repositories?: boolean;
  readonly members_can_create_private_repositories?: boolean;
  readonly members_can_create_internal_repositories?: boolean;
  readonly members_can_create_pages?: boolean;
  readonly members_can_create_public_pages?: boolean;
  readonly members_can_create_private_pages?: boolean;
  readonly members_can_fork_private_repositories?: boolean | null;
  readonly web_commit_signoff_required?: boolean;
  readonly updated_at: string;
  readonly advanced_security_enabled_for_new_repositories?: boolean;
  readonly dependabot_alerts_enabled_for_new_repositories?: boolean;
  readonly dependabot_security_updates_enabled_for_new_repositories?: boolean;
  readonly dependency_graph_enabled_for_new_repositories?: boolean;
  readonly secret_scanning_enabled_for_new_repositories?: boolean;
  readonly secret_scanning_push_protection_enabled_for_new_repositories?: boolean;
};

export type ActionsCacheUsageByRepository = {
  readonly full_name: string;
  readonly active_caches_size_in_bytes: number;
  readonly active_caches_count: number;
};

export type EnabledRepositories = 'all' | 'none' | 'selected';

export type ActionsOrganizationPermissions = {
  readonly enabled_repositories: EnabledRepositories;
  readonly selected_repositories_url?: string;
  readonly allowed_actions?: AllowedActions;
  readonly selected_actions_url?: SelectedActionsUrl;
};

export type RunnerGroupsOrg = {
  readonly id: number;
  readonly name: string;
  readonly visibility: string;
  readonly default: boolean;
  readonly selected_repositories_url?: string;
  readonly runners_url: string;
  readonly inherited: boolean;
  readonly inherited_allows_public_repositories?: boolean;
  readonly allows_public_repositories: boolean;
  readonly workflow_restrictions_read_only?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type ActionsSecretForAnOrganization = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repositories_url?: string;
};

export type ActionsPublicKey = {
  readonly key_id: string;
  readonly key: string;
  readonly id?: number;
  readonly url?: string;
  readonly title?: string;
  readonly created_at?: string;
};

export type EmptyObject = {};

export type CodespaceMachine = {
  readonly name: string;
  readonly display_name: string;
  readonly operating_system: string;
  readonly storage_in_bytes: number;
  readonly memory_in_bytes: number;
  readonly cpus: number;
  readonly prebuild_availability: 'none' | 'ready' | 'in_progress' | null;
} | null;

export type Codespace = {
  readonly id: number;
  readonly name: string;
  readonly display_name?: string | null;
  readonly environment_id: string | null;
  readonly owner: SimpleUser;
  readonly billable_owner: SimpleUser;
  readonly repository: MinimalRepository;
  readonly machine: CodespaceMachine;
  readonly devcontainer_path?: string | null;
  readonly prebuild: boolean | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly last_used_at: string;
  readonly state:
    | 'Unknown'
    | 'Created'
    | 'Queued'
    | 'Provisioning'
    | 'Available'
    | 'Awaiting'
    | 'Unavailable'
    | 'Deleted'
    | 'Moved'
    | 'Shutdown'
    | 'Archived'
    | 'Starting'
    | 'ShuttingDown'
    | 'Failed'
    | 'Exporting'
    | 'Updating'
    | 'Rebuilding';
  readonly url: string;
  readonly git_status: {
    readonly ahead?: number;
    readonly behind?: number;
    readonly has_unpushed_changes?: boolean;
    readonly has_uncommitted_changes?: boolean;
    readonly ref?: string;
  };
  readonly location: 'EastUs' | 'SouthEastAsia' | 'WestEurope' | 'WestUs2';
  readonly idle_timeout_minutes: number | null;
  readonly web_url: string;
  readonly machines_url: string;
  readonly start_url: string;
  readonly stop_url: string;
  readonly pulls_url: string | null;
  readonly recent_folders: ReadonlyArray<string>;
  readonly runtime_constraints?: {
    readonly allowed_port_privacy_settings?: ReadonlyArray<string> | null;
  };
  readonly pending_operation?: boolean | null;
  readonly pending_operation_disabled_reason?: string | null;
  readonly idle_timeout_notice?: string | null;
  readonly retention_period_minutes?: number | null;
  readonly retention_expires_at?: string | null;
  readonly last_known_stop_notice?: string | null;
};

export type CodespacesSecret = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repositories_url?: string;
};

export type CodespacesPublicKey = {
  readonly key_id: string;
  readonly key: string;
  readonly id?: number;
  readonly url?: string;
  readonly title?: string;
  readonly created_at?: string;
};

export type DependabotAlertPackage = {
  readonly ecosystem: string;
  readonly name: string;
};

export type DependabotAlertSecurityVulnerability = {
  readonly package: DependabotAlertPackage;
  readonly severity: 'low' | 'medium' | 'high' | 'critical';
  readonly vulnerable_version_range: string;
  readonly first_patched_version: { readonly identifier: string } | null;
};

export type DependabotAlertSecurityAdvisory = {
  readonly ghsa_id: string;
  readonly cve_id: string | null;
  readonly summary: string;
  readonly description: string;
  readonly vulnerabilities: ReadonlyArray<DependabotAlertSecurityVulnerability>;
  readonly severity: 'low' | 'medium' | 'high' | 'critical';
  readonly cvss: {
    readonly score: number;
    readonly vector_string: string | null;
  };
  readonly cwes: ReadonlyArray<{
    readonly cwe_id: string;
    readonly name: string;
  }>;
  readonly identifiers: ReadonlyArray<{
    readonly type: 'CVE' | 'GHSA';
    readonly value: string;
  }>;
  readonly references: ReadonlyArray<{ readonly url: string }>;
  readonly published_at: string;
  readonly updated_at: string;
  readonly withdrawn_at: string | null;
};

export type DependabotAlertWithRepository = {
  readonly number: AlertNumber;
  readonly state: 'dismissed' | 'fixed' | 'open';
  readonly dependency: {
    readonly package?: DependabotAlertPackage;
    readonly manifest_path?: string;
    readonly scope?: 'development' | 'runtime' | null;
  };
  readonly security_advisory: DependabotAlertSecurityAdvisory;
  readonly security_vulnerability: DependabotAlertSecurityVulnerability;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly created_at: AlertCreatedAt;
  readonly updated_at: AlertUpdatedAt;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_reason:
    | 'fix_started'
    | 'inaccurate'
    | 'no_bandwidth'
    | 'not_used'
    | 'tolerable_risk'
    | null;
  readonly dismissed_comment: string | null;
  readonly fixed_at: AlertFixedAt;
  readonly repository: SimpleRepository;
};

export type DependabotSecretForAnOrganization = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repositories_url?: string;
};

export type DependabotPublicKey = {
  readonly key_id: string;
  readonly key: string;
};

export type OrganizationInvitation = {
  readonly id: number;
  readonly login: string | null;
  readonly email: string | null;
  readonly role: string;
  readonly created_at: string;
  readonly failed_at?: string | null;
  readonly failed_reason?: string | null;
  readonly inviter: SimpleUser;
  readonly team_count: number;
  readonly node_id: string;
  readonly invitation_teams_url: string;
};

export type OrganizationFineGrainedPermission = {
  readonly name: string;
  readonly description: string;
};

export type OrgHook = {
  readonly id: number;
  readonly url: string;
  readonly ping_url: string;
  readonly deliveries_url?: string;
  readonly name: string;
  readonly events: ReadonlyArray<string>;
  readonly active: boolean;
  readonly config: {
    readonly url?: string;
    readonly insecure_ssl?: string;
    readonly content_type?: string;
    readonly secret?: string;
  };
  readonly updated_at: string;
  readonly created_at: string;
  readonly type: string;
};

export type InteractionGroup =
  | 'existing_users'
  | 'contributors_only'
  | 'collaborators_only';

export type InteractionLimits = {
  readonly limit: InteractionGroup;
  readonly origin: string;
  readonly expires_at: string;
};

export type InteractionExpiry =
  | 'one_day'
  | 'three_days'
  | 'one_week'
  | 'one_month'
  | 'six_months';

export type InteractionRestrictions = {
  readonly limit: InteractionGroup;
  readonly expiry?: InteractionExpiry;
};

export type TeamSimple = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly members_url: string;
  readonly name: string;
  readonly description: string | null;
  readonly permission: string;
  readonly privacy?: string;
  readonly html_url: string;
  readonly repositories_url: string;
  readonly slug: string;
  readonly ldap_dn?: string;
} | null;

export type Team = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly slug: string;
  readonly description: string | null;
  readonly privacy?: string;
  readonly permission: string;
  readonly permissions?: {
    readonly pull: boolean;
    readonly triage: boolean;
    readonly push: boolean;
    readonly maintain: boolean;
    readonly admin: boolean;
  };
  readonly url: string;
  readonly html_url: string;
  readonly members_url: string;
  readonly repositories_url: string;
  readonly parent: TeamSimple;
};

export type OrgMembership = {
  readonly url: string;
  readonly state: 'active' | 'pending';
  readonly role: 'admin' | 'member' | 'billing_manager';
  readonly organization_url: string;
  readonly organization: OrganizationSimple;
  readonly user: SimpleUser;
  readonly permissions?: { readonly can_create_repository: boolean };
};

export type Migration = {
  readonly id: number;
  readonly owner: SimpleUser;
  readonly guid: string;
  readonly state: string;
  readonly lock_repositories: boolean;
  readonly exclude_metadata: boolean;
  readonly exclude_git_data: boolean;
  readonly exclude_attachments: boolean;
  readonly exclude_releases: boolean;
  readonly exclude_owner_projects: boolean;
  readonly org_metadata_only: boolean;
  readonly repositories: ReadonlyArray<Repository>;
  readonly url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly node_id: string;
  readonly archive_url?: string;
  readonly exclude?: ReadonlyArray<unknown>;
};

export type Package = {
  readonly id: number;
  readonly name: string;
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly url: string;
  readonly html_url: string;
  readonly version_count: number;
  readonly visibility: 'private' | 'public';
  readonly owner?: SimpleUser;
  readonly repository?: MinimalRepository;
  readonly created_at: string;
  readonly updated_at: string;
};

export type ContainerMetadata = { readonly tags: ReadonlyArray<string> };

export type DockerMetadata = { readonly tag?: ReadonlyArray<string> };

export type PackageVersionMetadata = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly container?: ContainerMetadata;
  readonly docker?: DockerMetadata;
};

export type PackageVersion = {
  readonly id: number;
  readonly name: string;
  readonly url: string;
  readonly package_html_url: string;
  readonly html_url?: string;
  readonly license?: string;
  readonly description?: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly deleted_at?: string;
  readonly metadata?: PackageVersionMetadata;
};

export type Project = {
  readonly owner_url: string;
  readonly url: string;
  readonly html_url: string;
  readonly columns_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly body: string | null;
  readonly number: number;
  readonly state: string;
  readonly creator: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly organization_permission?: 'read' | 'write' | 'admin' | 'none';
  readonly private?: boolean;
};

export type ActionsBillingUsage = {
  readonly total_minutes_used: number;
  readonly total_paid_minutes_used: number;
  readonly included_minutes: number;
  readonly minutes_used_breakdown: {
    readonly UBUNTU?: number;
    readonly MACOS?: number;
    readonly WINDOWS?: number;
    readonly ubuntu_4_core?: number;
    readonly ubuntu_8_core?: number;
    readonly ubuntu_16_core?: number;
    readonly ubuntu_32_core?: number;
    readonly ubuntu_64_core?: number;
    readonly windows_4_core?: number;
    readonly windows_8_core?: number;
    readonly windows_16_core?: number;
    readonly windows_32_core?: number;
    readonly windows_64_core?: number;
    readonly total?: number;
  };
};

export type PackagesBillingUsage = {
  readonly total_gigabytes_bandwidth_used: number;
  readonly total_paid_gigabytes_bandwidth_used: number;
  readonly included_gigabytes_bandwidth: number;
};

export type CombinedBillingUsage = {
  readonly days_left_in_billing_cycle: number;
  readonly estimated_paid_storage_for_month: number;
  readonly estimated_storage_for_month: number;
};

export type TeamOrganization = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly hooks_url: string;
  readonly issues_url: string;
  readonly members_url: string;
  readonly public_members_url: string;
  readonly avatar_url: string;
  readonly description: string | null;
  readonly name?: string;
  readonly company?: string;
  readonly blog?: string;
  readonly location?: string;
  readonly email?: string;
  readonly twitter_username?: string | null;
  readonly is_verified?: boolean;
  readonly has_organization_projects: boolean;
  readonly has_repository_projects: boolean;
  readonly public_repos: number;
  readonly public_gists: number;
  readonly followers: number;
  readonly following: number;
  readonly html_url: string;
  readonly created_at: string;
  readonly type: string;
  readonly total_private_repos?: number;
  readonly owned_private_repos?: number;
  readonly private_gists?: number | null;
  readonly disk_usage?: number | null;
  readonly collaborators?: number | null;
  readonly billing_email?: string | null;
  readonly plan?: {
    readonly name: string;
    readonly space: number;
    readonly private_repos: number;
    readonly filled_seats?: number;
    readonly seats?: number;
  };
  readonly default_repository_permission?: string | null;
  readonly members_can_create_repositories?: boolean | null;
  readonly two_factor_requirement_enabled?: boolean | null;
  readonly members_allowed_repository_creation_type?: string;
  readonly members_can_create_public_repositories?: boolean;
  readonly members_can_create_private_repositories?: boolean;
  readonly members_can_create_internal_repositories?: boolean;
  readonly members_can_create_pages?: boolean;
  readonly members_can_create_public_pages?: boolean;
  readonly members_can_create_private_pages?: boolean;
  readonly members_can_fork_private_repositories?: boolean | null;
  readonly web_commit_signoff_required?: boolean;
  readonly updated_at: string;
};

export type FullTeam = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly html_url: string;
  readonly name: string;
  readonly slug: string;
  readonly description: string | null;
  readonly privacy?: 'closed' | 'secret';
  readonly permission: string;
  readonly members_url: string;
  readonly repositories_url: string;
  readonly parent?: TeamSimple;
  readonly members_count: number;
  readonly repos_count: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly organization: TeamOrganization;
  readonly ldap_dn?: string;
};

export type TeamDiscussion = {
  readonly author: SimpleUser;
  readonly body: string;
  readonly body_html: string;
  readonly body_version: string;
  readonly comments_count: number;
  readonly comments_url: string;
  readonly created_at: string;
  readonly last_edited_at: string | null;
  readonly html_url: string;
  readonly node_id: string;
  readonly number: number;
  readonly pinned: boolean;
  readonly private: boolean;
  readonly team_url: string;
  readonly title: string;
  readonly updated_at: string;
  readonly url: string;
  readonly reactions?: ReactionRollup;
};

export type TeamDiscussionComment = {
  readonly author: SimpleUser;
  readonly body: string;
  readonly body_html: string;
  readonly body_version: string;
  readonly created_at: string;
  readonly last_edited_at: string | null;
  readonly discussion_url: string;
  readonly html_url: string;
  readonly node_id: string;
  readonly number: number;
  readonly updated_at: string;
  readonly url: string;
  readonly reactions?: ReactionRollup;
};

export type Reaction = {
  readonly id: number;
  readonly node_id: string;
  readonly user: SimpleUser;
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly created_at: string;
};

export type TeamMembership = {
  readonly url: string;
  readonly role: 'member' | 'maintainer';
  readonly state: 'active' | 'pending';
};

export type TeamProject = {
  readonly owner_url: string;
  readonly url: string;
  readonly html_url: string;
  readonly columns_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly body: string | null;
  readonly number: number;
  readonly state: string;
  readonly creator: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly organization_permission?: string;
  readonly private?: boolean;
  readonly permissions: {
    readonly read: boolean;
    readonly write: boolean;
    readonly admin: boolean;
  };
};

export type TeamRepository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly license: LicenseSimple;
  readonly forks: number;
  readonly permissions?: {
    readonly admin: boolean;
    readonly pull: boolean;
    readonly triage?: boolean;
    readonly push: boolean;
    readonly maintain?: boolean;
  };
  readonly role_name?: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly git_url: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly ssh_url: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly clone_url: string;
  readonly mirror_url: string | null;
  readonly hooks_url: string;
  readonly svn_url: string;
  readonly homepage: string | null;
  readonly language: string | null;
  readonly forks_count: number;
  readonly stargazers_count: number;
  readonly watchers_count: number;
  readonly size: number;
  readonly default_branch: string;
  readonly open_issues_count: number;
  readonly is_template?: boolean;
  readonly topics?: ReadonlyArray<string>;
  readonly has_issues: boolean;
  readonly has_projects: boolean;
  readonly has_wiki: boolean;
  readonly has_pages: boolean;
  readonly has_downloads: boolean;
  readonly archived: boolean;
  readonly disabled: boolean;
  readonly visibility?: string;
  readonly pushed_at: string | null;
  readonly created_at: string | null;
  readonly updated_at: string | null;
  readonly allow_rebase_merge?: boolean;
  readonly template_repository?: Repository;
  readonly temp_clone_token?: string;
  readonly allow_squash_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_merge_commit?: boolean;
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
  readonly subscribers_count?: number;
  readonly network_count?: number;
  readonly open_issues: number;
  readonly watchers: number;
  readonly master_branch?: string;
};

export type ProjectCard = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly note: string | null;
  readonly creator: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly archived?: boolean;
  readonly column_name?: string;
  readonly project_id?: string;
  readonly column_url: string;
  readonly content_url?: string;
  readonly project_url: string;
};

export type ProjectColumn = {
  readonly url: string;
  readonly project_url: string;
  readonly cards_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
};

export type ProjectCollaboratorPermission = {
  readonly permission: string;
  readonly user: SimpleUser;
};

export type RateLimit = {
  readonly limit: number;
  readonly remaining: number;
  readonly reset: number;
  readonly used: number;
};

export type RateLimitOverview = {
  readonly resources: {
    readonly core: RateLimit;
    readonly graphql?: RateLimit;
    readonly search: RateLimit;
    readonly source_import?: RateLimit;
    readonly integration_manifest?: RateLimit;
    readonly code_scanning_upload?: RateLimit;
    readonly actions_runner_registration?: RateLimit;
    readonly scim?: RateLimit;
    readonly dependency_snapshots?: RateLimit;
  };
  readonly rate: RateLimit;
};

export type CodeOfConductSimple = {
  readonly url: string;
  readonly key: string;
  readonly name: string;
  readonly html_url: string | null;
};

export type SecurityAndAnalysis = {
  readonly advanced_security?: { readonly status?: 'enabled' | 'disabled' };
  readonly secret_scanning?: { readonly status?: 'enabled' | 'disabled' };
  readonly secret_scanning_push_protection?: {
    readonly status?: 'enabled' | 'disabled';
  };
} | null;

export type FullRepository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly git_url: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly ssh_url: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly clone_url: string;
  readonly mirror_url: string | null;
  readonly hooks_url: string;
  readonly svn_url: string;
  readonly homepage: string | null;
  readonly language: string | null;
  readonly forks_count: number;
  readonly stargazers_count: number;
  readonly watchers_count: number;
  readonly size: number;
  readonly default_branch: string;
  readonly open_issues_count: number;
  readonly is_template?: boolean;
  readonly topics?: ReadonlyArray<string>;
  readonly has_issues: boolean;
  readonly has_projects: boolean;
  readonly has_wiki: boolean;
  readonly has_pages: boolean;
  readonly has_downloads: boolean;
  readonly archived: boolean;
  readonly disabled: boolean;
  readonly visibility?: string;
  readonly pushed_at: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly permissions?: {
    readonly admin: boolean;
    readonly maintain?: boolean;
    readonly push: boolean;
    readonly triage?: boolean;
    readonly pull: boolean;
  };
  readonly allow_rebase_merge?: boolean;
  readonly template_repository?: Repository;
  readonly temp_clone_token?: string | null;
  readonly allow_squash_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_merge_commit?: boolean;
  readonly allow_update_branch?: boolean;
  readonly use_squash_pr_title_as_default?: boolean;
  readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
  readonly squash_merge_commit_message?:
    | 'PR_BODY'
    | 'COMMIT_MESSAGES'
    | 'BLANK';
  readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
  readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
  readonly subscribers_count: number;
  readonly network_count: number;
  readonly license: LicenseSimple;
  readonly organization?: SimpleUser;
  readonly parent?: Repository;
  readonly source?: Repository;
  readonly forks: number;
  readonly master_branch?: string;
  readonly open_issues: number;
  readonly watchers: number;
  readonly anonymous_access_enabled?: boolean;
  readonly code_of_conduct?: CodeOfConductSimple;
  readonly security_and_analysis?: SecurityAndAnalysis;
};

export type Artifact = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly size_in_bytes: number;
  readonly url: string;
  readonly archive_download_url: string;
  readonly expired: boolean;
  readonly created_at: string | null;
  readonly expires_at: string | null;
  readonly updated_at: string | null;
  readonly workflow_run?: {
    readonly id?: number;
    readonly repository_id?: number;
    readonly head_repository_id?: number;
    readonly head_branch?: string;
    readonly head_sha?: string;
  } | null;
};

export type RepositoryActionsCaches = {
  readonly total_count: number;
  readonly actions_caches: ReadonlyArray<{
    readonly id?: number;
    readonly ref?: string;
    readonly key?: string;
    readonly version?: string;
    readonly last_accessed_at?: string;
    readonly created_at?: string;
    readonly size_in_bytes?: number;
  }>;
};

export type Job = {
  readonly id: number;
  readonly run_id: number;
  readonly run_url: string;
  readonly run_attempt?: number;
  readonly node_id: string;
  readonly head_sha: string;
  readonly url: string;
  readonly html_url: string | null;
  readonly status: 'queued' | 'in_progress' | 'completed';
  readonly conclusion:
    | 'success'
    | 'failure'
    | 'neutral'
    | 'cancelled'
    | 'skipped'
    | 'timed_out'
    | 'action_required'
    | null;
  readonly started_at: string;
  readonly completed_at: string | null;
  readonly name: string;
  readonly steps?: ReadonlyArray<{
    readonly status: 'queued' | 'in_progress' | 'completed';
    readonly conclusion: string | null;
    readonly name: string;
    readonly number: number;
    readonly started_at?: string | null;
    readonly completed_at?: string | null;
  }>;
  readonly check_run_url: string;
  readonly labels: ReadonlyArray<string>;
  readonly runner_id: number | null;
  readonly runner_name: string | null;
  readonly runner_group_id: number | null;
  readonly runner_group_name: string | null;
};

export type ActionsEnabled = boolean;

export type ActionsRepositoryPermissions = {
  readonly enabled: ActionsEnabled;
  readonly allowed_actions?: AllowedActions;
  readonly selected_actions_url?: SelectedActionsUrl;
};

export type ActionsWorkflowAccessToRepository = {
  readonly access_level: 'none' | 'organization' | 'enterprise';
};

export type ReferencedWorkflow = {
  readonly path: string;
  readonly sha: string;
  readonly ref?: string;
};

export type PullRequestMinimal = {
  readonly id: number;
  readonly number: number;
  readonly url: string;
  readonly head: {
    readonly ref: string;
    readonly sha: string;
    readonly repo: {
      readonly id: number;
      readonly url: string;
      readonly name: string;
    };
  };
  readonly base: {
    readonly ref: string;
    readonly sha: string;
    readonly repo: {
      readonly id: number;
      readonly url: string;
      readonly name: string;
    };
  };
};

export type SimpleCommit = {
  readonly id: string;
  readonly tree_id: string;
  readonly message: string;
  readonly timestamp: string;
  readonly author: { readonly name: string; readonly email: string } | null;
  readonly committer: { readonly name: string; readonly email: string } | null;
} | null;

export type WorkflowRun = {
  readonly id: number;
  readonly name?: string | null;
  readonly node_id: string;
  readonly check_suite_id?: number;
  readonly check_suite_node_id?: string;
  readonly head_branch: string | null;
  readonly head_sha: string;
  readonly path: string;
  readonly run_number: number;
  readonly run_attempt?: number;
  readonly referenced_workflows?: ReadonlyArray<ReferencedWorkflow> | null;
  readonly event: string;
  readonly status: string | null;
  readonly conclusion: string | null;
  readonly workflow_id: number;
  readonly url: string;
  readonly html_url: string;
  readonly pull_requests: ReadonlyArray<PullRequestMinimal> | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly actor?: SimpleUser;
  readonly triggering_actor?: SimpleUser;
  readonly run_started_at?: string;
  readonly jobs_url: string;
  readonly logs_url: string;
  readonly check_suite_url: string;
  readonly artifacts_url: string;
  readonly cancel_url: string;
  readonly rerun_url: string;
  readonly previous_attempt_url?: string | null;
  readonly workflow_url: string;
  readonly head_commit: SimpleCommit;
  readonly repository: MinimalRepository;
  readonly head_repository: MinimalRepository;
  readonly head_repository_id?: number;
  readonly display_title: string;
};

export type EnvironmentApproval = {
  readonly environments: ReadonlyArray<{
    readonly id?: number;
    readonly node_id?: string;
    readonly name?: string;
    readonly url?: string;
    readonly html_url?: string;
    readonly created_at?: string;
    readonly updated_at?: string;
  }>;
  readonly state: 'approved' | 'rejected';
  readonly user: SimpleUser;
  readonly comment: string;
};

export type DeploymentReviewerType = 'User' | 'Team';

export type PendingDeployment = {
  readonly environment: {
    readonly id?: number;
    readonly node_id?: string;
    readonly name?: string;
    readonly url?: string;
    readonly html_url?: string;
  };
  readonly wait_timer: number;
  readonly wait_timer_started_at: string | null;
  readonly current_user_can_approve: boolean;
  readonly reviewers: ReadonlyArray<{
    readonly type?: DeploymentReviewerType;
    readonly reviewer?: SimpleUser | Team;
  }>;
};

export type Deployment = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly sha: string;
  readonly ref: string;
  readonly task: string;
  readonly payload: unknown | string;
  readonly original_environment?: string;
  readonly environment: string;
  readonly description: string | null;
  readonly creator: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly statuses_url: string;
  readonly repository_url: string;
  readonly transient_environment?: boolean;
  readonly production_environment?: boolean;
  readonly performed_via_github_app?: GitHubApp;
};

export type WorkflowRunUsage = {
  readonly billable: {
    readonly UBUNTU?: {
      readonly total_ms: number;
      readonly jobs: number;
      readonly job_runs?: ReadonlyArray<{
        readonly job_id: number;
        readonly duration_ms: number;
      }>;
    };
    readonly MACOS?: {
      readonly total_ms: number;
      readonly jobs: number;
      readonly job_runs?: ReadonlyArray<{
        readonly job_id: number;
        readonly duration_ms: number;
      }>;
    };
    readonly WINDOWS?: {
      readonly total_ms: number;
      readonly jobs: number;
      readonly job_runs?: ReadonlyArray<{
        readonly job_id: number;
        readonly duration_ms: number;
      }>;
    };
  };
  readonly run_duration_ms?: number;
};

export type ActionsSecret = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
};

export type Workflow = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly path: string;
  readonly state:
    | 'active'
    | 'deleted'
    | 'disabled_fork'
    | 'disabled_inactivity'
    | 'disabled_manually';
  readonly created_at: string;
  readonly updated_at: string;
  readonly url: string;
  readonly html_url: string;
  readonly badge_url: string;
  readonly deleted_at?: string;
};

export type WorkflowUsage = {
  readonly billable: {
    readonly UBUNTU?: { readonly total_ms?: number };
    readonly MACOS?: { readonly total_ms?: number };
    readonly WINDOWS?: { readonly total_ms?: number };
  };
};

export type AutolinkReference = {
  readonly id: number;
  readonly key_prefix: string;
  readonly url_template: string;
  readonly is_alphanumeric: boolean;
};

export type ProtectedBranchRequiredStatusCheck = {
  readonly url?: string;
  readonly enforcement_level?: string;
  readonly contexts: ReadonlyArray<string>;
  readonly checks: ReadonlyArray<{
    readonly context: string;
    readonly app_id: number | null;
  }>;
  readonly contexts_url?: string;
  readonly strict?: boolean;
};

export type ProtectedBranchAdminEnforced = {
  readonly url: string;
  readonly enabled: boolean;
};

export type ProtectedBranchPullRequestReview = {
  readonly url?: string;
  readonly dismissal_restrictions?: {
    readonly users?: ReadonlyArray<SimpleUser>;
    readonly teams?: ReadonlyArray<Team>;
    readonly apps?: ReadonlyArray<GitHubApp>;
    readonly url?: string;
    readonly users_url?: string;
    readonly teams_url?: string;
  };
  readonly bypass_pull_request_allowances?: {
    readonly users?: ReadonlyArray<SimpleUser>;
    readonly teams?: ReadonlyArray<Team>;
    readonly apps?: ReadonlyArray<GitHubApp>;
  };
  readonly dismiss_stale_reviews: boolean;
  readonly require_code_owner_reviews: boolean;
  readonly required_approving_review_count?: number;
  readonly require_last_push_approval?: boolean;
};

export type BranchRestrictionPolicy = {
  readonly url: string;
  readonly users_url: string;
  readonly teams_url: string;
  readonly apps_url: string;
  readonly users: ReadonlyArray<{
    readonly login?: string;
    readonly id?: number;
    readonly node_id?: string;
    readonly avatar_url?: string;
    readonly gravatar_id?: string;
    readonly url?: string;
    readonly html_url?: string;
    readonly followers_url?: string;
    readonly following_url?: string;
    readonly gists_url?: string;
    readonly starred_url?: string;
    readonly subscriptions_url?: string;
    readonly organizations_url?: string;
    readonly repos_url?: string;
    readonly events_url?: string;
    readonly received_events_url?: string;
    readonly type?: string;
    readonly site_admin?: boolean;
  }>;
  readonly teams: ReadonlyArray<{
    readonly id?: number;
    readonly node_id?: string;
    readonly url?: string;
    readonly html_url?: string;
    readonly name?: string;
    readonly slug?: string;
    readonly description?: string | null;
    readonly privacy?: string;
    readonly permission?: string;
    readonly members_url?: string;
    readonly repositories_url?: string;
    readonly parent?: string | null;
  }>;
  readonly apps: ReadonlyArray<{
    readonly id?: number;
    readonly slug?: string;
    readonly node_id?: string;
    readonly owner?: {
      readonly login?: string;
      readonly id?: number;
      readonly node_id?: string;
      readonly url?: string;
      readonly repos_url?: string;
      readonly events_url?: string;
      readonly hooks_url?: string;
      readonly issues_url?: string;
      readonly members_url?: string;
      readonly public_members_url?: string;
      readonly avatar_url?: string;
      readonly description?: string;
      readonly gravatar_id?: string;
      readonly html_url?: string;
      readonly followers_url?: string;
      readonly following_url?: string;
      readonly gists_url?: string;
      readonly starred_url?: string;
      readonly subscriptions_url?: string;
      readonly organizations_url?: string;
      readonly received_events_url?: string;
      readonly type?: string;
      readonly site_admin?: boolean;
    };
    readonly name?: string;
    readonly description?: string;
    readonly external_url?: string;
    readonly html_url?: string;
    readonly created_at?: string;
    readonly updated_at?: string;
    readonly permissions?: {
      readonly metadata?: string;
      readonly contents?: string;
      readonly issues?: string;
      readonly single_file?: string;
    };
    readonly events?: ReadonlyArray<string>;
  }>;
};

export type BranchProtection = {
  readonly url?: string;
  readonly enabled?: boolean;
  readonly required_status_checks?: ProtectedBranchRequiredStatusCheck;
  readonly enforce_admins?: ProtectedBranchAdminEnforced;
  readonly required_pull_request_reviews?: ProtectedBranchPullRequestReview;
  readonly restrictions?: BranchRestrictionPolicy;
  readonly required_linear_history?: { readonly enabled?: boolean };
  readonly allow_force_pushes?: { readonly enabled?: boolean };
  readonly allow_deletions?: { readonly enabled?: boolean };
  readonly block_creations?: { readonly enabled?: boolean };
  readonly required_conversation_resolution?: { readonly enabled?: boolean };
  readonly name?: string;
  readonly protection_url?: string;
  readonly required_signatures?: {
    readonly url: string;
    readonly enabled: boolean;
  };
  readonly lock_branch?: { readonly enabled?: boolean };
  readonly allow_fork_syncing?: { readonly enabled?: boolean };
};

export type ShortBranch = {
  readonly name: string;
  readonly commit: { readonly sha: string; readonly url: string };
  readonly protected: boolean;
  readonly protection?: BranchProtection;
  readonly protection_url?: string;
};

export type GitUser = {
  readonly name?: string;
  readonly email?: string;
  readonly date?: string;
} | null;

export type Verification = {
  readonly verified: boolean;
  readonly reason: string;
  readonly payload: string | null;
  readonly signature: string | null;
};

export type DiffEntry = {
  readonly sha: string;
  readonly filename: string;
  readonly status:
    | 'added'
    | 'removed'
    | 'modified'
    | 'renamed'
    | 'copied'
    | 'changed'
    | 'unchanged';
  readonly additions: number;
  readonly deletions: number;
  readonly changes: number;
  readonly blob_url: string;
  readonly raw_url: string;
  readonly contents_url: string;
  readonly patch?: string;
  readonly previous_filename?: string;
};

export type Commit = {
  readonly url: string;
  readonly sha: string;
  readonly node_id: string;
  readonly html_url: string;
  readonly comments_url: string;
  readonly commit: {
    readonly url: string;
    readonly author: GitUser;
    readonly committer: GitUser;
    readonly message: string;
    readonly comment_count: number;
    readonly tree: { readonly sha: string; readonly url: string };
    readonly verification?: Verification;
  };
  readonly author: SimpleUser;
  readonly committer: SimpleUser;
  readonly parents: ReadonlyArray<{
    readonly sha: string;
    readonly url: string;
    readonly html_url?: string;
  }>;
  readonly stats?: {
    readonly additions?: number;
    readonly deletions?: number;
    readonly total?: number;
  };
  readonly files?: ReadonlyArray<DiffEntry>;
};

export type BranchWithProtection = {
  readonly name: string;
  readonly commit: Commit;
  readonly _links: { readonly html: string; readonly self: string };
  readonly protected: boolean;
  readonly protection: BranchProtection;
  readonly protection_url: string;
  readonly pattern?: string;
  readonly required_approving_review_count?: number;
};

export type StatusCheckPolicy = {
  readonly url: string;
  readonly strict: boolean;
  readonly contexts: ReadonlyArray<string>;
  readonly checks: ReadonlyArray<{
    readonly context: string;
    readonly app_id: number | null;
  }>;
  readonly contexts_url: string;
};

export type ProtectedBranch = {
  readonly url: string;
  readonly required_status_checks?: StatusCheckPolicy;
  readonly required_pull_request_reviews?: {
    readonly url: string;
    readonly dismiss_stale_reviews?: boolean;
    readonly require_code_owner_reviews?: boolean;
    readonly required_approving_review_count?: number;
    readonly require_last_push_approval?: boolean;
    readonly dismissal_restrictions?: {
      readonly url: string;
      readonly users_url: string;
      readonly teams_url: string;
      readonly users: ReadonlyArray<SimpleUser>;
      readonly teams: ReadonlyArray<Team>;
      readonly apps?: ReadonlyArray<GitHubApp>;
    };
    readonly bypass_pull_request_allowances?: {
      readonly users: ReadonlyArray<SimpleUser>;
      readonly teams: ReadonlyArray<Team>;
      readonly apps?: ReadonlyArray<GitHubApp>;
    };
  };
  readonly required_signatures?: {
    readonly url: string;
    readonly enabled: boolean;
  };
  readonly enforce_admins?: { readonly url: string; readonly enabled: boolean };
  readonly required_linear_history?: { readonly enabled: boolean };
  readonly allow_force_pushes?: { readonly enabled: boolean };
  readonly allow_deletions?: { readonly enabled: boolean };
  readonly restrictions?: BranchRestrictionPolicy;
  readonly required_conversation_resolution?: { readonly enabled?: boolean };
  readonly block_creations?: { readonly enabled: boolean };
  readonly lock_branch?: { readonly enabled?: boolean };
  readonly allow_fork_syncing?: { readonly enabled?: boolean };
};

export type CheckRun = {
  readonly id: number;
  readonly head_sha: string;
  readonly node_id: string;
  readonly external_id: string | null;
  readonly url: string;
  readonly html_url: string | null;
  readonly details_url: string | null;
  readonly status: 'queued' | 'in_progress' | 'completed';
  readonly conclusion:
    | 'success'
    | 'failure'
    | 'neutral'
    | 'cancelled'
    | 'skipped'
    | 'timed_out'
    | 'action_required'
    | null;
  readonly started_at: string | null;
  readonly completed_at: string | null;
  readonly output: {
    readonly title: string | null;
    readonly summary: string | null;
    readonly text: string | null;
    readonly annotations_count: number;
    readonly annotations_url: string;
  };
  readonly name: string;
  readonly check_suite: { readonly id: number } | null;
  readonly app: GitHubApp;
  readonly pull_requests: ReadonlyArray<PullRequestMinimal>;
  readonly deployment?: Deployment;
};

export type CheckAnnotation = {
  readonly path: string;
  readonly start_line: number;
  readonly end_line: number;
  readonly start_column: number | null;
  readonly end_column: number | null;
  readonly annotation_level: string | null;
  readonly title: string | null;
  readonly message: string | null;
  readonly raw_details: string | null;
  readonly blob_href: string;
};

export type CheckSuite = {
  readonly id: number;
  readonly node_id: string;
  readonly head_branch: string | null;
  readonly head_sha: string;
  readonly status: 'queued' | 'in_progress' | 'completed' | null;
  readonly conclusion:
    | 'success'
    | 'failure'
    | 'neutral'
    | 'cancelled'
    | 'skipped'
    | 'timed_out'
    | 'action_required'
    | null;
  readonly url: string | null;
  readonly before: string | null;
  readonly after: string | null;
  readonly pull_requests: ReadonlyArray<PullRequestMinimal> | null;
  readonly app: GitHubApp;
  readonly repository: MinimalRepository;
  readonly created_at: string | null;
  readonly updated_at: string | null;
  readonly head_commit: SimpleCommit;
  readonly latest_check_runs_count: number;
  readonly check_runs_url: string;
  readonly rerequestable?: boolean;
  readonly runs_rerequestable?: boolean;
};

export type CheckSuitePreference = {
  readonly preferences: {
    readonly auto_trigger_checks?: ReadonlyArray<{
      readonly app_id: number;
      readonly setting: boolean;
    }>;
  };
  readonly repository: MinimalRepository;
};

export type CodeScanningAlertRuleSummary = {
  readonly id?: string | null;
  readonly name?: string;
  readonly tags?: ReadonlyArray<string> | null;
  readonly severity?: 'none' | 'note' | 'warning' | 'error' | null;
  readonly description?: string;
};

export type CodeScanningAlertItems = {
  readonly number: AlertNumber;
  readonly created_at: AlertCreatedAt;
  readonly updated_at?: AlertUpdatedAt;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly instances_url: AlertInstancesUrl;
  readonly state: CodeScanningAlertState;
  readonly fixed_at?: AlertFixedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_reason: CodeScanningAlertDismissedReason;
  readonly dismissed_comment?: CodeScanningAlertDismissedComment;
  readonly rule: CodeScanningAlertRuleSummary;
  readonly tool: CodeScanningAnalysisTool;
  readonly most_recent_instance: CodeScanningAlertInstance;
};

export type CodeScanningAlert = {
  readonly number: AlertNumber;
  readonly created_at: AlertCreatedAt;
  readonly updated_at?: AlertUpdatedAt;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly instances_url: AlertInstancesUrl;
  readonly state: CodeScanningAlertState;
  readonly fixed_at?: AlertFixedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_reason: CodeScanningAlertDismissedReason;
  readonly dismissed_comment?: CodeScanningAlertDismissedComment;
  readonly rule: CodeScanningAlertRule;
  readonly tool: CodeScanningAnalysisTool;
  readonly most_recent_instance: CodeScanningAlertInstance;
};

export type CodeScanningAlertSetState = 'open' | 'dismissed';

export type CodeScanningAnalysisSarifId = string;

export type CodeScanningAnalysisCommitSha = string;

export type CodeScanningAnalysisEnvironment = string;

export type CodeScanningAnalysisCreatedAt = string;

export type CodeScanningAnalysisUrl = string;

export type CodeScanningAnalysis = {
  readonly ref: CodeScanningRef;
  readonly commit_sha: CodeScanningAnalysisCommitSha;
  readonly analysis_key: CodeScanningAnalysisAnalysisKey;
  readonly environment: CodeScanningAnalysisEnvironment;
  readonly category?: CodeScanningAnalysisCategory;
  readonly error: string;
  readonly created_at: CodeScanningAnalysisCreatedAt;
  readonly results_count: number;
  readonly rules_count: number;
  readonly id: number;
  readonly url: CodeScanningAnalysisUrl;
  readonly sarif_id: CodeScanningAnalysisSarifId;
  readonly tool: CodeScanningAnalysisTool;
  readonly deletable: boolean;
  readonly warning: string;
};

export type AnalysisDeletion = {
  readonly next_analysis_url: string | null;
  readonly confirm_delete_url: string | null;
};

export type CodeQlDatabase = {
  readonly id: number;
  readonly name: string;
  readonly language: string;
  readonly uploader: SimpleUser;
  readonly content_type: string;
  readonly size: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly url: string;
};

export type CodeScanningAnalysisSarifFile = string;

export type CodeScanningSarifsReceipt = {
  readonly id?: CodeScanningAnalysisSarifId;
  readonly url?: string;
};

export type CodeScanningSarifsStatus = {
  readonly processing_status?: 'pending' | 'complete' | 'failed';
  readonly analyses_url?: string | null;
  readonly errors?: ReadonlyArray<string> | null;
};

export type CodeownersErrors = {
  readonly errors: ReadonlyArray<{
    readonly line: number;
    readonly column: number;
    readonly source?: string;
    readonly kind: string;
    readonly suggestion?: string | null;
    readonly message: string;
    readonly path: string;
  }>;
};

export type Collaborator = {
  readonly login: string;
  readonly id: number;
  readonly email?: string | null;
  readonly name?: string | null;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly site_admin: boolean;
  readonly permissions?: {
    readonly pull: boolean;
    readonly triage?: boolean;
    readonly push: boolean;
    readonly maintain?: boolean;
    readonly admin: boolean;
  };
  readonly role_name: string;
};

export type RepositoryInvitation = {
  readonly id: number;
  readonly repository: MinimalRepository;
  readonly invitee: SimpleUser;
  readonly inviter: SimpleUser;
  readonly permissions: 'read' | 'write' | 'admin' | 'triage' | 'maintain';
  readonly created_at: string;
  readonly expired?: boolean;
  readonly url: string;
  readonly html_url: string;
  readonly node_id: string;
};

export type RepositoryCollaboratorPermission = {
  readonly permission: string;
  readonly role_name: string;
  readonly user: Collaborator;
};

export type CommitComment = {
  readonly html_url: string;
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly body: string;
  readonly path: string | null;
  readonly position: number | null;
  readonly line: number | null;
  readonly commit_id: string;
  readonly user: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly author_association: AuthorAssociation;
  readonly reactions?: ReactionRollup;
};

export type BranchShort = {
  readonly name: string;
  readonly commit: { readonly sha: string; readonly url: string };
  readonly protected: boolean;
};

export type Link = { readonly href: string };

export type AutoMerge = {
  readonly enabled_by: SimpleUser;
  readonly merge_method: 'merge' | 'squash' | 'rebase';
  readonly commit_title: string;
  readonly commit_message: string;
} | null;

export type PullRequestSimple = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly html_url: string;
  readonly diff_url: string;
  readonly patch_url: string;
  readonly issue_url: string;
  readonly commits_url: string;
  readonly review_comments_url: string;
  readonly review_comment_url: string;
  readonly comments_url: string;
  readonly statuses_url: string;
  readonly number: number;
  readonly state: string;
  readonly locked: boolean;
  readonly title: string;
  readonly user: SimpleUser;
  readonly body: string | null;
  readonly labels: ReadonlyArray<{
    readonly id: number;
    readonly node_id: string;
    readonly url: string;
    readonly name: string;
    readonly description: string;
    readonly color: string;
    readonly default: boolean;
  }>;
  readonly milestone: Milestone;
  readonly active_lock_reason?: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly closed_at: string | null;
  readonly merged_at: string | null;
  readonly merge_commit_sha: string | null;
  readonly assignee: SimpleUser;
  readonly assignees?: ReadonlyArray<SimpleUser> | null;
  readonly requested_reviewers?: ReadonlyArray<SimpleUser> | null;
  readonly requested_teams?: ReadonlyArray<Team> | null;
  readonly head: {
    readonly label: string;
    readonly ref: string;
    readonly repo: Repository;
    readonly sha: string;
    readonly user: SimpleUser;
  };
  readonly base: {
    readonly label: string;
    readonly ref: string;
    readonly repo: Repository;
    readonly sha: string;
    readonly user: SimpleUser;
  };
  readonly _links: {
    readonly comments: Link;
    readonly commits: Link;
    readonly statuses: Link;
    readonly html: Link;
    readonly issue: Link;
    readonly review_comments: Link;
    readonly review_comment: Link;
    readonly self: Link;
  };
  readonly author_association: AuthorAssociation;
  readonly auto_merge: AutoMerge;
  readonly draft?: boolean;
};

export type SimpleCommitStatus = {
  readonly description: string | null;
  readonly id: number;
  readonly node_id: string;
  readonly state: string;
  readonly context: string;
  readonly target_url: string | null;
  readonly required?: boolean | null;
  readonly avatar_url: string | null;
  readonly url: string;
  readonly created_at: string;
  readonly updated_at: string;
};

export type CombinedCommitStatus = {
  readonly state: string;
  readonly statuses: ReadonlyArray<SimpleCommitStatus>;
  readonly sha: string;
  readonly total_count: number;
  readonly repository: MinimalRepository;
  readonly commit_url: string;
  readonly url: string;
};

export type Status = {
  readonly url: string;
  readonly avatar_url: string | null;
  readonly id: number;
  readonly node_id: string;
  readonly state: string;
  readonly description: string | null;
  readonly target_url: string | null;
  readonly context: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly creator: SimpleUser;
};

export type CommunityHealthFile = {
  readonly url: string;
  readonly html_url: string;
} | null;

export type CommunityProfile = {
  readonly health_percentage: number;
  readonly description: string | null;
  readonly documentation: string | null;
  readonly files: {
    readonly code_of_conduct: CodeOfConductSimple;
    readonly code_of_conduct_file: CommunityHealthFile;
    readonly license: LicenseSimple;
    readonly contributing: CommunityHealthFile;
    readonly readme: CommunityHealthFile;
    readonly issue_template: CommunityHealthFile;
    readonly pull_request_template: CommunityHealthFile;
  };
  readonly updated_at: string | null;
  readonly content_reports_enabled?: boolean;
};

export type CommitComparison = {
  readonly url: string;
  readonly html_url: string;
  readonly permalink_url: string;
  readonly diff_url: string;
  readonly patch_url: string;
  readonly base_commit: Commit;
  readonly merge_base_commit: Commit;
  readonly status: 'diverged' | 'ahead' | 'behind' | 'identical';
  readonly ahead_by: number;
  readonly behind_by: number;
  readonly total_commits: number;
  readonly commits: ReadonlyArray<Commit>;
  readonly files?: ReadonlyArray<DiffEntry>;
};

export type ContentDirectory = ReadonlyArray<{
  readonly type: 'dir' | 'file' | 'submodule' | 'symlink';
  readonly size: number;
  readonly name: string;
  readonly path: string;
  readonly content?: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string | null;
  readonly html_url: string | null;
  readonly download_url: string | null;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
}>;

export type ContentFile = {
  readonly type: 'file';
  readonly encoding: string;
  readonly size: number;
  readonly name: string;
  readonly path: string;
  readonly content: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string | null;
  readonly html_url: string | null;
  readonly download_url: string | null;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
  readonly target?: string;
  readonly submodule_git_url?: string;
};

export type SymlinkContent = {
  readonly type: 'symlink';
  readonly target: string;
  readonly size: number;
  readonly name: string;
  readonly path: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string | null;
  readonly html_url: string | null;
  readonly download_url: string | null;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
};

export type SubmoduleContent = {
  readonly type: 'submodule';
  readonly submodule_git_url: string;
  readonly size: number;
  readonly name: string;
  readonly path: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string | null;
  readonly html_url: string | null;
  readonly download_url: string | null;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
};

export type FileCommit = {
  readonly content: {
    readonly name?: string;
    readonly path?: string;
    readonly sha?: string;
    readonly size?: number;
    readonly url?: string;
    readonly html_url?: string;
    readonly git_url?: string;
    readonly download_url?: string;
    readonly type?: string;
    readonly _links?: {
      readonly self?: string;
      readonly git?: string;
      readonly html?: string;
    };
  } | null;
  readonly commit: {
    readonly sha?: string;
    readonly node_id?: string;
    readonly url?: string;
    readonly html_url?: string;
    readonly author?: {
      readonly date?: string;
      readonly name?: string;
      readonly email?: string;
    };
    readonly committer?: {
      readonly date?: string;
      readonly name?: string;
      readonly email?: string;
    };
    readonly message?: string;
    readonly tree?: { readonly url?: string; readonly sha?: string };
    readonly parents?: ReadonlyArray<{
      readonly url?: string;
      readonly html_url?: string;
      readonly sha?: string;
    }>;
    readonly verification?: {
      readonly verified?: boolean;
      readonly reason?: string;
      readonly signature?: string | null;
      readonly payload?: string | null;
    };
  };
};

export type Contributor = {
  readonly login?: string;
  readonly id?: number;
  readonly node_id?: string;
  readonly avatar_url?: string;
  readonly gravatar_id?: string | null;
  readonly url?: string;
  readonly html_url?: string;
  readonly followers_url?: string;
  readonly following_url?: string;
  readonly gists_url?: string;
  readonly starred_url?: string;
  readonly subscriptions_url?: string;
  readonly organizations_url?: string;
  readonly repos_url?: string;
  readonly events_url?: string;
  readonly received_events_url?: string;
  readonly type: string;
  readonly site_admin?: boolean;
  readonly contributions: number;
  readonly email?: string;
  readonly name?: string;
};

export type DependabotAlert = {
  readonly number: AlertNumber;
  readonly state: 'dismissed' | 'fixed' | 'open';
  readonly dependency: {
    readonly package?: DependabotAlertPackage;
    readonly manifest_path?: string;
    readonly scope?: 'development' | 'runtime' | null;
  };
  readonly security_advisory: DependabotAlertSecurityAdvisory;
  readonly security_vulnerability: DependabotAlertSecurityVulnerability;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly created_at: AlertCreatedAt;
  readonly updated_at: AlertUpdatedAt;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_reason:
    | 'fix_started'
    | 'inaccurate'
    | 'no_bandwidth'
    | 'not_used'
    | 'tolerable_risk'
    | null;
  readonly dismissed_comment: string | null;
  readonly fixed_at: AlertFixedAt;
};

export type DependabotSecret = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
};

export type DependencyGraphDiff = ReadonlyArray<{
  readonly change_type: 'added' | 'removed';
  readonly manifest: string;
  readonly ecosystem: string;
  readonly name: string;
  readonly version: string;
  readonly package_url: string | null;
  readonly license: string | null;
  readonly source_repository_url: string | null;
  readonly vulnerabilities: ReadonlyArray<{
    readonly severity: string;
    readonly advisory_ghsa_id: string;
    readonly advisory_summary: string;
    readonly advisory_url: string;
  }>;
  readonly scope: 'unknown' | 'runtime' | 'development';
}>;

export type Metadata = unknown;

export type Snapshot = {
  readonly version: number;
  readonly job: {
    readonly id: string;
    readonly correlator: string;
    readonly html_url?: string;
  };
  readonly sha: string;
  readonly ref: string;
  readonly detector: {
    readonly name: string;
    readonly version: string;
    readonly url: string;
  };
  readonly metadata?: Metadata;
  readonly manifests?: unknown;
  readonly scanned: string;
};

export type DeploymentStatus = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly state:
    | 'error'
    | 'failure'
    | 'inactive'
    | 'pending'
    | 'success'
    | 'queued'
    | 'in_progress';
  readonly creator: SimpleUser;
  readonly description: string;
  readonly environment?: string;
  readonly target_url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly deployment_url: string;
  readonly repository_url: string;
  readonly environment_url?: string;
  readonly log_url?: string;
  readonly performed_via_github_app?: GitHubApp;
};

export type WaitTimer = number;

export type DeploymentBranchPolicySettings = {
  readonly protected_branches: boolean;
  readonly custom_branch_policies: boolean;
} | null;

export type Environment = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly url: string;
  readonly html_url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly protection_rules?: ReadonlyArray<
    | {
        readonly id: number;
        readonly node_id: string;
        readonly type: string;
        readonly wait_timer?: WaitTimer;
      }
    | {
        readonly id: number;
        readonly node_id: string;
        readonly type: string;
        readonly reviewers?: ReadonlyArray<{
          readonly type?: DeploymentReviewerType;
          readonly reviewer?: SimpleUser | Team;
        }>;
      }
    | { readonly id: number; readonly node_id: string; readonly type: string }
  >;
  readonly deployment_branch_policy?: DeploymentBranchPolicySettings;
};

export type DeploymentBranchPolicy = {
  readonly id?: number;
  readonly node_id?: string;
  readonly name?: string;
};

export type DeploymentBranchPolicyNamePattern = { readonly name: string };

export type ShortBlob = { readonly url: string; readonly sha: string };

export type Blob = {
  readonly content: string;
  readonly encoding: string;
  readonly url: string;
  readonly sha: string;
  readonly size: number | null;
  readonly node_id: string;
  readonly highlighted_content?: string;
};

export type GitCommit = {
  readonly sha: string;
  readonly node_id: string;
  readonly url: string;
  readonly author: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly committer: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly message: string;
  readonly tree: { readonly sha: string; readonly url: string };
  readonly parents: ReadonlyArray<{
    readonly sha: string;
    readonly url: string;
    readonly html_url: string;
  }>;
  readonly verification: {
    readonly verified: boolean;
    readonly reason: string;
    readonly signature: string | null;
    readonly payload: string | null;
  };
  readonly html_url: string;
};

export type GitReference = {
  readonly ref: string;
  readonly node_id: string;
  readonly url: string;
  readonly object: {
    readonly type: string;
    readonly sha: string;
    readonly url: string;
  };
};

export type GitTag = {
  readonly node_id: string;
  readonly tag: string;
  readonly sha: string;
  readonly url: string;
  readonly message: string;
  readonly tagger: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly object: {
    readonly sha: string;
    readonly type: string;
    readonly url: string;
  };
  readonly verification?: Verification;
};

export type GitTree = {
  readonly sha: string;
  readonly url: string;
  readonly truncated: boolean;
  readonly tree: ReadonlyArray<{
    readonly path?: string;
    readonly mode?: string;
    readonly type?: string;
    readonly sha?: string;
    readonly size?: number;
    readonly url?: string;
  }>;
};

export type HookResponse = {
  readonly code: number | null;
  readonly status: string | null;
  readonly message: string | null;
};

export type Webhook = {
  readonly type: string;
  readonly id: number;
  readonly name: string;
  readonly active: boolean;
  readonly events: ReadonlyArray<string>;
  readonly config: {
    readonly email?: string;
    readonly password?: string;
    readonly room?: string;
    readonly subdomain?: string;
    readonly url?: WebhookConfigUrl;
    readonly insecure_ssl?: WebhookConfigInsecureSsl;
    readonly content_type?: WebhookConfigContentType;
    readonly digest?: string;
    readonly secret?: WebhookConfigSecret;
    readonly token?: string;
  };
  readonly updated_at: string;
  readonly created_at: string;
  readonly url: string;
  readonly test_url: string;
  readonly ping_url: string;
  readonly deliveries_url?: string;
  readonly last_response: HookResponse;
};

export type Import = {
  readonly vcs: string | null;
  readonly use_lfs?: boolean;
  readonly vcs_url: string;
  readonly svc_root?: string;
  readonly tfvc_project?: string;
  readonly status:
    | 'auth'
    | 'error'
    | 'none'
    | 'detecting'
    | 'choose'
    | 'auth_failed'
    | 'importing'
    | 'mapping'
    | 'waiting_to_push'
    | 'pushing'
    | 'complete'
    | 'setup'
    | 'unknown'
    | 'detection_found_multiple'
    | 'detection_found_nothing'
    | 'detection_needs_auth';
  readonly status_text?: string | null;
  readonly failed_step?: string | null;
  readonly error_message?: string | null;
  readonly import_percent?: number | null;
  readonly commit_count?: number | null;
  readonly push_percent?: number | null;
  readonly has_large_files?: boolean;
  readonly large_files_size?: number;
  readonly large_files_count?: number;
  readonly project_choices?: ReadonlyArray<{
    readonly vcs?: string;
    readonly tfvc_project?: string;
    readonly human_name?: string;
  }>;
  readonly message?: string;
  readonly authors_count?: number | null;
  readonly url: string;
  readonly html_url: string;
  readonly authors_url: string;
  readonly repository_url: string;
  readonly svn_root?: string;
};

export type PorterAuthor = {
  readonly id: number;
  readonly remote_id: string;
  readonly remote_name: string;
  readonly email: string;
  readonly name: string;
  readonly url: string;
  readonly import_url: string;
};

export type PorterLargeFile = {
  readonly ref_name: string;
  readonly path: string;
  readonly oid: string;
  readonly size: number;
};

export type IssueEventLabel = {
  readonly name: string | null;
  readonly color: string | null;
};

export type IssueEventDismissedReview = {
  readonly state: string;
  readonly review_id: number;
  readonly dismissal_message: string | null;
  readonly dismissal_commit_id?: string | null;
};

export type IssueEventMilestone = { readonly title: string };

export type IssueEventProjectCard = {
  readonly url: string;
  readonly id: number;
  readonly project_url: string;
  readonly project_id: number;
  readonly column_name: string;
  readonly previous_column_name?: string;
};

export type IssueEventRename = { readonly from: string; readonly to: string };

export type IssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly issue?: Issue;
  readonly label?: IssueEventLabel;
  readonly assignee?: SimpleUser;
  readonly assigner?: SimpleUser;
  readonly review_requester?: SimpleUser;
  readonly requested_reviewer?: SimpleUser;
  readonly requested_team?: Team;
  readonly dismissed_review?: IssueEventDismissedReview;
  readonly milestone?: IssueEventMilestone;
  readonly project_card?: IssueEventProjectCard;
  readonly rename?: IssueEventRename;
  readonly author_association?: AuthorAssociation;
  readonly lock_reason?: string | null;
  readonly performed_via_github_app?: GitHubApp;
};

export type LabeledIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly label: { readonly name: string; readonly color: string };
};

export type UnlabeledIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly label: { readonly name: string; readonly color: string };
};

export type AssignedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly assignee: SimpleUser;
  readonly assigner: SimpleUser;
};

export type UnassignedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly assignee: SimpleUser;
  readonly assigner: SimpleUser;
};

export type MilestonedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly milestone: { readonly title: string };
};

export type DemilestonedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly milestone: { readonly title: string };
};

export type RenamedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly rename: { readonly from: string; readonly to: string };
};

export type ReviewRequestedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly review_requester: SimpleUser;
  readonly requested_team?: Team;
  readonly requested_reviewer?: SimpleUser;
};

export type ReviewRequestRemovedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly review_requester: SimpleUser;
  readonly requested_team?: Team;
  readonly requested_reviewer?: SimpleUser;
};

export type ReviewDismissedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly dismissed_review: {
    readonly state: string;
    readonly review_id: number;
    readonly dismissal_message: string | null;
    readonly dismissal_commit_id?: string;
  };
};

export type LockedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly lock_reason: string | null;
};

export type AddedToProjectIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly project_card?: {
    readonly id: number;
    readonly url: string;
    readonly project_id: number;
    readonly project_url: string;
    readonly column_name: string;
    readonly previous_column_name?: string;
  };
};

export type MovedColumnInProjectIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly project_card?: {
    readonly id: number;
    readonly url: string;
    readonly project_id: number;
    readonly project_url: string;
    readonly column_name: string;
    readonly previous_column_name?: string;
  };
};

export type RemovedFromProjectIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly project_card?: {
    readonly id: number;
    readonly url: string;
    readonly project_id: number;
    readonly project_url: string;
    readonly column_name: string;
    readonly previous_column_name?: string;
  };
};

export type ConvertedNoteToIssueIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly project_card?: {
    readonly id: number;
    readonly url: string;
    readonly project_id: number;
    readonly project_url: string;
    readonly column_name: string;
    readonly previous_column_name?: string;
  };
};

export type IssueEventForIssue =
  | LabeledIssueEvent
  | UnlabeledIssueEvent
  | AssignedIssueEvent
  | UnassignedIssueEvent
  | MilestonedIssueEvent
  | DemilestonedIssueEvent
  | RenamedIssueEvent
  | ReviewRequestedIssueEvent
  | ReviewRequestRemovedIssueEvent
  | ReviewDismissedIssueEvent
  | LockedIssueEvent
  | AddedToProjectIssueEvent
  | MovedColumnInProjectIssueEvent
  | RemovedFromProjectIssueEvent
  | ConvertedNoteToIssueIssueEvent;

export type Label = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly name: string;
  readonly description: string | null;
  readonly color: string;
  readonly default: boolean;
};

export type TimelineCommentEvent = {
  readonly event: string;
  readonly actor: SimpleUser;
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly body?: string;
  readonly body_text?: string;
  readonly body_html?: string;
  readonly html_url: string;
  readonly user: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly issue_url: string;
  readonly author_association: AuthorAssociation;
  readonly performed_via_github_app?: GitHubApp;
  readonly reactions?: ReactionRollup;
};

export type TimelineCrossReferencedEvent = {
  readonly event: string;
  readonly actor?: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly source: { readonly type?: string; readonly issue?: Issue };
};

export type TimelineCommittedEvent = {
  readonly event?: string;
  readonly sha: string;
  readonly node_id: string;
  readonly url: string;
  readonly author: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly committer: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly message: string;
  readonly tree: { readonly sha: string; readonly url: string };
  readonly parents: ReadonlyArray<{
    readonly sha: string;
    readonly url: string;
    readonly html_url: string;
  }>;
  readonly verification: {
    readonly verified: boolean;
    readonly reason: string;
    readonly signature: string | null;
    readonly payload: string | null;
  };
  readonly html_url: string;
};

export type TimelineReviewedEvent = {
  readonly event: string;
  readonly id: number;
  readonly node_id: string;
  readonly user: SimpleUser;
  readonly body: string | null;
  readonly state: string;
  readonly html_url: string;
  readonly pull_request_url: string;
  readonly _links: {
    readonly html: { readonly href: string };
    readonly pull_request: { readonly href: string };
  };
  readonly submitted_at?: string;
  readonly commit_id: string;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly author_association: AuthorAssociation;
};

export type PullRequestReviewComment = {
  readonly url: string;
  readonly pull_request_review_id: number | null;
  readonly id: number;
  readonly node_id: string;
  readonly diff_hunk: string;
  readonly path: string;
  readonly position: number;
  readonly original_position: number;
  readonly commit_id: string;
  readonly original_commit_id: string;
  readonly in_reply_to_id?: number;
  readonly user: SimpleUser;
  readonly body: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly html_url: string;
  readonly pull_request_url: string;
  readonly author_association: AuthorAssociation;
  readonly _links: {
    readonly self: { readonly href: string };
    readonly html: { readonly href: string };
    readonly pull_request: { readonly href: string };
  };
  readonly start_line?: number | null;
  readonly original_start_line?: number | null;
  readonly start_side?: 'LEFT' | 'RIGHT' | null;
  readonly line?: number;
  readonly original_line?: number;
  readonly side?: 'LEFT' | 'RIGHT';
  readonly reactions?: ReactionRollup;
  readonly body_html?: string;
  readonly body_text?: string;
};

export type TimelineLineCommentedEvent = {
  readonly event?: string;
  readonly node_id?: string;
  readonly comments?: ReadonlyArray<PullRequestReviewComment>;
};

export type TimelineCommitCommentedEvent = {
  readonly event?: string;
  readonly node_id?: string;
  readonly commit_id?: string;
  readonly comments?: ReadonlyArray<CommitComment>;
};

export type TimelineAssignedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly assignee: SimpleUser;
};

export type TimelineUnassignedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly assignee: SimpleUser;
};

export type StateChangeIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly state_reason?: string | null;
};

export type TimelineEvent = unknown &
  (
    | LabeledIssueEvent
    | UnlabeledIssueEvent
    | MilestonedIssueEvent
    | DemilestonedIssueEvent
    | RenamedIssueEvent
    | ReviewRequestedIssueEvent
    | ReviewRequestRemovedIssueEvent
    | ReviewDismissedIssueEvent
    | LockedIssueEvent
    | AddedToProjectIssueEvent
    | MovedColumnInProjectIssueEvent
    | RemovedFromProjectIssueEvent
    | ConvertedNoteToIssueIssueEvent
    | TimelineCommentEvent
    | TimelineCrossReferencedEvent
    | TimelineCommittedEvent
    | TimelineReviewedEvent
    | TimelineLineCommentedEvent
    | TimelineCommitCommentedEvent
    | TimelineAssignedIssueEvent
    | TimelineUnassignedIssueEvent
    | StateChangeIssueEvent
  );

export type DeployKey = {
  readonly id: number;
  readonly key: string;
  readonly url: string;
  readonly title: string;
  readonly verified: boolean;
  readonly created_at: string;
  readonly read_only: boolean;
  readonly added_by?: string | null;
  readonly last_used?: string | null;
};

export type Language = unknown;

export type LicenseContent = {
  readonly name: string;
  readonly path: string;
  readonly sha: string;
  readonly size: number;
  readonly url: string;
  readonly html_url: string | null;
  readonly git_url: string | null;
  readonly download_url: string | null;
  readonly type: string;
  readonly content: string;
  readonly encoding: string;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
  readonly license: LicenseSimple;
};

export type MergedUpstream = {
  readonly message?: string;
  readonly merge_type?: 'merge' | 'fast-forward' | 'none';
  readonly base_branch?: string;
};

export type PagesSourceHash = {
  readonly branch: string;
  readonly path: string;
};

export type PagesHttpsCertificate = {
  readonly state:
    | 'new'
    | 'authorization_created'
    | 'authorization_pending'
    | 'authorized'
    | 'authorization_revoked'
    | 'issued'
    | 'uploaded'
    | 'approved'
    | 'errored'
    | 'bad_authz'
    | 'destroy_pending'
    | 'dns_changed';
  readonly description: string;
  readonly domains: ReadonlyArray<string>;
  readonly expires_at?: string;
};

export type GitHubPages = {
  readonly url: string;
  readonly status: 'built' | 'building' | 'errored' | null;
  readonly cname: string | null;
  readonly protected_domain_state?:
    | 'pending'
    | 'verified'
    | 'unverified'
    | null;
  readonly pending_domain_unverified_at?: string | null;
  readonly custom_404: boolean;
  readonly html_url?: string;
  readonly build_type?: 'legacy' | 'workflow' | null;
  readonly source?: PagesSourceHash;
  readonly public: boolean;
  readonly https_certificate?: PagesHttpsCertificate;
  readonly https_enforced?: boolean;
};

export type PageBuild = {
  readonly url: string;
  readonly status: string;
  readonly error: { readonly message: string | null };
  readonly pusher: SimpleUser;
  readonly commit: string;
  readonly duration: number;
  readonly created_at: string;
  readonly updated_at: string;
};

export type PageBuildStatus = { readonly url: string; readonly status: string };

export type PagesHealthCheckStatus = {
  readonly domain?: {
    readonly host?: string;
    readonly uri?: string;
    readonly nameservers?: string;
    readonly dns_resolves?: boolean;
    readonly is_proxied?: boolean | null;
    readonly is_cloudflare_ip?: boolean | null;
    readonly is_fastly_ip?: boolean | null;
    readonly is_old_ip_address?: boolean | null;
    readonly is_a_record?: boolean | null;
    readonly has_cname_record?: boolean | null;
    readonly has_mx_records_present?: boolean | null;
    readonly is_valid_domain?: boolean;
    readonly is_apex_domain?: boolean;
    readonly should_be_a_record?: boolean | null;
    readonly is_cname_to_github_user_domain?: boolean | null;
    readonly is_cname_to_pages_dot_github_dot_com?: boolean | null;
    readonly is_cname_to_fastly?: boolean | null;
    readonly is_pointed_to_github_pages_ip?: boolean | null;
    readonly is_non_github_pages_ip_present?: boolean | null;
    readonly is_pages_domain?: boolean;
    readonly is_served_by_pages?: boolean | null;
    readonly is_valid?: boolean;
    readonly reason?: string | null;
    readonly responds_to_https?: boolean;
    readonly enforces_https?: boolean;
    readonly https_error?: string | null;
    readonly is_https_eligible?: boolean | null;
    readonly caa_error?: string | null;
  };
  readonly alt_domain?: {
    readonly host?: string;
    readonly uri?: string;
    readonly nameservers?: string;
    readonly dns_resolves?: boolean;
    readonly is_proxied?: boolean | null;
    readonly is_cloudflare_ip?: boolean | null;
    readonly is_fastly_ip?: boolean | null;
    readonly is_old_ip_address?: boolean | null;
    readonly is_a_record?: boolean | null;
    readonly has_cname_record?: boolean | null;
    readonly has_mx_records_present?: boolean | null;
    readonly is_valid_domain?: boolean;
    readonly is_apex_domain?: boolean;
    readonly should_be_a_record?: boolean | null;
    readonly is_cname_to_github_user_domain?: boolean | null;
    readonly is_cname_to_pages_dot_github_dot_com?: boolean | null;
    readonly is_cname_to_fastly?: boolean | null;
    readonly is_pointed_to_github_pages_ip?: boolean | null;
    readonly is_non_github_pages_ip_present?: boolean | null;
    readonly is_pages_domain?: boolean;
    readonly is_served_by_pages?: boolean | null;
    readonly is_valid?: boolean;
    readonly reason?: string | null;
    readonly responds_to_https?: boolean;
    readonly enforces_https?: boolean;
    readonly https_error?: string | null;
    readonly is_https_eligible?: boolean | null;
    readonly caa_error?: string | null;
  } | null;
};

export type PullRequest = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly html_url: string;
  readonly diff_url: string;
  readonly patch_url: string;
  readonly issue_url: string;
  readonly commits_url: string;
  readonly review_comments_url: string;
  readonly review_comment_url: string;
  readonly comments_url: string;
  readonly statuses_url: string;
  readonly number: number;
  readonly state: 'open' | 'closed';
  readonly locked: boolean;
  readonly title: string;
  readonly user: SimpleUser;
  readonly body: string | null;
  readonly labels: ReadonlyArray<{
    readonly id: number;
    readonly node_id: string;
    readonly url: string;
    readonly name: string;
    readonly description: string | null;
    readonly color: string;
    readonly default: boolean;
  }>;
  readonly milestone: Milestone;
  readonly active_lock_reason?: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly closed_at: string | null;
  readonly merged_at: string | null;
  readonly merge_commit_sha: string | null;
  readonly assignee: SimpleUser;
  readonly assignees?: ReadonlyArray<SimpleUser> | null;
  readonly requested_reviewers?: ReadonlyArray<SimpleUser> | null;
  readonly requested_teams?: ReadonlyArray<TeamSimple> | null;
  readonly head: {
    readonly label: string;
    readonly ref: string;
    readonly repo: {
      readonly archive_url: string;
      readonly assignees_url: string;
      readonly blobs_url: string;
      readonly branches_url: string;
      readonly collaborators_url: string;
      readonly comments_url: string;
      readonly commits_url: string;
      readonly compare_url: string;
      readonly contents_url: string;
      readonly contributors_url: string;
      readonly deployments_url: string;
      readonly description: string | null;
      readonly downloads_url: string;
      readonly events_url: string;
      readonly fork: boolean;
      readonly forks_url: string;
      readonly full_name: string;
      readonly git_commits_url: string;
      readonly git_refs_url: string;
      readonly git_tags_url: string;
      readonly hooks_url: string;
      readonly html_url: string;
      readonly id: number;
      readonly node_id: string;
      readonly issue_comment_url: string;
      readonly issue_events_url: string;
      readonly issues_url: string;
      readonly keys_url: string;
      readonly labels_url: string;
      readonly languages_url: string;
      readonly merges_url: string;
      readonly milestones_url: string;
      readonly name: string;
      readonly notifications_url: string;
      readonly owner: {
        readonly avatar_url: string;
        readonly events_url: string;
        readonly followers_url: string;
        readonly following_url: string;
        readonly gists_url: string;
        readonly gravatar_id: string | null;
        readonly html_url: string;
        readonly id: number;
        readonly node_id: string;
        readonly login: string;
        readonly organizations_url: string;
        readonly received_events_url: string;
        readonly repos_url: string;
        readonly site_admin: boolean;
        readonly starred_url: string;
        readonly subscriptions_url: string;
        readonly type: string;
        readonly url: string;
      };
      readonly private: boolean;
      readonly pulls_url: string;
      readonly releases_url: string;
      readonly stargazers_url: string;
      readonly statuses_url: string;
      readonly subscribers_url: string;
      readonly subscription_url: string;
      readonly tags_url: string;
      readonly teams_url: string;
      readonly trees_url: string;
      readonly url: string;
      readonly clone_url: string;
      readonly default_branch: string;
      readonly forks: number;
      readonly forks_count: number;
      readonly git_url: string;
      readonly has_downloads: boolean;
      readonly has_issues: boolean;
      readonly has_projects: boolean;
      readonly has_wiki: boolean;
      readonly has_pages: boolean;
      readonly homepage: string | null;
      readonly language: string | null;
      readonly master_branch?: string;
      readonly archived: boolean;
      readonly disabled: boolean;
      readonly visibility?: string;
      readonly mirror_url: string | null;
      readonly open_issues: number;
      readonly open_issues_count: number;
      readonly permissions?: {
        readonly admin: boolean;
        readonly maintain?: boolean;
        readonly push: boolean;
        readonly triage?: boolean;
        readonly pull: boolean;
      };
      readonly temp_clone_token?: string;
      readonly allow_merge_commit?: boolean;
      readonly allow_squash_merge?: boolean;
      readonly allow_rebase_merge?: boolean;
      readonly license: {
        readonly key: string;
        readonly name: string;
        readonly url: string | null;
        readonly spdx_id: string | null;
        readonly node_id: string;
      } | null;
      readonly pushed_at: string;
      readonly size: number;
      readonly ssh_url: string;
      readonly stargazers_count: number;
      readonly svn_url: string;
      readonly topics?: ReadonlyArray<string>;
      readonly watchers: number;
      readonly watchers_count: number;
      readonly created_at: string;
      readonly updated_at: string;
      readonly allow_forking?: boolean;
      readonly is_template?: boolean;
      readonly web_commit_signoff_required?: boolean;
    } | null;
    readonly sha: string;
    readonly user: {
      readonly avatar_url: string;
      readonly events_url: string;
      readonly followers_url: string;
      readonly following_url: string;
      readonly gists_url: string;
      readonly gravatar_id: string | null;
      readonly html_url: string;
      readonly id: number;
      readonly node_id: string;
      readonly login: string;
      readonly organizations_url: string;
      readonly received_events_url: string;
      readonly repos_url: string;
      readonly site_admin: boolean;
      readonly starred_url: string;
      readonly subscriptions_url: string;
      readonly type: string;
      readonly url: string;
    };
  };
  readonly base: {
    readonly label: string;
    readonly ref: string;
    readonly repo: {
      readonly archive_url: string;
      readonly assignees_url: string;
      readonly blobs_url: string;
      readonly branches_url: string;
      readonly collaborators_url: string;
      readonly comments_url: string;
      readonly commits_url: string;
      readonly compare_url: string;
      readonly contents_url: string;
      readonly contributors_url: string;
      readonly deployments_url: string;
      readonly description: string | null;
      readonly downloads_url: string;
      readonly events_url: string;
      readonly fork: boolean;
      readonly forks_url: string;
      readonly full_name: string;
      readonly git_commits_url: string;
      readonly git_refs_url: string;
      readonly git_tags_url: string;
      readonly hooks_url: string;
      readonly html_url: string;
      readonly id: number;
      readonly is_template?: boolean;
      readonly node_id: string;
      readonly issue_comment_url: string;
      readonly issue_events_url: string;
      readonly issues_url: string;
      readonly keys_url: string;
      readonly labels_url: string;
      readonly languages_url: string;
      readonly merges_url: string;
      readonly milestones_url: string;
      readonly name: string;
      readonly notifications_url: string;
      readonly owner: {
        readonly avatar_url: string;
        readonly events_url: string;
        readonly followers_url: string;
        readonly following_url: string;
        readonly gists_url: string;
        readonly gravatar_id: string | null;
        readonly html_url: string;
        readonly id: number;
        readonly node_id: string;
        readonly login: string;
        readonly organizations_url: string;
        readonly received_events_url: string;
        readonly repos_url: string;
        readonly site_admin: boolean;
        readonly starred_url: string;
        readonly subscriptions_url: string;
        readonly type: string;
        readonly url: string;
      };
      readonly private: boolean;
      readonly pulls_url: string;
      readonly releases_url: string;
      readonly stargazers_url: string;
      readonly statuses_url: string;
      readonly subscribers_url: string;
      readonly subscription_url: string;
      readonly tags_url: string;
      readonly teams_url: string;
      readonly trees_url: string;
      readonly url: string;
      readonly clone_url: string;
      readonly default_branch: string;
      readonly forks: number;
      readonly forks_count: number;
      readonly git_url: string;
      readonly has_downloads: boolean;
      readonly has_issues: boolean;
      readonly has_projects: boolean;
      readonly has_wiki: boolean;
      readonly has_pages: boolean;
      readonly homepage: string | null;
      readonly language: string | null;
      readonly master_branch?: string;
      readonly archived: boolean;
      readonly disabled: boolean;
      readonly visibility?: string;
      readonly mirror_url: string | null;
      readonly open_issues: number;
      readonly open_issues_count: number;
      readonly permissions?: {
        readonly admin: boolean;
        readonly maintain?: boolean;
        readonly push: boolean;
        readonly triage?: boolean;
        readonly pull: boolean;
      };
      readonly temp_clone_token?: string;
      readonly allow_merge_commit?: boolean;
      readonly allow_squash_merge?: boolean;
      readonly allow_rebase_merge?: boolean;
      readonly license: LicenseSimple;
      readonly pushed_at: string;
      readonly size: number;
      readonly ssh_url: string;
      readonly stargazers_count: number;
      readonly svn_url: string;
      readonly topics?: ReadonlyArray<string>;
      readonly watchers: number;
      readonly watchers_count: number;
      readonly created_at: string;
      readonly updated_at: string;
      readonly allow_forking?: boolean;
      readonly web_commit_signoff_required?: boolean;
    };
    readonly sha: string;
    readonly user: {
      readonly avatar_url: string;
      readonly events_url: string;
      readonly followers_url: string;
      readonly following_url: string;
      readonly gists_url: string;
      readonly gravatar_id: string | null;
      readonly html_url: string;
      readonly id: number;
      readonly node_id: string;
      readonly login: string;
      readonly organizations_url: string;
      readonly received_events_url: string;
      readonly repos_url: string;
      readonly site_admin: boolean;
      readonly starred_url: string;
      readonly subscriptions_url: string;
      readonly type: string;
      readonly url: string;
    };
  };
  readonly _links: {
    readonly comments: Link;
    readonly commits: Link;
    readonly statuses: Link;
    readonly html: Link;
    readonly issue: Link;
    readonly review_comments: Link;
    readonly review_comment: Link;
    readonly self: Link;
  };
  readonly author_association: AuthorAssociation;
  readonly auto_merge: AutoMerge;
  readonly draft?: boolean;
  readonly merged: boolean;
  readonly mergeable: boolean | null;
  readonly rebaseable?: boolean | null;
  readonly mergeable_state: string;
  readonly merged_by: SimpleUser;
  readonly comments: number;
  readonly review_comments: number;
  readonly maintainer_can_modify: boolean;
  readonly commits: number;
  readonly additions: number;
  readonly deletions: number;
  readonly changed_files: number;
};

export type PullRequestMergeResult = {
  readonly sha: string;
  readonly merged: boolean;
  readonly message: string;
};

export type PullRequestReviewRequest = {
  readonly users: ReadonlyArray<SimpleUser>;
  readonly teams: ReadonlyArray<Team>;
};

export type PullRequestReview = {
  readonly id: number;
  readonly node_id: string;
  readonly user: SimpleUser;
  readonly body: string;
  readonly state: string;
  readonly html_url: string;
  readonly pull_request_url: string;
  readonly _links: {
    readonly html: { readonly href: string };
    readonly pull_request: { readonly href: string };
  };
  readonly submitted_at?: string;
  readonly commit_id: string;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly author_association: AuthorAssociation;
};

export type LegacyReviewComment = {
  readonly url: string;
  readonly pull_request_review_id: number | null;
  readonly id: number;
  readonly node_id: string;
  readonly diff_hunk: string;
  readonly path: string;
  readonly position: number | null;
  readonly original_position: number;
  readonly commit_id: string;
  readonly original_commit_id: string;
  readonly in_reply_to_id?: number;
  readonly user: SimpleUser;
  readonly body: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly html_url: string;
  readonly pull_request_url: string;
  readonly author_association: AuthorAssociation;
  readonly _links: {
    readonly self: Link;
    readonly html: Link;
    readonly pull_request: Link;
  };
  readonly body_text?: string;
  readonly body_html?: string;
  readonly reactions?: ReactionRollup;
  readonly side?: 'LEFT' | 'RIGHT';
  readonly start_side?: 'LEFT' | 'RIGHT' | null;
  readonly line?: number;
  readonly original_line?: number;
  readonly start_line?: number | null;
  readonly original_start_line?: number | null;
};

export type ReleaseAsset = {
  readonly url: string;
  readonly browser_download_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly label: string | null;
  readonly state: 'uploaded' | 'open';
  readonly content_type: string;
  readonly size: number;
  readonly download_count: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly uploader: SimpleUser;
};

export type Release = {
  readonly url: string;
  readonly html_url: string;
  readonly assets_url: string;
  readonly upload_url: string;
  readonly tarball_url: string | null;
  readonly zipball_url: string | null;
  readonly id: number;
  readonly node_id: string;
  readonly tag_name: string;
  readonly target_commitish: string;
  readonly name: string | null;
  readonly body?: string | null;
  readonly draft: boolean;
  readonly prerelease: boolean;
  readonly created_at: string;
  readonly published_at: string | null;
  readonly author: SimpleUser;
  readonly assets: ReadonlyArray<ReleaseAsset>;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly mentions_count?: number;
  readonly discussion_url?: string;
  readonly reactions?: ReactionRollup;
};

export type GeneratedReleaseNotesContent = {
  readonly name: string;
  readonly body: string;
};

export type SecretScanningAlert = {
  readonly number?: AlertNumber;
  readonly created_at?: AlertCreatedAt;
  readonly updated_at?: AlertUpdatedAt;
  readonly url?: AlertUrl;
  readonly html_url?: AlertHtmlUrl;
  readonly locations_url?: string;
  readonly state?: SecretScanningAlertState;
  readonly resolution?: SecretScanningAlertResolution;
  readonly resolved_at?: string | null;
  readonly resolved_by?: SimpleUser;
  readonly resolution_comment?: string | null;
  readonly secret_type?: string;
  readonly secret_type_display_name?: string;
  readonly secret?: string;
  readonly push_protection_bypassed?: boolean | null;
  readonly push_protection_bypassed_by?: SimpleUser;
  readonly push_protection_bypassed_at?: string | null;
};

export type SecretScanningAlertResolutionComment = string | null;

export type SecretScanningLocationCommit = {
  readonly path: string;
  readonly start_line: number;
  readonly end_line: number;
  readonly start_column: number;
  readonly end_column: number;
  readonly blob_sha: string;
  readonly blob_url: string;
  readonly commit_sha: string;
  readonly commit_url: string;
};

export type SecretScanningLocation = {
  readonly type: 'commit';
  readonly details: SecretScanningLocationCommit;
};

export type Stargazer = {
  readonly starred_at: string;
  readonly user: SimpleUser;
};

export type CodeFrequencyStat = ReadonlyArray<number>;

export type CommitActivity = {
  readonly days: ReadonlyArray<number>;
  readonly total: number;
  readonly week: number;
};

export type ContributorActivity = {
  readonly author: SimpleUser;
  readonly total: number;
  readonly weeks: ReadonlyArray<{
    readonly w?: number;
    readonly a?: number;
    readonly d?: number;
    readonly c?: number;
  }>;
};

export type ParticipationStats = {
  readonly all: ReadonlyArray<number>;
  readonly owner: ReadonlyArray<number>;
};

export type Tag = {
  readonly name: string;
  readonly commit: { readonly sha: string; readonly url: string };
  readonly zipball_url: string;
  readonly tarball_url: string;
  readonly node_id: string;
};

export type TagProtection = {
  readonly id?: number;
  readonly created_at?: string;
  readonly updated_at?: string;
  readonly enabled?: boolean;
  readonly pattern: string;
};

export type Topic = { readonly names: ReadonlyArray<string> };

export type Traffic = {
  readonly timestamp: string;
  readonly uniques: number;
  readonly count: number;
};

export type CloneTraffic = {
  readonly count: number;
  readonly uniques: number;
  readonly clones: ReadonlyArray<Traffic>;
};

export type ContentTraffic = {
  readonly path: string;
  readonly title: string;
  readonly count: number;
  readonly uniques: number;
};

export type ReferrerTraffic = {
  readonly referrer: string;
  readonly count: number;
  readonly uniques: number;
};

export type ViewTraffic = {
  readonly count: number;
  readonly uniques: number;
  readonly views: ReadonlyArray<Traffic>;
};

export type SearchResultTextMatches = ReadonlyArray<{
  readonly object_url?: string;
  readonly object_type?: string | null;
  readonly property?: string;
  readonly fragment?: string;
  readonly matches?: ReadonlyArray<{
    readonly text?: string;
    readonly indices?: ReadonlyArray<number>;
  }>;
}>;

export type CodeSearchResultItem = {
  readonly name: string;
  readonly path: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string;
  readonly html_url: string;
  readonly repository: MinimalRepository;
  readonly score: number;
  readonly file_size?: number;
  readonly language?: string | null;
  readonly last_modified_at?: string;
  readonly line_numbers?: ReadonlyArray<string>;
  readonly text_matches?: SearchResultTextMatches;
};

export type CommitSearchResultItem = {
  readonly url: string;
  readonly sha: string;
  readonly html_url: string;
  readonly comments_url: string;
  readonly commit: {
    readonly author: {
      readonly name: string;
      readonly email: string;
      readonly date: string;
    };
    readonly committer: GitUser;
    readonly comment_count: number;
    readonly message: string;
    readonly tree: { readonly sha: string; readonly url: string };
    readonly url: string;
    readonly verification?: Verification;
  };
  readonly author: SimpleUser;
  readonly committer: GitUser;
  readonly parents: ReadonlyArray<{
    readonly url?: string;
    readonly html_url?: string;
    readonly sha?: string;
  }>;
  readonly repository: MinimalRepository;
  readonly score: number;
  readonly node_id: string;
  readonly text_matches?: SearchResultTextMatches;
};

export type IssueSearchResultItem = {
  readonly url: string;
  readonly repository_url: string;
  readonly labels_url: string;
  readonly comments_url: string;
  readonly events_url: string;
  readonly html_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly number: number;
  readonly title: string;
  readonly locked: boolean;
  readonly active_lock_reason?: string | null;
  readonly assignees?: ReadonlyArray<SimpleUser> | null;
  readonly user: SimpleUser;
  readonly labels: ReadonlyArray<{
    readonly id?: number;
    readonly node_id?: string;
    readonly url?: string;
    readonly name?: string;
    readonly color?: string;
    readonly default?: boolean;
    readonly description?: string | null;
  }>;
  readonly state: string;
  readonly state_reason?: string | null;
  readonly assignee: SimpleUser;
  readonly milestone: Milestone;
  readonly comments: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly closed_at: string | null;
  readonly text_matches?: SearchResultTextMatches;
  readonly pull_request?: {
    readonly merged_at?: string | null;
    readonly diff_url: string | null;
    readonly html_url: string | null;
    readonly patch_url: string | null;
    readonly url: string | null;
  };
  readonly body?: string;
  readonly score: number;
  readonly author_association: AuthorAssociation;
  readonly draft?: boolean;
  readonly repository?: Repository;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly timeline_url?: string;
  readonly performed_via_github_app?: GitHubApp;
  readonly reactions?: ReactionRollup;
};

export type LabelSearchResultItem = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly name: string;
  readonly color: string;
  readonly default: boolean;
  readonly description: string | null;
  readonly score: number;
  readonly text_matches?: SearchResultTextMatches;
};

export type RepoSearchResultItem = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly pushed_at: string;
  readonly homepage: string | null;
  readonly size: number;
  readonly stargazers_count: number;
  readonly watchers_count: number;
  readonly language: string | null;
  readonly forks_count: number;
  readonly open_issues_count: number;
  readonly master_branch?: string;
  readonly default_branch: string;
  readonly score: number;
  readonly forks_url: string;
  readonly keys_url: string;
  readonly collaborators_url: string;
  readonly teams_url: string;
  readonly hooks_url: string;
  readonly issue_events_url: string;
  readonly events_url: string;
  readonly assignees_url: string;
  readonly branches_url: string;
  readonly tags_url: string;
  readonly blobs_url: string;
  readonly git_tags_url: string;
  readonly git_refs_url: string;
  readonly trees_url: string;
  readonly statuses_url: string;
  readonly languages_url: string;
  readonly stargazers_url: string;
  readonly contributors_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly commits_url: string;
  readonly git_commits_url: string;
  readonly comments_url: string;
  readonly issue_comment_url: string;
  readonly contents_url: string;
  readonly compare_url: string;
  readonly merges_url: string;
  readonly archive_url: string;
  readonly downloads_url: string;
  readonly issues_url: string;
  readonly pulls_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly labels_url: string;
  readonly releases_url: string;
  readonly deployments_url: string;
  readonly git_url: string;
  readonly ssh_url: string;
  readonly clone_url: string;
  readonly svn_url: string;
  readonly forks: number;
  readonly open_issues: number;
  readonly watchers: number;
  readonly topics?: ReadonlyArray<string>;
  readonly mirror_url: string | null;
  readonly has_issues: boolean;
  readonly has_projects: boolean;
  readonly has_pages: boolean;
  readonly has_wiki: boolean;
  readonly has_downloads: boolean;
  readonly archived: boolean;
  readonly disabled: boolean;
  readonly visibility?: string;
  readonly license: LicenseSimple;
  readonly permissions?: {
    readonly admin: boolean;
    readonly maintain?: boolean;
    readonly push: boolean;
    readonly triage?: boolean;
    readonly pull: boolean;
  };
  readonly text_matches?: SearchResultTextMatches;
  readonly temp_clone_token?: string;
  readonly allow_merge_commit?: boolean;
  readonly allow_squash_merge?: boolean;
  readonly allow_rebase_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_forking?: boolean;
  readonly is_template?: boolean;
  readonly web_commit_signoff_required?: boolean;
};

export type TopicSearchResultItem = {
  readonly name: string;
  readonly display_name: string | null;
  readonly short_description: string | null;
  readonly description: string | null;
  readonly created_by: string | null;
  readonly released: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly featured: boolean;
  readonly curated: boolean;
  readonly score: number;
  readonly repository_count?: number | null;
  readonly logo_url?: string | null;
  readonly text_matches?: SearchResultTextMatches;
  readonly related?: ReadonlyArray<{
    readonly topic_relation?: {
      readonly id?: number;
      readonly name?: string;
      readonly topic_id?: number;
      readonly relation_type?: string;
    };
  }> | null;
  readonly aliases?: ReadonlyArray<{
    readonly topic_relation?: {
      readonly id?: number;
      readonly name?: string;
      readonly topic_id?: number;
      readonly relation_type?: string;
    };
  }> | null;
};

export type UserSearchResultItem = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly score: number;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly events_url: string;
  readonly public_repos?: number;
  readonly public_gists?: number;
  readonly followers?: number;
  readonly following?: number;
  readonly created_at?: string;
  readonly updated_at?: string;
  readonly name?: string | null;
  readonly bio?: string | null;
  readonly email?: string | null;
  readonly location?: string | null;
  readonly site_admin: boolean;
  readonly hireable?: boolean | null;
  readonly text_matches?: SearchResultTextMatches;
  readonly blog?: string | null;
  readonly company?: string | null;
  readonly suspended_at?: string | null;
};

export type PrivateUser = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly site_admin: boolean;
  readonly name: string | null;
  readonly company: string | null;
  readonly blog: string | null;
  readonly location: string | null;
  readonly email: string | null;
  readonly hireable: boolean | null;
  readonly bio: string | null;
  readonly twitter_username?: string | null;
  readonly public_repos: number;
  readonly public_gists: number;
  readonly followers: number;
  readonly following: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly private_gists: number;
  readonly total_private_repos: number;
  readonly owned_private_repos: number;
  readonly disk_usage: number;
  readonly collaborators: number;
  readonly two_factor_authentication: boolean;
  readonly plan?: {
    readonly collaborators: number;
    readonly name: string;
    readonly space: number;
    readonly private_repos: number;
  };
  readonly suspended_at?: string | null;
  readonly business_plus?: boolean;
  readonly ldap_dn?: string;
};

export type CodespacesUserPublicKey = {
  readonly key_id: string;
  readonly key: string;
};

export type FetchesInformationAboutAnExportOfACodespace = {
  readonly state?: string | null;
  readonly completed_at?: string | null;
  readonly branch?: string | null;
  readonly sha?: string | null;
  readonly id?: string;
  readonly export_url?: string;
  readonly html_url?: string | null;
};

export type Email = {
  readonly email: string;
  readonly primary: boolean;
  readonly verified: boolean;
  readonly visibility: string | null;
};

export type GpgKey = {
  readonly id: number;
  readonly name?: string | null;
  readonly primary_key_id: number | null;
  readonly key_id: string;
  readonly public_key: string;
  readonly emails: ReadonlyArray<{
    readonly email?: string;
    readonly verified?: boolean;
  }>;
  readonly subkeys: ReadonlyArray<{
    readonly id?: number;
    readonly primary_key_id?: number;
    readonly key_id?: string;
    readonly public_key?: string;
    readonly emails?: ReadonlyArray<unknown>;
    readonly subkeys?: ReadonlyArray<unknown>;
    readonly can_sign?: boolean;
    readonly can_encrypt_comms?: boolean;
    readonly can_encrypt_storage?: boolean;
    readonly can_certify?: boolean;
    readonly created_at?: string;
    readonly expires_at?: string | null;
    readonly raw_key?: string | null;
    readonly revoked?: boolean;
  }>;
  readonly can_sign: boolean;
  readonly can_encrypt_comms: boolean;
  readonly can_encrypt_storage: boolean;
  readonly can_certify: boolean;
  readonly created_at: string;
  readonly expires_at: string | null;
  readonly revoked: boolean;
  readonly raw_key: string | null;
};

export type Key = {
  readonly key: string;
  readonly id: number;
  readonly url: string;
  readonly title: string;
  readonly created_at: string;
  readonly verified: boolean;
  readonly read_only: boolean;
};

export type MarketplaceAccount = {
  readonly url: string;
  readonly id: number;
  readonly type: string;
  readonly node_id?: string;
  readonly login: string;
  readonly email?: string | null;
  readonly organization_billing_email?: string | null;
};

export type UserMarketplacePurchase = {
  readonly billing_cycle: string;
  readonly next_billing_date: string | null;
  readonly unit_count: number | null;
  readonly on_free_trial: boolean;
  readonly free_trial_ends_on: string | null;
  readonly updated_at: string | null;
  readonly account: MarketplaceAccount;
  readonly plan: MarketplaceListingPlan;
};

export type SshSigningKey = {
  readonly key: string;
  readonly id: number;
  readonly title: string;
  readonly created_at: string;
};

export type Hovercard = {
  readonly contexts: ReadonlyArray<{
    readonly message: string;
    readonly octicon: string;
  }>;
};

export type KeySimple = { readonly id: number; readonly key: string };

export type StarredRepository = {
  readonly starred_at: string;
  readonly repo: Repository;
};

type ResponseWithData<TStatus, TData> = {
  status: TStatus;
  body: TData;
};

type LegacyLogFn = (message: string, data: Record<string, unknown>) => void;

type Logger = Pick<typeof console, 'info' | 'error'>;

export interface GitHubV3RestApiClientOptions {
  fetch: typeof fetch;
  logger: Logger | null;
  requestOptions: RequestInit;
}

export class GitHubV3RestApiClient {
  public constructor(
    public readonly baseUrl: string,
    options?: Partial<GitHubV3RestApiClientOptions> | LegacyLogFn
  ) {
    if (typeof options === 'function') {
      this.options = {
        fetch: global.fetch.bind(global),
        logger: {
          info: options,
          error: options
        },
        requestOptions: {}
      };
    } else {
      this.options = {
        fetch: global.fetch.bind(global),
        logger: console,
        requestOptions: {},
        ...options
      };
    }
  }

  private readonly options: GitHubV3RestApiClientOptions;

  public async 'meta/root'(
    options?: RequestInit
  ): Promise<ResponseWithData<200, Root>> {
    const method = 'GET';
    const url = `${this.baseUrl}/`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Root
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/get-authenticated'(
    options?: RequestInit
  ): Promise<ResponseWithData<200, GitHubApp>> {
    const method = 'GET';
    const url = `${this.baseUrl}/app`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GitHubApp
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/create-from-manifest'(
    args: { readonly code: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        201,
        GitHubApp & {
          readonly client_id: string;
          readonly client_secret: string;
          readonly webhook_secret: string | null;
          readonly pem: string;
        }
      >
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/app-manifests/${encodeURIComponent(args['code'])}/conversions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as GitHubApp & {
              readonly client_id: string;
              readonly client_secret: string;
              readonly webhook_secret: string | null;
              readonly pem: string;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/get-webhook-config-for-app'(
    options?: RequestInit
  ): Promise<ResponseWithData<200, WebhookConfiguration>> {
    const method = 'GET';
    const url = `${this.baseUrl}/app/hook/config`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as WebhookConfiguration
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/update-webhook-config-for-app'(
    args: {
      readonly body: {
        readonly url?: WebhookConfigUrl;
        readonly content_type?: WebhookConfigContentType;
        readonly secret?: WebhookConfigSecret;
        readonly insecure_ssl?: WebhookConfigInsecureSsl;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, WebhookConfiguration>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/app/hook/config`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as WebhookConfiguration
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/list-webhook-deliveries'(
    args: { readonly per_page?: number; readonly cursor?: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleWebhookDelivery>>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['cursor']: args['cursor']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/app/hook/deliveries?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleWebhookDelivery>
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/get-webhook-delivery'(
    args: { readonly delivery_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, WebhookDelivery>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/app/hook/deliveries/${encodeURIComponent(args['delivery_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as WebhookDelivery
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/redeliver-webhook-delivery'(
    args: { readonly delivery_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<202, unknown>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/app/hook/deliveries/${encodeURIComponent(args['delivery_id'])}/attempts`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as unknown
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/list-installations'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly since?: string;
      readonly outdated?: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Installation>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page'],
      ['since']: args['since'],
      ['outdated']: args['outdated']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/app/installations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Installation>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/get-installation'(
    args: { readonly installation_id: number },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, Installation> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/app/installations/${encodeURIComponent(args['installation_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Installation
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/delete-installation'(
    args: { readonly installation_id: number },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/app/installations/${encodeURIComponent(args['installation_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/create-installation-access-token'(
    args: {
      readonly installation_id: number;
      readonly body?: {
        readonly repositories?: ReadonlyArray<string>;
        readonly repository_ids?: ReadonlyArray<number>;
        readonly permissions?: AppPermissions;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, InstallationToken>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/app/installations/${encodeURIComponent(args['installation_id'])}/access_tokens`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as InstallationToken
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/suspend-installation'(
    args: { readonly installation_id: number },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/app/installations/${encodeURIComponent(args['installation_id'])}/suspended`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/unsuspend-installation'(
    args: { readonly installation_id: number },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/app/installations/${encodeURIComponent(args['installation_id'])}/suspended`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/delete-authorization'(
    args: {
      readonly client_id: string;
      readonly body: { readonly access_token: string };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/applications/${encodeURIComponent(args['client_id'])}/grant`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/check-token'(
    args: {
      readonly client_id: string;
      readonly body: { readonly access_token: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Authorization>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/applications/${encodeURIComponent(args['client_id'])}/token`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Authorization
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/reset-token'(
    args: {
      readonly client_id: string;
      readonly body: { readonly access_token: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Authorization>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/applications/${encodeURIComponent(args['client_id'])}/token`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Authorization
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/delete-token'(
    args: {
      readonly client_id: string;
      readonly body: { readonly access_token: string };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/applications/${encodeURIComponent(args['client_id'])}/token`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/scope-token'(
    args: {
      readonly client_id: string;
      readonly body: {
        readonly access_token: string;
        readonly target?: string;
        readonly target_id?: number;
        readonly repositories?: ReadonlyArray<string>;
        readonly repository_ids?: ReadonlyArray<number>;
        readonly permissions?: AppPermissions;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Authorization>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/applications/${encodeURIComponent(args['client_id'])}/token/scoped`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Authorization
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/get-by-slug'(
    args: { readonly app_slug: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, GitHubApp>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/apps/${encodeURIComponent(args['app_slug'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GitHubApp
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codes-of-conduct/get-all-codes-of-conduct'(
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<CodeOfConduct>>
    | ResponseWithData<304, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/codes_of_conduct`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<CodeOfConduct>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codes-of-conduct/get-conduct-code'(
    args: { readonly key: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, CodeOfConduct>
    | ResponseWithData<304, undefined>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/codes_of_conduct/${encodeURIComponent(args['key'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CodeOfConduct
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'emojis/get'(
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, unknown> | ResponseWithData<304, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/emojis`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as unknown
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/get-server-statistics'(
    args: {
      readonly date_start?: string;
      readonly date_end?: string;
      readonly enterprise_or_org: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ServerStatisticsProxyEndpoint>> {
    const query = qs.stringify({
      ['date_start']: args['date_start'],
      ['date_end']: args['date_end']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/enterprise-installation/${encodeURIComponent(args['enterprise_or_org'])}/server-statistics?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ServerStatisticsProxyEndpoint
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-actions-cache-usage-for-enterprise'(
    args: { readonly enterprise: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsCacheUsageOrgEnterprise>> {
    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/cache/usage`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsCacheUsageOrgEnterprise
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/get-github-actions-permissions-enterprise'(
    args: { readonly enterprise: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsEnterprisePermissions>> {
    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/permissions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsEnterprisePermissions
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/set-github-actions-permissions-enterprise'(
    args: {
      readonly enterprise: string;
      readonly body: {
        readonly enabled_organizations: EnabledOrganizations;
        readonly allowed_actions?: AllowedActions;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/permissions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/list-selected-organizations-enabled-github-actions-enterprise'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly enterprise: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly organizations: ReadonlyArray<OrganizationSimple>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/permissions/organizations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly organizations: ReadonlyArray<OrganizationSimple>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/set-selected-organizations-enabled-github-actions-enterprise'(
    args: {
      readonly enterprise: string;
      readonly body: {
        readonly selected_organization_ids: ReadonlyArray<number>;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/permissions/organizations`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/enable-selected-organization-github-actions-enterprise'(
    args: { readonly enterprise: string; readonly org_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/permissions/organizations/${encodeURIComponent(args['org_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/disable-selected-organization-github-actions-enterprise'(
    args: { readonly enterprise: string; readonly org_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/permissions/organizations/${encodeURIComponent(args['org_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/get-allowed-actions-enterprise'(
    args: { readonly enterprise: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, SelectedActions>> {
    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/permissions/selected-actions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as SelectedActions
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/set-allowed-actions-enterprise'(
    args: { readonly enterprise: string; readonly body: SelectedActions },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/permissions/selected-actions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-github-actions-default-workflow-permissions-enterprise'(
    args: { readonly enterprise: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsGetDefaultWorkflowPermissions>> {
    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/permissions/workflow`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsGetDefaultWorkflowPermissions
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-github-actions-default-workflow-permissions-enterprise'(
    args: {
      readonly enterprise: string;
      readonly body: ActionsSetDefaultWorkflowPermissions;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/permissions/workflow`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/list-self-hosted-runner-groups-for-enterprise'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly visible_to_organization?: string;
      readonly enterprise: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly runner_groups: ReadonlyArray<RunnerGroupsEnterprise>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page'],
      ['visible_to_organization']: args['visible_to_organization']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runner-groups?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly runner_groups: ReadonlyArray<RunnerGroupsEnterprise>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/create-self-hosted-runner-group-for-enterprise'(
    args: {
      readonly enterprise: string;
      readonly body: {
        readonly name: string;
        readonly visibility?: 'selected' | 'all';
        readonly selected_organization_ids?: ReadonlyArray<number>;
        readonly runners?: ReadonlyArray<number>;
        readonly allows_public_repositories?: boolean;
        readonly restricted_to_workflows?: boolean;
        readonly selected_workflows?: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, RunnerGroupsEnterprise>> {
    const method = 'POST';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runner-groups`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as RunnerGroupsEnterprise
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/get-self-hosted-runner-group-for-enterprise'(
    args: { readonly enterprise: string; readonly runner_group_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<200, RunnerGroupsEnterprise>> {
    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as RunnerGroupsEnterprise
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/update-self-hosted-runner-group-for-enterprise'(
    args: {
      readonly enterprise: string;
      readonly runner_group_id: number;
      readonly body?: {
        readonly name?: string;
        readonly visibility?: 'selected' | 'all';
        readonly allows_public_repositories?: boolean;
        readonly restricted_to_workflows?: boolean;
        readonly selected_workflows?: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, RunnerGroupsEnterprise>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as RunnerGroupsEnterprise
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/delete-self-hosted-runner-group-from-enterprise'(
    args: { readonly enterprise: string; readonly runner_group_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/list-org-access-to-self-hosted-runner-group-in-enterprise'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly enterprise: string;
      readonly runner_group_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly organizations: ReadonlyArray<OrganizationSimple>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/organizations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly organizations: ReadonlyArray<OrganizationSimple>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/set-org-access-to-self-hosted-runner-group-in-enterprise'(
    args: {
      readonly enterprise: string;
      readonly runner_group_id: number;
      readonly body: {
        readonly selected_organization_ids: ReadonlyArray<number>;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/organizations`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/add-org-access-to-self-hosted-runner-group-in-enterprise'(
    args: {
      readonly enterprise: string;
      readonly runner_group_id: number;
      readonly org_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/organizations/${encodeURIComponent(args['org_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/remove-org-access-to-self-hosted-runner-group-in-enterprise'(
    args: {
      readonly enterprise: string;
      readonly runner_group_id: number;
      readonly org_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/organizations/${encodeURIComponent(args['org_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/list-self-hosted-runners-in-group-for-enterprise'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly enterprise: string;
      readonly runner_group_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly runners: ReadonlyArray<SelfHostedRunners>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/runners?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly runners: ReadonlyArray<SelfHostedRunners>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/set-self-hosted-runners-in-group-for-enterprise'(
    args: {
      readonly enterprise: string;
      readonly runner_group_id: number;
      readonly body: { readonly runners: ReadonlyArray<number> };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/runners`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/add-self-hosted-runner-to-group-for-enterprise'(
    args: {
      readonly enterprise: string;
      readonly runner_group_id: number;
      readonly runner_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/runners/${encodeURIComponent(args['runner_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/remove-self-hosted-runner-from-group-for-enterprise'(
    args: {
      readonly enterprise: string;
      readonly runner_group_id: number;
      readonly runner_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/runners/${encodeURIComponent(args['runner_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/list-self-hosted-runners-for-enterprise'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly enterprise: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count?: number;
        readonly runners?: ReadonlyArray<SelfHostedRunners>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runners?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count?: number;
              readonly runners?: ReadonlyArray<SelfHostedRunners>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/list-runner-applications-for-enterprise'(
    args: { readonly enterprise: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<RunnerApplication>>> {
    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runners/downloads`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<RunnerApplication>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/create-registration-token-for-enterprise'(
    args: { readonly enterprise: string },
    options?: RequestInit
  ): Promise<ResponseWithData<201, AuthenticationToken>> {
    const method = 'POST';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runners/registration-token`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as AuthenticationToken
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/create-remove-token-for-enterprise'(
    args: { readonly enterprise: string },
    options?: RequestInit
  ): Promise<ResponseWithData<201, AuthenticationToken>> {
    const method = 'POST';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runners/remove-token`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as AuthenticationToken
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/get-self-hosted-runner-for-enterprise'(
    args: { readonly enterprise: string; readonly runner_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<200, SelfHostedRunners>> {
    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runners/${encodeURIComponent(args['runner_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as SelfHostedRunners
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/delete-self-hosted-runner-from-enterprise'(
    args: { readonly enterprise: string; readonly runner_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runners/${encodeURIComponent(args['runner_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/list-labels-for-self-hosted-runner-for-enterprise'(
    args: { readonly enterprise: string; readonly runner_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/add-custom-labels-to-self-hosted-runner-for-enterprise'(
    args: {
      readonly enterprise: string;
      readonly runner_id: number;
      readonly body: { readonly labels: ReadonlyArray<string> };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/set-custom-labels-for-self-hosted-runner-for-enterprise'(
    args: {
      readonly enterprise: string;
      readonly runner_id: number;
      readonly body: { readonly labels: ReadonlyArray<string> };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/remove-all-custom-labels-from-self-hosted-runner-for-enterprise'(
    args: { readonly enterprise: string; readonly runner_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'enterprise-admin/remove-custom-label-from-self-hosted-runner-for-enterprise'(
    args: {
      readonly enterprise: string;
      readonly runner_id: number;
      readonly name: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels/${encodeURIComponent(args['name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'code-scanning/list-alerts-for-enterprise'(
    args: {
      readonly tool_name?: CodeScanningAnalysisToolName;
      readonly tool_guid?: CodeScanningAnalysisToolGuid;
      readonly before?: string;
      readonly after?: string;
      readonly page?: number;
      readonly per_page?: number;
      readonly direction?: 'asc' | 'desc';
      readonly state?: CodeScanningAlertState;
      readonly sort?: 'created' | 'updated';
      readonly enterprise: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<CodeScanningOrganizationAlertItems>>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['tool_name']: args['tool_name'],
      ['tool_guid']: args['tool_guid'],
      ['before']: args['before'],
      ['after']: args['after'],
      ['page']: args['page'],
      ['per_page']: args['per_page'],
      ['direction']: args['direction'],
      ['state']: args['state'],
      ['sort']: args['sort']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/code-scanning/alerts?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<CodeScanningOrganizationAlertItems>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'secret-scanning/list-alerts-for-enterprise'(
    args: {
      readonly state?: 'open' | 'resolved';
      readonly secret_type?: string;
      readonly resolution?: string;
      readonly sort?: 'created' | 'updated';
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly before?: string;
      readonly after?: string;
      readonly enterprise: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<OrganizationSecretScanningAlert>>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['state']: args['state'],
      ['secret_type']: args['secret_type'],
      ['resolution']: args['resolution'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['before']: args['before'],
      ['after']: args['after']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/secret-scanning/alerts?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<OrganizationSecretScanningAlert>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'billing/get-github-advanced-security-billing-ghe'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly enterprise: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, AdvancedSecurityActiveCommitters>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/enterprises/${encodeURIComponent(args['enterprise'])}/settings/billing/advanced-security?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as AdvancedSecurityActiveCommitters
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-public-events'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Event>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/events?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Event>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/get-feeds'(
    options?: RequestInit
  ): Promise<ResponseWithData<200, Feed>> {
    const method = 'GET';
    const url = `${this.baseUrl}/feeds`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Feed
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/list'(
    args: {
      readonly since?: string;
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<BaseGist>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['since']: args['since'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/gists?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<BaseGist>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/create'(
    args: {
      readonly body: {
        readonly description?: string;
        readonly files: unknown;
        readonly public?: boolean | 'true' | 'false';
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, GistSimple>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/gists`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as GistSimple
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/list-public'(
    args: {
      readonly since?: string;
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<BaseGist>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['since']: args['since'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/gists/public?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<BaseGist>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/list-starred'(
    args: {
      readonly since?: string;
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<BaseGist>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['since']: args['since'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/gists/starred?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<BaseGist>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/get'(
    args: { readonly gist_id: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, GistSimple>
    | ResponseWithData<304, undefined>
    | ResponseWithData<
        403,
        {
          readonly block?: {
            readonly reason?: string;
            readonly created_at?: string;
            readonly html_url?: string | null;
          };
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GistSimple
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly block?: {
                readonly reason?: string;
                readonly created_at?: string;
                readonly html_url?: string | null;
              };
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/update'(
    args: {
      readonly gist_id: string;
      readonly body:
        | ({
            readonly description?: string;
            readonly files?: unknown;
          } & unknown)
        | null;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, GistSimple>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GistSimple
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/delete'(
    args: { readonly gist_id: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/list-comments'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly gist_id: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<GistComment>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}/comments?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<GistComment>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/create-comment'(
    args: {
      readonly gist_id: string;
      readonly body: { readonly body: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, GistComment>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}/comments`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as GistComment
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/get-comment'(
    args: { readonly gist_id: string; readonly comment_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, GistComment>
    | ResponseWithData<304, undefined>
    | ResponseWithData<
        403,
        {
          readonly block?: {
            readonly reason?: string;
            readonly created_at?: string;
            readonly html_url?: string | null;
          };
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}/comments/${encodeURIComponent(args['comment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GistComment
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly block?: {
                readonly reason?: string;
                readonly created_at?: string;
                readonly html_url?: string | null;
              };
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/update-comment'(
    args: {
      readonly gist_id: string;
      readonly comment_id: number;
      readonly body: { readonly body: string };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, GistComment> | ResponseWithData<404, BasicError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}/comments/${encodeURIComponent(args['comment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GistComment
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/delete-comment'(
    args: { readonly gist_id: string; readonly comment_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}/comments/${encodeURIComponent(args['comment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/list-commits'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly gist_id: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<GistCommit>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}/commits?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<GistCommit>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/list-forks'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly gist_id: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<GistSimple>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}/forks?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<GistSimple>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/fork'(
    args: { readonly gist_id: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, BaseGist>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}/forks`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as BaseGist
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/check-is-starred'(
    args: { readonly gist_id: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, {}>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}/star`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as {}
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/star'(
    args: { readonly gist_id: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}/star`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/unstar'(
    args: { readonly gist_id: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}/star`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/get-revision'(
    args: { readonly gist_id: string; readonly sha: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, GistSimple>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/gists/${encodeURIComponent(args['gist_id'])}/${encodeURIComponent(args['sha'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GistSimple
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gitignore/get-all-templates'(
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<string>>
    | ResponseWithData<304, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/gitignore/templates`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<string>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gitignore/get-template'(
    args: { readonly name: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, GitignoreTemplate> | ResponseWithData<304, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/gitignore/templates/${encodeURIComponent(args['name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GitignoreTemplate
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/list-repos-accessible-to-installation'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly repositories: ReadonlyArray<Repository>;
          readonly repository_selection?: string;
        }
      >
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/installation/repositories?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly repositories: ReadonlyArray<Repository>;
              readonly repository_selection?: string;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/revoke-installation-access-token'(
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/installation/token`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list'(
    args: {
      readonly filter?:
        | 'assigned'
        | 'created'
        | 'mentioned'
        | 'subscribed'
        | 'repos'
        | 'all';
      readonly state?: 'open' | 'closed' | 'all';
      readonly labels?: string;
      readonly sort?: 'created' | 'updated' | 'comments';
      readonly direction?: 'asc' | 'desc';
      readonly since?: string;
      readonly collab?: boolean;
      readonly orgs?: boolean;
      readonly owned?: boolean;
      readonly pulls?: boolean;
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Issue>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['filter']: args['filter'],
      ['state']: args['state'],
      ['labels']: args['labels'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['since']: args['since'],
      ['collab']: args['collab'],
      ['orgs']: args['orgs'],
      ['owned']: args['owned'],
      ['pulls']: args['pulls'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/issues?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Issue>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'licenses/get-all-commonly-used'(
    args: {
      readonly featured?: boolean;
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<LicenseSimple>>
    | ResponseWithData<304, undefined>
  > {
    const query = qs.stringify({
      ['featured']: args['featured'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/licenses?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<LicenseSimple>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'licenses/get'(
    args: { readonly license: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, License>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/licenses/${encodeURIComponent(args['license'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as License
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'markdown/render'(
    args: {
      readonly body: {
        readonly text: string;
        readonly mode?: 'markdown' | 'gfm';
        readonly context?: string;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, string> | ResponseWithData<304, undefined>> {
    const method = 'POST';
    const url = `${this.baseUrl}/markdown`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: await response.text()
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'markdown/render-raw'(
    options?: RequestInit
  ): Promise<ResponseWithData<200, string> | ResponseWithData<304, undefined>> {
    const method = 'POST';
    const url = `${this.baseUrl}/markdown/raw`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: await response.text()
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/get-subscription-plan-for-account'(
    args: { readonly account_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, MarketplacePurchase>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/marketplace_listing/accounts/${encodeURIComponent(args['account_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as MarketplacePurchase
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/list-plans'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<MarketplaceListingPlan>>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/marketplace_listing/plans?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MarketplaceListingPlan>
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/list-accounts-for-plan'(
    args: {
      readonly sort?: 'created' | 'updated';
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly page?: number;
      readonly plan_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<MarketplacePurchase>>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/marketplace_listing/plans/${encodeURIComponent(args['plan_id'])}/accounts?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MarketplacePurchase>
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/get-subscription-plan-for-account-stubbed'(
    args: { readonly account_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, MarketplacePurchase>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/marketplace_listing/stubbed/accounts/${encodeURIComponent(args['account_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as MarketplacePurchase
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/list-plans-stubbed'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<MarketplaceListingPlan>>
    | ResponseWithData<401, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/marketplace_listing/stubbed/plans?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MarketplaceListingPlan>
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/list-accounts-for-plan-stubbed'(
    args: {
      readonly sort?: 'created' | 'updated';
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly page?: number;
      readonly plan_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<MarketplacePurchase>>
    | ResponseWithData<401, BasicError>
  > {
    const query = qs.stringify({
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/marketplace_listing/stubbed/plans/${encodeURIComponent(args['plan_id'])}/accounts?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MarketplacePurchase>
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'meta/get'(
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, ApiOverview> | ResponseWithData<304, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/meta`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ApiOverview
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-public-events-for-repo-network'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Event>>
    | ResponseWithData<301, BasicError>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/networks/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/events?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Event>
          };

        case 301:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-notifications-for-authenticated-user'(
    args: {
      readonly all?: boolean;
      readonly participating?: boolean;
      readonly since?: string;
      readonly before?: string;
      readonly page?: number;
      readonly per_page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Thread>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['all']: args['all'],
      ['participating']: args['participating'],
      ['since']: args['since'],
      ['before']: args['before'],
      ['page']: args['page'],
      ['per_page']: args['per_page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/notifications?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Thread>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/mark-notifications-as-read'(
    args: {
      readonly body?: {
        readonly last_read_at?: string;
        readonly read?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<202, { readonly message?: string }>
    | ResponseWithData<205, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/notifications`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as { readonly message?: string }
          };

        case 205:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/get-thread'(
    args: { readonly thread_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Thread>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/notifications/threads/${encodeURIComponent(args['thread_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Thread
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/mark-thread-as-read'(
    args: { readonly thread_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<205, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/notifications/threads/${encodeURIComponent(args['thread_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 205:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/get-thread-subscription-for-authenticated-user'(
    args: { readonly thread_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ThreadSubscription>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/notifications/threads/${encodeURIComponent(args['thread_id'])}/subscription`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ThreadSubscription
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/set-thread-subscription'(
    args: {
      readonly thread_id: number;
      readonly body?: { readonly ignored?: boolean };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ThreadSubscription>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/notifications/threads/${encodeURIComponent(args['thread_id'])}/subscription`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ThreadSubscription
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/delete-thread-subscription'(
    args: { readonly thread_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/notifications/threads/${encodeURIComponent(args['thread_id'])}/subscription`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'meta/get-octocat'(
    args: { readonly s?: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, globalThis.Blob>> {
    const query = qs.stringify({ ['s']: args['s'] });

    const method = 'GET';
    const url = `${this.baseUrl}/octocat?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: await response.blob()
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list'(
    args: { readonly since?: number; readonly per_page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<OrganizationSimple>>
    | ResponseWithData<304, undefined>
  > {
    const query = qs.stringify({
      ['since']: args['since'],
      ['per_page']: args['per_page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/organizations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<OrganizationSimple>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-custom-roles'(
    args: { readonly organization_id: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count?: number;
        readonly custom_roles?: ReadonlyArray<OrganizationCustomRepositoryRole>;
      }
    >
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/organizations/${encodeURIComponent(args['organization_id'])}/custom_roles`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count?: number;
              readonly custom_roles?: ReadonlyArray<OrganizationCustomRepositoryRole>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/get'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, OrganizationFull> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as OrganizationFull
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/update'(
    args: {
      readonly org: string;
      readonly body?: {
        readonly billing_email?: string;
        readonly company?: string;
        readonly email?: string;
        readonly twitter_username?: string;
        readonly location?: string;
        readonly name?: string;
        readonly description?: string;
        readonly has_organization_projects?: boolean;
        readonly has_repository_projects?: boolean;
        readonly default_repository_permission?:
          | 'read'
          | 'write'
          | 'admin'
          | 'none';
        readonly members_can_create_repositories?: boolean;
        readonly members_can_create_internal_repositories?: boolean;
        readonly members_can_create_private_repositories?: boolean;
        readonly members_can_create_public_repositories?: boolean;
        readonly members_allowed_repository_creation_type?:
          | 'all'
          | 'private'
          | 'none';
        readonly members_can_create_pages?: boolean;
        readonly members_can_create_public_pages?: boolean;
        readonly members_can_create_private_pages?: boolean;
        readonly members_can_fork_private_repositories?: boolean;
        readonly web_commit_signoff_required?: boolean;
        readonly blog?: string;
        readonly advanced_security_enabled_for_new_repositories?: boolean;
        readonly dependabot_alerts_enabled_for_new_repositories?: boolean;
        readonly dependabot_security_updates_enabled_for_new_repositories?: boolean;
        readonly dependency_graph_enabled_for_new_repositories?: boolean;
        readonly secret_scanning_enabled_for_new_repositories?: boolean;
        readonly secret_scanning_push_protection_enabled_for_new_repositories?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, OrganizationFull>
    | ResponseWithData<409, BasicError>
    | ResponseWithData<422, ValidationError | ValidationErrorSimple>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as OrganizationFull
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as
              | ValidationError
              | ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-actions-cache-usage-for-org'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsCacheUsageOrgEnterprise>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/cache/usage`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsCacheUsageOrgEnterprise
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-actions-cache-usage-by-repo-for-org'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly repository_cache_usages: ReadonlyArray<ActionsCacheUsageByRepository>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/cache/usage-by-repository?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly repository_cache_usages: ReadonlyArray<ActionsCacheUsageByRepository>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-github-actions-permissions-organization'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsOrganizationPermissions>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/permissions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsOrganizationPermissions
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-github-actions-permissions-organization'(
    args: {
      readonly org: string;
      readonly body: {
        readonly enabled_repositories: EnabledRepositories;
        readonly allowed_actions?: AllowedActions;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/permissions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-selected-repositories-enabled-github-actions-organization'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly repositories: ReadonlyArray<Repository>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/permissions/repositories?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly repositories: ReadonlyArray<Repository>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-selected-repositories-enabled-github-actions-organization'(
    args: {
      readonly org: string;
      readonly body: {
        readonly selected_repository_ids: ReadonlyArray<number>;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/permissions/repositories`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/enable-selected-repository-github-actions-organization'(
    args: { readonly org: string; readonly repository_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/permissions/repositories/${encodeURIComponent(args['repository_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/disable-selected-repository-github-actions-organization'(
    args: { readonly org: string; readonly repository_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/permissions/repositories/${encodeURIComponent(args['repository_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-allowed-actions-organization'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, SelectedActions>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/permissions/selected-actions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as SelectedActions
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-allowed-actions-organization'(
    args: { readonly org: string; readonly body?: SelectedActions },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/permissions/selected-actions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-github-actions-default-workflow-permissions-organization'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsGetDefaultWorkflowPermissions>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/permissions/workflow`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsGetDefaultWorkflowPermissions
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-github-actions-default-workflow-permissions-organization'(
    args: {
      readonly org: string;
      readonly body?: ActionsSetDefaultWorkflowPermissions;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<409, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/permissions/workflow`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-self-hosted-runner-groups-for-org'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly visible_to_repository?: string;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly runner_groups: ReadonlyArray<RunnerGroupsOrg>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page'],
      ['visible_to_repository']: args['visible_to_repository']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runner-groups?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly runner_groups: ReadonlyArray<RunnerGroupsOrg>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/create-self-hosted-runner-group-for-org'(
    args: {
      readonly org: string;
      readonly body: {
        readonly name: string;
        readonly visibility?: 'selected' | 'all' | 'private';
        readonly selected_repository_ids?: ReadonlyArray<number>;
        readonly runners?: ReadonlyArray<number>;
        readonly allows_public_repositories?: boolean;
        readonly restricted_to_workflows?: boolean;
        readonly selected_workflows?: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, RunnerGroupsOrg>> {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runner-groups`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as RunnerGroupsOrg
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-self-hosted-runner-group-for-org'(
    args: { readonly org: string; readonly runner_group_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<200, RunnerGroupsOrg>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as RunnerGroupsOrg
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/update-self-hosted-runner-group-for-org'(
    args: {
      readonly org: string;
      readonly runner_group_id: number;
      readonly body: {
        readonly name: string;
        readonly visibility?: 'selected' | 'all' | 'private';
        readonly allows_public_repositories?: boolean;
        readonly restricted_to_workflows?: boolean;
        readonly selected_workflows?: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, RunnerGroupsOrg>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as RunnerGroupsOrg
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/delete-self-hosted-runner-group-from-org'(
    args: { readonly org: string; readonly runner_group_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-repo-access-to-self-hosted-runner-group-in-org'(
    args: {
      readonly page?: number;
      readonly per_page?: number;
      readonly org: string;
      readonly runner_group_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly repositories: ReadonlyArray<MinimalRepository>;
      }
    >
  > {
    const query = qs.stringify({
      ['page']: args['page'],
      ['per_page']: args['per_page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/repositories?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly repositories: ReadonlyArray<MinimalRepository>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-repo-access-to-self-hosted-runner-group-in-org'(
    args: {
      readonly org: string;
      readonly runner_group_id: number;
      readonly body: {
        readonly selected_repository_ids: ReadonlyArray<number>;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/repositories`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/remove-repo-access-to-self-hosted-runner-group-in-org'(
    args: {
      readonly org: string;
      readonly runner_group_id: number;
      readonly repository_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/repositories/${encodeURIComponent(args['repository_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-self-hosted-runners-in-group-for-org'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
      readonly runner_group_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly runners: ReadonlyArray<SelfHostedRunners>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/runners?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly runners: ReadonlyArray<SelfHostedRunners>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-self-hosted-runners-in-group-for-org'(
    args: {
      readonly org: string;
      readonly runner_group_id: number;
      readonly body: { readonly runners: ReadonlyArray<number> };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/runners`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/add-self-hosted-runner-to-group-for-org'(
    args: {
      readonly org: string;
      readonly runner_group_id: number;
      readonly runner_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/runners/${encodeURIComponent(args['runner_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/remove-self-hosted-runner-from-group-for-org'(
    args: {
      readonly org: string;
      readonly runner_group_id: number;
      readonly runner_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runner-groups/${encodeURIComponent(args['runner_group_id'])}/runners/${encodeURIComponent(args['runner_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-self-hosted-runners-for-org'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly runners: ReadonlyArray<SelfHostedRunners>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runners?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly runners: ReadonlyArray<SelfHostedRunners>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-runner-applications-for-org'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<RunnerApplication>>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runners/downloads`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<RunnerApplication>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/create-registration-token-for-org'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<201, AuthenticationToken>> {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runners/registration-token`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as AuthenticationToken
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/create-remove-token-for-org'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<201, AuthenticationToken>> {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runners/remove-token`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as AuthenticationToken
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-self-hosted-runner-for-org'(
    args: { readonly org: string; readonly runner_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<200, SelfHostedRunners>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runners/${encodeURIComponent(args['runner_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as SelfHostedRunners
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/delete-self-hosted-runner-from-org'(
    args: { readonly org: string; readonly runner_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runners/${encodeURIComponent(args['runner_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-labels-for-self-hosted-runner-for-org'(
    args: { readonly org: string; readonly runner_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/add-custom-labels-to-self-hosted-runner-for-org'(
    args: {
      readonly org: string;
      readonly runner_id: number;
      readonly body: { readonly labels: ReadonlyArray<string> };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-custom-labels-for-self-hosted-runner-for-org'(
    args: {
      readonly org: string;
      readonly runner_id: number;
      readonly body: { readonly labels: ReadonlyArray<string> };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/remove-all-custom-labels-from-self-hosted-runner-for-org'(
    args: { readonly org: string; readonly runner_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/remove-custom-label-from-self-hosted-runner-for-org'(
    args: {
      readonly org: string;
      readonly runner_id: number;
      readonly name: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels/${encodeURIComponent(args['name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-org-secrets'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly secrets: ReadonlyArray<ActionsSecretForAnOrganization>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/secrets?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly secrets: ReadonlyArray<ActionsSecretForAnOrganization>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-org-public-key'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsPublicKey>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/secrets/public-key`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsPublicKey
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-org-secret'(
    args: { readonly org: string; readonly secret_name: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsSecretForAnOrganization>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsSecretForAnOrganization
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/create-or-update-org-secret'(
    args: {
      readonly org: string;
      readonly secret_name: string;
      readonly body: {
        readonly encrypted_value?: string;
        readonly key_id?: string;
        readonly visibility: 'all' | 'private' | 'selected';
        readonly selected_repository_ids?: ReadonlyArray<number>;
      };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<201, EmptyObject> | ResponseWithData<204, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/delete-org-secret'(
    args: { readonly org: string; readonly secret_name: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-selected-repos-for-org-secret'(
    args: {
      readonly page?: number;
      readonly per_page?: number;
      readonly org: string;
      readonly secret_name: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly repositories: ReadonlyArray<MinimalRepository>;
      }
    >
  > {
    const query = qs.stringify({
      ['page']: args['page'],
      ['per_page']: args['per_page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/secrets/${encodeURIComponent(args['secret_name'])}/repositories?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly repositories: ReadonlyArray<MinimalRepository>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-selected-repos-for-org-secret'(
    args: {
      readonly org: string;
      readonly secret_name: string;
      readonly body: {
        readonly selected_repository_ids: ReadonlyArray<number>;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/secrets/${encodeURIComponent(args['secret_name'])}/repositories`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/add-selected-repo-to-org-secret'(
    args: {
      readonly org: string;
      readonly secret_name: string;
      readonly repository_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<409, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/secrets/${encodeURIComponent(args['secret_name'])}/repositories/${encodeURIComponent(args['repository_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/remove-selected-repo-from-org-secret'(
    args: {
      readonly org: string;
      readonly secret_name: string;
      readonly repository_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<409, undefined>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/actions/secrets/${encodeURIComponent(args['secret_name'])}/repositories/${encodeURIComponent(args['repository_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-blocked-users'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<SimpleUser>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/blocks?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/check-blocked-user'(
    args: { readonly org: string; readonly username: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/blocks/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/block-user'(
    args: { readonly org: string; readonly username: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/blocks/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/unblock-user'(
    args: { readonly org: string; readonly username: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/blocks/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'code-scanning/list-alerts-for-org'(
    args: {
      readonly tool_name?: CodeScanningAnalysisToolName;
      readonly tool_guid?: CodeScanningAnalysisToolGuid;
      readonly before?: string;
      readonly after?: string;
      readonly page?: number;
      readonly per_page?: number;
      readonly direction?: 'asc' | 'desc';
      readonly state?: CodeScanningAlertState;
      readonly sort?: 'created' | 'updated';
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<CodeScanningOrganizationAlertItems>>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['tool_name']: args['tool_name'],
      ['tool_guid']: args['tool_guid'],
      ['before']: args['before'],
      ['after']: args['after'],
      ['page']: args['page'],
      ['per_page']: args['per_page'],
      ['direction']: args['direction'],
      ['state']: args['state'],
      ['sort']: args['sort']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/code-scanning/alerts?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<CodeScanningOrganizationAlertItems>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/list-in-organization'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly codespaces: ReadonlyArray<Codespace>;
        }
      >
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/codespaces?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly codespaces: ReadonlyArray<Codespace>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/set-codespaces-billing'(
    args: {
      readonly org: string;
      readonly body: {
        readonly visibility:
          | 'disabled'
          | 'selected_members'
          | 'all_members'
          | 'all_members_and_outside_collaborators';
        readonly selected_usernames?: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<400, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/codespaces/billing`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 400:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/list-org-secrets'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly secrets: ReadonlyArray<CodespacesSecret>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/codespaces/secrets?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly secrets: ReadonlyArray<CodespacesSecret>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/get-org-public-key'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, CodespacesPublicKey>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/codespaces/secrets/public-key`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CodespacesPublicKey
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/get-org-secret'(
    args: { readonly org: string; readonly secret_name: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, CodespacesSecret>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/codespaces/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CodespacesSecret
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/create-or-update-org-secret'(
    args: {
      readonly org: string;
      readonly secret_name: string;
      readonly body: {
        readonly encrypted_value?: string;
        readonly key_id?: string;
        readonly visibility: 'all' | 'private' | 'selected';
        readonly selected_repository_ids?: ReadonlyArray<number>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, EmptyObject>
    | ResponseWithData<204, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/codespaces/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/delete-org-secret'(
    args: { readonly org: string; readonly secret_name: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/codespaces/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/list-selected-repos-for-org-secret'(
    args: {
      readonly page?: number;
      readonly per_page?: number;
      readonly org: string;
      readonly secret_name: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly repositories: ReadonlyArray<MinimalRepository>;
        }
      >
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['page']: args['page'],
      ['per_page']: args['per_page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/codespaces/secrets/${encodeURIComponent(args['secret_name'])}/repositories?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly repositories: ReadonlyArray<MinimalRepository>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/set-selected-repos-for-org-secret'(
    args: {
      readonly org: string;
      readonly secret_name: string;
      readonly body: {
        readonly selected_repository_ids: ReadonlyArray<number>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<409, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/codespaces/secrets/${encodeURIComponent(args['secret_name'])}/repositories`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/add-selected-repo-to-org-secret'(
    args: {
      readonly org: string;
      readonly secret_name: string;
      readonly repository_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<409, undefined>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/codespaces/secrets/${encodeURIComponent(args['secret_name'])}/repositories/${encodeURIComponent(args['repository_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/remove-selected-repo-from-org-secret'(
    args: {
      readonly org: string;
      readonly secret_name: string;
      readonly repository_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<409, undefined>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/codespaces/secrets/${encodeURIComponent(args['secret_name'])}/repositories/${encodeURIComponent(args['repository_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/create-custom-role'(
    args: {
      readonly org: string;
      readonly body: {
        readonly name: string;
        readonly description?: string;
        readonly base_role: 'read' | 'triage' | 'write' | 'maintain';
        readonly permissions: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, OrganizationCustomRepositoryRole>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/custom_roles`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as OrganizationCustomRepositoryRole
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/get-custom-role'(
    args: { readonly org: string; readonly role_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, OrganizationCustomRepositoryRole>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/custom_roles/${encodeURIComponent(args['role_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as OrganizationCustomRepositoryRole
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/update-custom-role'(
    args: {
      readonly org: string;
      readonly role_id: number;
      readonly body: {
        readonly name?: string;
        readonly description?: string;
        readonly base_role?: 'read' | 'triage' | 'write' | 'maintain';
        readonly permissions?: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, OrganizationCustomRepositoryRole>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/custom_roles/${encodeURIComponent(args['role_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as OrganizationCustomRepositoryRole
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/delete-custom-role'(
    args: { readonly org: string; readonly role_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/custom_roles/${encodeURIComponent(args['role_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/list-alerts-for-org'(
    args: {
      readonly state?: string;
      readonly severity?: string;
      readonly ecosystem?: string;
      readonly package?: string;
      readonly scope?: 'development' | 'runtime';
      readonly sort?: 'created' | 'updated';
      readonly direction?: 'asc' | 'desc';
      readonly before?: string;
      readonly after?: string;
      readonly first?: number;
      readonly last?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<DependabotAlertWithRepository>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const query = qs.stringify({
      ['state']: args['state'],
      ['severity']: args['severity'],
      ['ecosystem']: args['ecosystem'],
      ['package']: args['package'],
      ['scope']: args['scope'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['before']: args['before'],
      ['after']: args['after'],
      ['first']: args['first'],
      ['last']: args['last']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/dependabot/alerts?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<DependabotAlertWithRepository>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/list-org-secrets'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly secrets: ReadonlyArray<DependabotSecretForAnOrganization>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/dependabot/secrets?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly secrets: ReadonlyArray<DependabotSecretForAnOrganization>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/get-org-public-key'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, DependabotPublicKey>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/dependabot/secrets/public-key`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as DependabotPublicKey
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/get-org-secret'(
    args: { readonly org: string; readonly secret_name: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, DependabotSecretForAnOrganization>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/dependabot/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as DependabotSecretForAnOrganization
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/create-or-update-org-secret'(
    args: {
      readonly org: string;
      readonly secret_name: string;
      readonly body: {
        readonly encrypted_value?: string;
        readonly key_id?: string;
        readonly visibility: 'all' | 'private' | 'selected';
        readonly selected_repository_ids?: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<201, EmptyObject> | ResponseWithData<204, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/dependabot/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/delete-org-secret'(
    args: { readonly org: string; readonly secret_name: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/dependabot/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/list-selected-repos-for-org-secret'(
    args: {
      readonly page?: number;
      readonly per_page?: number;
      readonly org: string;
      readonly secret_name: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly repositories: ReadonlyArray<MinimalRepository>;
      }
    >
  > {
    const query = qs.stringify({
      ['page']: args['page'],
      ['per_page']: args['per_page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/dependabot/secrets/${encodeURIComponent(args['secret_name'])}/repositories?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly repositories: ReadonlyArray<MinimalRepository>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/set-selected-repos-for-org-secret'(
    args: {
      readonly org: string;
      readonly secret_name: string;
      readonly body: {
        readonly selected_repository_ids: ReadonlyArray<number>;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/dependabot/secrets/${encodeURIComponent(args['secret_name'])}/repositories`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/add-selected-repo-to-org-secret'(
    args: {
      readonly org: string;
      readonly secret_name: string;
      readonly repository_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<409, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/dependabot/secrets/${encodeURIComponent(args['secret_name'])}/repositories/${encodeURIComponent(args['repository_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/remove-selected-repo-from-org-secret'(
    args: {
      readonly org: string;
      readonly secret_name: string;
      readonly repository_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<409, undefined>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/dependabot/secrets/${encodeURIComponent(args['secret_name'])}/repositories/${encodeURIComponent(args['repository_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-public-org-events'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Event>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/events?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Event>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-failed-invitations'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<OrganizationInvitation>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/failed_invitations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<OrganizationInvitation>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-fine-grained-permissions'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, ReadonlyArray<OrganizationFineGrainedPermission>>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/fine_grained_permissions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<OrganizationFineGrainedPermission>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-webhooks'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<OrgHook>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/hooks?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<OrgHook>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/create-webhook'(
    args: {
      readonly org: string;
      readonly body: {
        readonly name: string;
        readonly config: {
          readonly url: WebhookConfigUrl;
          readonly content_type?: WebhookConfigContentType;
          readonly secret?: WebhookConfigSecret;
          readonly insecure_ssl?: WebhookConfigInsecureSsl;
          readonly username?: string;
          readonly password?: string;
        };
        readonly events?: ReadonlyArray<string>;
        readonly active?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, OrgHook>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/hooks`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as OrgHook
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/get-webhook'(
    args: { readonly org: string; readonly hook_id: number },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, OrgHook> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/hooks/${encodeURIComponent(args['hook_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as OrgHook
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/update-webhook'(
    args: {
      readonly org: string;
      readonly hook_id: number;
      readonly body?: {
        readonly config?: {
          readonly url: WebhookConfigUrl;
          readonly content_type?: WebhookConfigContentType;
          readonly secret?: WebhookConfigSecret;
          readonly insecure_ssl?: WebhookConfigInsecureSsl;
        };
        readonly events?: ReadonlyArray<string>;
        readonly active?: boolean;
        readonly name?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, OrgHook>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/hooks/${encodeURIComponent(args['hook_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as OrgHook
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/delete-webhook'(
    args: { readonly org: string; readonly hook_id: number },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/hooks/${encodeURIComponent(args['hook_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/get-webhook-config-for-org'(
    args: { readonly org: string; readonly hook_id: number },
    options?: RequestInit
  ): Promise<ResponseWithData<200, WebhookConfiguration>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/hooks/${encodeURIComponent(args['hook_id'])}/config`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as WebhookConfiguration
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/update-webhook-config-for-org'(
    args: {
      readonly org: string;
      readonly hook_id: number;
      readonly body?: {
        readonly url?: WebhookConfigUrl;
        readonly content_type?: WebhookConfigContentType;
        readonly secret?: WebhookConfigSecret;
        readonly insecure_ssl?: WebhookConfigInsecureSsl;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, WebhookConfiguration>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/hooks/${encodeURIComponent(args['hook_id'])}/config`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as WebhookConfiguration
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-webhook-deliveries'(
    args: {
      readonly per_page?: number;
      readonly cursor?: string;
      readonly org: string;
      readonly hook_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleWebhookDelivery>>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['cursor']: args['cursor']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/hooks/${encodeURIComponent(args['hook_id'])}/deliveries?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleWebhookDelivery>
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/get-webhook-delivery'(
    args: {
      readonly org: string;
      readonly hook_id: number;
      readonly delivery_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, WebhookDelivery>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/hooks/${encodeURIComponent(args['hook_id'])}/deliveries/${encodeURIComponent(args['delivery_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as WebhookDelivery
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/redeliver-webhook-delivery'(
    args: {
      readonly org: string;
      readonly hook_id: number;
      readonly delivery_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<202, unknown>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/hooks/${encodeURIComponent(args['hook_id'])}/deliveries/${encodeURIComponent(args['delivery_id'])}/attempts`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as unknown
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/ping-webhook'(
    args: { readonly org: string; readonly hook_id: number },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/hooks/${encodeURIComponent(args['hook_id'])}/pings`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/get-org-installation'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Installation>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/installation`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Installation
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-app-installations'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly installations: ReadonlyArray<Installation>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/installations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly installations: ReadonlyArray<Installation>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'interactions/get-restrictions-for-org'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, InteractionLimits | {}>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/interaction-limits`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as InteractionLimits | {}
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'interactions/set-restrictions-for-org'(
    args: { readonly org: string; readonly body: InteractionRestrictions },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, InteractionLimits>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/interaction-limits`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as InteractionLimits
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'interactions/remove-restrictions-for-org'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/interaction-limits`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-pending-invitations'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<OrganizationInvitation>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/invitations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<OrganizationInvitation>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/create-invitation'(
    args: {
      readonly org: string;
      readonly body?: {
        readonly invitee_id?: number;
        readonly email?: string;
        readonly role?: 'admin' | 'direct_member' | 'billing_manager';
        readonly team_ids?: ReadonlyArray<number>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, OrganizationInvitation>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/invitations`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as OrganizationInvitation
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/cancel-invitation'(
    args: { readonly org: string; readonly invitation_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/invitations/${encodeURIComponent(args['invitation_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-invitation-teams'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
      readonly invitation_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Team>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/invitations/${encodeURIComponent(args['invitation_id'])}/teams?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Team>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list-for-org'(
    args: {
      readonly filter?:
        | 'assigned'
        | 'created'
        | 'mentioned'
        | 'subscribed'
        | 'repos'
        | 'all';
      readonly state?: 'open' | 'closed' | 'all';
      readonly labels?: string;
      readonly sort?: 'created' | 'updated' | 'comments';
      readonly direction?: 'asc' | 'desc';
      readonly since?: string;
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Issue>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['filter']: args['filter'],
      ['state']: args['state'],
      ['labels']: args['labels'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['since']: args['since'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/issues?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Issue>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-members'(
    args: {
      readonly filter?: '2fa_disabled' | 'all';
      readonly role?: 'all' | 'admin' | 'member';
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleUser>>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['filter']: args['filter'],
      ['role']: args['role'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/members?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/check-membership-for-user'(
    args: { readonly org: string; readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<302, undefined>
    | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/members/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 302:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/remove-member'(
    args: { readonly org: string; readonly username: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<403, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/members/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/get-codespaces-for-user-in-org'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly codespaces: ReadonlyArray<Codespace>;
        }
      >
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/members/${encodeURIComponent(args['username'])}/codespaces?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly codespaces: ReadonlyArray<Codespace>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/delete-from-organization'(
    args: {
      readonly org: string;
      readonly username: string;
      readonly codespace_name: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<202, unknown>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/members/${encodeURIComponent(args['username'])}/codespaces/${encodeURIComponent(args['codespace_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as unknown
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/stop-in-organization'(
    args: {
      readonly org: string;
      readonly username: string;
      readonly codespace_name: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Codespace>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/members/${encodeURIComponent(args['username'])}/codespaces/${encodeURIComponent(args['codespace_name'])}/stop`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Codespace
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/get-membership-for-user'(
    args: { readonly org: string; readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, OrgMembership>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/memberships/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as OrgMembership
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/set-membership-for-user'(
    args: {
      readonly org: string;
      readonly username: string;
      readonly body?: { readonly role?: 'admin' | 'member' };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, OrgMembership>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/memberships/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as OrgMembership
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/remove-membership-for-user'(
    args: { readonly org: string; readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/memberships/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/list-for-org'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly exclude?: ReadonlyArray<'repositories'>;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Migration>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page'],
      ['exclude']: args['exclude']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/migrations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Migration>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/start-for-org'(
    args: {
      readonly org: string;
      readonly body: {
        readonly repositories: ReadonlyArray<string>;
        readonly lock_repositories?: boolean;
        readonly exclude_metadata?: boolean;
        readonly exclude_git_data?: boolean;
        readonly exclude_attachments?: boolean;
        readonly exclude_releases?: boolean;
        readonly exclude_owner_projects?: boolean;
        readonly org_metadata_only?: boolean;
        readonly exclude?: ReadonlyArray<'repositories'>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Migration>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/migrations`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Migration
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/get-status-for-org'(
    args: {
      readonly exclude?: ReadonlyArray<'repositories'>;
      readonly org: string;
      readonly migration_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, Migration> | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({ ['exclude']: args['exclude'] });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/migrations/${encodeURIComponent(args['migration_id'])}?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Migration
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/download-archive-for-org'(
    args: { readonly org: string; readonly migration_id: number },
    options?: RequestInit
  ): Promise<
    ResponseWithData<302, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/migrations/${encodeURIComponent(args['migration_id'])}/archive`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 302:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/delete-archive-for-org'(
    args: { readonly org: string; readonly migration_id: number },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/migrations/${encodeURIComponent(args['migration_id'])}/archive`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/unlock-repo-for-org'(
    args: {
      readonly org: string;
      readonly migration_id: number;
      readonly repo_name: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/migrations/${encodeURIComponent(args['migration_id'])}/repos/${encodeURIComponent(args['repo_name'])}/lock`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/list-repos-for-org'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
      readonly migration_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<MinimalRepository>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/migrations/${encodeURIComponent(args['migration_id'])}/repositories?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MinimalRepository>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-outside-collaborators'(
    args: {
      readonly filter?: '2fa_disabled' | 'all';
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<SimpleUser>>> {
    const query = qs.stringify({
      ['filter']: args['filter'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/outside_collaborators?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/convert-member-to-outside-collaborator'(
    args: {
      readonly org: string;
      readonly username: string;
      readonly body?: { readonly async?: boolean };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<202, {}>
    | ResponseWithData<204, undefined>
    | ResponseWithData<403, undefined>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/outside_collaborators/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as {}
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/remove-outside-collaborator'(
    args: { readonly org: string; readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<
        422,
        { readonly message?: string; readonly documentation_url?: string }
      >
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/outside_collaborators/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/list-packages-for-organization'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly visibility?: 'public' | 'private' | 'internal';
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Package>>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['package_type']: args['package_type'],
      ['visibility']: args['visibility']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/packages?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Package>
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/get-package-for-organization'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Package>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Package
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/delete-package-for-org'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/restore-package-for-org'(
    args: {
      readonly token?: string;
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({ ['token']: args['token'] });

    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/restore?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/get-all-package-versions-for-package-owned-by-org'(
    args: {
      readonly page?: number;
      readonly per_page?: number;
      readonly state?: 'active' | 'deleted';
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<PackageVersion>>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['page']: args['page'],
      ['per_page']: args['per_page'],
      ['state']: args['state']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/versions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<PackageVersion>
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/get-package-version-for-organization'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly org: string;
      readonly package_version_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, PackageVersion>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/versions/${encodeURIComponent(args['package_version_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PackageVersion
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/delete-package-version-for-org'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly org: string;
      readonly package_version_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/versions/${encodeURIComponent(args['package_version_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/restore-package-version-for-org'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly org: string;
      readonly package_version_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/versions/${encodeURIComponent(args['package_version_id'])}/restore`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/list-for-org'(
    args: {
      readonly state?: 'open' | 'closed' | 'all';
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Project>>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const query = qs.stringify({
      ['state']: args['state'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/projects?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Project>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/create-for-org'(
    args: {
      readonly org: string;
      readonly body: { readonly name: string; readonly body?: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Project>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/projects`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Project
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-public-members'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<SimpleUser>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/public_members?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/check-public-membership-for-user'(
    args: { readonly org: string; readonly username: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/public_members/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/set-public-membership-for-authenticated-user'(
    args: { readonly org: string; readonly username: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<403, BasicError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/public_members/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/remove-public-membership-for-authenticated-user'(
    args: { readonly org: string; readonly username: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/public_members/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-for-org'(
    args: {
      readonly type?:
        | 'all'
        | 'public'
        | 'private'
        | 'forks'
        | 'sources'
        | 'member'
        | 'internal';
      readonly sort?: 'created' | 'updated' | 'pushed' | 'full_name';
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<MinimalRepository>>> {
    const query = qs.stringify({
      ['type']: args['type'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/repos?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MinimalRepository>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-in-org'(
    args: {
      readonly org: string;
      readonly body: {
        readonly name: string;
        readonly description?: string;
        readonly homepage?: string;
        readonly private?: boolean;
        readonly visibility?: 'public' | 'private' | 'internal';
        readonly has_issues?: boolean;
        readonly has_projects?: boolean;
        readonly has_wiki?: boolean;
        readonly is_template?: boolean;
        readonly team_id?: number;
        readonly auto_init?: boolean;
        readonly gitignore_template?: string;
        readonly license_template?: string;
        readonly allow_squash_merge?: boolean;
        readonly allow_merge_commit?: boolean;
        readonly allow_rebase_merge?: boolean;
        readonly allow_auto_merge?: boolean;
        readonly delete_branch_on_merge?: boolean;
        readonly use_squash_pr_title_as_default?: boolean;
        readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
        readonly squash_merge_commit_message?:
          | 'PR_BODY'
          | 'COMMIT_MESSAGES'
          | 'BLANK';
        readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
        readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Repository>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/repos`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Repository
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'secret-scanning/list-alerts-for-org'(
    args: {
      readonly state?: 'open' | 'resolved';
      readonly secret_type?: string;
      readonly resolution?: string;
      readonly sort?: 'created' | 'updated';
      readonly direction?: 'asc' | 'desc';
      readonly page?: number;
      readonly per_page?: number;
      readonly before?: string;
      readonly after?: string;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<OrganizationSecretScanningAlert>>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['state']: args['state'],
      ['secret_type']: args['secret_type'],
      ['resolution']: args['resolution'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['page']: args['page'],
      ['per_page']: args['per_page'],
      ['before']: args['before'],
      ['after']: args['after']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/secret-scanning/alerts?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<OrganizationSecretScanningAlert>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-security-manager-teams'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<TeamSimple>>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/security-managers`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<TeamSimple>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/add-security-manager-team'(
    args: { readonly org: string; readonly team_slug: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<409, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/security-managers/teams/${encodeURIComponent(args['team_slug'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/remove-security-manager-team'(
    args: { readonly org: string; readonly team_slug: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/security-managers/teams/${encodeURIComponent(args['team_slug'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'billing/get-github-actions-billing-org'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsBillingUsage>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/settings/billing/actions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsBillingUsage
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'billing/get-github-advanced-security-billing-org'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, AdvancedSecurityActiveCommitters>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/settings/billing/advanced-security?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as AdvancedSecurityActiveCommitters
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'billing/get-github-packages-billing-org'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, PackagesBillingUsage>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/settings/billing/packages`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PackagesBillingUsage
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'billing/get-shared-storage-billing-org'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, CombinedBillingUsage>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/settings/billing/shared-storage`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CombinedBillingUsage
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Team>>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Team>
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/create'(
    args: {
      readonly org: string;
      readonly body: {
        readonly name: string;
        readonly description?: string;
        readonly maintainers?: ReadonlyArray<string>;
        readonly repo_names?: ReadonlyArray<string>;
        readonly privacy?: 'secret' | 'closed';
        readonly permission?: 'pull' | 'push';
        readonly parent_team_id?: number;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, FullTeam>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as FullTeam
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/get-by-name'(
    args: { readonly org: string; readonly team_slug: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, FullTeam> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as FullTeam
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/update-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly body?: {
        readonly name?: string;
        readonly description?: string;
        readonly privacy?: 'secret' | 'closed';
        readonly permission?: 'pull' | 'push' | 'admin';
        readonly parent_team_id?: number | null;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, FullTeam>
    | ResponseWithData<201, FullTeam>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as FullTeam
          };

        case 201:
          return {
            status: $status,
            body: (await response.json()) as FullTeam
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/delete-in-org'(
    args: { readonly org: string; readonly team_slug: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-discussions-in-org'(
    args: {
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly page?: number;
      readonly pinned?: string;
      readonly org: string;
      readonly team_slug: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<TeamDiscussion>>> {
    const query = qs.stringify({
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['page']: args['page'],
      ['pinned']: args['pinned']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<TeamDiscussion>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/create-discussion-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly body: {
        readonly title: string;
        readonly body: string;
        readonly private?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, TeamDiscussion>> {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as TeamDiscussion
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/get-discussion-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, TeamDiscussion>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamDiscussion
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/update-discussion-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
      readonly body?: { readonly title?: string; readonly body?: string };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, TeamDiscussion>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamDiscussion
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/delete-discussion-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-discussion-comments-in-org'(
    args: {
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<TeamDiscussionComment>>> {
    const query = qs.stringify({
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<TeamDiscussionComment>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/create-discussion-comment-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
      readonly body: { readonly body: string };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, TeamDiscussionComment>> {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as TeamDiscussionComment
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/get-discussion-comment-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
      readonly comment_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, TeamDiscussionComment>> {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments/${encodeURIComponent(args['comment_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamDiscussionComment
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/update-discussion-comment-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
      readonly comment_number: number;
      readonly body: { readonly body: string };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, TeamDiscussionComment>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments/${encodeURIComponent(args['comment_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamDiscussionComment
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/delete-discussion-comment-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
      readonly comment_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments/${encodeURIComponent(args['comment_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/list-for-team-discussion-comment-in-org'(
    args: {
      readonly content?:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
      readonly comment_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Reaction>>> {
    const query = qs.stringify({
      ['content']: args['content'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments/${encodeURIComponent(args['comment_number'])}/reactions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Reaction>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/create-for-team-discussion-comment-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
      readonly comment_number: number;
      readonly body: {
        readonly content:
          | '+1'
          | '-1'
          | 'laugh'
          | 'confused'
          | 'heart'
          | 'hooray'
          | 'rocket'
          | 'eyes';
      };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, Reaction> | ResponseWithData<201, Reaction>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments/${encodeURIComponent(args['comment_number'])}/reactions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        case 201:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/delete-for-team-discussion-comment'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
      readonly comment_number: number;
      readonly reaction_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments/${encodeURIComponent(args['comment_number'])}/reactions/${encodeURIComponent(args['reaction_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/list-for-team-discussion-in-org'(
    args: {
      readonly content?:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Reaction>>> {
    const query = qs.stringify({
      ['content']: args['content'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}/reactions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Reaction>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/create-for-team-discussion-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
      readonly body: {
        readonly content:
          | '+1'
          | '-1'
          | 'laugh'
          | 'confused'
          | 'heart'
          | 'hooray'
          | 'rocket'
          | 'eyes';
      };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, Reaction> | ResponseWithData<201, Reaction>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}/reactions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        case 201:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/delete-for-team-discussion'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly discussion_number: number;
      readonly reaction_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/discussions/${encodeURIComponent(args['discussion_number'])}/reactions/${encodeURIComponent(args['reaction_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-pending-invitations-in-org'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
      readonly team_slug: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<OrganizationInvitation>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/invitations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<OrganizationInvitation>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-members-in-org'(
    args: {
      readonly role?: 'member' | 'maintainer' | 'all';
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
      readonly team_slug: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<SimpleUser>>> {
    const query = qs.stringify({
      ['role']: args['role'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/members?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/get-membership-for-user-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, TeamMembership> | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/memberships/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamMembership
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/add-or-update-membership-for-user-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly username: string;
      readonly body?: { readonly role?: 'member' | 'maintainer' };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, TeamMembership>
    | ResponseWithData<403, undefined>
    | ResponseWithData<422, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/memberships/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamMembership
          };

        case 403:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/remove-membership-for-user-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<403, undefined>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/memberships/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-projects-in-org'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
      readonly team_slug: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<TeamProject>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/projects?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<TeamProject>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/check-permissions-for-project-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly project_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, TeamProject> | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/projects/${encodeURIComponent(args['project_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamProject
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/add-or-update-project-permissions-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly project_id: number;
      readonly body?: {
        readonly permission?: 'read' | 'write' | 'admin';
      } | null;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<
        403,
        { readonly message?: string; readonly documentation_url?: string }
      >
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/projects/${encodeURIComponent(args['project_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/remove-project-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly project_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/projects/${encodeURIComponent(args['project_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-repos-in-org'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
      readonly team_slug: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<MinimalRepository>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/repos?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MinimalRepository>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/check-permissions-for-repo-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, TeamRepository>
    | ResponseWithData<204, undefined>
    | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamRepository
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/add-or-update-repo-permissions-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly owner: string;
      readonly repo: string;
      readonly body?: { readonly permission?: string };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/remove-repo-in-org'(
    args: {
      readonly org: string;
      readonly team_slug: string;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-child-in-org'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly org: string;
      readonly team_slug: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Team>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/teams/${encodeURIComponent(args['team_slug'])}/teams?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Team>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/enable-or-disable-security-product-on-all-org-repos'(
    args: {
      readonly org: string;
      readonly security_product:
        | 'dependency_graph'
        | 'dependabot_alerts'
        | 'dependabot_security_updates'
        | 'advanced_security'
        | 'secret_scanning'
        | 'secret_scanning_push_protection';
      readonly enablement: 'enable_all' | 'disable_all';
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<422, undefined>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/orgs/${encodeURIComponent(args['org'])}/${encodeURIComponent(args['security_product'])}/${encodeURIComponent(args['enablement'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/get-card'(
    args: { readonly card_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ProjectCard>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/projects/columns/cards/${encodeURIComponent(args['card_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ProjectCard
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/update-card'(
    args: {
      readonly card_id: number;
      readonly body?: {
        readonly note?: string | null;
        readonly archived?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ProjectCard>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/projects/columns/cards/${encodeURIComponent(args['card_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ProjectCard
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/delete-card'(
    args: { readonly card_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<
        403,
        {
          readonly message?: string;
          readonly documentation_url?: string;
          readonly errors?: ReadonlyArray<string>;
        }
      >
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/projects/columns/cards/${encodeURIComponent(args['card_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly message?: string;
              readonly documentation_url?: string;
              readonly errors?: ReadonlyArray<string>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/move-card'(
    args: {
      readonly card_id: number;
      readonly body: { readonly position: string; readonly column_id?: number };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, {}>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<
        403,
        {
          readonly message?: string;
          readonly documentation_url?: string;
          readonly errors?: ReadonlyArray<{
            readonly code?: string;
            readonly message?: string;
            readonly resource?: string;
            readonly field?: string;
          }>;
        }
      >
    | ResponseWithData<422, ValidationError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
          readonly errors?: ReadonlyArray<{
            readonly code?: string;
            readonly message?: string;
          }>;
        }
      >
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/projects/columns/cards/${encodeURIComponent(args['card_id'])}/moves`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as {}
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly message?: string;
              readonly documentation_url?: string;
              readonly errors?: ReadonlyArray<{
                readonly code?: string;
                readonly message?: string;
                readonly resource?: string;
                readonly field?: string;
              }>;
            }
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
              readonly errors?: ReadonlyArray<{
                readonly code?: string;
                readonly message?: string;
              }>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/get-column'(
    args: { readonly column_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ProjectColumn>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/projects/columns/${encodeURIComponent(args['column_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ProjectColumn
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/update-column'(
    args: {
      readonly column_id: number;
      readonly body: { readonly name: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ProjectColumn>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/projects/columns/${encodeURIComponent(args['column_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ProjectColumn
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/delete-column'(
    args: { readonly column_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/projects/columns/${encodeURIComponent(args['column_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/list-cards'(
    args: {
      readonly archived_state?: 'all' | 'archived' | 'not_archived';
      readonly per_page?: number;
      readonly page?: number;
      readonly column_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<ProjectCard>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['archived_state']: args['archived_state'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/projects/columns/${encodeURIComponent(args['column_id'])}/cards?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<ProjectCard>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/create-card'(
    args: {
      readonly column_id: number;
      readonly body:
        | { readonly note: string | null }
        | { readonly content_id: number; readonly content_type: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, ProjectCard>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError | ValidationErrorSimple>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
          readonly errors?: ReadonlyArray<{
            readonly code?: string;
            readonly message?: string;
          }>;
        }
      >
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/projects/columns/${encodeURIComponent(args['column_id'])}/cards`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as ProjectCard
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as
              | ValidationError
              | ValidationErrorSimple
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
              readonly errors?: ReadonlyArray<{
                readonly code?: string;
                readonly message?: string;
              }>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/move-column'(
    args: {
      readonly column_id: number;
      readonly body: { readonly position: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, {}>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/projects/columns/${encodeURIComponent(args['column_id'])}/moves`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as {}
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/get'(
    args: { readonly project_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Project>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/projects/${encodeURIComponent(args['project_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Project
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/update'(
    args: {
      readonly project_id: number;
      readonly body?: {
        readonly name?: string;
        readonly body?: string | null;
        readonly state?: string;
        readonly organization_permission?: 'read' | 'write' | 'admin' | 'none';
        readonly private?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Project>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<
        403,
        {
          readonly message?: string;
          readonly documentation_url?: string;
          readonly errors?: ReadonlyArray<string>;
        }
      >
    | ResponseWithData<404, undefined>
    | ResponseWithData<410, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/projects/${encodeURIComponent(args['project_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Project
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly message?: string;
              readonly documentation_url?: string;
              readonly errors?: ReadonlyArray<string>;
            }
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/delete'(
    args: { readonly project_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<
        403,
        {
          readonly message?: string;
          readonly documentation_url?: string;
          readonly errors?: ReadonlyArray<string>;
        }
      >
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/projects/${encodeURIComponent(args['project_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly message?: string;
              readonly documentation_url?: string;
              readonly errors?: ReadonlyArray<string>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/list-collaborators'(
    args: {
      readonly affiliation?: 'outside' | 'direct' | 'all';
      readonly per_page?: number;
      readonly page?: number;
      readonly project_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleUser>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['affiliation']: args['affiliation'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/projects/${encodeURIComponent(args['project_id'])}/collaborators?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/add-collaborator'(
    args: {
      readonly project_id: number;
      readonly username: string;
      readonly body?: {
        readonly permission?: 'read' | 'write' | 'admin';
      } | null;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/projects/${encodeURIComponent(args['project_id'])}/collaborators/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/remove-collaborator'(
    args: { readonly project_id: number; readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/projects/${encodeURIComponent(args['project_id'])}/collaborators/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/get-permission-for-user'(
    args: { readonly project_id: number; readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ProjectCollaboratorPermission>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/projects/${encodeURIComponent(args['project_id'])}/collaborators/${encodeURIComponent(args['username'])}/permission`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ProjectCollaboratorPermission
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/list-columns'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly project_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<ProjectColumn>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/projects/${encodeURIComponent(args['project_id'])}/columns?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<ProjectColumn>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/create-column'(
    args: {
      readonly project_id: number;
      readonly body: { readonly name: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, ProjectColumn>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/projects/${encodeURIComponent(args['project_id'])}/columns`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as ProjectColumn
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'rate-limit/get'(
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, RateLimitOverview>
    | ResponseWithData<304, undefined>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/rate_limit`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as RateLimitOverview
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, FullRepository>
    | ResponseWithData<301, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as FullRepository
          };

        case 301:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/update'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body?: {
        readonly name?: string;
        readonly description?: string;
        readonly homepage?: string;
        readonly private?: boolean;
        readonly visibility?: 'public' | 'private' | 'internal';
        readonly security_and_analysis?: {
          readonly advanced_security?: { readonly status?: string };
          readonly secret_scanning?: { readonly status?: string };
          readonly secret_scanning_push_protection?: {
            readonly status?: string;
          };
        } | null;
        readonly has_issues?: boolean;
        readonly has_projects?: boolean;
        readonly has_wiki?: boolean;
        readonly is_template?: boolean;
        readonly default_branch?: string;
        readonly allow_squash_merge?: boolean;
        readonly allow_merge_commit?: boolean;
        readonly allow_rebase_merge?: boolean;
        readonly allow_auto_merge?: boolean;
        readonly delete_branch_on_merge?: boolean;
        readonly allow_update_branch?: boolean;
        readonly use_squash_pr_title_as_default?: boolean;
        readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
        readonly squash_merge_commit_message?:
          | 'PR_BODY'
          | 'COMMIT_MESSAGES'
          | 'BLANK';
        readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
        readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
        readonly archived?: boolean;
        readonly allow_forking?: boolean;
        readonly web_commit_signoff_required?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, FullRepository>
    | ResponseWithData<307, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as FullRepository
          };

        case 307:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<307, BasicError>
    | ResponseWithData<
        403,
        { readonly message?: string; readonly documentation_url?: string }
      >
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 307:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-artifacts-for-repo'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly name?: string;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly artifacts: ReadonlyArray<Artifact>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page'],
      ['name']: args['name']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/artifacts?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly artifacts: ReadonlyArray<Artifact>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-artifact'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly artifact_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Artifact>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/artifacts/${encodeURIComponent(args['artifact_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Artifact
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/delete-artifact'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly artifact_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/artifacts/${encodeURIComponent(args['artifact_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/download-artifact'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly artifact_id: number;
      readonly archive_format: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<302, undefined> | ResponseWithData<410, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/artifacts/${encodeURIComponent(args['artifact_id'])}/${encodeURIComponent(args['archive_format'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 302:
          return {
            status: $status,
            body: undefined
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-actions-cache-usage'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsCacheUsageByRepository>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/cache/usage`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsCacheUsageByRepository
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-actions-cache-list'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly ref?: CodeScanningRef;
      readonly key?: string;
      readonly sort?: 'created_at' | 'last_accessed_at' | 'size_in_bytes';
      readonly direction?: 'asc' | 'desc';
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, RepositoryActionsCaches>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page'],
      ['ref']: args['ref'],
      ['key']: args['key'],
      ['sort']: args['sort'],
      ['direction']: args['direction']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/caches?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as RepositoryActionsCaches
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/delete-actions-cache-by-key'(
    args: {
      readonly key: string;
      readonly ref?: CodeScanningRef;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, RepositoryActionsCaches>> {
    const query = qs.stringify({ ['key']: args['key'], ['ref']: args['ref'] });

    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/caches?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as RepositoryActionsCaches
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/delete-actions-cache-by-id'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly cache_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/caches/${encodeURIComponent(args['cache_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-job-for-workflow-run'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly job_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Job>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/jobs/${encodeURIComponent(args['job_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Job
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/download-job-logs-for-workflow-run'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly job_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<302, undefined>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/jobs/${encodeURIComponent(args['job_id'])}/logs`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 302:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/re-run-job-for-workflow-run'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly job_id: number;
      readonly body?: { readonly enable_debug_logging?: boolean } | null;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<201, EmptyObject> | ResponseWithData<403, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/jobs/${encodeURIComponent(args['job_id'])}/rerun`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-github-actions-permissions-repository'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsRepositoryPermissions>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/permissions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsRepositoryPermissions
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-github-actions-permissions-repository'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly enabled: ActionsEnabled;
        readonly allowed_actions?: AllowedActions;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/permissions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-workflow-access-to-repository'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsWorkflowAccessToRepository>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/permissions/access`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsWorkflowAccessToRepository
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-workflow-access-to-repository'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: ActionsWorkflowAccessToRepository;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/permissions/access`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-allowed-actions-repository'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, SelectedActions>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/permissions/selected-actions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as SelectedActions
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-allowed-actions-repository'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body?: SelectedActions;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/permissions/selected-actions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-github-actions-default-workflow-permissions-repository'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsGetDefaultWorkflowPermissions>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/permissions/workflow`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsGetDefaultWorkflowPermissions
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-github-actions-default-workflow-permissions-repository'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: ActionsSetDefaultWorkflowPermissions;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<409, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/permissions/workflow`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-self-hosted-runners-for-repo'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly runners: ReadonlyArray<SelfHostedRunners>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runners?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly runners: ReadonlyArray<SelfHostedRunners>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-runner-applications-for-repo'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<RunnerApplication>>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runners/downloads`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<RunnerApplication>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/create-registration-token-for-repo'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<201, AuthenticationToken>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runners/registration-token`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as AuthenticationToken
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/create-remove-token-for-repo'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<201, AuthenticationToken>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runners/remove-token`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as AuthenticationToken
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-self-hosted-runner-for-repo'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly runner_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, SelfHostedRunners>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runners/${encodeURIComponent(args['runner_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as SelfHostedRunners
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/delete-self-hosted-runner-from-repo'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly runner_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runners/${encodeURIComponent(args['runner_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-labels-for-self-hosted-runner-for-repo'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly runner_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/add-custom-labels-to-self-hosted-runner-for-repo'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly runner_id: number;
      readonly body: { readonly labels: ReadonlyArray<string> };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/set-custom-labels-for-self-hosted-runner-for-repo'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly runner_id: number;
      readonly body: { readonly labels: ReadonlyArray<string> };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/remove-all-custom-labels-from-self-hosted-runner-for-repo'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly runner_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/remove-custom-label-from-self-hosted-runner-for-repo'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly runner_id: number;
      readonly name: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
        }
      >
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runners/${encodeURIComponent(args['runner_id'])}/labels/${encodeURIComponent(args['name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-workflow-runs-for-repo'(
    args: {
      readonly actor?: string;
      readonly branch?: string;
      readonly event?: string;
      readonly status?:
        | 'completed'
        | 'action_required'
        | 'cancelled'
        | 'failure'
        | 'neutral'
        | 'skipped'
        | 'stale'
        | 'success'
        | 'timed_out'
        | 'in_progress'
        | 'queued'
        | 'requested'
        | 'waiting';
      readonly per_page?: number;
      readonly page?: number;
      readonly created?: string;
      readonly exclude_pull_requests?: boolean;
      readonly check_suite_id?: number;
      readonly head_sha?: string;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly workflow_runs: ReadonlyArray<WorkflowRun>;
      }
    >
  > {
    const query = qs.stringify({
      ['actor']: args['actor'],
      ['branch']: args['branch'],
      ['event']: args['event'],
      ['status']: args['status'],
      ['per_page']: args['per_page'],
      ['page']: args['page'],
      ['created']: args['created'],
      ['exclude_pull_requests']: args['exclude_pull_requests'],
      ['check_suite_id']: args['check_suite_id'],
      ['head_sha']: args['head_sha']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly workflow_runs: ReadonlyArray<WorkflowRun>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-workflow-run'(
    args: {
      readonly exclude_pull_requests?: boolean;
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, WorkflowRun>> {
    const query = qs.stringify({
      ['exclude_pull_requests']: args['exclude_pull_requests']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as WorkflowRun
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/delete-workflow-run'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-reviews-for-run'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<EnvironmentApproval>>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/approvals`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<EnvironmentApproval>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/approve-workflow-run'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, EmptyObject>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/approve`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-workflow-run-artifacts'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly artifacts: ReadonlyArray<Artifact>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/artifacts?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly artifacts: ReadonlyArray<Artifact>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-workflow-run-attempt'(
    args: {
      readonly exclude_pull_requests?: boolean;
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
      readonly attempt_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, WorkflowRun>> {
    const query = qs.stringify({
      ['exclude_pull_requests']: args['exclude_pull_requests']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/attempts/${encodeURIComponent(args['attempt_number'])}?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as WorkflowRun
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-jobs-for-workflow-run-attempt'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
      readonly attempt_number: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        { readonly total_count: number; readonly jobs: ReadonlyArray<Job> }
      >
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/attempts/${encodeURIComponent(args['attempt_number'])}/jobs?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly jobs: ReadonlyArray<Job>;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/download-workflow-run-attempt-logs'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
      readonly attempt_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<302, undefined>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/attempts/${encodeURIComponent(args['attempt_number'])}/logs`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 302:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/cancel-workflow-run'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<202, EmptyObject> | ResponseWithData<409, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/cancel`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-jobs-for-workflow-run'(
    args: {
      readonly filter?: 'latest' | 'all';
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      { readonly total_count: number; readonly jobs: ReadonlyArray<Job> }
    >
  > {
    const query = qs.stringify({
      ['filter']: args['filter'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/jobs?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly jobs: ReadonlyArray<Job>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/download-workflow-run-logs'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<302, undefined>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/logs`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 302:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/delete-workflow-run-logs'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/logs`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-pending-deployments-for-run'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<PendingDeployment>>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/pending_deployments`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<PendingDeployment>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/review-pending-deployments-for-run'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
      readonly body: {
        readonly environment_ids: ReadonlyArray<number>;
        readonly state: 'approved' | 'rejected';
        readonly comment: string;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Deployment>>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/pending_deployments`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Deployment>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/re-run-workflow'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
      readonly body?: { readonly enable_debug_logging?: boolean } | null;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, EmptyObject>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/rerun`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/re-run-workflow-failed-jobs'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
      readonly body?: { readonly enable_debug_logging?: boolean } | null;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, EmptyObject>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/rerun-failed-jobs`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-workflow-run-usage'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly run_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, WorkflowRunUsage>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/runs/${encodeURIComponent(args['run_id'])}/timing`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as WorkflowRunUsage
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-repo-secrets'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly secrets: ReadonlyArray<ActionsSecret>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/secrets?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly secrets: ReadonlyArray<ActionsSecret>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-repo-public-key'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsPublicKey>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/secrets/public-key`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsPublicKey
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-repo-secret'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly secret_name: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsSecret>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsSecret
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/create-or-update-repo-secret'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly secret_name: string;
      readonly body: {
        readonly encrypted_value?: string;
        readonly key_id?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<201, EmptyObject> | ResponseWithData<204, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/delete-repo-secret'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly secret_name: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-repo-workflows'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly workflows: ReadonlyArray<Workflow>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/workflows?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly workflows: ReadonlyArray<Workflow>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-workflow'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly workflow_id: number | string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Workflow>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/workflows/${encodeURIComponent(args['workflow_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Workflow
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/disable-workflow'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly workflow_id: number | string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/workflows/${encodeURIComponent(args['workflow_id'])}/disable`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/create-workflow-dispatch'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly workflow_id: number | string;
      readonly body: { readonly ref: string; readonly inputs?: unknown };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/workflows/${encodeURIComponent(args['workflow_id'])}/dispatches`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/enable-workflow'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly workflow_id: number | string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/workflows/${encodeURIComponent(args['workflow_id'])}/enable`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-workflow-runs'(
    args: {
      readonly actor?: string;
      readonly branch?: string;
      readonly event?: string;
      readonly status?:
        | 'completed'
        | 'action_required'
        | 'cancelled'
        | 'failure'
        | 'neutral'
        | 'skipped'
        | 'stale'
        | 'success'
        | 'timed_out'
        | 'in_progress'
        | 'queued'
        | 'requested'
        | 'waiting';
      readonly per_page?: number;
      readonly page?: number;
      readonly created?: string;
      readonly exclude_pull_requests?: boolean;
      readonly check_suite_id?: number;
      readonly head_sha?: string;
      readonly owner: string;
      readonly repo: string;
      readonly workflow_id: number | string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly workflow_runs: ReadonlyArray<WorkflowRun>;
      }
    >
  > {
    const query = qs.stringify({
      ['actor']: args['actor'],
      ['branch']: args['branch'],
      ['event']: args['event'],
      ['status']: args['status'],
      ['per_page']: args['per_page'],
      ['page']: args['page'],
      ['created']: args['created'],
      ['exclude_pull_requests']: args['exclude_pull_requests'],
      ['check_suite_id']: args['check_suite_id'],
      ['head_sha']: args['head_sha']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/workflows/${encodeURIComponent(args['workflow_id'])}/runs?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly workflow_runs: ReadonlyArray<WorkflowRun>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-workflow-usage'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly workflow_id: number | string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, WorkflowUsage>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/actions/workflows/${encodeURIComponent(args['workflow_id'])}/timing`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as WorkflowUsage
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list-assignees'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleUser>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/assignees?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/check-user-can-be-assigned'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly assignee: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/assignees/${encodeURIComponent(args['assignee'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-autolinks'(
    args: {
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<AutolinkReference>>> {
    const query = qs.stringify({ ['page']: args['page'] });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/autolinks?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<AutolinkReference>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-autolink'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly key_prefix: string;
        readonly url_template: string;
        readonly is_alphanumeric?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, AutolinkReference>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/autolinks`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as AutolinkReference
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-autolink'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly autolink_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, AutolinkReference> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/autolinks/${encodeURIComponent(args['autolink_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as AutolinkReference
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-autolink'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly autolink_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/autolinks/${encodeURIComponent(args['autolink_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/enable-automated-security-fixes'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/automated-security-fixes`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/disable-automated-security-fixes'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/automated-security-fixes`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-branches'(
    args: {
      readonly protected?: boolean;
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<ShortBranch>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['protected']: args['protected'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<ShortBranch>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-branch'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, BranchWithProtection>
    | ResponseWithData<301, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as BranchWithProtection
          };

        case 301:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-branch-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, BranchProtection> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as BranchProtection
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/update-branch-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body: {
        readonly required_status_checks: {
          readonly strict: boolean;
          readonly contexts: ReadonlyArray<string>;
          readonly checks?: ReadonlyArray<{
            readonly context: string;
            readonly app_id?: number;
          }>;
        } | null;
        readonly enforce_admins: boolean | null;
        readonly required_pull_request_reviews: {
          readonly dismissal_restrictions?: {
            readonly users?: ReadonlyArray<string>;
            readonly teams?: ReadonlyArray<string>;
            readonly apps?: ReadonlyArray<string>;
          };
          readonly dismiss_stale_reviews?: boolean;
          readonly require_code_owner_reviews?: boolean;
          readonly required_approving_review_count?: number;
          readonly require_last_push_approval?: boolean;
          readonly bypass_pull_request_allowances?: {
            readonly users?: ReadonlyArray<string>;
            readonly teams?: ReadonlyArray<string>;
            readonly apps?: ReadonlyArray<string>;
          };
        } | null;
        readonly restrictions: {
          readonly users: ReadonlyArray<string>;
          readonly teams: ReadonlyArray<string>;
          readonly apps?: ReadonlyArray<string>;
        } | null;
        readonly required_linear_history?: boolean;
        readonly allow_force_pushes?: boolean | null;
        readonly allow_deletions?: boolean;
        readonly block_creations?: boolean;
        readonly required_conversation_resolution?: boolean;
        readonly lock_branch?: boolean;
        readonly allow_fork_syncing?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ProtectedBranch>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ProtectedBranch
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-branch-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<403, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-admin-branch-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ProtectedBranchAdminEnforced>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/enforce_admins`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ProtectedBranchAdminEnforced
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/set-admin-branch-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ProtectedBranchAdminEnforced>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/enforce_admins`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ProtectedBranchAdminEnforced
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-admin-branch-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/enforce_admins`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-pull-request-review-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ProtectedBranchPullRequestReview>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/required_pull_request_reviews`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ProtectedBranchPullRequestReview
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/update-pull-request-review-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?: {
        readonly dismissal_restrictions?: {
          readonly users?: ReadonlyArray<string>;
          readonly teams?: ReadonlyArray<string>;
          readonly apps?: ReadonlyArray<string>;
        };
        readonly dismiss_stale_reviews?: boolean;
        readonly require_code_owner_reviews?: boolean;
        readonly required_approving_review_count?: number;
        readonly require_last_push_approval?: boolean;
        readonly bypass_pull_request_allowances?: {
          readonly users?: ReadonlyArray<string>;
          readonly teams?: ReadonlyArray<string>;
          readonly apps?: ReadonlyArray<string>;
        };
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ProtectedBranchPullRequestReview>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/required_pull_request_reviews`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ProtectedBranchPullRequestReview
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-pull-request-review-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/required_pull_request_reviews`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-commit-signature-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ProtectedBranchAdminEnforced>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/required_signatures`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ProtectedBranchAdminEnforced
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-commit-signature-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ProtectedBranchAdminEnforced>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/required_signatures`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ProtectedBranchAdminEnforced
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-commit-signature-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/required_signatures`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-status-checks-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, StatusCheckPolicy> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/required_status_checks`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as StatusCheckPolicy
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/update-status-check-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?: {
        readonly strict?: boolean;
        readonly contexts?: ReadonlyArray<string>;
        readonly checks?: ReadonlyArray<{
          readonly context: string;
          readonly app_id?: number;
        }>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, StatusCheckPolicy>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/required_status_checks`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as StatusCheckPolicy
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/remove-status-check-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/required_status_checks`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-all-status-check-contexts'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<string>>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/required_status_checks/contexts`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<string>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/add-status-check-contexts'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?:
        | { readonly contexts: ReadonlyArray<string> }
        | ReadonlyArray<string>;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<string>>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/required_status_checks/contexts`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<string>
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/set-status-check-contexts'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?:
        | { readonly contexts: ReadonlyArray<string> }
        | ReadonlyArray<string>;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<string>>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/required_status_checks/contexts`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<string>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/remove-status-check-contexts'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?:
        | { readonly contexts: ReadonlyArray<string> }
        | ReadonlyArray<string>;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<string>>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/required_status_checks/contexts`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<string>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-access-restrictions'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, BranchRestrictionPolicy>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as BranchRestrictionPolicy
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-access-restrictions'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-apps-with-access-to-protected-branch'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<GitHubApp>>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions/apps`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<GitHubApp>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/add-app-access-restrictions'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?:
        | { readonly apps: ReadonlyArray<string> }
        | ReadonlyArray<string>;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<GitHubApp>>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions/apps`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<GitHubApp>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/set-app-access-restrictions'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?:
        | { readonly apps: ReadonlyArray<string> }
        | ReadonlyArray<string>;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<GitHubApp>>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions/apps`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<GitHubApp>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/remove-app-access-restrictions'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?:
        | { readonly apps: ReadonlyArray<string> }
        | ReadonlyArray<string>;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<GitHubApp>>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions/apps`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<GitHubApp>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-teams-with-access-to-protected-branch'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Team>>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions/teams`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Team>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/add-team-access-restrictions'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?:
        | { readonly teams: ReadonlyArray<string> }
        | ReadonlyArray<string>;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Team>>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions/teams`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Team>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/set-team-access-restrictions'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?:
        | { readonly teams: ReadonlyArray<string> }
        | ReadonlyArray<string>;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Team>>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions/teams`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Team>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/remove-team-access-restrictions'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?:
        | { readonly teams: ReadonlyArray<string> }
        | ReadonlyArray<string>;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Team>>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions/teams`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Team>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-users-with-access-to-protected-branch'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleUser>>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions/users`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/add-user-access-restrictions'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?:
        | { readonly users: ReadonlyArray<string> }
        | ReadonlyArray<string>;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleUser>>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions/users`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/set-user-access-restrictions'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?:
        | { readonly users: ReadonlyArray<string> }
        | ReadonlyArray<string>;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleUser>>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions/users`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/remove-user-access-restrictions'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body?:
        | { readonly users: ReadonlyArray<string> }
        | ReadonlyArray<string>;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleUser>>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/protection/restrictions/users`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/rename-branch'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly branch: string;
      readonly body: { readonly new_name: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, BranchWithProtection>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/branches/${encodeURIComponent(args['branch'])}/rename`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as BranchWithProtection
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'checks/create'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly name: string;
        readonly head_sha: string;
        readonly details_url?: string;
        readonly external_id?: string;
        readonly status?: 'queued' | 'in_progress' | 'completed';
        readonly started_at?: string;
        readonly conclusion?:
          | 'action_required'
          | 'cancelled'
          | 'failure'
          | 'neutral'
          | 'success'
          | 'skipped'
          | 'stale'
          | 'timed_out';
        readonly completed_at?: string;
        readonly output?: {
          readonly title: string;
          readonly summary: string;
          readonly text?: string;
          readonly annotations?: ReadonlyArray<{
            readonly path: string;
            readonly start_line: number;
            readonly end_line: number;
            readonly start_column?: number;
            readonly end_column?: number;
            readonly annotation_level: 'notice' | 'warning' | 'failure';
            readonly message: string;
            readonly title?: string;
            readonly raw_details?: string;
          }>;
          readonly images?: ReadonlyArray<{
            readonly alt: string;
            readonly image_url: string;
            readonly caption?: string;
          }>;
        };
        readonly actions?: ReadonlyArray<{
          readonly label: string;
          readonly description: string;
          readonly identifier: string;
        }>;
      } & (
        | { readonly status: 'completed' }
        | { readonly status?: 'queued' | 'in_progress' }
      );
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, CheckRun>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/check-runs`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as CheckRun
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'checks/get'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly check_run_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, CheckRun>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/check-runs/${encodeURIComponent(args['check_run_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CheckRun
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'checks/update'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly check_run_id: number;
      readonly body: {
        readonly name?: string;
        readonly details_url?: string;
        readonly external_id?: string;
        readonly started_at?: string;
        readonly status?: 'queued' | 'in_progress' | 'completed';
        readonly conclusion?:
          | 'action_required'
          | 'cancelled'
          | 'failure'
          | 'neutral'
          | 'success'
          | 'skipped'
          | 'stale'
          | 'timed_out';
        readonly completed_at?: string;
        readonly output?: {
          readonly title?: string;
          readonly summary: string;
          readonly text?: string;
          readonly annotations?: ReadonlyArray<{
            readonly path: string;
            readonly start_line: number;
            readonly end_line: number;
            readonly start_column?: number;
            readonly end_column?: number;
            readonly annotation_level: 'notice' | 'warning' | 'failure';
            readonly message: string;
            readonly title?: string;
            readonly raw_details?: string;
          }>;
          readonly images?: ReadonlyArray<{
            readonly alt: string;
            readonly image_url: string;
            readonly caption?: string;
          }>;
        };
        readonly actions?: ReadonlyArray<{
          readonly label: string;
          readonly description: string;
          readonly identifier: string;
        }>;
      } & (
        | { readonly status?: 'completed' }
        | { readonly status?: 'queued' | 'in_progress' }
      );
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, CheckRun>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/check-runs/${encodeURIComponent(args['check_run_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CheckRun
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'checks/list-annotations'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly check_run_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<CheckAnnotation>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/check-runs/${encodeURIComponent(args['check_run_id'])}/annotations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<CheckAnnotation>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'checks/rerequest-run'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly check_run_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, EmptyObject>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/check-runs/${encodeURIComponent(args['check_run_id'])}/rerequest`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'checks/create-suite'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: { readonly head_sha: string };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, CheckSuite> | ResponseWithData<201, CheckSuite>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/check-suites`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CheckSuite
          };

        case 201:
          return {
            status: $status,
            body: (await response.json()) as CheckSuite
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'checks/set-suites-preferences'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly auto_trigger_checks?: ReadonlyArray<{
          readonly app_id: number;
          readonly setting: boolean;
        }>;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, CheckSuitePreference>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/check-suites/preferences`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CheckSuitePreference
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'checks/get-suite'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly check_suite_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, CheckSuite>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/check-suites/${encodeURIComponent(args['check_suite_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CheckSuite
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'checks/list-for-suite'(
    args: {
      readonly check_name?: string;
      readonly status?: 'queued' | 'in_progress' | 'completed';
      readonly filter?: 'latest' | 'all';
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly check_suite_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly check_runs: ReadonlyArray<CheckRun>;
      }
    >
  > {
    const query = qs.stringify({
      ['check_name']: args['check_name'],
      ['status']: args['status'],
      ['filter']: args['filter'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/check-suites/${encodeURIComponent(args['check_suite_id'])}/check-runs?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly check_runs: ReadonlyArray<CheckRun>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'checks/rerequest-suite'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly check_suite_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, EmptyObject>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/check-suites/${encodeURIComponent(args['check_suite_id'])}/rerequest`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'code-scanning/list-alerts-for-repo'(
    args: {
      readonly tool_name?: CodeScanningAnalysisToolName;
      readonly tool_guid?: CodeScanningAnalysisToolGuid;
      readonly page?: number;
      readonly per_page?: number;
      readonly ref?: CodeScanningRef;
      readonly direction?: 'asc' | 'desc';
      readonly sort?: 'created' | 'updated';
      readonly state?: CodeScanningAlertState;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<CodeScanningAlertItems>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['tool_name']: args['tool_name'],
      ['tool_guid']: args['tool_guid'],
      ['page']: args['page'],
      ['per_page']: args['per_page'],
      ['ref']: args['ref'],
      ['direction']: args['direction'],
      ['sort']: args['sort'],
      ['state']: args['state']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/code-scanning/alerts?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<CodeScanningAlertItems>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'code-scanning/get-alert'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly alert_number: AlertNumber;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, CodeScanningAlert>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/code-scanning/alerts/${encodeURIComponent(args['alert_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CodeScanningAlert
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'code-scanning/update-alert'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly alert_number: AlertNumber;
      readonly body: {
        readonly state: CodeScanningAlertSetState;
        readonly dismissed_reason?: CodeScanningAlertDismissedReason;
        readonly dismissed_comment?: CodeScanningAlertDismissedComment;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, CodeScanningAlert>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/code-scanning/alerts/${encodeURIComponent(args['alert_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CodeScanningAlert
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'code-scanning/list-alert-instances'(
    args: {
      readonly page?: number;
      readonly per_page?: number;
      readonly ref?: CodeScanningRef;
      readonly owner: string;
      readonly repo: string;
      readonly alert_number: AlertNumber;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<CodeScanningAlertInstance>>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['page']: args['page'],
      ['per_page']: args['per_page'],
      ['ref']: args['ref']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/code-scanning/alerts/${encodeURIComponent(args['alert_number'])}/instances?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<CodeScanningAlertInstance>
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'code-scanning/list-recent-analyses'(
    args: {
      readonly tool_name?: CodeScanningAnalysisToolName;
      readonly tool_guid?: CodeScanningAnalysisToolGuid;
      readonly page?: number;
      readonly per_page?: number;
      readonly ref?: CodeScanningRef;
      readonly sarif_id?: CodeScanningAnalysisSarifId;
      readonly direction?: 'asc' | 'desc';
      readonly sort?: 'created';
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<CodeScanningAnalysis>>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['tool_name']: args['tool_name'],
      ['tool_guid']: args['tool_guid'],
      ['page']: args['page'],
      ['per_page']: args['per_page'],
      ['ref']: args['ref'],
      ['sarif_id']: args['sarif_id'],
      ['direction']: args['direction'],
      ['sort']: args['sort']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/code-scanning/analyses?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<CodeScanningAnalysis>
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'code-scanning/get-analysis'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly analysis_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, CodeScanningAnalysis>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/code-scanning/analyses/${encodeURIComponent(args['analysis_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CodeScanningAnalysis
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'code-scanning/delete-analysis'(
    args: {
      readonly confirm_delete?: string | null;
      readonly owner: string;
      readonly repo: string;
      readonly analysis_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, AnalysisDeletion>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({ ['confirm_delete']: args['confirm_delete'] });

    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/code-scanning/analyses/${encodeURIComponent(args['analysis_id'])}?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as AnalysisDeletion
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'code-scanning/list-codeql-databases'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<CodeQlDatabase>>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/code-scanning/codeql/databases`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<CodeQlDatabase>
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'code-scanning/get-codeql-database'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly language: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, CodeQlDatabase>
    | ResponseWithData<302, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/code-scanning/codeql/databases/${encodeURIComponent(args['language'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CodeQlDatabase
          };

        case 302:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'code-scanning/upload-sarif'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly commit_sha: CodeScanningAnalysisCommitSha;
        readonly ref: CodeScanningRef;
        readonly sarif: CodeScanningAnalysisSarifFile;
        readonly checkout_uri?: string;
        readonly started_at?: string;
        readonly tool_name?: string;
        readonly validate?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<202, CodeScanningSarifsReceipt>
    | ResponseWithData<400, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<413, undefined>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/code-scanning/sarifs`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as CodeScanningSarifsReceipt
          };

        case 400:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 413:
          return {
            status: $status,
            body: undefined
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'code-scanning/get-sarif'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly sarif_id: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, CodeScanningSarifsStatus>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, undefined>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/code-scanning/sarifs/${encodeURIComponent(args['sarif_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CodeScanningSarifsStatus
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/codeowners-errors'(
    args: {
      readonly ref?: string;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, CodeownersErrors> | ResponseWithData<404, undefined>
  > {
    const query = qs.stringify({ ['ref']: args['ref'] });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/codeowners/errors?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CodeownersErrors
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/list-in-repository-for-authenticated-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly codespaces: ReadonlyArray<Codespace>;
        }
      >
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/codespaces?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly codespaces: ReadonlyArray<Codespace>;
            }
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/create-with-repo-for-authenticated-user'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly ref?: string;
        readonly location?: string;
        readonly client_ip?: string;
        readonly machine?: string;
        readonly devcontainer_path?: string;
        readonly multi_repo_permissions_opt_out?: boolean;
        readonly working_directory?: string;
        readonly idle_timeout_minutes?: number;
        readonly display_name?: string;
        readonly retention_period_minutes?: number;
      } | null;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Codespace>
    | ResponseWithData<202, Codespace>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/codespaces`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Codespace
          };

        case 202:
          return {
            status: $status,
            body: (await response.json()) as Codespace
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/list-devcontainers-in-repository-for-authenticated-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly devcontainers: ReadonlyArray<{
            readonly path: string;
            readonly name?: string;
          }>;
        }
      >
    | ResponseWithData<400, BasicError>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/codespaces/devcontainers?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly devcontainers: ReadonlyArray<{
                readonly path: string;
                readonly name?: string;
              }>;
            }
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/repo-machines-for-authenticated-user'(
    args: {
      readonly location?: string;
      readonly client_ip?: string;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly machines: ReadonlyArray<CodespaceMachine>;
        }
      >
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const query = qs.stringify({
      ['location']: args['location'],
      ['client_ip']: args['client_ip']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/codespaces/machines?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly machines: ReadonlyArray<CodespaceMachine>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/pre-flight-with-repo-for-authenticated-user'(
    args: {
      readonly ref?: string;
      readonly client_ip?: string;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly billable_owner?: SimpleUser;
          readonly defaults?: {
            readonly location: string;
            readonly devcontainer_path: string | null;
          };
        }
      >
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['ref']: args['ref'],
      ['client_ip']: args['client_ip']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/codespaces/new?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly billable_owner?: SimpleUser;
              readonly defaults?: {
                readonly location: string;
                readonly devcontainer_path: string | null;
              };
            }
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/list-repo-secrets'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly secrets: ReadonlyArray<CodespacesSecret>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/codespaces/secrets?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly secrets: ReadonlyArray<CodespacesSecret>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/get-repo-public-key'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, CodespacesPublicKey>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/codespaces/secrets/public-key`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CodespacesPublicKey
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/get-repo-secret'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly secret_name: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, CodespacesSecret>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/codespaces/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CodespacesSecret
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/create-or-update-repo-secret'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly secret_name: string;
      readonly body: {
        readonly encrypted_value?: string;
        readonly key_id?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<201, EmptyObject> | ResponseWithData<204, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/codespaces/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/delete-repo-secret'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly secret_name: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/codespaces/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-collaborators'(
    args: {
      readonly affiliation?: 'outside' | 'direct' | 'all';
      readonly permission?: 'pull' | 'triage' | 'push' | 'maintain' | 'admin';
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Collaborator>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['affiliation']: args['affiliation'],
      ['permission']: args['permission'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/collaborators?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Collaborator>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/check-collaborator'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/collaborators/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/add-collaborator'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly username: string;
      readonly body?: { readonly permission?: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, RepositoryInvitation>
    | ResponseWithData<204, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/collaborators/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as RepositoryInvitation
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/remove-collaborator'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/collaborators/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-collaborator-permission-level'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, RepositoryCollaboratorPermission>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/collaborators/${encodeURIComponent(args['username'])}/permission`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as RepositoryCollaboratorPermission
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-commit-comments-for-repo'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<CommitComment>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/comments?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<CommitComment>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-commit-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, CommitComment> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/comments/${encodeURIComponent(args['comment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CommitComment
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/update-commit-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
      readonly body: { readonly body: string };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, CommitComment> | ResponseWithData<404, BasicError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/comments/${encodeURIComponent(args['comment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CommitComment
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-commit-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/comments/${encodeURIComponent(args['comment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/list-for-commit-comment'(
    args: {
      readonly content?:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Reaction>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['content']: args['content'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/comments/${encodeURIComponent(args['comment_id'])}/reactions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Reaction>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/create-for-commit-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
      readonly body: {
        readonly content:
          | '+1'
          | '-1'
          | 'laugh'
          | 'confused'
          | 'heart'
          | 'hooray'
          | 'rocket'
          | 'eyes';
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Reaction>
    | ResponseWithData<201, Reaction>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/comments/${encodeURIComponent(args['comment_id'])}/reactions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        case 201:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/delete-for-commit-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
      readonly reaction_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/comments/${encodeURIComponent(args['comment_id'])}/reactions/${encodeURIComponent(args['reaction_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-commits'(
    args: {
      readonly sha?: string;
      readonly path?: string;
      readonly author?: string;
      readonly since?: string;
      readonly until?: string;
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Commit>>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<409, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const query = qs.stringify({
      ['sha']: args['sha'],
      ['path']: args['path'],
      ['author']: args['author'],
      ['since']: args['since'],
      ['until']: args['until'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/commits?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Commit>
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-branches-for-head-commit'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly commit_sha: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<BranchShort>>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/commits/${encodeURIComponent(args['commit_sha'])}/branches-where-head`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<BranchShort>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-comments-for-commit'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly commit_sha: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<CommitComment>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/commits/${encodeURIComponent(args['commit_sha'])}/comments?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<CommitComment>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-commit-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly commit_sha: string;
      readonly body: {
        readonly body: string;
        readonly path?: string;
        readonly position?: number;
        readonly line?: number;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, CommitComment>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/commits/${encodeURIComponent(args['commit_sha'])}/comments`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as CommitComment
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-pull-requests-associated-with-commit'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly commit_sha: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<PullRequestSimple>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/commits/${encodeURIComponent(args['commit_sha'])}/pulls?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<PullRequestSimple>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-commit'(
    args: {
      readonly page?: number;
      readonly per_page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly ref: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Commit>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
    | ResponseWithData<500, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['page']: args['page'],
      ['per_page']: args['per_page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/commits/${encodeURIComponent(args['ref'])}?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Commit
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'checks/list-for-ref'(
    args: {
      readonly check_name?: string;
      readonly status?: 'queued' | 'in_progress' | 'completed';
      readonly filter?: 'latest' | 'all';
      readonly per_page?: number;
      readonly page?: number;
      readonly app_id?: number;
      readonly owner: string;
      readonly repo: string;
      readonly ref: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly check_runs: ReadonlyArray<CheckRun>;
      }
    >
  > {
    const query = qs.stringify({
      ['check_name']: args['check_name'],
      ['status']: args['status'],
      ['filter']: args['filter'],
      ['per_page']: args['per_page'],
      ['page']: args['page'],
      ['app_id']: args['app_id']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/commits/${encodeURIComponent(args['ref'])}/check-runs?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly check_runs: ReadonlyArray<CheckRun>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'checks/list-suites-for-ref'(
    args: {
      readonly app_id?: number;
      readonly check_name?: string;
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly ref: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly check_suites: ReadonlyArray<CheckSuite>;
      }
    >
  > {
    const query = qs.stringify({
      ['app_id']: args['app_id'],
      ['check_name']: args['check_name'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/commits/${encodeURIComponent(args['ref'])}/check-suites?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly check_suites: ReadonlyArray<CheckSuite>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-combined-status-for-ref'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly ref: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, CombinedCommitStatus>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/commits/${encodeURIComponent(args['ref'])}/status?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CombinedCommitStatus
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-commit-statuses-for-ref'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly ref: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Status>>
    | ResponseWithData<301, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/commits/${encodeURIComponent(args['ref'])}/statuses?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Status>
          };

        case 301:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-community-profile-metrics'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, CommunityProfile>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/community/profile`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CommunityProfile
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/compare-commits'(
    args: {
      readonly page?: number;
      readonly per_page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly basehead: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, CommitComparison>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['page']: args['page'],
      ['per_page']: args['per_page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/compare/${encodeURIComponent(args['basehead'])}?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CommitComparison
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-content'(
    args: {
      readonly ref?: string;
      readonly owner: string;
      readonly repo: string;
      readonly path: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        ContentDirectory | ContentFile | SymlinkContent | SubmoduleContent
      >
    | ResponseWithData<302, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({ ['ref']: args['ref'] });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/contents/${encodeURIComponent(args['path'])}?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as
              | ContentDirectory
              | ContentFile
              | SymlinkContent
              | SubmoduleContent
          };

        case 302:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-or-update-file-contents'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly path: string;
      readonly body: {
        readonly message: string;
        readonly content: string;
        readonly sha?: string;
        readonly branch?: string;
        readonly committer?: {
          readonly name: string;
          readonly email: string;
          readonly date?: string;
        };
        readonly author?: {
          readonly name: string;
          readonly email: string;
          readonly date?: string;
        };
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, FileCommit>
    | ResponseWithData<201, FileCommit>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<409, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/contents/${encodeURIComponent(args['path'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as FileCommit
          };

        case 201:
          return {
            status: $status,
            body: (await response.json()) as FileCommit
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-file'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly path: string;
      readonly body: {
        readonly message: string;
        readonly sha: string;
        readonly branch?: string;
        readonly committer?: {
          readonly name?: string;
          readonly email?: string;
        };
        readonly author?: { readonly name?: string; readonly email?: string };
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, FileCommit>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<409, BasicError>
    | ResponseWithData<422, ValidationError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/contents/${encodeURIComponent(args['path'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as FileCommit
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-contributors'(
    args: {
      readonly anon?: string;
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Contributor>>
    | ResponseWithData<204, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['anon']: args['anon'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/contributors?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Contributor>
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/list-alerts-for-repo'(
    args: {
      readonly state?: string;
      readonly severity?: string;
      readonly ecosystem?: string;
      readonly package?: string;
      readonly manifest?: string;
      readonly scope?: 'development' | 'runtime';
      readonly sort?: 'created' | 'updated';
      readonly direction?: 'asc' | 'desc';
      readonly page?: number;
      readonly per_page?: number;
      readonly before?: string;
      readonly after?: string;
      readonly first?: number;
      readonly last?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<DependabotAlert>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const query = qs.stringify({
      ['state']: args['state'],
      ['severity']: args['severity'],
      ['ecosystem']: args['ecosystem'],
      ['package']: args['package'],
      ['manifest']: args['manifest'],
      ['scope']: args['scope'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['page']: args['page'],
      ['per_page']: args['per_page'],
      ['before']: args['before'],
      ['after']: args['after'],
      ['first']: args['first'],
      ['last']: args['last']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/dependabot/alerts?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<DependabotAlert>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/get-alert'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly alert_number: AlertNumber;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, DependabotAlert>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/dependabot/alerts/${encodeURIComponent(args['alert_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as DependabotAlert
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/update-alert'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly alert_number: AlertNumber;
      readonly body: {
        readonly state: 'dismissed' | 'open';
        readonly dismissed_reason?:
          | 'fix_started'
          | 'inaccurate'
          | 'no_bandwidth'
          | 'not_used'
          | 'tolerable_risk';
        readonly dismissed_comment?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, DependabotAlert>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<409, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/dependabot/alerts/${encodeURIComponent(args['alert_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as DependabotAlert
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/list-repo-secrets'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly secrets: ReadonlyArray<DependabotSecret>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/dependabot/secrets?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly secrets: ReadonlyArray<DependabotSecret>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/get-repo-public-key'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, DependabotPublicKey>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/dependabot/secrets/public-key`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as DependabotPublicKey
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/get-repo-secret'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly secret_name: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, DependabotSecret>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/dependabot/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as DependabotSecret
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/create-or-update-repo-secret'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly secret_name: string;
      readonly body: {
        readonly encrypted_value?: string;
        readonly key_id?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<201, EmptyObject> | ResponseWithData<204, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/dependabot/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependabot/delete-repo-secret'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly secret_name: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/dependabot/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependency-graph/diff-range'(
    args: {
      readonly name?: string;
      readonly owner: string;
      readonly repo: string;
      readonly basehead: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, DependencyGraphDiff>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({ ['name']: args['name'] });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/dependency-graph/compare/${encodeURIComponent(args['basehead'])}?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as DependencyGraphDiff
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'dependency-graph/create-repository-snapshot'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: Snapshot;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      201,
      {
        readonly id: number;
        readonly created_at: string;
        readonly result: string;
        readonly message: string;
      }
    >
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/dependency-graph/snapshots`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly id: number;
              readonly created_at: string;
              readonly result: string;
              readonly message: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-deployments'(
    args: {
      readonly sha?: string;
      readonly ref?: string;
      readonly task?: string;
      readonly environment?: string | null;
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Deployment>>> {
    const query = qs.stringify({
      ['sha']: args['sha'],
      ['ref']: args['ref'],
      ['task']: args['task'],
      ['environment']: args['environment'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/deployments?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Deployment>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-deployment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly ref: string;
        readonly task?: string;
        readonly auto_merge?: boolean;
        readonly required_contexts?: ReadonlyArray<string>;
        readonly payload?: unknown | string;
        readonly environment?: string;
        readonly description?: string | null;
        readonly transient_environment?: boolean;
        readonly production_environment?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Deployment>
    | ResponseWithData<202, { readonly message?: string }>
    | ResponseWithData<409, undefined>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/deployments`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Deployment
          };

        case 202:
          return {
            status: $status,
            body: (await response.json()) as { readonly message?: string }
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-deployment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly deployment_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, Deployment> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/deployments/${encodeURIComponent(args['deployment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Deployment
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-deployment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly deployment_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/deployments/${encodeURIComponent(args['deployment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-deployment-statuses'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly deployment_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<DeploymentStatus>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/deployments/${encodeURIComponent(args['deployment_id'])}/statuses?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<DeploymentStatus>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-deployment-status'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly deployment_id: number;
      readonly body: {
        readonly state:
          | 'error'
          | 'failure'
          | 'inactive'
          | 'in_progress'
          | 'queued'
          | 'pending'
          | 'success';
        readonly target_url?: string;
        readonly log_url?: string;
        readonly description?: string;
        readonly environment?: 'production' | 'staging' | 'qa';
        readonly environment_url?: string;
        readonly auto_inactive?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, DeploymentStatus>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/deployments/${encodeURIComponent(args['deployment_id'])}/statuses`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as DeploymentStatus
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-deployment-status'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly deployment_id: number;
      readonly status_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, DeploymentStatus> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/deployments/${encodeURIComponent(args['deployment_id'])}/statuses/${encodeURIComponent(args['status_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as DeploymentStatus
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-dispatch-event'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly event_type: string;
        readonly client_payload?: unknown;
      };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/dispatches`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-all-environments'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count?: number;
        readonly environments?: ReadonlyArray<Environment>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/environments?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count?: number;
              readonly environments?: ReadonlyArray<Environment>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-environment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly environment_name: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Environment>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/environments/${encodeURIComponent(args['environment_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Environment
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-or-update-environment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly environment_name: string;
      readonly body?: {
        readonly wait_timer?: WaitTimer;
        readonly reviewers?: ReadonlyArray<{
          readonly type?: DeploymentReviewerType;
          readonly id?: number;
        }> | null;
        readonly deployment_branch_policy?: DeploymentBranchPolicySettings;
      } | null;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, Environment> | ResponseWithData<422, BasicError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/environments/${encodeURIComponent(args['environment_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Environment
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-an-environment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly environment_name: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/environments/${encodeURIComponent(args['environment_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-deployment-branch-policies'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly environment_name: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly branch_policies: ReadonlyArray<DeploymentBranchPolicy>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/environments/${encodeURIComponent(args['environment_name'])}/deployment-branch-policies?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly branch_policies: ReadonlyArray<DeploymentBranchPolicy>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-deployment-branch-policy'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly environment_name: string;
      readonly body: DeploymentBranchPolicyNamePattern;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, DeploymentBranchPolicy>
    | ResponseWithData<303, undefined>
    | ResponseWithData<404, undefined>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/environments/${encodeURIComponent(args['environment_name'])}/deployment-branch-policies`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as DeploymentBranchPolicy
          };

        case 303:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-deployment-branch-policy'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly environment_name: string;
      readonly branch_policy_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, DeploymentBranchPolicy>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/environments/${encodeURIComponent(args['environment_name'])}/deployment-branch-policies/${encodeURIComponent(args['branch_policy_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as DeploymentBranchPolicy
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/update-deployment-branch-policy'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly environment_name: string;
      readonly branch_policy_id: number;
      readonly body: DeploymentBranchPolicyNamePattern;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, DeploymentBranchPolicy>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/environments/${encodeURIComponent(args['environment_name'])}/deployment-branch-policies/${encodeURIComponent(args['branch_policy_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as DeploymentBranchPolicy
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-deployment-branch-policy'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly environment_name: string;
      readonly branch_policy_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/environments/${encodeURIComponent(args['environment_name'])}/deployment-branch-policies/${encodeURIComponent(args['branch_policy_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-repo-events'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Event>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/events?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Event>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-forks'(
    args: {
      readonly sort?: 'newest' | 'oldest' | 'stargazers' | 'watchers';
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<MinimalRepository>>
    | ResponseWithData<400, BasicError>
  > {
    const query = qs.stringify({
      ['sort']: args['sort'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/forks?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MinimalRepository>
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-fork'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body?: {
        readonly organization?: string;
        readonly name?: string;
        readonly default_branch_only?: boolean;
      } | null;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<202, FullRepository>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/forks`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as FullRepository
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'git/create-blob'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: { readonly content: string; readonly encoding?: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, ShortBlob>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<409, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/git/blobs`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as ShortBlob
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'git/get-blob'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly file_sha: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Blob>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/git/blobs/${encodeURIComponent(args['file_sha'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Blob
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'git/create-commit'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly message: string;
        readonly tree: string;
        readonly parents?: ReadonlyArray<string>;
        readonly author?: {
          readonly name: string;
          readonly email: string;
          readonly date?: string;
        };
        readonly committer?: {
          readonly name?: string;
          readonly email?: string;
          readonly date?: string;
        };
        readonly signature?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, GitCommit>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/git/commits`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as GitCommit
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'git/get-commit'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly commit_sha: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, GitCommit> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/git/commits/${encodeURIComponent(args['commit_sha'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GitCommit
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'git/list-matching-refs'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly ref: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<GitReference>>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/git/matching-refs/${encodeURIComponent(args['ref'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<GitReference>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'git/get-ref'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly ref: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, GitReference> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/git/ref/${encodeURIComponent(args['ref'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GitReference
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'git/create-ref'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly ref: string;
        readonly sha: string;
        readonly key?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<201, GitReference> | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/git/refs`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as GitReference
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'git/update-ref'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly ref: string;
      readonly body: { readonly sha: string; readonly force?: boolean };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, GitReference> | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/git/refs/${encodeURIComponent(args['ref'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GitReference
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'git/delete-ref'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly ref: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/git/refs/${encodeURIComponent(args['ref'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'git/create-tag'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly tag: string;
        readonly message: string;
        readonly object: string;
        readonly type: 'commit' | 'tree' | 'blob';
        readonly tagger?: {
          readonly name: string;
          readonly email: string;
          readonly date?: string;
        };
      };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<201, GitTag> | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/git/tags`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as GitTag
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'git/get-tag'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly tag_sha: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, GitTag> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/git/tags/${encodeURIComponent(args['tag_sha'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GitTag
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'git/create-tree'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly tree: ReadonlyArray<{
          readonly path?: string;
          readonly mode?: '100644' | '100755' | '040000' | '160000' | '120000';
          readonly type?: 'blob' | 'tree' | 'commit';
          readonly sha?: string | null;
          readonly content?: string;
        }>;
        readonly base_tree?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, GitTree>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/git/trees`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as GitTree
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'git/get-tree'(
    args: {
      readonly recursive?: string;
      readonly owner: string;
      readonly repo: string;
      readonly tree_sha: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, GitTree>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({ ['recursive']: args['recursive'] });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/git/trees/${encodeURIComponent(args['tree_sha'])}?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GitTree
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-webhooks'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Webhook>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/hooks?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Webhook>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-webhook'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body?: {
        readonly name?: string;
        readonly config?: {
          readonly url?: WebhookConfigUrl;
          readonly content_type?: WebhookConfigContentType;
          readonly secret?: WebhookConfigSecret;
          readonly insecure_ssl?: WebhookConfigInsecureSsl;
          readonly token?: string;
          readonly digest?: string;
        };
        readonly events?: ReadonlyArray<string>;
        readonly active?: boolean;
      } | null;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Webhook>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/hooks`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Webhook
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-webhook'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly hook_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, Webhook> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/hooks/${encodeURIComponent(args['hook_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Webhook
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/update-webhook'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly hook_id: number;
      readonly body: {
        readonly config?: {
          readonly url: WebhookConfigUrl;
          readonly content_type?: WebhookConfigContentType;
          readonly secret?: WebhookConfigSecret;
          readonly insecure_ssl?: WebhookConfigInsecureSsl;
          readonly address?: string;
          readonly room?: string;
        };
        readonly events?: ReadonlyArray<string>;
        readonly add_events?: ReadonlyArray<string>;
        readonly remove_events?: ReadonlyArray<string>;
        readonly active?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Webhook>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/hooks/${encodeURIComponent(args['hook_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Webhook
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-webhook'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly hook_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/hooks/${encodeURIComponent(args['hook_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-webhook-config-for-repo'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly hook_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, WebhookConfiguration>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/hooks/${encodeURIComponent(args['hook_id'])}/config`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as WebhookConfiguration
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/update-webhook-config-for-repo'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly hook_id: number;
      readonly body?: {
        readonly url?: WebhookConfigUrl;
        readonly content_type?: WebhookConfigContentType;
        readonly secret?: WebhookConfigSecret;
        readonly insecure_ssl?: WebhookConfigInsecureSsl;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, WebhookConfiguration>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/hooks/${encodeURIComponent(args['hook_id'])}/config`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as WebhookConfiguration
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-webhook-deliveries'(
    args: {
      readonly per_page?: number;
      readonly cursor?: string;
      readonly owner: string;
      readonly repo: string;
      readonly hook_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleWebhookDelivery>>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['cursor']: args['cursor']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/hooks/${encodeURIComponent(args['hook_id'])}/deliveries?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleWebhookDelivery>
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-webhook-delivery'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly hook_id: number;
      readonly delivery_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, WebhookDelivery>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/hooks/${encodeURIComponent(args['hook_id'])}/deliveries/${encodeURIComponent(args['delivery_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as WebhookDelivery
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/redeliver-webhook-delivery'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly hook_id: number;
      readonly delivery_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<202, unknown>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/hooks/${encodeURIComponent(args['hook_id'])}/deliveries/${encodeURIComponent(args['delivery_id'])}/attempts`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as unknown
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/ping-webhook'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly hook_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/hooks/${encodeURIComponent(args['hook_id'])}/pings`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/test-push-webhook'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly hook_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/hooks/${encodeURIComponent(args['hook_id'])}/tests`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/get-import-status'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, Import> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/import`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Import
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/start-import'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly vcs_url: string;
        readonly vcs?: 'subversion' | 'git' | 'mercurial' | 'tfvc';
        readonly vcs_username?: string;
        readonly vcs_password?: string;
        readonly tfvc_project?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Import>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/import`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Import
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/update-import'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body?: {
        readonly vcs_username?: string;
        readonly vcs_password?: string;
        readonly vcs?: 'subversion' | 'tfvc' | 'git' | 'mercurial';
        readonly tfvc_project?: string;
      } | null;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Import>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/import`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Import
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/cancel-import'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/import`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/get-commit-authors'(
    args: {
      readonly since?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<PorterAuthor>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({ ['since']: args['since'] });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/import/authors?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<PorterAuthor>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/map-commit-author'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly author_id: number;
      readonly body?: { readonly email?: string; readonly name?: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PorterAuthor>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/import/authors/${encodeURIComponent(args['author_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PorterAuthor
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/get-large-files'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<PorterLargeFile>>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/import/large_files`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<PorterLargeFile>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/set-lfs-preference'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: { readonly use_lfs: 'opt_in' | 'opt_out' };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, Import> | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/import/lfs`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Import
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/get-repo-installation'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Installation>
    | ResponseWithData<301, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/installation`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Installation
          };

        case 301:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'interactions/get-restrictions-for-repo'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, InteractionLimits | {}>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/interaction-limits`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as InteractionLimits | {}
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'interactions/set-restrictions-for-repo'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: InteractionRestrictions;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, InteractionLimits> | ResponseWithData<409, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/interaction-limits`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as InteractionLimits
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'interactions/remove-restrictions-for-repo'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<409, undefined>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/interaction-limits`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-invitations'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<RepositoryInvitation>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/invitations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<RepositoryInvitation>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/update-invitation'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly invitation_id: number;
      readonly body?: {
        readonly permissions?:
          | 'read'
          | 'write'
          | 'maintain'
          | 'triage'
          | 'admin';
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, RepositoryInvitation>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/invitations/${encodeURIComponent(args['invitation_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as RepositoryInvitation
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-invitation'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly invitation_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/invitations/${encodeURIComponent(args['invitation_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list-for-repo'(
    args: {
      readonly milestone?: string;
      readonly state?: 'open' | 'closed' | 'all';
      readonly assignee?: string;
      readonly creator?: string;
      readonly mentioned?: string;
      readonly labels?: string;
      readonly sort?: 'created' | 'updated' | 'comments';
      readonly direction?: 'asc' | 'desc';
      readonly since?: string;
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Issue>>
    | ResponseWithData<301, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['milestone']: args['milestone'],
      ['state']: args['state'],
      ['assignee']: args['assignee'],
      ['creator']: args['creator'],
      ['mentioned']: args['mentioned'],
      ['labels']: args['labels'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['since']: args['since'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Issue>
          };

        case 301:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/create'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly title: string | number;
        readonly body?: string;
        readonly assignee?: string | null;
        readonly milestone?: string | number | null;
        readonly labels?: ReadonlyArray<
          | string
          | {
              readonly id?: number;
              readonly name?: string;
              readonly description?: string | null;
              readonly color?: string | null;
            }
        >;
        readonly assignees?: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Issue>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
    | ResponseWithData<422, ValidationError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Issue
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list-comments-for-repo'(
    args: {
      readonly sort?: 'created' | 'updated';
      readonly direction?: 'asc' | 'desc';
      readonly since?: string;
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<IssueComment>>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['since']: args['since'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/comments?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<IssueComment>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/get-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, IssueComment> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/comments/${encodeURIComponent(args['comment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as IssueComment
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/update-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
      readonly body: { readonly body: string };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, IssueComment> | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/comments/${encodeURIComponent(args['comment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as IssueComment
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/delete-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/comments/${encodeURIComponent(args['comment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/list-for-issue-comment'(
    args: {
      readonly content?:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Reaction>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['content']: args['content'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/comments/${encodeURIComponent(args['comment_id'])}/reactions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Reaction>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/create-for-issue-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
      readonly body: {
        readonly content:
          | '+1'
          | '-1'
          | 'laugh'
          | 'confused'
          | 'heart'
          | 'hooray'
          | 'rocket'
          | 'eyes';
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Reaction>
    | ResponseWithData<201, Reaction>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/comments/${encodeURIComponent(args['comment_id'])}/reactions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        case 201:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/delete-for-issue-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
      readonly reaction_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/comments/${encodeURIComponent(args['comment_id'])}/reactions/${encodeURIComponent(args['reaction_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list-events-for-repo'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<IssueEvent>>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/events?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<IssueEvent>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/get-event'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly event_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, IssueEvent>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/events/${encodeURIComponent(args['event_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as IssueEvent
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/get'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Issue>
    | ResponseWithData<301, BasicError>
    | ResponseWithData<304, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Issue
          };

        case 301:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/update'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
      readonly body?: {
        readonly title?: string | number | null;
        readonly body?: string | null;
        readonly assignee?: string | null;
        readonly state?: 'open' | 'closed';
        readonly state_reason?: 'completed' | 'not_planned' | 'reopened' | null;
        readonly milestone?: string | number | null;
        readonly labels?: ReadonlyArray<
          | string
          | {
              readonly id?: number;
              readonly name?: string;
              readonly description?: string | null;
              readonly color?: string | null;
            }
        >;
        readonly assignees?: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Issue>
    | ResponseWithData<301, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
    | ResponseWithData<422, ValidationError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Issue
          };

        case 301:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/add-assignees'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
      readonly body?: { readonly assignees?: ReadonlyArray<string> };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, Issue>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/assignees`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Issue
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/remove-assignees'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
      readonly body?: { readonly assignees?: ReadonlyArray<string> };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Issue>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/assignees`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Issue
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list-comments'(
    args: {
      readonly since?: string;
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<IssueComment>>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
  > {
    const query = qs.stringify({
      ['since']: args['since'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/comments?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<IssueComment>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/create-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
      readonly body: { readonly body: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, IssueComment>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/comments`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as IssueComment
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list-events'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<IssueEventForIssue>>
    | ResponseWithData<410, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/events?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<IssueEventForIssue>
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list-labels-on-issue'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Label>>
    | ResponseWithData<301, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/labels?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Label>
          };

        case 301:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/add-labels'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
      readonly body?:
        | { readonly labels?: ReadonlyArray<string> }
        | ReadonlyArray<string>
        | { readonly labels?: ReadonlyArray<{ readonly name: string }> }
        | ReadonlyArray<{ readonly name: string }>
        | string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Label>>
    | ResponseWithData<301, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Label>
          };

        case 301:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/set-labels'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
      readonly body?:
        | { readonly labels?: ReadonlyArray<string> }
        | ReadonlyArray<string>
        | { readonly labels?: ReadonlyArray<{ readonly name: string }> }
        | ReadonlyArray<{ readonly name: string }>
        | string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Label>>
    | ResponseWithData<301, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Label>
          };

        case 301:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/remove-all-labels'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<301, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 301:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/remove-label'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
      readonly name: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Label>>
    | ResponseWithData<301, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/labels/${encodeURIComponent(args['name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Label>
          };

        case 301:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/lock'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
      readonly body?: {
        readonly lock_reason?: 'off-topic' | 'too heated' | 'resolved' | 'spam';
      } | null;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/lock`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/unlock'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/lock`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/list-for-issue'(
    args: {
      readonly content?:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Reaction>>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
  > {
    const query = qs.stringify({
      ['content']: args['content'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/reactions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Reaction>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/create-for-issue'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
      readonly body: {
        readonly content:
          | '+1'
          | '-1'
          | 'laugh'
          | 'confused'
          | 'heart'
          | 'hooray'
          | 'rocket'
          | 'eyes';
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Reaction>
    | ResponseWithData<201, Reaction>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/reactions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        case 201:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/delete-for-issue'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
      readonly reaction_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/reactions/${encodeURIComponent(args['reaction_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list-events-for-timeline'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly issue_number: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<TimelineEvent>>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/issues/${encodeURIComponent(args['issue_number'])}/timeline?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<TimelineEvent>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-deploy-keys'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<DeployKey>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/keys?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<DeployKey>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-deploy-key'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly title?: string;
        readonly key: string;
        readonly read_only?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<201, DeployKey> | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/keys`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as DeployKey
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-deploy-key'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly key_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, DeployKey> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/keys/${encodeURIComponent(args['key_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as DeployKey
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-deploy-key'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly key_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/keys/${encodeURIComponent(args['key_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list-labels-for-repo'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Label>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/labels?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Label>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/create-label'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly name: string;
        readonly color?: string;
        readonly description?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Label>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/labels`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Label
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/get-label'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly name: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Label> | ResponseWithData<404, BasicError>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/labels/${encodeURIComponent(args['name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Label
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/update-label'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly name: string;
      readonly body?: {
        readonly new_name?: string;
        readonly color?: string;
        readonly description?: string;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Label>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/labels/${encodeURIComponent(args['name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Label
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/delete-label'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly name: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/labels/${encodeURIComponent(args['name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-languages'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Language>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/languages`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Language
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/enable-lfs-for-repo'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<202, unknown> | ResponseWithData<403, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/lfs`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as unknown
          };

        case 403:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/disable-lfs-for-repo'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/lfs`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'licenses/get-for-repo'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, LicenseContent>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/license`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as LicenseContent
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/merge-upstream'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: { readonly branch: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, MergedUpstream>
    | ResponseWithData<409, undefined>
    | ResponseWithData<422, undefined>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/merge-upstream`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as MergedUpstream
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/merge'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly base: string;
        readonly head: string;
        readonly commit_message?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Commit>
    | ResponseWithData<204, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, undefined>
    | ResponseWithData<409, undefined>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/merges`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Commit
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        case 409:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list-milestones'(
    args: {
      readonly state?: 'open' | 'closed' | 'all';
      readonly sort?: 'due_on' | 'completeness';
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Milestone>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['state']: args['state'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/milestones?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Milestone>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/create-milestone'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly title: string;
        readonly state?: 'open' | 'closed';
        readonly description?: string;
        readonly due_on?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Milestone>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/milestones`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Milestone
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/get-milestone'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly milestone_number: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, Milestone> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/milestones/${encodeURIComponent(args['milestone_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Milestone
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/update-milestone'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly milestone_number: number;
      readonly body?: {
        readonly title?: string;
        readonly state?: 'open' | 'closed';
        readonly description?: string;
        readonly due_on?: string;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Milestone>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/milestones/${encodeURIComponent(args['milestone_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Milestone
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/delete-milestone'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly milestone_number: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/milestones/${encodeURIComponent(args['milestone_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list-labels-for-milestone'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly milestone_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Label>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/milestones/${encodeURIComponent(args['milestone_number'])}/labels?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Label>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-repo-notifications-for-authenticated-user'(
    args: {
      readonly all?: boolean;
      readonly participating?: boolean;
      readonly since?: string;
      readonly before?: string;
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Thread>>> {
    const query = qs.stringify({
      ['all']: args['all'],
      ['participating']: args['participating'],
      ['since']: args['since'],
      ['before']: args['before'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/notifications?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Thread>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/mark-repo-notifications-as-read'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body?: { readonly last_read_at?: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        202,
        { readonly message?: string; readonly url?: string }
      >
    | ResponseWithData<205, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/notifications`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly message?: string;
              readonly url?: string;
            }
          };

        case 205:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-pages'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, GitHubPages> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pages`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GitHubPages
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-pages-site'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body:
        | ({
            readonly build_type?: 'legacy' | 'workflow';
            readonly source?: {
              readonly branch: string;
              readonly path?: '/' | '/docs';
            };
          } & unknown)
        | null;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, GitHubPages>
    | ResponseWithData<409, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pages`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as GitHubPages
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/update-information-about-pages-site'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly cname?: string | null;
        readonly https_enforced?: boolean;
        readonly public?: boolean;
        readonly build_type?: 'legacy' | 'workflow';
        readonly source?:
          | 'gh-pages'
          | 'master'
          | 'master /docs'
          | { readonly branch: string; readonly path: '/' | '/docs' };
      } & unknown;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<409, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pages`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-pages-site'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<409, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pages`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-pages-builds'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<PageBuild>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pages/builds?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<PageBuild>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/request-pages-build'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<201, PageBuildStatus>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pages/builds`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as PageBuildStatus
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-latest-pages-build'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, PageBuild>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pages/builds/latest`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PageBuild
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-pages-build'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly build_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, PageBuild>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pages/builds/${encodeURIComponent(args['build_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PageBuild
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-pages-deployment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly artifact_url: string;
        readonly environment?: string;
        readonly pages_build_version: string;
        readonly oidc_token: string;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, GitHubPages>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pages/deployment`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GitHubPages
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-pages-health-check'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PagesHealthCheckStatus>
    | ResponseWithData<202, EmptyObject>
    | ResponseWithData<400, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pages/health`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PagesHealthCheckStatus
          };

        case 202:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        case 400:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/list-for-repo'(
    args: {
      readonly state?: 'open' | 'closed' | 'all';
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Project>>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const query = qs.stringify({
      ['state']: args['state'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/projects?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Project>
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/create-for-repo'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: { readonly name: string; readonly body?: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Project>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<410, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/projects`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Project
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 410:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/list'(
    args: {
      readonly state?: 'open' | 'closed' | 'all';
      readonly head?: string;
      readonly base?: string;
      readonly sort?: 'created' | 'updated' | 'popularity' | 'long-running';
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<PullRequestSimple>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['state']: args['state'],
      ['head']: args['head'],
      ['base']: args['base'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<PullRequestSimple>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/create'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly title?: string;
        readonly head: string;
        readonly base: string;
        readonly body?: string;
        readonly maintainer_can_modify?: boolean;
        readonly draft?: boolean;
        readonly issue?: number;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, PullRequest>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as PullRequest
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/list-review-comments-for-repo'(
    args: {
      readonly sort?: 'created' | 'updated' | 'created_at';
      readonly direction?: 'asc' | 'desc';
      readonly since?: string;
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<PullRequestReviewComment>>> {
    const query = qs.stringify({
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['since']: args['since'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/comments?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<PullRequestReviewComment>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/get-review-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PullRequestReviewComment>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/comments/${encodeURIComponent(args['comment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PullRequestReviewComment
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/update-review-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
      readonly body: { readonly body: string };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, PullRequestReviewComment>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/comments/${encodeURIComponent(args['comment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PullRequestReviewComment
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/delete-review-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/comments/${encodeURIComponent(args['comment_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/list-for-pull-request-review-comment'(
    args: {
      readonly content?:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Reaction>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['content']: args['content'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/comments/${encodeURIComponent(args['comment_id'])}/reactions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Reaction>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/create-for-pull-request-review-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
      readonly body: {
        readonly content:
          | '+1'
          | '-1'
          | 'laugh'
          | 'confused'
          | 'heart'
          | 'hooray'
          | 'rocket'
          | 'eyes';
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Reaction>
    | ResponseWithData<201, Reaction>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/comments/${encodeURIComponent(args['comment_id'])}/reactions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        case 201:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/delete-for-pull-request-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly comment_id: number;
      readonly reaction_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/comments/${encodeURIComponent(args['comment_id'])}/reactions/${encodeURIComponent(args['reaction_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/get'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PullRequest>
    | ResponseWithData<304, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PullRequest
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/update'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly body?: {
        readonly title?: string;
        readonly body?: string;
        readonly state?: 'open' | 'closed';
        readonly base?: string;
        readonly maintainer_can_modify?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PullRequest>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PullRequest
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/create-with-pr-for-authenticated-user'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly body: {
        readonly location?: string;
        readonly client_ip?: string;
        readonly machine?: string;
        readonly devcontainer_path?: string;
        readonly multi_repo_permissions_opt_out?: boolean;
        readonly working_directory?: string;
        readonly idle_timeout_minutes?: number;
        readonly display_name?: string;
        readonly retention_period_minutes?: number;
      } | null;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Codespace>
    | ResponseWithData<202, Codespace>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/codespaces`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Codespace
          };

        case 202:
          return {
            status: $status,
            body: (await response.json()) as Codespace
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/list-review-comments'(
    args: {
      readonly sort?: 'created' | 'updated';
      readonly direction?: 'asc' | 'desc';
      readonly since?: string;
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<PullRequestReviewComment>>> {
    const query = qs.stringify({
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['since']: args['since'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/comments?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<PullRequestReviewComment>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/create-review-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly body: {
        readonly body: string;
        readonly commit_id: string;
        readonly path: string;
        readonly position?: number;
        readonly side?: 'LEFT' | 'RIGHT';
        readonly line: number;
        readonly start_line?: number;
        readonly start_side?: 'LEFT' | 'RIGHT' | 'side';
        readonly in_reply_to?: number;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, PullRequestReviewComment>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/comments`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as PullRequestReviewComment
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/create-reply-for-review-comment'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly comment_id: number;
      readonly body: { readonly body: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, PullRequestReviewComment>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/comments/${encodeURIComponent(args['comment_id'])}/replies`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as PullRequestReviewComment
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/list-commits'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Commit>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/commits?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Commit>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/list-files'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<DiffEntry>>
    | ResponseWithData<422, ValidationError>
    | ResponseWithData<500, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/files?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<DiffEntry>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/check-if-merged'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/merge`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/merge'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly body?: {
        readonly commit_title?: string;
        readonly commit_message?: string;
        readonly sha?: string;
        readonly merge_method?: 'merge' | 'squash' | 'rebase';
      } | null;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PullRequestMergeResult>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        405,
        { readonly message?: string; readonly documentation_url?: string }
      >
    | ResponseWithData<
        409,
        { readonly message?: string; readonly documentation_url?: string }
      >
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/merge`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PullRequestMergeResult
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 405:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/list-requested-reviewers'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, PullRequestReviewRequest>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/requested_reviewers`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PullRequestReviewRequest
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/request-reviewers'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly body?: {
        readonly reviewers?: ReadonlyArray<string>;
        readonly team_reviewers?: ReadonlyArray<string>;
      } & unknown;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, PullRequestSimple>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, undefined>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/requested_reviewers`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as PullRequestSimple
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/remove-requested-reviewers'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly body: {
        readonly reviewers: ReadonlyArray<string>;
        readonly team_reviewers?: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PullRequestSimple>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/requested_reviewers`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PullRequestSimple
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/list-reviews'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<PullRequestReview>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/reviews?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<PullRequestReview>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/create-review'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly body?: {
        readonly commit_id?: string;
        readonly body?: string;
        readonly event?: 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT';
        readonly comments?: ReadonlyArray<{
          readonly path: string;
          readonly position?: number;
          readonly body: string;
          readonly line?: number;
          readonly side?: string;
          readonly start_line?: number;
          readonly start_side?: string;
        }>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PullRequestReview>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/reviews`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PullRequestReview
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/get-review'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly review_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, PullRequestReview> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/reviews/${encodeURIComponent(args['review_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PullRequestReview
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/update-review'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly review_id: number;
      readonly body: { readonly body: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PullRequestReview>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/reviews/${encodeURIComponent(args['review_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PullRequestReview
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/delete-pending-review'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly review_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PullRequestReview>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/reviews/${encodeURIComponent(args['review_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PullRequestReview
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/list-comments-for-review'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly review_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<LegacyReviewComment>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/reviews/${encodeURIComponent(args['review_id'])}/comments?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<LegacyReviewComment>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/dismiss-review'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly review_id: number;
      readonly body: { readonly message: string; readonly event?: 'DISMISS' };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PullRequestReview>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/reviews/${encodeURIComponent(args['review_id'])}/dismissals`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PullRequestReview
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/submit-review'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly review_id: number;
      readonly body: {
        readonly body?: string;
        readonly event: 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT';
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PullRequestReview>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/reviews/${encodeURIComponent(args['review_id'])}/events`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PullRequestReview
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'pulls/update-branch'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly pull_number: number;
      readonly body?: { readonly expected_head_sha?: string } | null;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        202,
        { readonly message?: string; readonly url?: string }
      >
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/pulls/${encodeURIComponent(args['pull_number'])}/update-branch`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly message?: string;
              readonly url?: string;
            }
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-readme'(
    args: {
      readonly ref?: string;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ContentFile>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({ ['ref']: args['ref'] });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/readme?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ContentFile
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-readme-in-directory'(
    args: {
      readonly ref?: string;
      readonly owner: string;
      readonly repo: string;
      readonly dir: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ContentFile>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({ ['ref']: args['ref'] });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/readme/${encodeURIComponent(args['dir'])}?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ContentFile
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-releases'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Release>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Release>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-release'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly tag_name: string;
        readonly target_commitish?: string;
        readonly name?: string;
        readonly body?: string;
        readonly draft?: boolean;
        readonly prerelease?: boolean;
        readonly discussion_category_name?: string;
        readonly generate_release_notes?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Release>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Release
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-release-asset'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly asset_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReleaseAsset>
    | ResponseWithData<302, undefined>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/assets/${encodeURIComponent(args['asset_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReleaseAsset
          };

        case 302:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/update-release-asset'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly asset_id: number;
      readonly body?: {
        readonly name?: string;
        readonly label?: string;
        readonly state?: string;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReleaseAsset>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/assets/${encodeURIComponent(args['asset_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReleaseAsset
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-release-asset'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly asset_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/assets/${encodeURIComponent(args['asset_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/generate-release-notes'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly tag_name: string;
        readonly target_commitish?: string;
        readonly previous_tag_name?: string;
        readonly configuration_file_path?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, GeneratedReleaseNotesContent>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/generate-notes`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GeneratedReleaseNotesContent
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-latest-release'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Release>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/latest`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Release
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-release-by-tag'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly tag: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, Release> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/tags/${encodeURIComponent(args['tag'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Release
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-release'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly release_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, Release> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/${encodeURIComponent(args['release_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Release
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/update-release'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly release_id: number;
      readonly body?: {
        readonly tag_name?: string;
        readonly target_commitish?: string;
        readonly name?: string;
        readonly body?: string;
        readonly draft?: boolean;
        readonly prerelease?: boolean;
        readonly discussion_category_name?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, Release> | ResponseWithData<404, BasicError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/${encodeURIComponent(args['release_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Release
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-release'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly release_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/${encodeURIComponent(args['release_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-release-assets'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly release_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<ReleaseAsset>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/${encodeURIComponent(args['release_id'])}/assets?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<ReleaseAsset>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/upload-release-asset'(
    args: {
      readonly name: string;
      readonly label?: string;
      readonly owner: string;
      readonly repo: string;
      readonly release_id: number;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<201, ReleaseAsset> | ResponseWithData<422, undefined>
  > {
    const query = qs.stringify({
      ['name']: args['name'],
      ['label']: args['label']
    });

    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/${encodeURIComponent(args['release_id'])}/assets?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as ReleaseAsset
          };

        case 422:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/list-for-release'(
    args: {
      readonly content?:
        | '+1'
        | 'laugh'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly release_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Reaction>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['content']: args['content'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/${encodeURIComponent(args['release_id'])}/reactions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Reaction>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/create-for-release'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly release_id: number;
      readonly body: {
        readonly content:
          | '+1'
          | 'laugh'
          | 'heart'
          | 'hooray'
          | 'rocket'
          | 'eyes';
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Reaction>
    | ResponseWithData<201, Reaction>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/${encodeURIComponent(args['release_id'])}/reactions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        case 201:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/delete-for-release'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly release_id: number;
      readonly reaction_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/releases/${encodeURIComponent(args['release_id'])}/reactions/${encodeURIComponent(args['reaction_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'secret-scanning/list-alerts-for-repo'(
    args: {
      readonly state?: 'open' | 'resolved';
      readonly secret_type?: string;
      readonly resolution?: string;
      readonly sort?: 'created' | 'updated';
      readonly direction?: 'asc' | 'desc';
      readonly page?: number;
      readonly per_page?: number;
      readonly before?: string;
      readonly after?: string;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SecretScanningAlert>>
    | ResponseWithData<404, undefined>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['state']: args['state'],
      ['secret_type']: args['secret_type'],
      ['resolution']: args['resolution'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['page']: args['page'],
      ['per_page']: args['per_page'],
      ['before']: args['before'],
      ['after']: args['after']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/secret-scanning/alerts?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SecretScanningAlert>
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'secret-scanning/get-alert'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly alert_number: AlertNumber;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, SecretScanningAlert>
    | ResponseWithData<304, undefined>
    | ResponseWithData<404, undefined>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/secret-scanning/alerts/${encodeURIComponent(args['alert_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as SecretScanningAlert
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'secret-scanning/update-alert'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly alert_number: AlertNumber;
      readonly body: {
        readonly state: SecretScanningAlertState;
        readonly resolution?: SecretScanningAlertResolution;
        readonly resolution_comment?: SecretScanningAlertResolutionComment;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, SecretScanningAlert>
    | ResponseWithData<400, undefined>
    | ResponseWithData<404, undefined>
    | ResponseWithData<422, undefined>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/secret-scanning/alerts/${encodeURIComponent(args['alert_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as SecretScanningAlert
          };

        case 400:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: undefined
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'secret-scanning/list-locations-for-alert'(
    args: {
      readonly page?: number;
      readonly per_page?: number;
      readonly owner: string;
      readonly repo: string;
      readonly alert_number: AlertNumber;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SecretScanningLocation>>
    | ResponseWithData<404, undefined>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['page']: args['page'],
      ['per_page']: args['per_page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/secret-scanning/alerts/${encodeURIComponent(args['alert_number'])}/locations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SecretScanningLocation>
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-stargazers-for-repo'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        ReadonlyArray<SimpleUser> | ReadonlyArray<Stargazer>
      >
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/stargazers?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as
              | ReadonlyArray<SimpleUser>
              | ReadonlyArray<Stargazer>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-code-frequency-stats'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<CodeFrequencyStat>>
    | ResponseWithData<202, unknown>
    | ResponseWithData<204, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/stats/code_frequency`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<CodeFrequencyStat>
          };

        case 202:
          return {
            status: $status,
            body: (await response.json()) as unknown
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-commit-activity-stats'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<CommitActivity>>
    | ResponseWithData<202, unknown>
    | ResponseWithData<204, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/stats/commit_activity`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<CommitActivity>
          };

        case 202:
          return {
            status: $status,
            body: (await response.json()) as unknown
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-contributors-stats'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<ContributorActivity>>
    | ResponseWithData<202, unknown>
    | ResponseWithData<204, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/stats/contributors`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<ContributorActivity>
          };

        case 202:
          return {
            status: $status,
            body: (await response.json()) as unknown
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-participation-stats'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ParticipationStats>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/stats/participation`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ParticipationStats
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-punch-card-stats'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<CodeFrequencyStat>>
    | ResponseWithData<204, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/stats/punch_card`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<CodeFrequencyStat>
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-commit-status'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly sha: string;
      readonly body: {
        readonly state: 'error' | 'failure' | 'pending' | 'success';
        readonly target_url?: string | null;
        readonly description?: string | null;
        readonly context?: string;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, Status>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/statuses/${encodeURIComponent(args['sha'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Status
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-watchers-for-repo'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<SimpleUser>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/subscribers?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/get-repo-subscription'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, RepositoryInvitation>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/subscription`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as RepositoryInvitation
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/set-repo-subscription'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body?: {
        readonly subscribed?: boolean;
        readonly ignored?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, RepositoryInvitation>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/subscription`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as RepositoryInvitation
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/delete-repo-subscription'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/subscription`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-tags'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Tag>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/tags?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Tag>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-tag-protection'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<TagProtection>>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/tags/protection`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<TagProtection>
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-tag-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: { readonly pattern: string };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, TagProtection>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/tags/protection`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as TagProtection
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/delete-tag-protection'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly tag_protection_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/tags/protection/${encodeURIComponent(args['tag_protection_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/download-tarball-archive'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly ref: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<302, undefined>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/tarball/${encodeURIComponent(args['ref'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 302:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-teams'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Team>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/teams?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Team>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-all-topics'(
    args: {
      readonly page?: number;
      readonly per_page?: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Topic> | ResponseWithData<404, BasicError>> {
    const query = qs.stringify({
      ['page']: args['page'],
      ['per_page']: args['per_page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/topics?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Topic
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/replace-all-topics'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: { readonly names: ReadonlyArray<string> };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Topic>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/topics`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Topic
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-clones'(
    args: {
      readonly per?: '' | 'day' | 'week';
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, CloneTraffic> | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({ ['per']: args['per'] });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/traffic/clones?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CloneTraffic
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-top-paths'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<ContentTraffic>>
    | ResponseWithData<403, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/traffic/popular/paths`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<ContentTraffic>
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-top-referrers'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<ReferrerTraffic>>
    | ResponseWithData<403, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/traffic/popular/referrers`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<ReferrerTraffic>
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/get-views'(
    args: {
      readonly per?: '' | 'day' | 'week';
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, ViewTraffic> | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({ ['per']: args['per'] });

    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/traffic/views?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ViewTraffic
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/transfer'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly body: {
        readonly new_owner: string;
        readonly team_ids?: ReadonlyArray<number>;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<202, MinimalRepository>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/transfer`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as MinimalRepository
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/check-vulnerability-alerts'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/vulnerability-alerts`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/enable-vulnerability-alerts'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'PUT';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/vulnerability-alerts`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/disable-vulnerability-alerts'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/vulnerability-alerts`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/download-zipball-archive'(
    args: {
      readonly owner: string;
      readonly repo: string;
      readonly ref: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<302, undefined>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}/zipball/${encodeURIComponent(args['ref'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 302:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-using-template'(
    args: {
      readonly template_owner: string;
      readonly template_repo: string;
      readonly body: {
        readonly owner?: string;
        readonly name: string;
        readonly description?: string;
        readonly include_all_branches?: boolean;
        readonly private?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, Repository>> {
    const method = 'POST';
    const url = `${this.baseUrl}/repos/${encodeURIComponent(args['template_owner'])}/${encodeURIComponent(args['template_repo'])}/generate`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Repository
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-public'(
    args: { readonly since?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<MinimalRepository>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({ ['since']: args['since'] });

    const method = 'GET';
    const url = `${this.baseUrl}/repositories?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MinimalRepository>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/list-environment-secrets'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly repository_id: number;
      readonly environment_name: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly secrets: ReadonlyArray<ActionsSecret>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/repositories/${encodeURIComponent(args['repository_id'])}/environments/${encodeURIComponent(args['environment_name'])}/secrets?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly secrets: ReadonlyArray<ActionsSecret>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-environment-public-key'(
    args: { readonly repository_id: number; readonly environment_name: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsPublicKey>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repositories/${encodeURIComponent(args['repository_id'])}/environments/${encodeURIComponent(args['environment_name'])}/secrets/public-key`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsPublicKey
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/get-environment-secret'(
    args: {
      readonly repository_id: number;
      readonly environment_name: string;
      readonly secret_name: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsSecret>> {
    const method = 'GET';
    const url = `${this.baseUrl}/repositories/${encodeURIComponent(args['repository_id'])}/environments/${encodeURIComponent(args['environment_name'])}/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsSecret
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/create-or-update-environment-secret'(
    args: {
      readonly repository_id: number;
      readonly environment_name: string;
      readonly secret_name: string;
      readonly body: {
        readonly encrypted_value: string;
        readonly key_id: string;
      };
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<201, EmptyObject> | ResponseWithData<204, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/repositories/${encodeURIComponent(args['repository_id'])}/environments/${encodeURIComponent(args['environment_name'])}/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'actions/delete-environment-secret'(
    args: {
      readonly repository_id: number;
      readonly environment_name: string;
      readonly secret_name: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/repositories/${encodeURIComponent(args['repository_id'])}/environments/${encodeURIComponent(args['environment_name'])}/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'search/code'(
    args: {
      readonly q: string;
      readonly sort?: 'indexed';
      readonly order?: 'desc' | 'asc';
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly incomplete_results: boolean;
          readonly items: ReadonlyArray<CodeSearchResultItem>;
        }
      >
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['q']: args['q'],
      ['sort']: args['sort'],
      ['order']: args['order'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/search/code?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly incomplete_results: boolean;
              readonly items: ReadonlyArray<CodeSearchResultItem>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'search/commits'(
    args: {
      readonly q: string;
      readonly sort?: 'author-date' | 'committer-date';
      readonly order?: 'desc' | 'asc';
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly incomplete_results: boolean;
          readonly items: ReadonlyArray<CommitSearchResultItem>;
        }
      >
    | ResponseWithData<304, undefined>
  > {
    const query = qs.stringify({
      ['q']: args['q'],
      ['sort']: args['sort'],
      ['order']: args['order'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/search/commits?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly incomplete_results: boolean;
              readonly items: ReadonlyArray<CommitSearchResultItem>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'search/issues-and-pull-requests'(
    args: {
      readonly q: string;
      readonly sort?:
        | 'comments'
        | 'reactions'
        | 'reactions-+1'
        | 'reactions--1'
        | 'reactions-smile'
        | 'reactions-thinking_face'
        | 'reactions-heart'
        | 'reactions-tada'
        | 'interactions'
        | 'created'
        | 'updated';
      readonly order?: 'desc' | 'asc';
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly incomplete_results: boolean;
          readonly items: ReadonlyArray<IssueSearchResultItem>;
        }
      >
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['q']: args['q'],
      ['sort']: args['sort'],
      ['order']: args['order'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/search/issues?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly incomplete_results: boolean;
              readonly items: ReadonlyArray<IssueSearchResultItem>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'search/labels'(
    args: {
      readonly repository_id: number;
      readonly q: string;
      readonly sort?: 'created' | 'updated';
      readonly order?: 'desc' | 'asc';
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly incomplete_results: boolean;
          readonly items: ReadonlyArray<LabelSearchResultItem>;
        }
      >
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['repository_id']: args['repository_id'],
      ['q']: args['q'],
      ['sort']: args['sort'],
      ['order']: args['order'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/search/labels?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly incomplete_results: boolean;
              readonly items: ReadonlyArray<LabelSearchResultItem>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'search/repos'(
    args: {
      readonly q: string;
      readonly sort?: 'stars' | 'forks' | 'help-wanted-issues' | 'updated';
      readonly order?: 'desc' | 'asc';
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly incomplete_results: boolean;
          readonly items: ReadonlyArray<RepoSearchResultItem>;
        }
      >
    | ResponseWithData<304, undefined>
    | ResponseWithData<422, ValidationError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['q']: args['q'],
      ['sort']: args['sort'],
      ['order']: args['order'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/search/repositories?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly incomplete_results: boolean;
              readonly items: ReadonlyArray<RepoSearchResultItem>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'search/topics'(
    args: {
      readonly q: string;
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly incomplete_results: boolean;
          readonly items: ReadonlyArray<TopicSearchResultItem>;
        }
      >
    | ResponseWithData<304, undefined>
  > {
    const query = qs.stringify({
      ['q']: args['q'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/search/topics?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly incomplete_results: boolean;
              readonly items: ReadonlyArray<TopicSearchResultItem>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'search/users'(
    args: {
      readonly q: string;
      readonly sort?: 'followers' | 'repositories' | 'joined';
      readonly order?: 'desc' | 'asc';
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly incomplete_results: boolean;
          readonly items: ReadonlyArray<UserSearchResultItem>;
        }
      >
    | ResponseWithData<304, undefined>
    | ResponseWithData<422, ValidationError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const query = qs.stringify({
      ['q']: args['q'],
      ['sort']: args['sort'],
      ['order']: args['order'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/search/users?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly incomplete_results: boolean;
              readonly items: ReadonlyArray<UserSearchResultItem>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/get-legacy'(
    args: { readonly team_id: number },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, FullTeam> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as FullTeam
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/update-legacy'(
    args: {
      readonly team_id: number;
      readonly body: {
        readonly name: string;
        readonly description?: string;
        readonly privacy?: 'secret' | 'closed';
        readonly permission?: 'pull' | 'push' | 'admin';
        readonly parent_team_id?: number | null;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, FullTeam>
    | ResponseWithData<201, FullTeam>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as FullTeam
          };

        case 201:
          return {
            status: $status,
            body: (await response.json()) as FullTeam
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/delete-legacy'(
    args: { readonly team_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-discussions-legacy'(
    args: {
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly page?: number;
      readonly team_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<TeamDiscussion>>> {
    const query = qs.stringify({
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<TeamDiscussion>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/create-discussion-legacy'(
    args: {
      readonly team_id: number;
      readonly body: {
        readonly title: string;
        readonly body: string;
        readonly private?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, TeamDiscussion>> {
    const method = 'POST';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as TeamDiscussion
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/get-discussion-legacy'(
    args: { readonly team_id: number; readonly discussion_number: number },
    options?: RequestInit
  ): Promise<ResponseWithData<200, TeamDiscussion>> {
    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions/${encodeURIComponent(args['discussion_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamDiscussion
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/update-discussion-legacy'(
    args: {
      readonly team_id: number;
      readonly discussion_number: number;
      readonly body?: { readonly title?: string; readonly body?: string };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, TeamDiscussion>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions/${encodeURIComponent(args['discussion_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamDiscussion
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/delete-discussion-legacy'(
    args: { readonly team_id: number; readonly discussion_number: number },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions/${encodeURIComponent(args['discussion_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-discussion-comments-legacy'(
    args: {
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly page?: number;
      readonly team_id: number;
      readonly discussion_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<TeamDiscussionComment>>> {
    const query = qs.stringify({
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<TeamDiscussionComment>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/create-discussion-comment-legacy'(
    args: {
      readonly team_id: number;
      readonly discussion_number: number;
      readonly body: { readonly body: string };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, TeamDiscussionComment>> {
    const method = 'POST';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as TeamDiscussionComment
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/get-discussion-comment-legacy'(
    args: {
      readonly team_id: number;
      readonly discussion_number: number;
      readonly comment_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, TeamDiscussionComment>> {
    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments/${encodeURIComponent(args['comment_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamDiscussionComment
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/update-discussion-comment-legacy'(
    args: {
      readonly team_id: number;
      readonly discussion_number: number;
      readonly comment_number: number;
      readonly body: { readonly body: string };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, TeamDiscussionComment>> {
    const method = 'PATCH';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments/${encodeURIComponent(args['comment_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamDiscussionComment
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/delete-discussion-comment-legacy'(
    args: {
      readonly team_id: number;
      readonly discussion_number: number;
      readonly comment_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments/${encodeURIComponent(args['comment_number'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/list-for-team-discussion-comment-legacy'(
    args: {
      readonly content?:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
      readonly per_page?: number;
      readonly page?: number;
      readonly team_id: number;
      readonly discussion_number: number;
      readonly comment_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Reaction>>> {
    const query = qs.stringify({
      ['content']: args['content'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments/${encodeURIComponent(args['comment_number'])}/reactions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Reaction>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/create-for-team-discussion-comment-legacy'(
    args: {
      readonly team_id: number;
      readonly discussion_number: number;
      readonly comment_number: number;
      readonly body: {
        readonly content:
          | '+1'
          | '-1'
          | 'laugh'
          | 'confused'
          | 'heart'
          | 'hooray'
          | 'rocket'
          | 'eyes';
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, Reaction>> {
    const method = 'POST';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions/${encodeURIComponent(args['discussion_number'])}/comments/${encodeURIComponent(args['comment_number'])}/reactions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/list-for-team-discussion-legacy'(
    args: {
      readonly content?:
        | '+1'
        | '-1'
        | 'laugh'
        | 'confused'
        | 'heart'
        | 'hooray'
        | 'rocket'
        | 'eyes';
      readonly per_page?: number;
      readonly page?: number;
      readonly team_id: number;
      readonly discussion_number: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Reaction>>> {
    const query = qs.stringify({
      ['content']: args['content'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions/${encodeURIComponent(args['discussion_number'])}/reactions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Reaction>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'reactions/create-for-team-discussion-legacy'(
    args: {
      readonly team_id: number;
      readonly discussion_number: number;
      readonly body: {
        readonly content:
          | '+1'
          | '-1'
          | 'laugh'
          | 'confused'
          | 'heart'
          | 'hooray'
          | 'rocket'
          | 'eyes';
      };
    },
    options?: RequestInit
  ): Promise<ResponseWithData<201, Reaction>> {
    const method = 'POST';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/discussions/${encodeURIComponent(args['discussion_number'])}/reactions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Reaction
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-pending-invitations-legacy'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly team_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<OrganizationInvitation>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/invitations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<OrganizationInvitation>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-members-legacy'(
    args: {
      readonly role?: 'member' | 'maintainer' | 'all';
      readonly per_page?: number;
      readonly page?: number;
      readonly team_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleUser>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['role']: args['role'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/members?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/get-member-legacy'(
    args: { readonly team_id: number; readonly username: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/members/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/add-member-legacy'(
    args: { readonly team_id: number; readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, undefined>
    | ResponseWithData<422, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/members/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        case 422:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/remove-member-legacy'(
    args: { readonly team_id: number; readonly username: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, undefined>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/members/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/get-membership-for-user-legacy'(
    args: { readonly team_id: number; readonly username: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, TeamMembership> | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/memberships/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamMembership
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/add-or-update-membership-for-user-legacy'(
    args: {
      readonly team_id: number;
      readonly username: string;
      readonly body?: { readonly role?: 'member' | 'maintainer' };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, TeamMembership>
    | ResponseWithData<403, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, undefined>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/memberships/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamMembership
          };

        case 403:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/remove-membership-for-user-legacy'(
    args: { readonly team_id: number; readonly username: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<403, undefined>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/memberships/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-projects-legacy'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly team_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<TeamProject>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/projects?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<TeamProject>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/check-permissions-for-project-legacy'(
    args: { readonly team_id: number; readonly project_id: number },
    options?: RequestInit
  ): Promise<
    ResponseWithData<200, TeamProject> | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/projects/${encodeURIComponent(args['project_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamProject
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/add-or-update-project-permissions-legacy'(
    args: {
      readonly team_id: number;
      readonly project_id: number;
      readonly body?: { readonly permission?: 'read' | 'write' | 'admin' };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<
        403,
        { readonly message?: string; readonly documentation_url?: string }
      >
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/projects/${encodeURIComponent(args['project_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/remove-project-legacy'(
    args: { readonly team_id: number; readonly project_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/projects/${encodeURIComponent(args['project_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-repos-legacy'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly team_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<MinimalRepository>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/repos?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MinimalRepository>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/check-permissions-for-repo-legacy'(
    args: {
      readonly team_id: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, TeamRepository>
    | ResponseWithData<204, undefined>
    | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as TeamRepository
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/add-or-update-repo-permissions-legacy'(
    args: {
      readonly team_id: number;
      readonly owner: string;
      readonly repo: string;
      readonly body?: { readonly permission?: 'pull' | 'push' | 'admin' };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/remove-repo-legacy'(
    args: {
      readonly team_id: number;
      readonly owner: string;
      readonly repo: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/repos/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-child-legacy'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly team_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Team>>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/teams/${encodeURIComponent(args['team_id'])}/teams?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Team>
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/get-authenticated'(
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PrivateUser | PublicUser>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PrivateUser | PublicUser
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/update-authenticated'(
    args: {
      readonly body?: {
        readonly name?: string;
        readonly email?: string;
        readonly blog?: string;
        readonly twitter_username?: string | null;
        readonly company?: string;
        readonly location?: string;
        readonly hireable?: boolean;
        readonly bio?: string;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PrivateUser>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/user`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PrivateUser
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list-blocked-by-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleUser>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/blocks?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/check-blocked'(
    args: { readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user/blocks/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/block'(
    args: { readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/user/blocks/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/unblock'(
    args: { readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/blocks/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/list-for-authenticated-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly repository_id?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly codespaces: ReadonlyArray<Codespace>;
        }
      >
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page'],
      ['repository_id']: args['repository_id']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/codespaces?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly codespaces: ReadonlyArray<Codespace>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/create-for-authenticated-user'(
    args: {
      readonly body:
        | {
            readonly repository_id: number;
            readonly ref?: string;
            readonly location?: string;
            readonly client_ip?: string;
            readonly machine?: string;
            readonly devcontainer_path?: string;
            readonly multi_repo_permissions_opt_out?: boolean;
            readonly working_directory?: string;
            readonly idle_timeout_minutes?: number;
            readonly display_name?: string;
            readonly retention_period_minutes?: number;
          }
        | {
            readonly pull_request: {
              readonly pull_request_number: number;
              readonly repository_id: number;
            };
            readonly location?: string;
            readonly machine?: string;
            readonly devcontainer_path?: string;
            readonly working_directory?: string;
            readonly idle_timeout_minutes?: number;
          };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Codespace>
    | ResponseWithData<202, Codespace>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<
        503,
        {
          readonly code?: string;
          readonly message?: string;
          readonly documentation_url?: string;
        }
      >
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/user/codespaces`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Codespace
          };

        case 202:
          return {
            status: $status,
            body: (await response.json()) as Codespace
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 503:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly code?: string;
              readonly message?: string;
              readonly documentation_url?: string;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/list-secrets-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      {
        readonly total_count: number;
        readonly secrets: ReadonlyArray<CodespacesSecret>;
      }
    >
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/codespaces/secrets?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly secrets: ReadonlyArray<CodespacesSecret>;
            }
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/get-public-key-for-authenticated-user'(
    options?: RequestInit
  ): Promise<ResponseWithData<200, CodespacesUserPublicKey>> {
    const method = 'GET';
    const url = `${this.baseUrl}/user/codespaces/secrets/public-key`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CodespacesUserPublicKey
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/get-secret-for-authenticated-user'(
    args: { readonly secret_name: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, CodespacesSecret>> {
    const method = 'GET';
    const url = `${this.baseUrl}/user/codespaces/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CodespacesSecret
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/create-or-update-secret-for-authenticated-user'(
    args: {
      readonly secret_name: string;
      readonly body: {
        readonly encrypted_value?: string;
        readonly key_id: string;
        readonly selected_repository_ids?: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, EmptyObject>
    | ResponseWithData<204, undefined>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/user/codespaces/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as EmptyObject
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/delete-secret-for-authenticated-user'(
    args: { readonly secret_name: string },
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/codespaces/secrets/${encodeURIComponent(args['secret_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/list-repositories-for-secret-for-authenticated-user'(
    args: { readonly secret_name: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly repositories: ReadonlyArray<MinimalRepository>;
        }
      >
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user/codespaces/secrets/${encodeURIComponent(args['secret_name'])}/repositories`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly repositories: ReadonlyArray<MinimalRepository>;
            }
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/set-repositories-for-secret-for-authenticated-user'(
    args: {
      readonly secret_name: string;
      readonly body: {
        readonly selected_repository_ids: ReadonlyArray<number>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/user/codespaces/secrets/${encodeURIComponent(args['secret_name'])}/repositories`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/add-repository-for-secret-for-authenticated-user'(
    args: { readonly secret_name: string; readonly repository_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/user/codespaces/secrets/${encodeURIComponent(args['secret_name'])}/repositories/${encodeURIComponent(args['repository_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/remove-repository-for-secret-for-authenticated-user'(
    args: { readonly secret_name: string; readonly repository_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/codespaces/secrets/${encodeURIComponent(args['secret_name'])}/repositories/${encodeURIComponent(args['repository_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/get-for-authenticated-user'(
    args: { readonly codespace_name: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Codespace>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user/codespaces/${encodeURIComponent(args['codespace_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Codespace
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/update-for-authenticated-user'(
    args: {
      readonly codespace_name: string;
      readonly body?: {
        readonly machine?: string;
        readonly display_name?: string;
        readonly recent_folders?: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Codespace>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/user/codespaces/${encodeURIComponent(args['codespace_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Codespace
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/delete-for-authenticated-user'(
    args: { readonly codespace_name: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<202, unknown>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/codespaces/${encodeURIComponent(args['codespace_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as unknown
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/export-for-authenticated-user'(
    args: { readonly codespace_name: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<202, FetchesInformationAboutAnExportOfACodespace>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/user/codespaces/${encodeURIComponent(args['codespace_name'])}/exports`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 202:
          return {
            status: $status,
            body: (await response.json()) as FetchesInformationAboutAnExportOfACodespace
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/get-export-details-for-authenticated-user'(
    args: { readonly codespace_name: string; readonly export_id: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, FetchesInformationAboutAnExportOfACodespace>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user/codespaces/${encodeURIComponent(args['codespace_name'])}/exports/${encodeURIComponent(args['export_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as FetchesInformationAboutAnExportOfACodespace
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/codespace-machines-for-authenticated-user'(
    args: { readonly codespace_name: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly machines: ReadonlyArray<CodespaceMachine>;
        }
      >
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user/codespaces/${encodeURIComponent(args['codespace_name'])}/machines`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly machines: ReadonlyArray<CodespaceMachine>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/start-for-authenticated-user'(
    args: { readonly codespace_name: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Codespace>
    | ResponseWithData<304, undefined>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<402, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<409, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/user/codespaces/${encodeURIComponent(args['codespace_name'])}/start`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Codespace
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 402:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'codespaces/stop-for-authenticated-user'(
    args: { readonly codespace_name: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Codespace>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<500, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/user/codespaces/${encodeURIComponent(args['codespace_name'])}/stop`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Codespace
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 500:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/set-primary-email-visibility-for-authenticated-user'(
    args: { readonly body: { readonly visibility: 'public' | 'private' } },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Email>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/user/email/visibility`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Email>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list-emails-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Email>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/emails?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Email>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/add-email-for-authenticated-user'(
    args: {
      readonly body?:
        | { readonly emails: ReadonlyArray<string> }
        | ReadonlyArray<string>
        | string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, ReadonlyArray<Email>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/user/emails`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Email>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/delete-email-for-authenticated-user'(
    args: {
      readonly body?:
        | { readonly emails: ReadonlyArray<string> }
        | ReadonlyArray<string>
        | string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/emails`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list-followers-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleUser>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/followers?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list-followed-by-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleUser>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/following?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/check-person-is-followed-by-authenticated'(
    args: { readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user/following/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/follow'(
    args: { readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/user/following/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/unfollow'(
    args: { readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/following/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list-gpg-keys-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<GpgKey>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/gpg_keys?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<GpgKey>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/create-gpg-key-for-authenticated-user'(
    args: {
      readonly body: {
        readonly name?: string;
        readonly armored_public_key: string;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, GpgKey>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/user/gpg_keys`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as GpgKey
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/get-gpg-key-for-authenticated-user'(
    args: { readonly gpg_key_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, GpgKey>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user/gpg_keys/${encodeURIComponent(args['gpg_key_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as GpgKey
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/delete-gpg-key-for-authenticated-user'(
    args: { readonly gpg_key_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/gpg_keys/${encodeURIComponent(args['gpg_key_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/list-installations-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly installations: ReadonlyArray<Installation>;
        }
      >
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/installations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly installations: ReadonlyArray<Installation>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/list-installation-repos-for-authenticated-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly installation_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<
        200,
        {
          readonly total_count: number;
          readonly repository_selection?: string;
          readonly repositories: ReadonlyArray<Repository>;
        }
      >
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/installations/${encodeURIComponent(args['installation_id'])}/repositories?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as {
              readonly total_count: number;
              readonly repository_selection?: string;
              readonly repositories: ReadonlyArray<Repository>;
            }
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/add-repo-to-installation-for-authenticated-user'(
    args: { readonly installation_id: number; readonly repository_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/user/installations/${encodeURIComponent(args['installation_id'])}/repositories/${encodeURIComponent(args['repository_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/remove-repo-from-installation-for-authenticated-user'(
    args: { readonly installation_id: number; readonly repository_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/installations/${encodeURIComponent(args['installation_id'])}/repositories/${encodeURIComponent(args['repository_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'interactions/get-restrictions-for-authenticated-user'(
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, InteractionLimits | {}>
    | ResponseWithData<204, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user/interaction-limits`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as InteractionLimits | {}
          };

        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'interactions/set-restrictions-for-authenticated-user'(
    args: { readonly body: InteractionRestrictions },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, InteractionLimits>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/user/interaction-limits`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as InteractionLimits
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'interactions/remove-restrictions-for-authenticated-user'(
    options?: RequestInit
  ): Promise<ResponseWithData<204, undefined>> {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/interaction-limits`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'issues/list-for-authenticated-user'(
    args: {
      readonly filter?:
        | 'assigned'
        | 'created'
        | 'mentioned'
        | 'subscribed'
        | 'repos'
        | 'all';
      readonly state?: 'open' | 'closed' | 'all';
      readonly labels?: string;
      readonly sort?: 'created' | 'updated' | 'comments';
      readonly direction?: 'asc' | 'desc';
      readonly since?: string;
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Issue>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['filter']: args['filter'],
      ['state']: args['state'],
      ['labels']: args['labels'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['since']: args['since'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/issues?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Issue>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list-public-ssh-keys-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Key>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/keys?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Key>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/create-public-ssh-key-for-authenticated-user'(
    args: { readonly body: { readonly title?: string; readonly key: string } },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Key>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/user/keys`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Key
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/get-public-ssh-key-for-authenticated-user'(
    args: { readonly key_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Key>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user/keys/${encodeURIComponent(args['key_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Key
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/delete-public-ssh-key-for-authenticated-user'(
    args: { readonly key_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/keys/${encodeURIComponent(args['key_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/list-subscriptions-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<UserMarketplacePurchase>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/marketplace_purchases?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<UserMarketplacePurchase>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/list-subscriptions-for-authenticated-user-stubbed'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<UserMarketplacePurchase>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/marketplace_purchases/stubbed?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<UserMarketplacePurchase>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-memberships-for-authenticated-user'(
    args: {
      readonly state?: 'active' | 'pending';
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<OrgMembership>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['state']: args['state'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/memberships/orgs?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<OrgMembership>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/get-membership-for-authenticated-user'(
    args: { readonly org: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, OrgMembership>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user/memberships/orgs/${encodeURIComponent(args['org'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as OrgMembership
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/update-membership-for-authenticated-user'(
    args: { readonly org: string; readonly body: { readonly state: 'active' } },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, OrgMembership>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/user/memberships/orgs/${encodeURIComponent(args['org'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as OrgMembership
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/list-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Migration>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/migrations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Migration>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/start-for-authenticated-user'(
    args: {
      readonly body: {
        readonly lock_repositories?: boolean;
        readonly exclude_metadata?: boolean;
        readonly exclude_git_data?: boolean;
        readonly exclude_attachments?: boolean;
        readonly exclude_releases?: boolean;
        readonly exclude_owner_projects?: boolean;
        readonly org_metadata_only?: boolean;
        readonly exclude?: ReadonlyArray<'repositories'>;
        readonly repositories: ReadonlyArray<string>;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Migration>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/user/migrations`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Migration
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/get-status-for-authenticated-user'(
    args: {
      readonly exclude?: ReadonlyArray<string>;
      readonly migration_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Migration>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({ ['exclude']: args['exclude'] });

    const method = 'GET';
    const url = `${this.baseUrl}/user/migrations/${encodeURIComponent(args['migration_id'])}?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Migration
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/get-archive-for-authenticated-user'(
    args: { readonly migration_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<302, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user/migrations/${encodeURIComponent(args['migration_id'])}/archive`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 302:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/delete-archive-for-authenticated-user'(
    args: { readonly migration_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/migrations/${encodeURIComponent(args['migration_id'])}/archive`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/unlock-repo-for-authenticated-user'(
    args: { readonly migration_id: number; readonly repo_name: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/migrations/${encodeURIComponent(args['migration_id'])}/repos/${encodeURIComponent(args['repo_name'])}/lock`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'migrations/list-repos-for-authenticated-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly migration_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<MinimalRepository>>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/migrations/${encodeURIComponent(args['migration_id'])}/repositories?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MinimalRepository>
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<OrganizationSimple>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/orgs?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<OrganizationSimple>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/list-packages-for-authenticated-user'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly visibility?: 'public' | 'private' | 'internal';
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Package>>> {
    const query = qs.stringify({
      ['package_type']: args['package_type'],
      ['visibility']: args['visibility']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/packages?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Package>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/get-package-for-authenticated-user'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Package>> {
    const method = 'GET';
    const url = `${this.baseUrl}/user/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Package
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/delete-package-for-authenticated-user'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/restore-package-for-authenticated-user'(
    args: {
      readonly token?: string;
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({ ['token']: args['token'] });

    const method = 'POST';
    const url = `${this.baseUrl}/user/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/restore?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/get-all-package-versions-for-package-owned-by-authenticated-user'(
    args: {
      readonly page?: number;
      readonly per_page?: number;
      readonly state?: 'active' | 'deleted';
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<PackageVersion>>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['page']: args['page'],
      ['per_page']: args['per_page'],
      ['state']: args['state']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/versions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<PackageVersion>
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/get-package-version-for-authenticated-user'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly package_version_id: number;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, PackageVersion>> {
    const method = 'GET';
    const url = `${this.baseUrl}/user/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/versions/${encodeURIComponent(args['package_version_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PackageVersion
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/delete-package-version-for-authenticated-user'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly package_version_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/versions/${encodeURIComponent(args['package_version_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/restore-package-version-for-authenticated-user'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly package_version_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/user/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/versions/${encodeURIComponent(args['package_version_id'])}/restore`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/create-for-authenticated-user'(
    args: {
      readonly body: { readonly name: string; readonly body?: string | null };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Project>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationErrorSimple>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/user/projects`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Project
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationErrorSimple
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list-public-emails-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Email>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/public_emails?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Email>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-for-authenticated-user'(
    args: {
      readonly visibility?: 'all' | 'public' | 'private';
      readonly affiliation?: string;
      readonly type?: 'all' | 'owner' | 'public' | 'private' | 'member';
      readonly sort?: 'created' | 'updated' | 'pushed' | 'full_name';
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly page?: number;
      readonly since?: string;
      readonly before?: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Repository>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['visibility']: args['visibility'],
      ['affiliation']: args['affiliation'],
      ['type']: args['type'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['page']: args['page'],
      ['since']: args['since'],
      ['before']: args['before']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/repos?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Repository>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/create-for-authenticated-user'(
    args: {
      readonly body: {
        readonly name: string;
        readonly description?: string;
        readonly homepage?: string;
        readonly private?: boolean;
        readonly has_issues?: boolean;
        readonly has_projects?: boolean;
        readonly has_wiki?: boolean;
        readonly team_id?: number;
        readonly auto_init?: boolean;
        readonly gitignore_template?: string;
        readonly license_template?: string;
        readonly allow_squash_merge?: boolean;
        readonly allow_merge_commit?: boolean;
        readonly allow_rebase_merge?: boolean;
        readonly allow_auto_merge?: boolean;
        readonly delete_branch_on_merge?: boolean;
        readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
        readonly squash_merge_commit_message?:
          | 'PR_BODY'
          | 'COMMIT_MESSAGES'
          | 'BLANK';
        readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
        readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
        readonly has_downloads?: boolean;
        readonly is_template?: boolean;
      };
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, Repository>
    | ResponseWithData<304, undefined>
    | ResponseWithData<400, BasicError>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/user/repos`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as Repository
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 400:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-invitations-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<RepositoryInvitation>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/repository_invitations?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<RepositoryInvitation>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/accept-invitation-for-authenticated-user'(
    args: { readonly invitation_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<409, BasicError>
  > {
    const method = 'PATCH';
    const url = `${this.baseUrl}/user/repository_invitations/${encodeURIComponent(args['invitation_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/decline-invitation-for-authenticated-user'(
    args: { readonly invitation_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<409, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/repository_invitations/${encodeURIComponent(args['invitation_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 409:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list-ssh-signing-keys-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SshSigningKey>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/ssh_signing_keys?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SshSigningKey>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/create-ssh-signing-key-for-authenticated-user'(
    args: { readonly body: { readonly title?: string; readonly key: string } },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<201, SshSigningKey>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/user/ssh_signing_keys`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      body: JSON.stringify(args.body),
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
        ...this.options.requestOptions.headers
      }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 201:
          return {
            status: $status,
            body: (await response.json()) as SshSigningKey
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/get-ssh-signing-key-for-authenticated-user'(
    args: { readonly ssh_signing_key_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, SshSigningKey>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user/ssh_signing_keys/${encodeURIComponent(args['ssh_signing_key_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as SshSigningKey
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/delete-ssh-signing-key-for-authenticated-user'(
    args: { readonly ssh_signing_key_id: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/ssh_signing_keys/${encodeURIComponent(args['ssh_signing_key_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-repos-starred-by-authenticated-user'(
    args: {
      readonly sort?: 'created' | 'updated';
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly page?: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Repository>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/starred?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Repository>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/check-repo-is-starred-by-authenticated-user'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/user/starred/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/star-repo-for-authenticated-user'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'PUT';
    const url = `${this.baseUrl}/user/starred/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/unstar-repo-for-authenticated-user'(
    args: { readonly owner: string; readonly repo: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/user/starred/${encodeURIComponent(args['owner'])}/${encodeURIComponent(args['repo'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-watched-repos-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<MinimalRepository>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/subscriptions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MinimalRepository>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'teams/list-for-authenticated-user'(
    args: { readonly per_page?: number; readonly page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<FullTeam>>
    | ResponseWithData<304, undefined>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/user/teams?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<FullTeam>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list'(
    args: { readonly since?: number; readonly per_page?: number },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<SimpleUser>>
    | ResponseWithData<304, undefined>
  > {
    const query = qs.stringify({
      ['since']: args['since'],
      ['per_page']: args['per_page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        case 304:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/get-by-username'(
    args: { readonly username: string },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, PrivateUser | PublicUser>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PrivateUser | PublicUser
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-events-for-authenticated-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Event>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/events?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Event>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-org-events-for-authenticated-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
      readonly org: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Event>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/events/orgs/${encodeURIComponent(args['org'])}?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Event>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-public-events-for-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Event>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/events/public?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Event>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list-followers-for-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<SimpleUser>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/followers?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list-following-for-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<SimpleUser>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/following?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SimpleUser>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/check-following-for-user'(
    args: { readonly username: string; readonly target_user: string },
    options?: RequestInit
  ): Promise<
    ResponseWithData<204, undefined> | ResponseWithData<404, undefined>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/following/${encodeURIComponent(args['target_user'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 404:
          return {
            status: $status,
            body: undefined
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'gists/list-for-user'(
    args: {
      readonly since?: string;
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<BaseGist>>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['since']: args['since'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/gists?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<BaseGist>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list-gpg-keys-for-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<GpgKey>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/gpg_keys?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<GpgKey>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/get-context-for-user'(
    args: {
      readonly subject_type?:
        | 'organization'
        | 'repository'
        | 'issue'
        | 'pull_request';
      readonly subject_id?: string;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, Hovercard>
    | ResponseWithData<404, BasicError>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['subject_type']: args['subject_type'],
      ['subject_id']: args['subject_id']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/hovercard?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Hovercard
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'apps/get-user-installation'(
    args: { readonly username: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Installation>> {
    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/installation`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Installation
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list-public-keys-for-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<KeySimple>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/keys?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<KeySimple>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'orgs/list-for-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<OrganizationSimple>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/orgs?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<OrganizationSimple>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/list-packages-for-user'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly visibility?: 'public' | 'private' | 'internal';
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Package>>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
  > {
    const query = qs.stringify({
      ['package_type']: args['package_type'],
      ['visibility']: args['visibility']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/packages?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Package>
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/get-package-for-user'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, Package>> {
    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as Package
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/delete-package-for-user'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/restore-package-for-user'(
    args: {
      readonly token?: string;
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const query = qs.stringify({ ['token']: args['token'] });

    const method = 'POST';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/restore?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/get-all-package-versions-for-package-owned-by-user'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<PackageVersion>>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/versions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<PackageVersion>
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/get-package-version-for-user'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly package_version_id: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, PackageVersion>> {
    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/versions/${encodeURIComponent(args['package_version_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PackageVersion
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/delete-package-version-for-user'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly username: string;
      readonly package_version_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'DELETE';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/versions/${encodeURIComponent(args['package_version_id'])}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'packages/restore-package-version-for-user'(
    args: {
      readonly package_type:
        | 'npm'
        | 'maven'
        | 'rubygems'
        | 'docker'
        | 'nuget'
        | 'container';
      readonly package_name: string;
      readonly username: string;
      readonly package_version_id: number;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<204, undefined>
    | ResponseWithData<401, BasicError>
    | ResponseWithData<403, BasicError>
    | ResponseWithData<404, BasicError>
  > {
    const method = 'POST';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/packages/${encodeURIComponent(args['package_type'])}/${encodeURIComponent(args['package_name'])}/versions/${encodeURIComponent(args['package_version_id'])}/restore`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 204:
          return {
            status: $status,
            body: undefined
          };

        case 401:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 403:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        case 404:
          return {
            status: $status,
            body: (await response.json()) as BasicError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'projects/list-for-user'(
    args: {
      readonly state?: 'open' | 'closed' | 'all';
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<
    | ResponseWithData<200, ReadonlyArray<Project>>
    | ResponseWithData<422, ValidationError>
  > {
    const query = qs.stringify({
      ['state']: args['state'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/projects?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Project>
          };

        case 422:
          return {
            status: $status,
            body: (await response.json()) as ValidationError
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-received-events-for-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Event>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/received_events?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Event>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-received-public-events-for-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<Event>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/received_events/public?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<Event>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'repos/list-for-user'(
    args: {
      readonly type?: 'all' | 'owner' | 'member';
      readonly sort?: 'created' | 'updated' | 'pushed' | 'full_name';
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<MinimalRepository>>> {
    const query = qs.stringify({
      ['type']: args['type'],
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/repos?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MinimalRepository>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'billing/get-github-actions-billing-user'(
    args: { readonly username: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ActionsBillingUsage>> {
    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/settings/billing/actions`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ActionsBillingUsage
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'billing/get-github-packages-billing-user'(
    args: { readonly username: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, PackagesBillingUsage>> {
    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/settings/billing/packages`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as PackagesBillingUsage
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'billing/get-shared-storage-billing-user'(
    args: { readonly username: string },
    options?: RequestInit
  ): Promise<ResponseWithData<200, CombinedBillingUsage>> {
    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/settings/billing/shared-storage`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as CombinedBillingUsage
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'users/list-ssh-signing-keys-for-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<SshSigningKey>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/ssh_signing_keys?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<SshSigningKey>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-repos-starred-by-user'(
    args: {
      readonly sort?: 'created' | 'updated';
      readonly direction?: 'asc' | 'desc';
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<
    ResponseWithData<
      200,
      ReadonlyArray<StarredRepository> | ReadonlyArray<Repository>
    >
  > {
    const query = qs.stringify({
      ['sort']: args['sort'],
      ['direction']: args['direction'],
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/starred?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as
              | ReadonlyArray<StarredRepository>
              | ReadonlyArray<Repository>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'activity/list-repos-watched-by-user'(
    args: {
      readonly per_page?: number;
      readonly page?: number;
      readonly username: string;
    },
    options?: RequestInit
  ): Promise<ResponseWithData<200, ReadonlyArray<MinimalRepository>>> {
    const query = qs.stringify({
      ['per_page']: args['per_page'],
      ['page']: args['page']
    });

    const method = 'GET';
    const url = `${this.baseUrl}/users/${encodeURIComponent(args['username'])}/subscriptions?${query}`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: (await response.json()) as ReadonlyArray<MinimalRepository>
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }

  public async 'meta/get-zen'(
    options?: RequestInit
  ): Promise<ResponseWithData<200, globalThis.Blob>> {
    const method = 'GET';
    const url = `${this.baseUrl}/zen`;
    const fetchOptions = {
      method,
      ...options,
      ...this.options.requestOptions,
      headers: { ...options?.headers, ...this.options.requestOptions.headers }
    };

    try {
      const response = await this.options.fetch(url, fetchOptions);

      const { status: $status } = response;

      this.options.logger?.info(
        `[${fetchOptions.method}] ${url} status ${String($status)}`,
        { responseHeaders: response.headers }
      );

      switch ($status) {
        case 200:
          return {
            status: $status,
            body: await response.blob()
          };

        default:
          throw new Error(`Unexpected status ${$status}`);
      }
    } catch (error: unknown) {
      this.options.logger?.error(
        `Error while ${fetchOptions.method}ing from/to ${url}`,
        { error }
      );

      throw error;
    }
  }
}
