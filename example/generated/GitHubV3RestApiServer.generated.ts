import {
  Request,
  Response,
  Express,
  NextFunction,
  ParamsDictionary,
  ErrorRequestHandler
} from 'express-serve-static-core';
import { Router } from 'express';
import { asyncRequestHandler } from '@laurence79/express-async-request-handler';
import { ParsedQs } from 'qs';
import { injectable } from 'tsyringe';
import { Validator, ValidationError } from 'express-json-validator-middleware';

export type Root = {
  readonly current_user_url: string;
  readonly current_user_authorizations_html_url: string;
  readonly authorizations_url: string;
  readonly code_search_url: string;
  readonly commit_search_url: string;
  readonly emails_url: string;
  readonly emojis_url: string;
  readonly events_url: string;
  readonly feeds_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly hub_url: string;
  readonly issue_search_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly label_search_url: string;
  readonly notifications_url: string;
  readonly organization_url: string;
  readonly organization_repositories_url: string;
  readonly organization_teams_url: string;
  readonly public_gists_url: string;
  readonly rate_limit_url: string;
  readonly repository_url: string;
  readonly repository_search_url: string;
  readonly current_user_repositories_url: string;
  readonly starred_url: string;
  readonly starred_gists_url: string;
  readonly topic_search_url?: string;
  readonly user_url: string;
  readonly user_organizations_url: string;
  readonly user_repositories_url: string;
  readonly user_search_url: string;
};

export type MetaRoot200ResponseBody = Root;

export type SimpleUser = {
  readonly name?: string | null;
  readonly email?: string | null;
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly site_admin: boolean;
  readonly starred_at?: string;
} | null;

export type GitHubApp = {
  readonly id: number;
  readonly slug?: string;
  readonly node_id: string;
  readonly owner: SimpleUser;
  readonly name: string;
  readonly description: string | null;
  readonly external_url: string;
  readonly html_url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly permissions: {
    readonly issues?: string;
    readonly checks?: string;
    readonly metadata?: string;
    readonly contents?: string;
    readonly deployments?: string;
  };
  readonly events: ReadonlyArray<string>;
  readonly installations_count?: number;
  readonly client_id?: string;
  readonly client_secret?: string;
  readonly webhook_secret?: string | null;
  readonly pem?: string;
};

export type AppsGetAuthenticated200ResponseBody = GitHubApp;

export type AppsCreateFromManifest201ResponseBody = GitHubApp & {
  readonly client_id: string;
  readonly client_secret: string;
  readonly webhook_secret: string | null;
  readonly pem: string;
};

export type BasicError = {
  readonly message?: string;
  readonly documentation_url?: string;
  readonly url?: string;
  readonly status?: string;
};

export type AppsCreateFromManifest404ResponseBody = BasicError;

export type ValidationErrorSimple = {
  readonly message: string;
  readonly documentation_url: string;
  readonly errors?: ReadonlyArray<string>;
};

export type AppsCreateFromManifest422ResponseBody = ValidationErrorSimple;

export type AppsCreateFromManifestRequestPath = { readonly code: string };

export type WebhookConfigUrl = string;

export type WebhookConfigContentType = string;

export type WebhookConfigSecret = string;

export type WebhookConfigInsecureSsl = string | number;

export type WebhookConfiguration = {
  readonly url?: WebhookConfigUrl;
  readonly content_type?: WebhookConfigContentType;
  readonly secret?: WebhookConfigSecret;
  readonly insecure_ssl?: WebhookConfigInsecureSsl;
};

export type AppsGetWebhookConfigForApp200ResponseBody = WebhookConfiguration;

export type AppsUpdateWebhookConfigForApp200ResponseBody = WebhookConfiguration;

export type AppsUpdateWebhookConfigForAppRequestBody = {
  readonly url?: WebhookConfigUrl;
  readonly content_type?: WebhookConfigContentType;
  readonly secret?: WebhookConfigSecret;
  readonly insecure_ssl?: WebhookConfigInsecureSsl;
};

export type SimpleWebhookDelivery = {
  readonly id: number;
  readonly guid: string;
  readonly delivered_at: string;
  readonly redelivery: boolean;
  readonly duration: number;
  readonly status: string;
  readonly status_code: number;
  readonly event: string;
  readonly action: string | null;
  readonly installation_id: number | null;
  readonly repository_id: number | null;
};

export type AppsListWebhookDeliveries200ResponseBody = ReadonlyArray<SimpleWebhookDelivery>;

export type AppsListWebhookDeliveries400ResponseBody = BasicError;

export type ValidationError = {
  readonly message: string;
  readonly documentation_url: string;
  readonly errors?: ReadonlyArray<{
    readonly resource?: string;
    readonly field?: string;
    readonly message?: string;
    readonly code: string;
    readonly index?: number;
    readonly value?:
      | string
      | null
      | number
      | null
      | ReadonlyArray<string>
      | null;
  }>;
};

export type AppsListWebhookDeliveries422ResponseBody = ValidationError;

export type AppsListWebhookDeliveriesRequestQuery = {
  readonly per_page?: number;
  readonly cursor?: string;
};

export type WebhookDelivery = {
  readonly id: number;
  readonly guid: string;
  readonly delivered_at: string;
  readonly redelivery: boolean;
  readonly duration: number;
  readonly status: string;
  readonly status_code: number;
  readonly event: string;
  readonly action: string | null;
  readonly installation_id: number | null;
  readonly repository_id: number | null;
  readonly url?: string;
  readonly request: {
    readonly headers: unknown | null;
    readonly payload: unknown | null;
  };
  readonly response: {
    readonly headers: unknown | null;
    readonly payload: string | null;
  };
};

export type AppsGetWebhookDelivery200ResponseBody = WebhookDelivery;

export type AppsGetWebhookDelivery400ResponseBody = BasicError;

export type AppsGetWebhookDelivery422ResponseBody = ValidationError;

export type AppsGetWebhookDeliveryRequestPath = {
  readonly delivery_id: number;
};

export type AppsRedeliverWebhookDelivery202ResponseBody = unknown;

export type AppsRedeliverWebhookDelivery400ResponseBody = BasicError;

export type AppsRedeliverWebhookDelivery422ResponseBody = ValidationError;

export type AppsRedeliverWebhookDeliveryRequestPath = {
  readonly delivery_id: number;
};

export type Enterprise = {
  readonly description?: string | null;
  readonly html_url: string;
  readonly website_url?: string | null;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly slug: string;
  readonly created_at: string | null;
  readonly updated_at: string | null;
  readonly avatar_url: string;
};

export type AppPermissions = {
  readonly actions?: 'read' | 'write';
  readonly administration?: 'read' | 'write';
  readonly checks?: 'read' | 'write';
  readonly contents?: 'read' | 'write';
  readonly deployments?: 'read' | 'write';
  readonly environments?: 'read' | 'write';
  readonly issues?: 'read' | 'write';
  readonly metadata?: 'read' | 'write';
  readonly packages?: 'read' | 'write';
  readonly pages?: 'read' | 'write';
  readonly pull_requests?: 'read' | 'write';
  readonly repository_announcement_banners?: 'read' | 'write';
  readonly repository_hooks?: 'read' | 'write';
  readonly repository_projects?: 'read' | 'write' | 'admin';
  readonly secret_scanning_alerts?: 'read' | 'write';
  readonly secrets?: 'read' | 'write';
  readonly security_events?: 'read' | 'write';
  readonly single_file?: 'read' | 'write';
  readonly statuses?: 'read' | 'write';
  readonly vulnerability_alerts?: 'read' | 'write';
  readonly workflows?: 'write';
  readonly members?: 'read' | 'write';
  readonly organization_administration?: 'read' | 'write';
  readonly organization_custom_roles?: 'read' | 'write';
  readonly organization_announcement_banners?: 'read' | 'write';
  readonly organization_hooks?: 'read' | 'write';
  readonly organization_plan?: 'read';
  readonly organization_projects?: 'read' | 'write' | 'admin';
  readonly organization_packages?: 'read' | 'write';
  readonly organization_secrets?: 'read' | 'write';
  readonly organization_self_hosted_runners?: 'read' | 'write';
  readonly organization_user_blocking?: 'read' | 'write';
  readonly team_discussions?: 'read' | 'write';
};

export type Installation = {
  readonly id: number;
  readonly account: SimpleUser | Enterprise | null;
  readonly repository_selection: 'all' | 'selected';
  readonly access_tokens_url: string;
  readonly repositories_url: string;
  readonly html_url: string;
  readonly app_id: number;
  readonly target_id: number;
  readonly target_type: string;
  readonly permissions: AppPermissions;
  readonly events: ReadonlyArray<string>;
  readonly created_at: string;
  readonly updated_at: string;
  readonly single_file_name: string | null;
  readonly has_multiple_single_files?: boolean;
  readonly single_file_paths?: ReadonlyArray<string>;
  readonly app_slug: string;
  readonly suspended_by: SimpleUser;
  readonly suspended_at: string | null;
  readonly contact_email?: string | null;
};

export type AppsListInstallations200ResponseBody = ReadonlyArray<Installation>;

export type AppsListInstallationsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly since?: string;
  readonly outdated?: string;
};

export type AppsGetInstallation200ResponseBody = Installation;

export type AppsGetInstallation404ResponseBody = BasicError;

export type AppsGetInstallationRequestPath = {
  readonly installation_id: number;
};

export type AppsDeleteInstallation404ResponseBody = BasicError;

export type AppsDeleteInstallationRequestPath = {
  readonly installation_id: number;
};

export type LicenseSimple = {
  readonly key: string;
  readonly name: string;
  readonly url: string | null;
  readonly spdx_id: string | null;
  readonly node_id: string;
  readonly html_url?: string;
} | null;

export type Repository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly license: LicenseSimple;
  readonly organization?: SimpleUser;
  readonly forks: number;
  readonly permissions?: {
    readonly admin: boolean;
    readonly pull: boolean;
    readonly triage?: boolean;
    readonly push: boolean;
    readonly maintain?: boolean;
  };
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly git_url: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly ssh_url: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly clone_url: string;
  readonly mirror_url: string | null;
  readonly hooks_url: string;
  readonly svn_url: string;
  readonly homepage: string | null;
  readonly language: string | null;
  readonly forks_count: number;
  readonly stargazers_count: number;
  readonly watchers_count: number;
  readonly size: number;
  readonly default_branch: string;
  readonly open_issues_count: number;
  readonly is_template?: boolean;
  readonly topics?: ReadonlyArray<string>;
  readonly has_issues: boolean;
  readonly has_projects: boolean;
  readonly has_wiki: boolean;
  readonly has_pages: boolean;
  readonly has_downloads: boolean;
  readonly archived: boolean;
  readonly disabled: boolean;
  readonly visibility?: string;
  readonly pushed_at: string | null;
  readonly created_at: string | null;
  readonly updated_at: string | null;
  readonly allow_rebase_merge?: boolean;
  readonly template_repository?: {
    readonly id?: number;
    readonly node_id?: string;
    readonly name?: string;
    readonly full_name?: string;
    readonly owner?: {
      readonly login?: string;
      readonly id?: number;
      readonly node_id?: string;
      readonly avatar_url?: string;
      readonly gravatar_id?: string;
      readonly url?: string;
      readonly html_url?: string;
      readonly followers_url?: string;
      readonly following_url?: string;
      readonly gists_url?: string;
      readonly starred_url?: string;
      readonly subscriptions_url?: string;
      readonly organizations_url?: string;
      readonly repos_url?: string;
      readonly events_url?: string;
      readonly received_events_url?: string;
      readonly type?: string;
      readonly site_admin?: boolean;
    };
    readonly private?: boolean;
    readonly html_url?: string;
    readonly description?: string;
    readonly fork?: boolean;
    readonly url?: string;
    readonly archive_url?: string;
    readonly assignees_url?: string;
    readonly blobs_url?: string;
    readonly branches_url?: string;
    readonly collaborators_url?: string;
    readonly comments_url?: string;
    readonly commits_url?: string;
    readonly compare_url?: string;
    readonly contents_url?: string;
    readonly contributors_url?: string;
    readonly deployments_url?: string;
    readonly downloads_url?: string;
    readonly events_url?: string;
    readonly forks_url?: string;
    readonly git_commits_url?: string;
    readonly git_refs_url?: string;
    readonly git_tags_url?: string;
    readonly git_url?: string;
    readonly issue_comment_url?: string;
    readonly issue_events_url?: string;
    readonly issues_url?: string;
    readonly keys_url?: string;
    readonly labels_url?: string;
    readonly languages_url?: string;
    readonly merges_url?: string;
    readonly milestones_url?: string;
    readonly notifications_url?: string;
    readonly pulls_url?: string;
    readonly releases_url?: string;
    readonly ssh_url?: string;
    readonly stargazers_url?: string;
    readonly statuses_url?: string;
    readonly subscribers_url?: string;
    readonly subscription_url?: string;
    readonly tags_url?: string;
    readonly teams_url?: string;
    readonly trees_url?: string;
    readonly clone_url?: string;
    readonly mirror_url?: string;
    readonly hooks_url?: string;
    readonly svn_url?: string;
    readonly homepage?: string;
    readonly language?: string;
    readonly forks_count?: number;
    readonly stargazers_count?: number;
    readonly watchers_count?: number;
    readonly size?: number;
    readonly default_branch?: string;
    readonly open_issues_count?: number;
    readonly is_template?: boolean;
    readonly topics?: ReadonlyArray<string>;
    readonly has_issues?: boolean;
    readonly has_projects?: boolean;
    readonly has_wiki?: boolean;
    readonly has_pages?: boolean;
    readonly has_downloads?: boolean;
    readonly archived?: boolean;
    readonly disabled?: boolean;
    readonly visibility?: string;
    readonly pushed_at?: string;
    readonly created_at?: string;
    readonly updated_at?: string;
    readonly permissions?: {
      readonly admin?: boolean;
      readonly maintain?: boolean;
      readonly push?: boolean;
      readonly triage?: boolean;
      readonly pull?: boolean;
    };
    readonly allow_rebase_merge?: boolean;
    readonly temp_clone_token?: string;
    readonly allow_squash_merge?: boolean;
    readonly allow_auto_merge?: boolean;
    readonly delete_branch_on_merge?: boolean;
    readonly allow_update_branch?: boolean;
    readonly use_squash_pr_title_as_default?: boolean;
    readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
    readonly squash_merge_commit_message?:
      | 'PR_BODY'
      | 'COMMIT_MESSAGES'
      | 'BLANK';
    readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
    readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
    readonly allow_merge_commit?: boolean;
    readonly subscribers_count?: number;
    readonly network_count?: number;
  } | null;
  readonly temp_clone_token?: string;
  readonly allow_squash_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_update_branch?: boolean;
  readonly use_squash_pr_title_as_default?: boolean;
  readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
  readonly squash_merge_commit_message?:
    | 'PR_BODY'
    | 'COMMIT_MESSAGES'
    | 'BLANK';
  readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
  readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
  readonly allow_merge_commit?: boolean;
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
  readonly subscribers_count?: number;
  readonly network_count?: number;
  readonly open_issues: number;
  readonly watchers: number;
  readonly master_branch?: string;
  readonly starred_at?: string;
  readonly anonymous_access_enabled?: boolean;
};

export type InstallationToken = {
  readonly token: string;
  readonly expires_at: string;
  readonly permissions?: AppPermissions;
  readonly repository_selection?: 'all' | 'selected';
  readonly repositories?: ReadonlyArray<Repository>;
  readonly single_file?: string;
  readonly has_multiple_single_files?: boolean;
  readonly single_file_paths?: ReadonlyArray<string>;
};

export type AppsCreateInstallationAccessToken201ResponseBody = InstallationToken;

export type AppsCreateInstallationAccessToken401ResponseBody = BasicError;

export type AppsCreateInstallationAccessToken403ResponseBody = BasicError;

export type AppsCreateInstallationAccessToken404ResponseBody = BasicError;

export type AppsCreateInstallationAccessToken422ResponseBody = ValidationError;

export type AppsCreateInstallationAccessTokenRequestBody = {
  readonly repositories?: ReadonlyArray<string>;
  readonly repository_ids?: ReadonlyArray<number>;
  readonly permissions?: AppPermissions;
};

export type AppsCreateInstallationAccessTokenRequestPath = {
  readonly installation_id: number;
};

export type AppsSuspendInstallation404ResponseBody = BasicError;

export type AppsSuspendInstallationRequestPath = {
  readonly installation_id: number;
};

export type AppsUnsuspendInstallation404ResponseBody = BasicError;

export type AppsUnsuspendInstallationRequestPath = {
  readonly installation_id: number;
};

export type AppsDeleteAuthorization422ResponseBody = ValidationError;

export type AppsDeleteAuthorizationRequestBody = {
  readonly access_token: string;
};

export type AppsDeleteAuthorizationRequestPath = { readonly client_id: string };

export type ScopedInstallation = {
  readonly permissions: AppPermissions;
  readonly repository_selection: 'all' | 'selected';
  readonly single_file_name: string | null;
  readonly has_multiple_single_files?: boolean;
  readonly single_file_paths?: ReadonlyArray<string>;
  readonly repositories_url: string;
  readonly account: SimpleUser;
} | null;

export type Authorization = {
  readonly id: number;
  readonly url: string;
  readonly scopes: ReadonlyArray<string> | null;
  readonly token: string;
  readonly token_last_eight: string | null;
  readonly hashed_token: string | null;
  readonly app: {
    readonly client_id: string;
    readonly name: string;
    readonly url: string;
  };
  readonly note: string | null;
  readonly note_url: string | null;
  readonly updated_at: string;
  readonly created_at: string;
  readonly fingerprint: string | null;
  readonly user?: SimpleUser;
  readonly installation?: ScopedInstallation;
  readonly expires_at: string | null;
};

export type AppsCheckToken200ResponseBody = Authorization;

export type AppsCheckToken404ResponseBody = BasicError;

export type AppsCheckToken422ResponseBody = ValidationError;

export type AppsCheckTokenRequestBody = { readonly access_token: string };

export type AppsCheckTokenRequestPath = { readonly client_id: string };

export type AppsResetToken200ResponseBody = Authorization;

export type AppsResetToken422ResponseBody = ValidationError;

export type AppsResetTokenRequestBody = { readonly access_token: string };

export type AppsResetTokenRequestPath = { readonly client_id: string };

export type AppsDeleteToken422ResponseBody = ValidationError;

export type AppsDeleteTokenRequestBody = { readonly access_token: string };

export type AppsDeleteTokenRequestPath = { readonly client_id: string };

export type AppsScopeToken200ResponseBody = Authorization;

export type AppsScopeToken401ResponseBody = BasicError;

export type AppsScopeToken403ResponseBody = BasicError;

export type AppsScopeToken404ResponseBody = BasicError;

export type AppsScopeToken422ResponseBody = ValidationError;

export type AppsScopeTokenRequestBody = {
  readonly access_token: string;
  readonly target?: string;
  readonly target_id?: number;
  readonly repositories?: ReadonlyArray<string>;
  readonly repository_ids?: ReadonlyArray<number>;
  readonly permissions?: AppPermissions;
};

export type AppsScopeTokenRequestPath = { readonly client_id: string };

export type AppsGetBySlug200ResponseBody = GitHubApp;

export type AppsGetBySlug403ResponseBody = BasicError;

export type AppsGetBySlug404ResponseBody = BasicError;

export type AppsGetBySlugRequestPath = { readonly app_slug: string };

export type CodeOfConduct = {
  readonly key: string;
  readonly name: string;
  readonly url: string;
  readonly body?: string;
  readonly html_url: string | null;
};

export type CodesOfConductGetAllCodesOfConduct200ResponseBody = ReadonlyArray<CodeOfConduct>;

export type CodesOfConductGetConductCode200ResponseBody = CodeOfConduct;

export type CodesOfConductGetConductCode404ResponseBody = BasicError;

export type CodesOfConductGetConductCodeRequestPath = { readonly key: string };

export type EmojisGet200ResponseBody = unknown;

export type ServerStatisticsProxyEndpoint = ReadonlyArray<{
  readonly server_id?: string;
  readonly collection_date?: string;
  readonly schema_version?: string;
  readonly ghes_version?: string;
  readonly host_name?: string;
  readonly github_connect?: {
    readonly features_enabled?: ReadonlyArray<string>;
  };
  readonly ghe_stats?: {
    readonly comments?: {
      readonly total_commit_comments?: number;
      readonly total_gist_comments?: number;
      readonly total_issue_comments?: number;
      readonly total_pull_request_comments?: number;
    };
    readonly gists?: {
      readonly total_gists?: number;
      readonly private_gists?: number;
      readonly public_gists?: number;
    };
    readonly hooks?: {
      readonly total_hooks?: number;
      readonly active_hooks?: number;
      readonly inactive_hooks?: number;
    };
    readonly issues?: {
      readonly total_issues?: number;
      readonly open_issues?: number;
      readonly closed_issues?: number;
    };
    readonly milestones?: {
      readonly total_milestones?: number;
      readonly open_milestones?: number;
      readonly closed_milestones?: number;
    };
    readonly orgs?: {
      readonly total_orgs?: number;
      readonly disabled_orgs?: number;
      readonly total_teams?: number;
      readonly total_team_members?: number;
    };
    readonly pages?: { readonly total_pages?: number };
    readonly pulls?: {
      readonly total_pulls?: number;
      readonly merged_pulls?: number;
      readonly mergeable_pulls?: number;
      readonly unmergeable_pulls?: number;
    };
    readonly repos?: {
      readonly total_repos?: number;
      readonly root_repos?: number;
      readonly fork_repos?: number;
      readonly org_repos?: number;
      readonly total_pushes?: number;
      readonly total_wikis?: number;
    };
    readonly users?: {
      readonly total_users?: number;
      readonly admin_users?: number;
      readonly suspended_users?: number;
    };
  };
  readonly dormant_users?: {
    readonly total_dormant_users?: number;
    readonly dormancy_threshold?: string;
  };
}>;

export type EnterpriseAdminGetServerStatistics200ResponseBody = ServerStatisticsProxyEndpoint;

export type EnterpriseAdminGetServerStatisticsRequestQuery = {
  readonly date_start?: string;
  readonly date_end?: string;
};

export type EnterpriseAdminGetServerStatisticsRequestPath = {
  readonly enterprise_or_org: string;
};

export type ActionsCacheUsageOrgEnterprise = {
  readonly total_active_caches_count: number;
  readonly total_active_caches_size_in_bytes: number;
};

export type ActionsGetActionsCacheUsageForEnterprise200ResponseBody = ActionsCacheUsageOrgEnterprise;

export type ActionsGetActionsCacheUsageForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnabledOrganizations = 'all' | 'none' | 'selected';

export type AllowedActions = 'all' | 'local_only' | 'selected';

export type SelectedActionsUrl = string;

export type ActionsEnterprisePermissions = {
  readonly enabled_organizations: EnabledOrganizations;
  readonly selected_organizations_url?: string;
  readonly allowed_actions?: AllowedActions;
  readonly selected_actions_url?: SelectedActionsUrl;
};

export type EnterpriseAdminGetGithubActionsPermissionsEnterprise200ResponseBody = ActionsEnterprisePermissions;

export type EnterpriseAdminGetGithubActionsPermissionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequestBody = {
  readonly enabled_organizations: EnabledOrganizations;
  readonly allowed_actions?: AllowedActions;
};

export type EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type OrganizationSimple = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly hooks_url: string;
  readonly issues_url: string;
  readonly members_url: string;
  readonly public_members_url: string;
  readonly avatar_url: string;
  readonly description: string | null;
};

export type EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly organizations: ReadonlyArray<OrganizationSimple>;
};

export type EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequestBody = {
  readonly selected_organization_ids: ReadonlyArray<number>;
};

export type EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly org_id: number;
};

export type EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly org_id: number;
};

export type SelectedActions = {
  readonly github_owned_allowed?: boolean;
  readonly verified_allowed?: boolean;
  readonly patterns_allowed?: ReadonlyArray<string>;
};

export type EnterpriseAdminGetAllowedActionsEnterprise200ResponseBody = SelectedActions;

export type EnterpriseAdminGetAllowedActionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminSetAllowedActionsEnterpriseRequestBody = SelectedActions;

export type EnterpriseAdminSetAllowedActionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type ActionsDefaultWorkflowPermissions = 'read' | 'write';

export type ActionsCanApprovePullRequestReviews = boolean;

export type ActionsGetDefaultWorkflowPermissions = {
  readonly default_workflow_permissions: ActionsDefaultWorkflowPermissions;
  readonly can_approve_pull_request_reviews: ActionsCanApprovePullRequestReviews;
};

export type ActionsGetGithubActionsDefaultWorkflowPermissionsEnterprise200ResponseBody = ActionsGetDefaultWorkflowPermissions;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type ActionsSetDefaultWorkflowPermissions = {
  readonly default_workflow_permissions?: ActionsDefaultWorkflowPermissions;
  readonly can_approve_pull_request_reviews?: ActionsCanApprovePullRequestReviews;
};

export type ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestBody = ActionsSetDefaultWorkflowPermissions;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type RunnerGroupsEnterprise = {
  readonly id: number;
  readonly name: string;
  readonly visibility: string;
  readonly default: boolean;
  readonly selected_organizations_url?: string;
  readonly runners_url: string;
  readonly allows_public_repositories: boolean;
  readonly workflow_restrictions_read_only?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly runner_groups: ReadonlyArray<RunnerGroupsEnterprise>;
};

export type EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly visible_to_organization?: string;
};

export type EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise201ResponseBody = RunnerGroupsEnterprise;

export type EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequestBody = {
  readonly name: string;
  readonly visibility?: 'selected' | 'all';
  readonly selected_organization_ids?: ReadonlyArray<number>;
  readonly runners?: ReadonlyArray<number>;
  readonly allows_public_repositories?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise200ResponseBody = RunnerGroupsEnterprise;

export type EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise200ResponseBody = RunnerGroupsEnterprise;

export type EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequestBody = {
  readonly name?: string;
  readonly visibility?: 'selected' | 'all';
  readonly allows_public_repositories?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly organizations: ReadonlyArray<OrganizationSimple>;
};

export type EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestBody = {
  readonly selected_organization_ids: ReadonlyArray<number>;
};

export type EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
  readonly org_id: number;
};

export type EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
  readonly org_id: number;
};

export type SelfHostedRunnerLabel = {
  readonly id?: number;
  readonly name: string;
  readonly type?: 'read-only' | 'custom';
};

export type SelfHostedRunners = {
  readonly id: number;
  readonly name: string;
  readonly os: string;
  readonly status: string;
  readonly busy: boolean;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly runners: ReadonlyArray<SelfHostedRunners>;
};

export type EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequestBody = {
  readonly runners: ReadonlyArray<number>;
};

export type EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
};

export type EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
  readonly runner_id: number;
};

export type EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_group_id: number;
  readonly runner_id: number;
};

export type EnterpriseAdminListSelfHostedRunnersForEnterprise200ResponseBody = {
  readonly total_count?: number;
  readonly runners?: ReadonlyArray<SelfHostedRunners>;
};

export type EnterpriseAdminListSelfHostedRunnersForEnterpriseRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type EnterpriseAdminListSelfHostedRunnersForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type RunnerApplication = {
  readonly os: string;
  readonly architecture: string;
  readonly download_url: string;
  readonly filename: string;
  readonly temp_download_token?: string;
  readonly sha256_checksum?: string;
};

export type EnterpriseAdminListRunnerApplicationsForEnterprise200ResponseBody = ReadonlyArray<RunnerApplication>;

export type EnterpriseAdminListRunnerApplicationsForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type AuthenticationToken = {
  readonly token: string;
  readonly expires_at: string;
  readonly permissions?: unknown;
  readonly repositories?: ReadonlyArray<Repository>;
  readonly single_file?: string | null;
  readonly repository_selection?: 'all' | 'selected';
};

export type EnterpriseAdminCreateRegistrationTokenForEnterprise201ResponseBody = AuthenticationToken;

export type EnterpriseAdminCreateRegistrationTokenForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminCreateRemoveTokenForEnterprise201ResponseBody = AuthenticationToken;

export type EnterpriseAdminCreateRemoveTokenForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type EnterpriseAdminGetSelfHostedRunnerForEnterprise200ResponseBody = SelfHostedRunners;

export type EnterpriseAdminGetSelfHostedRunnerForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
};

export type EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
};

export type EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise404ResponseBody = BasicError;

export type EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
};

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise404ResponseBody = BasicError;

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise422ResponseBody = ValidationErrorSimple;

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequestBody = {
  readonly labels: ReadonlyArray<string>;
};

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
};

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise404ResponseBody = BasicError;

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise422ResponseBody = ValidationErrorSimple;

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequestBody = {
  readonly labels: ReadonlyArray<string>;
};

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
};

export type EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise404ResponseBody = BasicError;

export type EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise422ResponseBody = ValidationErrorSimple;

export type EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
};

export type EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise404ResponseBody = BasicError;

export type EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise422ResponseBody = ValidationErrorSimple;

export type EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseRequestPath = {
  readonly enterprise: string;
  readonly runner_id: number;
  readonly name: string;
};

export type AlertNumber = number;

export type AlertCreatedAt = string;

export type AlertUpdatedAt = string;

export type AlertUrl = string;

export type AlertHtmlUrl = string;

export type AlertInstancesUrl = string;

export type CodeScanningAlertState = 'open' | 'closed' | 'dismissed' | 'fixed';

export type AlertFixedAt = string | null;

export type AlertDismissedAt = string | null;

export type CodeScanningAlertDismissedReason =
  | null
  | 'false positive'
  | "won't fix"
  | 'used in tests'
  | null;

export type CodeScanningAlertDismissedComment = string | null;

export type CodeScanningAlertRule = {
  readonly id?: string | null;
  readonly name?: string;
  readonly severity?: 'none' | 'note' | 'warning' | 'error' | null;
  readonly security_severity_level?:
    | 'low'
    | 'medium'
    | 'high'
    | 'critical'
    | null;
  readonly description?: string;
  readonly full_description?: string;
  readonly tags?: ReadonlyArray<string> | null;
  readonly help?: string | null;
  readonly help_uri?: string | null;
};

export type CodeScanningAnalysisToolName = string;

export type CodeScanningAnalysisToolVersion = string | null;

export type CodeScanningAnalysisToolGuid = string | null;

export type CodeScanningAnalysisTool = {
  readonly name?: CodeScanningAnalysisToolName;
  readonly version?: CodeScanningAnalysisToolVersion;
  readonly guid?: CodeScanningAnalysisToolGuid;
};

export type CodeScanningRef = string;

export type CodeScanningAnalysisAnalysisKey = string;

export type CodeScanningAlertEnvironment = string;

export type CodeScanningAnalysisCategory = string;

export type CodeScanningAlertLocation = {
  readonly path?: string;
  readonly start_line?: number;
  readonly end_line?: number;
  readonly start_column?: number;
  readonly end_column?: number;
};

export type CodeScanningAlertClassification =
  | 'source'
  | 'generated'
  | 'test'
  | 'library'
  | null;

export type CodeScanningAlertInstance = {
  readonly ref?: CodeScanningRef;
  readonly analysis_key?: CodeScanningAnalysisAnalysisKey;
  readonly environment?: CodeScanningAlertEnvironment;
  readonly category?: CodeScanningAnalysisCategory;
  readonly state?: CodeScanningAlertState;
  readonly commit_sha?: string;
  readonly message?: { readonly text?: string };
  readonly location?: CodeScanningAlertLocation;
  readonly html_url?: string;
  readonly classifications?: ReadonlyArray<CodeScanningAlertClassification>;
};

export type SimpleRepository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly hooks_url: string;
};

export type CodeScanningOrganizationAlertItems = {
  readonly number: AlertNumber;
  readonly created_at: AlertCreatedAt;
  readonly updated_at?: AlertUpdatedAt;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly instances_url: AlertInstancesUrl;
  readonly state: CodeScanningAlertState;
  readonly fixed_at?: AlertFixedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_reason: CodeScanningAlertDismissedReason;
  readonly dismissed_comment?: CodeScanningAlertDismissedComment;
  readonly rule: CodeScanningAlertRule;
  readonly tool: CodeScanningAnalysisTool;
  readonly most_recent_instance: CodeScanningAlertInstance;
  readonly repository: SimpleRepository;
};

export type CodeScanningListAlertsForEnterprise200ResponseBody = ReadonlyArray<CodeScanningOrganizationAlertItems>;

export type CodeScanningListAlertsForEnterprise404ResponseBody = BasicError;

export type CodeScanningListAlertsForEnterprise503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningListAlertsForEnterpriseRequestQuery = {
  readonly tool_name?: CodeScanningAnalysisToolName;
  readonly tool_guid?: CodeScanningAnalysisToolGuid;
  readonly before?: string;
  readonly after?: string;
  readonly page?: number;
  readonly per_page?: number;
  readonly direction?: 'asc' | 'desc';
  readonly state?: CodeScanningAlertState;
  readonly sort?: 'created' | 'updated';
};

export type CodeScanningListAlertsForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type NullableAlertUpdatedAt = string | null;

export type SecretScanningAlertState = 'open' | 'resolved';

export type SecretScanningAlertResolution =
  | null
  | 'false_positive'
  | 'wont_fix'
  | 'revoked'
  | 'used_in_tests'
  | null;

export type OrganizationSecretScanningAlert = {
  readonly number?: AlertNumber;
  readonly created_at?: AlertCreatedAt;
  readonly updated_at?: NullableAlertUpdatedAt;
  readonly url?: AlertUrl;
  readonly html_url?: AlertHtmlUrl;
  readonly locations_url?: string;
  readonly state?: SecretScanningAlertState;
  readonly resolution?: SecretScanningAlertResolution;
  readonly resolved_at?: string | null;
  readonly resolved_by?: SimpleUser;
  readonly secret_type?: string;
  readonly secret_type_display_name?: string;
  readonly secret?: string;
  readonly repository?: SimpleRepository;
  readonly push_protection_bypassed?: boolean | null;
  readonly push_protection_bypassed_by?: SimpleUser;
  readonly push_protection_bypassed_at?: string | null;
  readonly resolution_comment?: string | null;
};

export type SecretScanningListAlertsForEnterprise200ResponseBody = ReadonlyArray<OrganizationSecretScanningAlert>;

export type SecretScanningListAlertsForEnterprise404ResponseBody = BasicError;

export type SecretScanningListAlertsForEnterprise503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SecretScanningListAlertsForEnterpriseRequestQuery = {
  readonly state?: 'open' | 'resolved';
  readonly secret_type?: string;
  readonly resolution?: string;
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly before?: string;
  readonly after?: string;
};

export type SecretScanningListAlertsForEnterpriseRequestPath = {
  readonly enterprise: string;
};

export type AdvancedSecurityActiveCommittersUser = {
  readonly user_login: string;
  readonly last_pushed_date: string;
};

export type AdvancedSecurityActiveCommittersRepository = {
  readonly name: string;
  readonly advanced_security_committers: number;
  readonly advanced_security_committers_breakdown: ReadonlyArray<AdvancedSecurityActiveCommittersUser>;
};

export type AdvancedSecurityActiveCommitters = {
  readonly total_advanced_security_committers?: number;
  readonly total_count?: number;
  readonly repositories: ReadonlyArray<AdvancedSecurityActiveCommittersRepository>;
};

export type BillingGetGithubAdvancedSecurityBillingGhe200ResponseBody = AdvancedSecurityActiveCommitters;

export type BillingGetGithubAdvancedSecurityBillingGhe403ResponseBody = BasicError;

export type BillingGetGithubAdvancedSecurityBillingGheRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type BillingGetGithubAdvancedSecurityBillingGheRequestPath = {
  readonly enterprise: string;
};

export type Actor = {
  readonly id: number;
  readonly login: string;
  readonly display_login?: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly avatar_url: string;
};

export type Milestone = {
  readonly url: string;
  readonly html_url: string;
  readonly labels_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly number: number;
  readonly state: 'open' | 'closed';
  readonly title: string;
  readonly description: string | null;
  readonly creator: SimpleUser;
  readonly open_issues: number;
  readonly closed_issues: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly closed_at: string | null;
  readonly due_on: string | null;
} | null;

export type AuthorAssociation =
  | 'COLLABORATOR'
  | 'CONTRIBUTOR'
  | 'FIRST_TIMER'
  | 'FIRST_TIME_CONTRIBUTOR'
  | 'MANNEQUIN'
  | 'MEMBER'
  | 'NONE'
  | 'OWNER';

export type ReactionRollup = {
  readonly url: string;
  readonly total_count: number;
  readonly '+1': number;
  readonly '-1': number;
  readonly laugh: number;
  readonly confused: number;
  readonly heart: number;
  readonly hooray: number;
  readonly eyes: number;
  readonly rocket: number;
};

export type Issue = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly repository_url: string;
  readonly labels_url: string;
  readonly comments_url: string;
  readonly events_url: string;
  readonly html_url: string;
  readonly number: number;
  readonly state: string;
  readonly state_reason?: 'completed' | 'reopened' | 'not_planned' | null;
  readonly title: string;
  readonly body?: string | null;
  readonly user: SimpleUser;
  readonly labels: ReadonlyArray<
    | string
    | {
        readonly id?: number;
        readonly node_id?: string;
        readonly url?: string;
        readonly name?: string;
        readonly description?: string | null;
        readonly color?: string | null;
        readonly default?: boolean;
      }
  >;
  readonly assignee: SimpleUser;
  readonly assignees?: ReadonlyArray<SimpleUser> | null;
  readonly milestone: Milestone;
  readonly locked: boolean;
  readonly active_lock_reason?: string | null;
  readonly comments: number;
  readonly pull_request?: {
    readonly merged_at?: string | null;
    readonly diff_url: string | null;
    readonly html_url: string | null;
    readonly patch_url: string | null;
    readonly url: string | null;
  };
  readonly closed_at: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly draft?: boolean;
  readonly closed_by?: SimpleUser;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly timeline_url?: string;
  readonly repository?: Repository;
  readonly performed_via_github_app?: GitHubApp;
  readonly author_association: AuthorAssociation;
  readonly reactions?: ReactionRollup;
};

export type IssueComment = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly body?: string;
  readonly body_text?: string;
  readonly body_html?: string;
  readonly html_url: string;
  readonly user: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly issue_url: string;
  readonly author_association: AuthorAssociation;
  readonly performed_via_github_app?: GitHubApp;
  readonly reactions?: ReactionRollup;
};

export type Event = {
  readonly id: string;
  readonly type: string | null;
  readonly actor: Actor;
  readonly repo: {
    readonly id: number;
    readonly name: string;
    readonly url: string;
  };
  readonly org?: Actor;
  readonly payload: {
    readonly action?: string;
    readonly issue?: Issue;
    readonly comment?: IssueComment;
    readonly pages?: ReadonlyArray<{
      readonly page_name?: string;
      readonly title?: string;
      readonly summary?: string | null;
      readonly action?: string;
      readonly sha?: string;
      readonly html_url?: string;
    }>;
  };
  readonly public: boolean;
  readonly created_at: string | null;
};

export type ActivityListPublicEvents200ResponseBody = ReadonlyArray<Event>;

export type ActivityListPublicEvents403ResponseBody = BasicError;

export type ActivityListPublicEvents503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type ActivityListPublicEventsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type LinkWithType = { readonly href: string; readonly type: string };

export type Feed = {
  readonly timeline_url: string;
  readonly user_url: string;
  readonly current_user_public_url?: string;
  readonly current_user_url?: string;
  readonly current_user_actor_url?: string;
  readonly current_user_organization_url?: string;
  readonly current_user_organization_urls?: ReadonlyArray<string>;
  readonly security_advisories_url?: string;
  readonly _links: {
    readonly timeline: LinkWithType;
    readonly user: LinkWithType;
    readonly security_advisories?: LinkWithType;
    readonly current_user?: LinkWithType;
    readonly current_user_public?: LinkWithType;
    readonly current_user_actor?: LinkWithType;
    readonly current_user_organization?: LinkWithType;
    readonly current_user_organizations?: ReadonlyArray<LinkWithType>;
  };
};

export type ActivityGetFeeds200ResponseBody = Feed;

export type BaseGist = {
  readonly url: string;
  readonly forks_url: string;
  readonly commits_url: string;
  readonly id: string;
  readonly node_id: string;
  readonly git_pull_url: string;
  readonly git_push_url: string;
  readonly html_url: string;
  readonly files: unknown;
  readonly public: boolean;
  readonly created_at: string;
  readonly updated_at: string;
  readonly description: string | null;
  readonly comments: number;
  readonly user: SimpleUser;
  readonly comments_url: string;
  readonly owner?: SimpleUser;
  readonly truncated?: boolean;
  readonly forks?: ReadonlyArray<unknown>;
  readonly history?: ReadonlyArray<unknown>;
};

export type GistsList200ResponseBody = ReadonlyArray<BaseGist>;

export type GistsList403ResponseBody = BasicError;

export type GistsListRequestQuery = {
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type PublicUser = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly site_admin: boolean;
  readonly name: string | null;
  readonly company: string | null;
  readonly blog: string | null;
  readonly location: string | null;
  readonly email: string | null;
  readonly hireable: boolean | null;
  readonly bio: string | null;
  readonly twitter_username?: string | null;
  readonly public_repos: number;
  readonly public_gists: number;
  readonly followers: number;
  readonly following: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly plan?: {
    readonly collaborators: number;
    readonly name: string;
    readonly space: number;
    readonly private_repos: number;
  };
  readonly suspended_at?: string | null;
  readonly private_gists?: number;
  readonly total_private_repos?: number;
  readonly owned_private_repos?: number;
  readonly disk_usage?: number;
  readonly collaborators?: number;
};

export type GistHistory = {
  readonly user?: SimpleUser;
  readonly version?: string;
  readonly committed_at?: string;
  readonly change_status?: {
    readonly total?: number;
    readonly additions?: number;
    readonly deletions?: number;
  };
  readonly url?: string;
};

export type Gist = {
  readonly url: string;
  readonly forks_url: string;
  readonly commits_url: string;
  readonly id: string;
  readonly node_id: string;
  readonly git_pull_url: string;
  readonly git_push_url: string;
  readonly html_url: string;
  readonly files: unknown;
  readonly public: boolean;
  readonly created_at: string;
  readonly updated_at: string;
  readonly description: string | null;
  readonly comments: number;
  readonly user: SimpleUser;
  readonly comments_url: string;
  readonly owner?: SimpleUser;
  readonly truncated?: boolean;
  readonly forks?: ReadonlyArray<unknown>;
  readonly history?: ReadonlyArray<unknown>;
} | null;

export type GistSimple = {
  readonly forks?: ReadonlyArray<{
    readonly id?: string;
    readonly url?: string;
    readonly user?: PublicUser;
    readonly created_at?: string;
    readonly updated_at?: string;
  }> | null;
  readonly history?: ReadonlyArray<GistHistory> | null;
  readonly fork_of?: Gist;
  readonly url?: string;
  readonly forks_url?: string;
  readonly commits_url?: string;
  readonly id?: string;
  readonly node_id?: string;
  readonly git_pull_url?: string;
  readonly git_push_url?: string;
  readonly html_url?: string;
  readonly files?: unknown;
  readonly public?: boolean;
  readonly created_at?: string;
  readonly updated_at?: string;
  readonly description?: string | null;
  readonly comments?: number;
  readonly user?: string | null;
  readonly comments_url?: string;
  readonly owner?: SimpleUser;
  readonly truncated?: boolean;
};

export type GistsCreate201ResponseBody = GistSimple;

export type GistsCreate403ResponseBody = BasicError;

export type GistsCreate404ResponseBody = BasicError;

export type GistsCreate422ResponseBody = ValidationError;

export type GistsCreateRequestBody = {
  readonly description?: string;
  readonly files: unknown;
  readonly public?: boolean | 'true' | 'false';
};

export type GistsListPublic200ResponseBody = ReadonlyArray<BaseGist>;

export type GistsListPublic403ResponseBody = BasicError;

export type GistsListPublic422ResponseBody = ValidationError;

export type GistsListPublicRequestQuery = {
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type GistsListStarred200ResponseBody = ReadonlyArray<BaseGist>;

export type GistsListStarred401ResponseBody = BasicError;

export type GistsListStarred403ResponseBody = BasicError;

export type GistsListStarredRequestQuery = {
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type GistsGet200ResponseBody = GistSimple;

export type GistsGet403ResponseBody = {
  readonly block?: {
    readonly reason?: string;
    readonly created_at?: string;
    readonly html_url?: string | null;
  };
  readonly message?: string;
  readonly documentation_url?: string;
};

export type GistsGet404ResponseBody = BasicError;

export type GistsGetRequestPath = { readonly gist_id: string };

export type GistsUpdate200ResponseBody = GistSimple;

export type GistsUpdate404ResponseBody = BasicError;

export type GistsUpdate422ResponseBody = ValidationError;

export type GistsUpdateRequestBody =
  | ({ readonly description?: string; readonly files?: unknown } & (
      | unknown
      | unknown
    ))
  | null;

export type GistsUpdateRequestPath = { readonly gist_id: string };

export type GistsDelete403ResponseBody = BasicError;

export type GistsDelete404ResponseBody = BasicError;

export type GistsDeleteRequestPath = { readonly gist_id: string };

export type GistComment = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly body: string;
  readonly user: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly author_association: AuthorAssociation;
};

export type GistsListComments200ResponseBody = ReadonlyArray<GistComment>;

export type GistsListComments403ResponseBody = BasicError;

export type GistsListComments404ResponseBody = BasicError;

export type GistsListCommentsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type GistsListCommentsRequestPath = { readonly gist_id: string };

export type GistsCreateComment201ResponseBody = GistComment;

export type GistsCreateComment403ResponseBody = BasicError;

export type GistsCreateComment404ResponseBody = BasicError;

export type GistsCreateCommentRequestBody = { readonly body: string };

export type GistsCreateCommentRequestPath = { readonly gist_id: string };

export type GistsGetComment200ResponseBody = GistComment;

export type GistsGetComment403ResponseBody = {
  readonly block?: {
    readonly reason?: string;
    readonly created_at?: string;
    readonly html_url?: string | null;
  };
  readonly message?: string;
  readonly documentation_url?: string;
};

export type GistsGetComment404ResponseBody = BasicError;

export type GistsGetCommentRequestPath = {
  readonly gist_id: string;
  readonly comment_id: number;
};

export type GistsUpdateComment200ResponseBody = GistComment;

export type GistsUpdateComment404ResponseBody = BasicError;

export type GistsUpdateCommentRequestBody = { readonly body: string };

export type GistsUpdateCommentRequestPath = {
  readonly gist_id: string;
  readonly comment_id: number;
};

export type GistsDeleteComment403ResponseBody = BasicError;

export type GistsDeleteComment404ResponseBody = BasicError;

export type GistsDeleteCommentRequestPath = {
  readonly gist_id: string;
  readonly comment_id: number;
};

export type GistCommit = {
  readonly url: string;
  readonly version: string;
  readonly user: SimpleUser;
  readonly change_status: {
    readonly total?: number;
    readonly additions?: number;
    readonly deletions?: number;
  };
  readonly committed_at: string;
};

export type GistsListCommits200ResponseBody = ReadonlyArray<GistCommit>;

export type GistsListCommits403ResponseBody = BasicError;

export type GistsListCommits404ResponseBody = BasicError;

export type GistsListCommitsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type GistsListCommitsRequestPath = { readonly gist_id: string };

export type GistsListForks200ResponseBody = ReadonlyArray<GistSimple>;

export type GistsListForks403ResponseBody = BasicError;

export type GistsListForks404ResponseBody = BasicError;

export type GistsListForksRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type GistsListForksRequestPath = { readonly gist_id: string };

export type GistsFork201ResponseBody = BaseGist;

export type GistsFork403ResponseBody = BasicError;

export type GistsFork404ResponseBody = BasicError;

export type GistsFork422ResponseBody = ValidationError;

export type GistsForkRequestPath = { readonly gist_id: string };

export type GistsCheckIsStarred403ResponseBody = BasicError;

export type GistsCheckIsStarred404ResponseBody = {};

export type GistsCheckIsStarredRequestPath = { readonly gist_id: string };

export type GistsStar403ResponseBody = BasicError;

export type GistsStar404ResponseBody = BasicError;

export type GistsStarRequestPath = { readonly gist_id: string };

export type GistsUnstar403ResponseBody = BasicError;

export type GistsUnstar404ResponseBody = BasicError;

export type GistsUnstarRequestPath = { readonly gist_id: string };

export type GistsGetRevision200ResponseBody = GistSimple;

export type GistsGetRevision403ResponseBody = BasicError;

export type GistsGetRevision404ResponseBody = BasicError;

export type GistsGetRevision422ResponseBody = ValidationError;

export type GistsGetRevisionRequestPath = {
  readonly gist_id: string;
  readonly sha: string;
};

export type GitignoreGetAllTemplates200ResponseBody = ReadonlyArray<string>;

export type GitignoreTemplate = {
  readonly name: string;
  readonly source: string;
};

export type GitignoreGetTemplate200ResponseBody = GitignoreTemplate;

export type GitignoreGetTemplateRequestPath = { readonly name: string };

export type AppsListReposAccessibleToInstallation200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<Repository>;
  readonly repository_selection?: string;
};

export type AppsListReposAccessibleToInstallation401ResponseBody = BasicError;

export type AppsListReposAccessibleToInstallation403ResponseBody = BasicError;

export type AppsListReposAccessibleToInstallationRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesList200ResponseBody = ReadonlyArray<Issue>;

export type IssuesList404ResponseBody = BasicError;

export type IssuesList422ResponseBody = ValidationError;

export type IssuesListRequestQuery = {
  readonly filter?:
    | 'assigned'
    | 'created'
    | 'mentioned'
    | 'subscribed'
    | 'repos'
    | 'all';
  readonly state?: 'open' | 'closed' | 'all';
  readonly labels?: string;
  readonly sort?: 'created' | 'updated' | 'comments';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly collab?: boolean;
  readonly orgs?: boolean;
  readonly owned?: boolean;
  readonly pulls?: boolean;
  readonly per_page?: number;
  readonly page?: number;
};

export type LicensesGetAllCommonlyUsed200ResponseBody = ReadonlyArray<LicenseSimple>;

export type LicensesGetAllCommonlyUsedRequestQuery = {
  readonly featured?: boolean;
  readonly per_page?: number;
  readonly page?: number;
};

export type License = {
  readonly key: string;
  readonly name: string;
  readonly spdx_id: string | null;
  readonly url: string | null;
  readonly node_id: string;
  readonly html_url: string;
  readonly description: string;
  readonly implementation: string;
  readonly permissions: ReadonlyArray<string>;
  readonly conditions: ReadonlyArray<string>;
  readonly limitations: ReadonlyArray<string>;
  readonly body: string;
  readonly featured: boolean;
};

export type LicensesGet200ResponseBody = License;

export type LicensesGet403ResponseBody = BasicError;

export type LicensesGet404ResponseBody = BasicError;

export type LicensesGetRequestPath = { readonly license: string };

export type MarkdownRenderRequestBody = {
  readonly text: string;
  readonly mode?: 'markdown' | 'gfm';
  readonly context?: string;
};

export type MarketplaceListingPlan = {
  readonly url: string;
  readonly accounts_url: string;
  readonly id: number;
  readonly number: number;
  readonly name: string;
  readonly description: string;
  readonly monthly_price_in_cents: number;
  readonly yearly_price_in_cents: number;
  readonly price_model: string;
  readonly has_free_trial: boolean;
  readonly unit_name: string | null;
  readonly state: string;
  readonly bullets: ReadonlyArray<string>;
};

export type MarketplacePurchase = {
  readonly url: string;
  readonly type: string;
  readonly id: number;
  readonly login: string;
  readonly organization_billing_email?: string;
  readonly email?: string | null;
  readonly marketplace_pending_change?: {
    readonly is_installed?: boolean;
    readonly effective_date?: string;
    readonly unit_count?: number | null;
    readonly id?: number;
    readonly plan?: MarketplaceListingPlan;
  } | null;
  readonly marketplace_purchase: {
    readonly billing_cycle?: string;
    readonly next_billing_date?: string | null;
    readonly is_installed?: boolean;
    readonly unit_count?: number | null;
    readonly on_free_trial?: boolean;
    readonly free_trial_ends_on?: string | null;
    readonly updated_at?: string;
    readonly plan?: MarketplaceListingPlan;
  };
};

export type AppsGetSubscriptionPlanForAccount200ResponseBody = MarketplacePurchase;

export type AppsGetSubscriptionPlanForAccount401ResponseBody = BasicError;

export type AppsGetSubscriptionPlanForAccount404ResponseBody = BasicError;

export type AppsGetSubscriptionPlanForAccountRequestPath = {
  readonly account_id: number;
};

export type AppsListPlans200ResponseBody = ReadonlyArray<MarketplaceListingPlan>;

export type AppsListPlans401ResponseBody = BasicError;

export type AppsListPlans404ResponseBody = BasicError;

export type AppsListPlansRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListAccountsForPlan200ResponseBody = ReadonlyArray<MarketplacePurchase>;

export type AppsListAccountsForPlan401ResponseBody = BasicError;

export type AppsListAccountsForPlan404ResponseBody = BasicError;

export type AppsListAccountsForPlan422ResponseBody = ValidationError;

export type AppsListAccountsForPlanRequestQuery = {
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListAccountsForPlanRequestPath = { readonly plan_id: number };

export type AppsGetSubscriptionPlanForAccountStubbed200ResponseBody = MarketplacePurchase;

export type AppsGetSubscriptionPlanForAccountStubbed401ResponseBody = BasicError;

export type AppsGetSubscriptionPlanForAccountStubbedRequestPath = {
  readonly account_id: number;
};

export type AppsListPlansStubbed200ResponseBody = ReadonlyArray<MarketplaceListingPlan>;

export type AppsListPlansStubbed401ResponseBody = BasicError;

export type AppsListPlansStubbedRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListAccountsForPlanStubbed200ResponseBody = ReadonlyArray<MarketplacePurchase>;

export type AppsListAccountsForPlanStubbed401ResponseBody = BasicError;

export type AppsListAccountsForPlanStubbedRequestQuery = {
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListAccountsForPlanStubbedRequestPath = {
  readonly plan_id: number;
};

export type ApiOverview = {
  readonly verifiable_password_authentication: boolean;
  readonly ssh_key_fingerprints?: {
    readonly SHA256_RSA?: string;
    readonly SHA256_DSA?: string;
    readonly SHA256_ECDSA?: string;
    readonly SHA256_ED25519?: string;
  };
  readonly ssh_keys?: ReadonlyArray<string>;
  readonly hooks?: ReadonlyArray<string>;
  readonly web?: ReadonlyArray<string>;
  readonly api?: ReadonlyArray<string>;
  readonly git?: ReadonlyArray<string>;
  readonly packages?: ReadonlyArray<string>;
  readonly pages?: ReadonlyArray<string>;
  readonly importer?: ReadonlyArray<string>;
  readonly actions?: ReadonlyArray<string>;
  readonly dependabot?: ReadonlyArray<string>;
};

export type MetaGet200ResponseBody = ApiOverview;

export type ActivityListPublicEventsForRepoNetwork200ResponseBody = ReadonlyArray<Event>;

export type ActivityListPublicEventsForRepoNetwork301ResponseBody = BasicError;

export type ActivityListPublicEventsForRepoNetwork403ResponseBody = BasicError;

export type ActivityListPublicEventsForRepoNetwork404ResponseBody = BasicError;

export type ActivityListPublicEventsForRepoNetworkRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListPublicEventsForRepoNetworkRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MinimalRepository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly git_url?: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly ssh_url?: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly clone_url?: string;
  readonly mirror_url?: string | null;
  readonly hooks_url: string;
  readonly svn_url?: string;
  readonly homepage?: string | null;
  readonly language?: string | null;
  readonly forks_count?: number;
  readonly stargazers_count?: number;
  readonly watchers_count?: number;
  readonly size?: number;
  readonly default_branch?: string;
  readonly open_issues_count?: number;
  readonly is_template?: boolean;
  readonly topics?: ReadonlyArray<string>;
  readonly has_issues?: boolean;
  readonly has_projects?: boolean;
  readonly has_wiki?: boolean;
  readonly has_pages?: boolean;
  readonly has_downloads?: boolean;
  readonly archived?: boolean;
  readonly disabled?: boolean;
  readonly visibility?: string;
  readonly pushed_at?: string | null;
  readonly created_at?: string | null;
  readonly updated_at?: string | null;
  readonly permissions?: {
    readonly admin?: boolean;
    readonly maintain?: boolean;
    readonly push?: boolean;
    readonly triage?: boolean;
    readonly pull?: boolean;
  };
  readonly role_name?: string;
  readonly temp_clone_token?: string;
  readonly delete_branch_on_merge?: boolean;
  readonly subscribers_count?: number;
  readonly network_count?: number;
  readonly code_of_conduct?: CodeOfConduct;
  readonly license?: {
    readonly key?: string;
    readonly name?: string;
    readonly spdx_id?: string;
    readonly url?: string;
    readonly node_id?: string;
  } | null;
  readonly forks?: number;
  readonly open_issues?: number;
  readonly watchers?: number;
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
};

export type Thread = {
  readonly id: string;
  readonly repository: MinimalRepository;
  readonly subject: {
    readonly title: string;
    readonly url: string;
    readonly latest_comment_url: string;
    readonly type: string;
  };
  readonly reason: string;
  readonly unread: boolean;
  readonly updated_at: string;
  readonly last_read_at: string | null;
  readonly url: string;
  readonly subscription_url: string;
};

export type ActivityListNotificationsForAuthenticatedUser200ResponseBody = ReadonlyArray<Thread>;

export type ActivityListNotificationsForAuthenticatedUser401ResponseBody = BasicError;

export type ActivityListNotificationsForAuthenticatedUser403ResponseBody = BasicError;

export type ActivityListNotificationsForAuthenticatedUser422ResponseBody = ValidationError;

export type ActivityListNotificationsForAuthenticatedUserRequestQuery = {
  readonly all?: boolean;
  readonly participating?: boolean;
  readonly since?: string;
  readonly before?: string;
  readonly page?: number;
  readonly per_page?: number;
};

export type ActivityMarkNotificationsAsRead202ResponseBody = {
  readonly message?: string;
};

export type ActivityMarkNotificationsAsRead401ResponseBody = BasicError;

export type ActivityMarkNotificationsAsRead403ResponseBody = BasicError;

export type ActivityMarkNotificationsAsReadRequestBody = {
  readonly last_read_at?: string;
  readonly read?: boolean;
};

export type ActivityGetThread200ResponseBody = Thread;

export type ActivityGetThread401ResponseBody = BasicError;

export type ActivityGetThread403ResponseBody = BasicError;

export type ActivityGetThreadRequestPath = { readonly thread_id: number };

export type ActivityMarkThreadAsRead403ResponseBody = BasicError;

export type ActivityMarkThreadAsReadRequestPath = {
  readonly thread_id: number;
};

export type ThreadSubscription = {
  readonly subscribed: boolean;
  readonly ignored: boolean;
  readonly reason: string | null;
  readonly created_at: string | null;
  readonly url: string;
  readonly thread_url?: string;
  readonly repository_url?: string;
};

export type ActivityGetThreadSubscriptionForAuthenticatedUser200ResponseBody = ThreadSubscription;

export type ActivityGetThreadSubscriptionForAuthenticatedUser401ResponseBody = BasicError;

export type ActivityGetThreadSubscriptionForAuthenticatedUser403ResponseBody = BasicError;

export type ActivityGetThreadSubscriptionForAuthenticatedUserRequestPath = {
  readonly thread_id: number;
};

export type ActivitySetThreadSubscription200ResponseBody = ThreadSubscription;

export type ActivitySetThreadSubscription401ResponseBody = BasicError;

export type ActivitySetThreadSubscription403ResponseBody = BasicError;

export type ActivitySetThreadSubscriptionRequestBody = {
  readonly ignored?: boolean;
};

export type ActivitySetThreadSubscriptionRequestPath = {
  readonly thread_id: number;
};

export type ActivityDeleteThreadSubscription401ResponseBody = BasicError;

export type ActivityDeleteThreadSubscription403ResponseBody = BasicError;

export type ActivityDeleteThreadSubscriptionRequestPath = {
  readonly thread_id: number;
};

export type MetaGetOctocatRequestQuery = { readonly s?: string };

export type OrgsList200ResponseBody = ReadonlyArray<OrganizationSimple>;

export type OrgsListRequestQuery = {
  readonly since?: number;
  readonly per_page?: number;
};

export type OrganizationCustomRepositoryRole = {
  readonly id: number;
  readonly name: string;
  readonly description?: string | null;
  readonly base_role?: 'read' | 'triage' | 'write' | 'maintain';
  readonly permissions?: ReadonlyArray<string>;
  readonly organization?: SimpleUser;
  readonly created_at?: string;
  readonly updated_at?: string;
};

export type OrgsListCustomRoles200ResponseBody = {
  readonly total_count?: number;
  readonly custom_roles?: ReadonlyArray<OrganizationCustomRepositoryRole>;
};

export type OrgsListCustomRolesRequestPath = {
  readonly organization_id: string;
};

export type OrganizationFull = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly hooks_url: string;
  readonly issues_url: string;
  readonly members_url: string;
  readonly public_members_url: string;
  readonly avatar_url: string;
  readonly description: string | null;
  readonly name?: string;
  readonly company?: string;
  readonly blog?: string;
  readonly location?: string;
  readonly email?: string;
  readonly twitter_username?: string | null;
  readonly is_verified?: boolean;
  readonly has_organization_projects: boolean;
  readonly has_repository_projects: boolean;
  readonly public_repos: number;
  readonly public_gists: number;
  readonly followers: number;
  readonly following: number;
  readonly html_url: string;
  readonly created_at: string;
  readonly type: string;
  readonly total_private_repos?: number;
  readonly owned_private_repos?: number;
  readonly private_gists?: number | null;
  readonly disk_usage?: number | null;
  readonly collaborators?: number | null;
  readonly billing_email?: string | null;
  readonly plan?: {
    readonly name: string;
    readonly space: number;
    readonly private_repos: number;
    readonly filled_seats?: number;
    readonly seats?: number;
  };
  readonly default_repository_permission?: string | null;
  readonly members_can_create_repositories?: boolean | null;
  readonly two_factor_requirement_enabled?: boolean | null;
  readonly members_allowed_repository_creation_type?: string;
  readonly members_can_create_public_repositories?: boolean;
  readonly members_can_create_private_repositories?: boolean;
  readonly members_can_create_internal_repositories?: boolean;
  readonly members_can_create_pages?: boolean;
  readonly members_can_create_public_pages?: boolean;
  readonly members_can_create_private_pages?: boolean;
  readonly members_can_fork_private_repositories?: boolean | null;
  readonly web_commit_signoff_required?: boolean;
  readonly updated_at: string;
  readonly advanced_security_enabled_for_new_repositories?: boolean;
  readonly dependabot_alerts_enabled_for_new_repositories?: boolean;
  readonly dependabot_security_updates_enabled_for_new_repositories?: boolean;
  readonly dependency_graph_enabled_for_new_repositories?: boolean;
  readonly secret_scanning_enabled_for_new_repositories?: boolean;
  readonly secret_scanning_push_protection_enabled_for_new_repositories?: boolean;
};

export type OrgsGet200ResponseBody = OrganizationFull;

export type OrgsGet404ResponseBody = BasicError;

export type OrgsGetRequestPath = { readonly org: string };

export type OrgsUpdate200ResponseBody = OrganizationFull;

export type OrgsUpdate409ResponseBody = BasicError;

export type OrgsUpdate422ResponseBody = ValidationError | ValidationErrorSimple;

export type OrgsUpdateRequestBody = {
  readonly billing_email?: string;
  readonly company?: string;
  readonly email?: string;
  readonly twitter_username?: string;
  readonly location?: string;
  readonly name?: string;
  readonly description?: string;
  readonly has_organization_projects?: boolean;
  readonly has_repository_projects?: boolean;
  readonly default_repository_permission?: 'read' | 'write' | 'admin' | 'none';
  readonly members_can_create_repositories?: boolean;
  readonly members_can_create_internal_repositories?: boolean;
  readonly members_can_create_private_repositories?: boolean;
  readonly members_can_create_public_repositories?: boolean;
  readonly members_allowed_repository_creation_type?:
    | 'all'
    | 'private'
    | 'none';
  readonly members_can_create_pages?: boolean;
  readonly members_can_create_public_pages?: boolean;
  readonly members_can_create_private_pages?: boolean;
  readonly members_can_fork_private_repositories?: boolean;
  readonly web_commit_signoff_required?: boolean;
  readonly blog?: string;
  readonly advanced_security_enabled_for_new_repositories?: boolean;
  readonly dependabot_alerts_enabled_for_new_repositories?: boolean;
  readonly dependabot_security_updates_enabled_for_new_repositories?: boolean;
  readonly dependency_graph_enabled_for_new_repositories?: boolean;
  readonly secret_scanning_enabled_for_new_repositories?: boolean;
  readonly secret_scanning_push_protection_enabled_for_new_repositories?: boolean;
};

export type OrgsUpdateRequestPath = { readonly org: string };

export type ActionsGetActionsCacheUsageForOrg200ResponseBody = ActionsCacheUsageOrgEnterprise;

export type ActionsGetActionsCacheUsageForOrgRequestPath = {
  readonly org: string;
};

export type ActionsCacheUsageByRepository = {
  readonly full_name: string;
  readonly active_caches_size_in_bytes: number;
  readonly active_caches_count: number;
};

export type ActionsGetActionsCacheUsageByRepoForOrg200ResponseBody = {
  readonly total_count: number;
  readonly repository_cache_usages: ReadonlyArray<ActionsCacheUsageByRepository>;
};

export type ActionsGetActionsCacheUsageByRepoForOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsGetActionsCacheUsageByRepoForOrgRequestPath = {
  readonly org: string;
};

export type EnabledRepositories = 'all' | 'none' | 'selected';

export type ActionsOrganizationPermissions = {
  readonly enabled_repositories: EnabledRepositories;
  readonly selected_repositories_url?: string;
  readonly allowed_actions?: AllowedActions;
  readonly selected_actions_url?: SelectedActionsUrl;
};

export type ActionsGetGithubActionsPermissionsOrganization200ResponseBody = ActionsOrganizationPermissions;

export type ActionsGetGithubActionsPermissionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsSetGithubActionsPermissionsOrganizationRequestBody = {
  readonly enabled_repositories: EnabledRepositories;
  readonly allowed_actions?: AllowedActions;
};

export type ActionsSetGithubActionsPermissionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<Repository>;
};

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestBody = {
  readonly selected_repository_ids: ReadonlyArray<number>;
};

export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsEnableSelectedRepositoryGithubActionsOrganizationRequestPath = {
  readonly org: string;
  readonly repository_id: number;
};

export type ActionsDisableSelectedRepositoryGithubActionsOrganizationRequestPath = {
  readonly org: string;
  readonly repository_id: number;
};

export type ActionsGetAllowedActionsOrganization200ResponseBody = SelectedActions;

export type ActionsGetAllowedActionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsSetAllowedActionsOrganizationRequestBody = SelectedActions;

export type ActionsSetAllowedActionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization200ResponseBody = ActionsGetDefaultWorkflowPermissions;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequestPath = {
  readonly org: string;
};

export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequestBody = ActionsSetDefaultWorkflowPermissions;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequestPath = {
  readonly org: string;
};

export type RunnerGroupsOrg = {
  readonly id: number;
  readonly name: string;
  readonly visibility: string;
  readonly default: boolean;
  readonly selected_repositories_url?: string;
  readonly runners_url: string;
  readonly inherited: boolean;
  readonly inherited_allows_public_repositories?: boolean;
  readonly allows_public_repositories: boolean;
  readonly workflow_restrictions_read_only?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type ActionsListSelfHostedRunnerGroupsForOrg200ResponseBody = {
  readonly total_count: number;
  readonly runner_groups: ReadonlyArray<RunnerGroupsOrg>;
};

export type ActionsListSelfHostedRunnerGroupsForOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly visible_to_repository?: string;
};

export type ActionsListSelfHostedRunnerGroupsForOrgRequestPath = {
  readonly org: string;
};

export type ActionsCreateSelfHostedRunnerGroupForOrg201ResponseBody = RunnerGroupsOrg;

export type ActionsCreateSelfHostedRunnerGroupForOrgRequestBody = {
  readonly name: string;
  readonly visibility?: 'selected' | 'all' | 'private';
  readonly selected_repository_ids?: ReadonlyArray<number>;
  readonly runners?: ReadonlyArray<number>;
  readonly allows_public_repositories?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type ActionsCreateSelfHostedRunnerGroupForOrgRequestPath = {
  readonly org: string;
};

export type ActionsGetSelfHostedRunnerGroupForOrg200ResponseBody = RunnerGroupsOrg;

export type ActionsGetSelfHostedRunnerGroupForOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsUpdateSelfHostedRunnerGroupForOrg200ResponseBody = RunnerGroupsOrg;

export type ActionsUpdateSelfHostedRunnerGroupForOrgRequestBody = {
  readonly name: string;
  readonly visibility?: 'selected' | 'all' | 'private';
  readonly allows_public_repositories?: boolean;
  readonly restricted_to_workflows?: boolean;
  readonly selected_workflows?: ReadonlyArray<string>;
};

export type ActionsUpdateSelfHostedRunnerGroupForOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsDeleteSelfHostedRunnerGroupFromOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<MinimalRepository>;
};

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestBody = {
  readonly selected_repository_ids: ReadonlyArray<number>;
};

export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
  readonly repository_id: number;
};

export type ActionsListSelfHostedRunnersInGroupForOrg200ResponseBody = {
  readonly total_count: number;
  readonly runners: ReadonlyArray<SelfHostedRunners>;
};

export type ActionsListSelfHostedRunnersInGroupForOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListSelfHostedRunnersInGroupForOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsSetSelfHostedRunnersInGroupForOrgRequestBody = {
  readonly runners: ReadonlyArray<number>;
};

export type ActionsSetSelfHostedRunnersInGroupForOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
};

export type ActionsAddSelfHostedRunnerToGroupForOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
  readonly runner_id: number;
};

export type ActionsRemoveSelfHostedRunnerFromGroupForOrgRequestPath = {
  readonly org: string;
  readonly runner_group_id: number;
  readonly runner_id: number;
};

export type ActionsListSelfHostedRunnersForOrg200ResponseBody = {
  readonly total_count: number;
  readonly runners: ReadonlyArray<SelfHostedRunners>;
};

export type ActionsListSelfHostedRunnersForOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListSelfHostedRunnersForOrgRequestPath = {
  readonly org: string;
};

export type ActionsListRunnerApplicationsForOrg200ResponseBody = ReadonlyArray<RunnerApplication>;

export type ActionsListRunnerApplicationsForOrgRequestPath = {
  readonly org: string;
};

export type ActionsCreateRegistrationTokenForOrg201ResponseBody = AuthenticationToken;

export type ActionsCreateRegistrationTokenForOrgRequestPath = {
  readonly org: string;
};

export type ActionsCreateRemoveTokenForOrg201ResponseBody = AuthenticationToken;

export type ActionsCreateRemoveTokenForOrgRequestPath = {
  readonly org: string;
};

export type ActionsGetSelfHostedRunnerForOrg200ResponseBody = SelfHostedRunners;

export type ActionsGetSelfHostedRunnerForOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
};

export type ActionsDeleteSelfHostedRunnerFromOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
};

export type ActionsListLabelsForSelfHostedRunnerForOrg200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsListLabelsForSelfHostedRunnerForOrg404ResponseBody = BasicError;

export type ActionsListLabelsForSelfHostedRunnerForOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
};

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrg200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrg404ResponseBody = BasicError;

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrg422ResponseBody = ValidationErrorSimple;

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestBody = {
  readonly labels: ReadonlyArray<string>;
};

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
};

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrg200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrg404ResponseBody = BasicError;

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrg422ResponseBody = ValidationErrorSimple;

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestBody = {
  readonly labels: ReadonlyArray<string>;
};

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
};

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg404ResponseBody = BasicError;

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
};

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg404ResponseBody = BasicError;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg422ResponseBody = ValidationErrorSimple;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequestPath = {
  readonly org: string;
  readonly runner_id: number;
  readonly name: string;
};

export type ActionsSecretForAnOrganization = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repositories_url?: string;
};

export type ActionsListOrgSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<ActionsSecretForAnOrganization>;
};

export type ActionsListOrgSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListOrgSecretsRequestPath = { readonly org: string };

export type ActionsPublicKey = {
  readonly key_id: string;
  readonly key: string;
  readonly id?: number;
  readonly url?: string;
  readonly title?: string;
  readonly created_at?: string;
};

export type ActionsGetOrgPublicKey200ResponseBody = ActionsPublicKey;

export type ActionsGetOrgPublicKeyRequestPath = { readonly org: string };

export type ActionsGetOrgSecret200ResponseBody = ActionsSecretForAnOrganization;

export type ActionsGetOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type EmptyObject = {};

export type ActionsCreateOrUpdateOrgSecret201ResponseBody = EmptyObject;

export type ActionsCreateOrUpdateOrgSecretRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id?: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repository_ids?: ReadonlyArray<number>;
};

export type ActionsCreateOrUpdateOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type ActionsDeleteOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type ActionsListSelectedReposForOrgSecret200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<MinimalRepository>;
};

export type ActionsListSelectedReposForOrgSecretRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type ActionsListSelectedReposForOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type ActionsSetSelectedReposForOrgSecretRequestBody = {
  readonly selected_repository_ids: ReadonlyArray<number>;
};

export type ActionsSetSelectedReposForOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type ActionsAddSelectedRepoToOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
  readonly repository_id: number;
};

export type ActionsRemoveSelectedRepoFromOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
  readonly repository_id: number;
};

export type OrgsListBlockedUsers200ResponseBody = ReadonlyArray<SimpleUser>;

export type OrgsListBlockedUsersRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListBlockedUsersRequestPath = { readonly org: string };

export type OrgsCheckBlockedUser404ResponseBody = BasicError;

export type OrgsCheckBlockedUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsBlockUser422ResponseBody = ValidationError;

export type OrgsBlockUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsUnblockUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type CodeScanningListAlertsForOrg200ResponseBody = ReadonlyArray<CodeScanningOrganizationAlertItems>;

export type CodeScanningListAlertsForOrg404ResponseBody = BasicError;

export type CodeScanningListAlertsForOrg503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningListAlertsForOrgRequestQuery = {
  readonly tool_name?: CodeScanningAnalysisToolName;
  readonly tool_guid?: CodeScanningAnalysisToolGuid;
  readonly before?: string;
  readonly after?: string;
  readonly page?: number;
  readonly per_page?: number;
  readonly direction?: 'asc' | 'desc';
  readonly state?: CodeScanningAlertState;
  readonly sort?: 'created' | 'updated';
};

export type CodeScanningListAlertsForOrgRequestPath = { readonly org: string };

export type CodespaceMachine = {
  readonly name: string;
  readonly display_name: string;
  readonly operating_system: string;
  readonly storage_in_bytes: number;
  readonly memory_in_bytes: number;
  readonly cpus: number;
  readonly prebuild_availability: 'none' | 'ready' | 'in_progress' | null;
} | null;

export type Codespace = {
  readonly id: number;
  readonly name: string;
  readonly display_name?: string | null;
  readonly environment_id: string | null;
  readonly owner: SimpleUser;
  readonly billable_owner: SimpleUser;
  readonly repository: MinimalRepository;
  readonly machine: CodespaceMachine;
  readonly devcontainer_path?: string | null;
  readonly prebuild: boolean | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly last_used_at: string;
  readonly state:
    | 'Unknown'
    | 'Created'
    | 'Queued'
    | 'Provisioning'
    | 'Available'
    | 'Awaiting'
    | 'Unavailable'
    | 'Deleted'
    | 'Moved'
    | 'Shutdown'
    | 'Archived'
    | 'Starting'
    | 'ShuttingDown'
    | 'Failed'
    | 'Exporting'
    | 'Updating'
    | 'Rebuilding';
  readonly url: string;
  readonly git_status: {
    readonly ahead?: number;
    readonly behind?: number;
    readonly has_unpushed_changes?: boolean;
    readonly has_uncommitted_changes?: boolean;
    readonly ref?: string;
  };
  readonly location: 'EastUs' | 'SouthEastAsia' | 'WestEurope' | 'WestUs2';
  readonly idle_timeout_minutes: number | null;
  readonly web_url: string;
  readonly machines_url: string;
  readonly start_url: string;
  readonly stop_url: string;
  readonly pulls_url: string | null;
  readonly recent_folders: ReadonlyArray<string>;
  readonly runtime_constraints?: {
    readonly allowed_port_privacy_settings?: ReadonlyArray<string> | null;
  };
  readonly pending_operation?: boolean | null;
  readonly pending_operation_disabled_reason?: string | null;
  readonly idle_timeout_notice?: string | null;
  readonly retention_period_minutes?: number | null;
  readonly retention_expires_at?: string | null;
  readonly last_known_stop_notice?: string | null;
};

export type CodespacesListInOrganization200ResponseBody = {
  readonly total_count: number;
  readonly codespaces: ReadonlyArray<Codespace>;
};

export type CodespacesListInOrganization401ResponseBody = BasicError;

export type CodespacesListInOrganization403ResponseBody = BasicError;

export type CodespacesListInOrganization404ResponseBody = BasicError;

export type CodespacesListInOrganization500ResponseBody = BasicError;

export type CodespacesListInOrganizationRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesListInOrganizationRequestPath = { readonly org: string };

export type CodespacesSetCodespacesBilling404ResponseBody = BasicError;

export type CodespacesSetCodespacesBilling422ResponseBody = ValidationError;

export type CodespacesSetCodespacesBilling500ResponseBody = BasicError;

export type CodespacesSetCodespacesBillingRequestBody = {
  readonly visibility:
    | 'disabled'
    | 'selected_members'
    | 'all_members'
    | 'all_members_and_outside_collaborators';
  readonly selected_usernames?: ReadonlyArray<string>;
};

export type CodespacesSetCodespacesBillingRequestPath = {
  readonly org: string;
};

export type CodespacesSecret = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repositories_url?: string;
};

export type CodespacesListOrgSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<CodespacesSecret>;
};

export type CodespacesListOrgSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesListOrgSecretsRequestPath = { readonly org: string };

export type CodespacesPublicKey = {
  readonly key_id: string;
  readonly key: string;
  readonly id?: number;
  readonly url?: string;
  readonly title?: string;
  readonly created_at?: string;
};

export type CodespacesGetOrgPublicKey200ResponseBody = CodespacesPublicKey;

export type CodespacesGetOrgPublicKeyRequestPath = { readonly org: string };

export type CodespacesGetOrgSecret200ResponseBody = CodespacesSecret;

export type CodespacesGetOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type CodespacesCreateOrUpdateOrgSecret201ResponseBody = EmptyObject;

export type CodespacesCreateOrUpdateOrgSecret404ResponseBody = BasicError;

export type CodespacesCreateOrUpdateOrgSecret422ResponseBody = ValidationError;

export type CodespacesCreateOrUpdateOrgSecretRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id?: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repository_ids?: ReadonlyArray<number>;
};

export type CodespacesCreateOrUpdateOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type CodespacesDeleteOrgSecret404ResponseBody = BasicError;

export type CodespacesDeleteOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type CodespacesListSelectedReposForOrgSecret200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<MinimalRepository>;
};

export type CodespacesListSelectedReposForOrgSecret404ResponseBody = BasicError;

export type CodespacesListSelectedReposForOrgSecretRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type CodespacesListSelectedReposForOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type CodespacesSetSelectedReposForOrgSecret404ResponseBody = BasicError;

export type CodespacesSetSelectedReposForOrgSecretRequestBody = {
  readonly selected_repository_ids: ReadonlyArray<number>;
};

export type CodespacesSetSelectedReposForOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type CodespacesAddSelectedRepoToOrgSecret404ResponseBody = BasicError;

export type CodespacesAddSelectedRepoToOrgSecret422ResponseBody = ValidationError;

export type CodespacesAddSelectedRepoToOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
  readonly repository_id: number;
};

export type CodespacesRemoveSelectedRepoFromOrgSecret404ResponseBody = BasicError;

export type CodespacesRemoveSelectedRepoFromOrgSecret422ResponseBody = ValidationError;

export type CodespacesRemoveSelectedRepoFromOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
  readonly repository_id: number;
};

export type OrgsCreateCustomRole201ResponseBody = OrganizationCustomRepositoryRole;

export type OrgsCreateCustomRole404ResponseBody = BasicError;

export type OrgsCreateCustomRole422ResponseBody = ValidationError;

export type OrgsCreateCustomRoleRequestBody = {
  readonly name: string;
  readonly description?: string;
  readonly base_role: 'read' | 'triage' | 'write' | 'maintain';
  readonly permissions: ReadonlyArray<string>;
};

export type OrgsCreateCustomRoleRequestPath = { readonly org: string };

export type OrgsGetCustomRole200ResponseBody = OrganizationCustomRepositoryRole;

export type OrgsGetCustomRole404ResponseBody = BasicError;

export type OrgsGetCustomRoleRequestPath = {
  readonly org: string;
  readonly role_id: number;
};

export type OrgsUpdateCustomRole200ResponseBody = OrganizationCustomRepositoryRole;

export type OrgsUpdateCustomRole404ResponseBody = BasicError;

export type OrgsUpdateCustomRole422ResponseBody = ValidationError;

export type OrgsUpdateCustomRoleRequestBody = {
  readonly name?: string;
  readonly description?: string;
  readonly base_role?: 'read' | 'triage' | 'write' | 'maintain';
  readonly permissions?: ReadonlyArray<string>;
};

export type OrgsUpdateCustomRoleRequestPath = {
  readonly org: string;
  readonly role_id: number;
};

export type OrgsDeleteCustomRoleRequestPath = {
  readonly org: string;
  readonly role_id: number;
};

export type DependabotAlertPackage = {
  readonly ecosystem: string;
  readonly name: string;
};

export type DependabotAlertSecurityVulnerability = {
  readonly package: DependabotAlertPackage;
  readonly severity: 'low' | 'medium' | 'high' | 'critical';
  readonly vulnerable_version_range: string;
  readonly first_patched_version: { readonly identifier: string } | null;
};

export type DependabotAlertSecurityAdvisory = {
  readonly ghsa_id: string;
  readonly cve_id: string | null;
  readonly summary: string;
  readonly description: string;
  readonly vulnerabilities: ReadonlyArray<DependabotAlertSecurityVulnerability>;
  readonly severity: 'low' | 'medium' | 'high' | 'critical';
  readonly cvss: {
    readonly score: number;
    readonly vector_string: string | null;
  };
  readonly cwes: ReadonlyArray<{
    readonly cwe_id: string;
    readonly name: string;
  }>;
  readonly identifiers: ReadonlyArray<{
    readonly type: 'CVE' | 'GHSA';
    readonly value: string;
  }>;
  readonly references: ReadonlyArray<{ readonly url: string }>;
  readonly published_at: string;
  readonly updated_at: string;
  readonly withdrawn_at: string | null;
};

export type DependabotAlertWithRepository = {
  readonly number: AlertNumber;
  readonly state: 'dismissed' | 'fixed' | 'open';
  readonly dependency: {
    readonly package?: DependabotAlertPackage;
    readonly manifest_path?: string;
    readonly scope?: 'development' | 'runtime' | null;
  };
  readonly security_advisory: DependabotAlertSecurityAdvisory;
  readonly security_vulnerability: DependabotAlertSecurityVulnerability;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly created_at: AlertCreatedAt;
  readonly updated_at: AlertUpdatedAt;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_reason:
    | 'fix_started'
    | 'inaccurate'
    | 'no_bandwidth'
    | 'not_used'
    | 'tolerable_risk'
    | null;
  readonly dismissed_comment: string | null;
  readonly fixed_at: AlertFixedAt;
  readonly repository: SimpleRepository;
};

export type DependabotListAlertsForOrg200ResponseBody = ReadonlyArray<DependabotAlertWithRepository>;

export type DependabotListAlertsForOrg400ResponseBody = BasicError;

export type DependabotListAlertsForOrg403ResponseBody = BasicError;

export type DependabotListAlertsForOrg404ResponseBody = BasicError;

export type DependabotListAlertsForOrg422ResponseBody = ValidationErrorSimple;

export type DependabotListAlertsForOrgRequestQuery = {
  readonly state?: string;
  readonly severity?: string;
  readonly ecosystem?: string;
  readonly package?: string;
  readonly scope?: 'development' | 'runtime';
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly before?: string;
  readonly after?: string;
  readonly first?: number;
  readonly last?: number;
};

export type DependabotListAlertsForOrgRequestPath = { readonly org: string };

export type DependabotSecretForAnOrganization = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repositories_url?: string;
};

export type DependabotListOrgSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<DependabotSecretForAnOrganization>;
};

export type DependabotListOrgSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type DependabotListOrgSecretsRequestPath = { readonly org: string };

export type DependabotPublicKey = {
  readonly key_id: string;
  readonly key: string;
};

export type DependabotGetOrgPublicKey200ResponseBody = DependabotPublicKey;

export type DependabotGetOrgPublicKeyRequestPath = { readonly org: string };

export type DependabotGetOrgSecret200ResponseBody = DependabotSecretForAnOrganization;

export type DependabotGetOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type DependabotCreateOrUpdateOrgSecret201ResponseBody = EmptyObject;

export type DependabotCreateOrUpdateOrgSecretRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id?: string;
  readonly visibility: 'all' | 'private' | 'selected';
  readonly selected_repository_ids?: ReadonlyArray<string>;
};

export type DependabotCreateOrUpdateOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type DependabotDeleteOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type DependabotListSelectedReposForOrgSecret200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<MinimalRepository>;
};

export type DependabotListSelectedReposForOrgSecretRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type DependabotListSelectedReposForOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type DependabotSetSelectedReposForOrgSecretRequestBody = {
  readonly selected_repository_ids: ReadonlyArray<number>;
};

export type DependabotSetSelectedReposForOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
};

export type DependabotAddSelectedRepoToOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
  readonly repository_id: number;
};

export type DependabotRemoveSelectedRepoFromOrgSecretRequestPath = {
  readonly org: string;
  readonly secret_name: string;
  readonly repository_id: number;
};

export type ActivityListPublicOrgEvents200ResponseBody = ReadonlyArray<Event>;

export type ActivityListPublicOrgEventsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListPublicOrgEventsRequestPath = { readonly org: string };

export type OrganizationInvitation = {
  readonly id: number;
  readonly login: string | null;
  readonly email: string | null;
  readonly role: string;
  readonly created_at: string;
  readonly failed_at?: string | null;
  readonly failed_reason?: string | null;
  readonly inviter: SimpleUser;
  readonly team_count: number;
  readonly node_id: string;
  readonly invitation_teams_url: string;
};

export type OrgsListFailedInvitations200ResponseBody = ReadonlyArray<OrganizationInvitation>;

export type OrgsListFailedInvitations404ResponseBody = BasicError;

export type OrgsListFailedInvitationsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListFailedInvitationsRequestPath = { readonly org: string };

export type OrganizationFineGrainedPermission = {
  readonly name: string;
  readonly description: string;
};

export type OrgsListFineGrainedPermissions200ResponseBody = ReadonlyArray<OrganizationFineGrainedPermission>;

export type OrgsListFineGrainedPermissionsRequestPath = {
  readonly org: string;
};

export type OrgHook = {
  readonly id: number;
  readonly url: string;
  readonly ping_url: string;
  readonly deliveries_url?: string;
  readonly name: string;
  readonly events: ReadonlyArray<string>;
  readonly active: boolean;
  readonly config: {
    readonly url?: string;
    readonly insecure_ssl?: string;
    readonly content_type?: string;
    readonly secret?: string;
  };
  readonly updated_at: string;
  readonly created_at: string;
  readonly type: string;
};

export type OrgsListWebhooks200ResponseBody = ReadonlyArray<OrgHook>;

export type OrgsListWebhooks404ResponseBody = BasicError;

export type OrgsListWebhooksRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListWebhooksRequestPath = { readonly org: string };

export type OrgsCreateWebhook201ResponseBody = OrgHook;

export type OrgsCreateWebhook404ResponseBody = BasicError;

export type OrgsCreateWebhook422ResponseBody = ValidationError;

export type OrgsCreateWebhookRequestBody = {
  readonly name: string;
  readonly config: {
    readonly url: WebhookConfigUrl;
    readonly content_type?: WebhookConfigContentType;
    readonly secret?: WebhookConfigSecret;
    readonly insecure_ssl?: WebhookConfigInsecureSsl;
    readonly username?: string;
    readonly password?: string;
  };
  readonly events?: ReadonlyArray<string>;
  readonly active?: boolean;
};

export type OrgsCreateWebhookRequestPath = { readonly org: string };

export type OrgsGetWebhook200ResponseBody = OrgHook;

export type OrgsGetWebhook404ResponseBody = BasicError;

export type OrgsGetWebhookRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type OrgsUpdateWebhook200ResponseBody = OrgHook;

export type OrgsUpdateWebhook404ResponseBody = BasicError;

export type OrgsUpdateWebhook422ResponseBody = ValidationError;

export type OrgsUpdateWebhookRequestBody = {
  readonly config?: {
    readonly url: WebhookConfigUrl;
    readonly content_type?: WebhookConfigContentType;
    readonly secret?: WebhookConfigSecret;
    readonly insecure_ssl?: WebhookConfigInsecureSsl;
  };
  readonly events?: ReadonlyArray<string>;
  readonly active?: boolean;
  readonly name?: string;
};

export type OrgsUpdateWebhookRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type OrgsDeleteWebhook404ResponseBody = BasicError;

export type OrgsDeleteWebhookRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type OrgsGetWebhookConfigForOrg200ResponseBody = WebhookConfiguration;

export type OrgsGetWebhookConfigForOrgRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type OrgsUpdateWebhookConfigForOrg200ResponseBody = WebhookConfiguration;

export type OrgsUpdateWebhookConfigForOrgRequestBody = {
  readonly url?: WebhookConfigUrl;
  readonly content_type?: WebhookConfigContentType;
  readonly secret?: WebhookConfigSecret;
  readonly insecure_ssl?: WebhookConfigInsecureSsl;
};

export type OrgsUpdateWebhookConfigForOrgRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type OrgsListWebhookDeliveries200ResponseBody = ReadonlyArray<SimpleWebhookDelivery>;

export type OrgsListWebhookDeliveries400ResponseBody = BasicError;

export type OrgsListWebhookDeliveries422ResponseBody = ValidationError;

export type OrgsListWebhookDeliveriesRequestQuery = {
  readonly per_page?: number;
  readonly cursor?: string;
};

export type OrgsListWebhookDeliveriesRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type OrgsGetWebhookDelivery200ResponseBody = WebhookDelivery;

export type OrgsGetWebhookDelivery400ResponseBody = BasicError;

export type OrgsGetWebhookDelivery422ResponseBody = ValidationError;

export type OrgsGetWebhookDeliveryRequestPath = {
  readonly org: string;
  readonly hook_id: number;
  readonly delivery_id: number;
};

export type OrgsRedeliverWebhookDelivery202ResponseBody = unknown;

export type OrgsRedeliverWebhookDelivery400ResponseBody = BasicError;

export type OrgsRedeliverWebhookDelivery422ResponseBody = ValidationError;

export type OrgsRedeliverWebhookDeliveryRequestPath = {
  readonly org: string;
  readonly hook_id: number;
  readonly delivery_id: number;
};

export type OrgsPingWebhook404ResponseBody = BasicError;

export type OrgsPingWebhookRequestPath = {
  readonly org: string;
  readonly hook_id: number;
};

export type AppsGetOrgInstallation200ResponseBody = Installation;

export type AppsGetOrgInstallationRequestPath = { readonly org: string };

export type OrgsListAppInstallations200ResponseBody = {
  readonly total_count: number;
  readonly installations: ReadonlyArray<Installation>;
};

export type OrgsListAppInstallationsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListAppInstallationsRequestPath = { readonly org: string };

export type InteractionGroup =
  | 'existing_users'
  | 'contributors_only'
  | 'collaborators_only';

export type InteractionLimits = {
  readonly limit: InteractionGroup;
  readonly origin: string;
  readonly expires_at: string;
};

export type InteractionsGetRestrictionsForOrg200ResponseBody =
  | InteractionLimits
  | {};

export type InteractionsGetRestrictionsForOrgRequestPath = {
  readonly org: string;
};

export type InteractionsSetRestrictionsForOrg200ResponseBody = InteractionLimits;

export type InteractionsSetRestrictionsForOrg422ResponseBody = ValidationError;

export type InteractionExpiry =
  | 'one_day'
  | 'three_days'
  | 'one_week'
  | 'one_month'
  | 'six_months';

export type InteractionRestrictions = {
  readonly limit: InteractionGroup;
  readonly expiry?: InteractionExpiry;
};

export type InteractionsSetRestrictionsForOrgRequestBody = InteractionRestrictions;

export type InteractionsSetRestrictionsForOrgRequestPath = {
  readonly org: string;
};

export type InteractionsRemoveRestrictionsForOrgRequestPath = {
  readonly org: string;
};

export type OrgsListPendingInvitations200ResponseBody = ReadonlyArray<OrganizationInvitation>;

export type OrgsListPendingInvitations404ResponseBody = BasicError;

export type OrgsListPendingInvitationsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListPendingInvitationsRequestPath = { readonly org: string };

export type OrgsCreateInvitation201ResponseBody = OrganizationInvitation;

export type OrgsCreateInvitation404ResponseBody = BasicError;

export type OrgsCreateInvitation422ResponseBody = ValidationError;

export type OrgsCreateInvitationRequestBody = {
  readonly invitee_id?: number;
  readonly email?: string;
  readonly role?: 'admin' | 'direct_member' | 'billing_manager';
  readonly team_ids?: ReadonlyArray<number>;
};

export type OrgsCreateInvitationRequestPath = { readonly org: string };

export type OrgsCancelInvitation404ResponseBody = BasicError;

export type OrgsCancelInvitation422ResponseBody = ValidationError;

export type OrgsCancelInvitationRequestPath = {
  readonly org: string;
  readonly invitation_id: number;
};

export type TeamSimple = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly members_url: string;
  readonly name: string;
  readonly description: string | null;
  readonly permission: string;
  readonly privacy?: string;
  readonly html_url: string;
  readonly repositories_url: string;
  readonly slug: string;
  readonly ldap_dn?: string;
} | null;

export type Team = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly slug: string;
  readonly description: string | null;
  readonly privacy?: string;
  readonly permission: string;
  readonly permissions?: {
    readonly pull: boolean;
    readonly triage: boolean;
    readonly push: boolean;
    readonly maintain: boolean;
    readonly admin: boolean;
  };
  readonly url: string;
  readonly html_url: string;
  readonly members_url: string;
  readonly repositories_url: string;
  readonly parent: TeamSimple;
};

export type OrgsListInvitationTeams200ResponseBody = ReadonlyArray<Team>;

export type OrgsListInvitationTeams404ResponseBody = BasicError;

export type OrgsListInvitationTeamsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListInvitationTeamsRequestPath = {
  readonly org: string;
  readonly invitation_id: number;
};

export type IssuesListForOrg200ResponseBody = ReadonlyArray<Issue>;

export type IssuesListForOrg404ResponseBody = BasicError;

export type IssuesListForOrgRequestQuery = {
  readonly filter?:
    | 'assigned'
    | 'created'
    | 'mentioned'
    | 'subscribed'
    | 'repos'
    | 'all';
  readonly state?: 'open' | 'closed' | 'all';
  readonly labels?: string;
  readonly sort?: 'created' | 'updated' | 'comments';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListForOrgRequestPath = { readonly org: string };

export type OrgsListMembers200ResponseBody = ReadonlyArray<SimpleUser>;

export type OrgsListMembers422ResponseBody = ValidationError;

export type OrgsListMembersRequestQuery = {
  readonly filter?: '2fa_disabled' | 'all';
  readonly role?: 'all' | 'admin' | 'member';
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListMembersRequestPath = { readonly org: string };

export type OrgsCheckMembershipForUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsRemoveMember403ResponseBody = BasicError;

export type OrgsRemoveMemberRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type CodespacesGetCodespacesForUserInOrg200ResponseBody = {
  readonly total_count: number;
  readonly codespaces: ReadonlyArray<Codespace>;
};

export type CodespacesGetCodespacesForUserInOrg401ResponseBody = BasicError;

export type CodespacesGetCodespacesForUserInOrg403ResponseBody = BasicError;

export type CodespacesGetCodespacesForUserInOrg404ResponseBody = BasicError;

export type CodespacesGetCodespacesForUserInOrg500ResponseBody = BasicError;

export type CodespacesGetCodespacesForUserInOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesGetCodespacesForUserInOrgRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type CodespacesDeleteFromOrganization202ResponseBody = unknown;

export type CodespacesDeleteFromOrganization401ResponseBody = BasicError;

export type CodespacesDeleteFromOrganization403ResponseBody = BasicError;

export type CodespacesDeleteFromOrganization404ResponseBody = BasicError;

export type CodespacesDeleteFromOrganization500ResponseBody = BasicError;

export type CodespacesDeleteFromOrganizationRequestPath = {
  readonly org: string;
  readonly username: string;
  readonly codespace_name: string;
};

export type CodespacesStopInOrganization200ResponseBody = Codespace;

export type CodespacesStopInOrganization401ResponseBody = BasicError;

export type CodespacesStopInOrganization403ResponseBody = BasicError;

export type CodespacesStopInOrganization404ResponseBody = BasicError;

export type CodespacesStopInOrganization500ResponseBody = BasicError;

export type CodespacesStopInOrganizationRequestPath = {
  readonly org: string;
  readonly username: string;
  readonly codespace_name: string;
};

export type OrgMembership = {
  readonly url: string;
  readonly state: 'active' | 'pending';
  readonly role: 'admin' | 'member' | 'billing_manager';
  readonly organization_url: string;
  readonly organization: OrganizationSimple;
  readonly user: SimpleUser;
  readonly permissions?: { readonly can_create_repository: boolean };
};

export type OrgsGetMembershipForUser200ResponseBody = OrgMembership;

export type OrgsGetMembershipForUser403ResponseBody = BasicError;

export type OrgsGetMembershipForUser404ResponseBody = BasicError;

export type OrgsGetMembershipForUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsSetMembershipForUser200ResponseBody = OrgMembership;

export type OrgsSetMembershipForUser403ResponseBody = BasicError;

export type OrgsSetMembershipForUser422ResponseBody = ValidationError;

export type OrgsSetMembershipForUserRequestBody = {
  readonly role?: 'admin' | 'member';
};

export type OrgsSetMembershipForUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsRemoveMembershipForUser403ResponseBody = BasicError;

export type OrgsRemoveMembershipForUser404ResponseBody = BasicError;

export type OrgsRemoveMembershipForUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type Migration = {
  readonly id: number;
  readonly owner: SimpleUser;
  readonly guid: string;
  readonly state: string;
  readonly lock_repositories: boolean;
  readonly exclude_metadata: boolean;
  readonly exclude_git_data: boolean;
  readonly exclude_attachments: boolean;
  readonly exclude_releases: boolean;
  readonly exclude_owner_projects: boolean;
  readonly org_metadata_only: boolean;
  readonly repositories: ReadonlyArray<Repository>;
  readonly url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly node_id: string;
  readonly archive_url?: string;
  readonly exclude?: ReadonlyArray<unknown>;
};

export type MigrationsListForOrg200ResponseBody = ReadonlyArray<Migration>;

export type MigrationsListForOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly exclude?: ReadonlyArray<'repositories'> | 'repositories';
};

export type MigrationsListForOrgRequestPath = { readonly org: string };

export type MigrationsStartForOrg201ResponseBody = Migration;

export type MigrationsStartForOrg404ResponseBody = BasicError;

export type MigrationsStartForOrg422ResponseBody = ValidationError;

export type MigrationsStartForOrgRequestBody = {
  readonly repositories: ReadonlyArray<string>;
  readonly lock_repositories?: boolean;
  readonly exclude_metadata?: boolean;
  readonly exclude_git_data?: boolean;
  readonly exclude_attachments?: boolean;
  readonly exclude_releases?: boolean;
  readonly exclude_owner_projects?: boolean;
  readonly org_metadata_only?: boolean;
  readonly exclude?: ReadonlyArray<'repositories'>;
};

export type MigrationsStartForOrgRequestPath = { readonly org: string };

export type MigrationsGetStatusForOrg200ResponseBody = Migration;

export type MigrationsGetStatusForOrg404ResponseBody = BasicError;

export type MigrationsGetStatusForOrgRequestQuery = {
  readonly exclude?: ReadonlyArray<'repositories'> | 'repositories';
};

export type MigrationsGetStatusForOrgRequestPath = {
  readonly org: string;
  readonly migration_id: number;
};

export type MigrationsDownloadArchiveForOrg404ResponseBody = BasicError;

export type MigrationsDownloadArchiveForOrgRequestPath = {
  readonly org: string;
  readonly migration_id: number;
};

export type MigrationsDeleteArchiveForOrg404ResponseBody = BasicError;

export type MigrationsDeleteArchiveForOrgRequestPath = {
  readonly org: string;
  readonly migration_id: number;
};

export type MigrationsUnlockRepoForOrg404ResponseBody = BasicError;

export type MigrationsUnlockRepoForOrgRequestPath = {
  readonly org: string;
  readonly migration_id: number;
  readonly repo_name: string;
};

export type MigrationsListReposForOrg200ResponseBody = ReadonlyArray<MinimalRepository>;

export type MigrationsListReposForOrg404ResponseBody = BasicError;

export type MigrationsListReposForOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type MigrationsListReposForOrgRequestPath = {
  readonly org: string;
  readonly migration_id: number;
};

export type OrgsListOutsideCollaborators200ResponseBody = ReadonlyArray<SimpleUser>;

export type OrgsListOutsideCollaboratorsRequestQuery = {
  readonly filter?: '2fa_disabled' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListOutsideCollaboratorsRequestPath = { readonly org: string };

export type OrgsConvertMemberToOutsideCollaborator202ResponseBody = {};

export type OrgsConvertMemberToOutsideCollaborator404ResponseBody = BasicError;

export type OrgsConvertMemberToOutsideCollaboratorRequestBody = {
  readonly async?: boolean;
};

export type OrgsConvertMemberToOutsideCollaboratorRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsRemoveOutsideCollaborator422ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
};

export type OrgsRemoveOutsideCollaboratorRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type Package = {
  readonly id: number;
  readonly name: string;
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly url: string;
  readonly html_url: string;
  readonly version_count: number;
  readonly visibility: 'private' | 'public';
  readonly owner?: SimpleUser;
  readonly repository?: MinimalRepository;
  readonly created_at: string;
  readonly updated_at: string;
};

export type PackagesListPackagesForOrganization200ResponseBody = ReadonlyArray<Package>;

export type PackagesListPackagesForOrganization401ResponseBody = BasicError;

export type PackagesListPackagesForOrganization403ResponseBody = BasicError;

export type PackagesListPackagesForOrganizationRequestQuery = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly visibility?: 'public' | 'private' | 'internal';
};

export type PackagesListPackagesForOrganizationRequestPath = {
  readonly org: string;
};

export type PackagesGetPackageForOrganization200ResponseBody = Package;

export type PackagesGetPackageForOrganizationRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
};

export type PackagesDeletePackageForOrg401ResponseBody = BasicError;

export type PackagesDeletePackageForOrg403ResponseBody = BasicError;

export type PackagesDeletePackageForOrg404ResponseBody = BasicError;

export type PackagesDeletePackageForOrgRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
};

export type PackagesRestorePackageForOrg401ResponseBody = BasicError;

export type PackagesRestorePackageForOrg403ResponseBody = BasicError;

export type PackagesRestorePackageForOrg404ResponseBody = BasicError;

export type PackagesRestorePackageForOrgRequestQuery = {
  readonly token?: string;
};

export type PackagesRestorePackageForOrgRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
};

export type ContainerMetadata = { readonly tags: ReadonlyArray<string> };

export type DockerMetadata = { readonly tag?: ReadonlyArray<string> };

export type PackageVersionMetadata = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly container?: ContainerMetadata;
  readonly docker?: DockerMetadata;
};

export type PackageVersion = {
  readonly id: number;
  readonly name: string;
  readonly url: string;
  readonly package_html_url: string;
  readonly html_url?: string;
  readonly license?: string;
  readonly description?: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly deleted_at?: string;
  readonly metadata?: PackageVersionMetadata;
};

export type PackagesGetAllPackageVersionsForPackageOwnedByOrg200ResponseBody = ReadonlyArray<PackageVersion>;

export type PackagesGetAllPackageVersionsForPackageOwnedByOrg401ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByOrg403ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByOrg404ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByOrgRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
  readonly state?: 'active' | 'deleted';
};

export type PackagesGetAllPackageVersionsForPackageOwnedByOrgRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
};

export type PackagesGetPackageVersionForOrganization200ResponseBody = PackageVersion;

export type PackagesGetPackageVersionForOrganizationRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
  readonly package_version_id: number;
};

export type PackagesDeletePackageVersionForOrg401ResponseBody = BasicError;

export type PackagesDeletePackageVersionForOrg403ResponseBody = BasicError;

export type PackagesDeletePackageVersionForOrg404ResponseBody = BasicError;

export type PackagesDeletePackageVersionForOrgRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
  readonly package_version_id: number;
};

export type PackagesRestorePackageVersionForOrg401ResponseBody = BasicError;

export type PackagesRestorePackageVersionForOrg403ResponseBody = BasicError;

export type PackagesRestorePackageVersionForOrg404ResponseBody = BasicError;

export type PackagesRestorePackageVersionForOrgRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly org: string;
  readonly package_version_id: number;
};

export type Project = {
  readonly owner_url: string;
  readonly url: string;
  readonly html_url: string;
  readonly columns_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly body: string | null;
  readonly number: number;
  readonly state: string;
  readonly creator: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly organization_permission?: 'read' | 'write' | 'admin' | 'none';
  readonly private?: boolean;
};

export type ProjectsListForOrg200ResponseBody = ReadonlyArray<Project>;

export type ProjectsListForOrg422ResponseBody = ValidationErrorSimple;

export type ProjectsListForOrgRequestQuery = {
  readonly state?: 'open' | 'closed' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type ProjectsListForOrgRequestPath = { readonly org: string };

export type ProjectsCreateForOrg201ResponseBody = Project;

export type ProjectsCreateForOrg401ResponseBody = BasicError;

export type ProjectsCreateForOrg403ResponseBody = BasicError;

export type ProjectsCreateForOrg404ResponseBody = BasicError;

export type ProjectsCreateForOrg410ResponseBody = BasicError;

export type ProjectsCreateForOrg422ResponseBody = ValidationErrorSimple;

export type ProjectsCreateForOrgRequestBody = {
  readonly name: string;
  readonly body?: string;
};

export type ProjectsCreateForOrgRequestPath = { readonly org: string };

export type OrgsListPublicMembers200ResponseBody = ReadonlyArray<SimpleUser>;

export type OrgsListPublicMembersRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListPublicMembersRequestPath = { readonly org: string };

export type OrgsCheckPublicMembershipForUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsSetPublicMembershipForAuthenticatedUser403ResponseBody = BasicError;

export type OrgsSetPublicMembershipForAuthenticatedUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type OrgsRemovePublicMembershipForAuthenticatedUserRequestPath = {
  readonly org: string;
  readonly username: string;
};

export type ReposListForOrg200ResponseBody = ReadonlyArray<MinimalRepository>;

export type ReposListForOrgRequestQuery = {
  readonly type?:
    | 'all'
    | 'public'
    | 'private'
    | 'forks'
    | 'sources'
    | 'member'
    | 'internal';
  readonly sort?: 'created' | 'updated' | 'pushed' | 'full_name';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListForOrgRequestPath = { readonly org: string };

export type ReposCreateInOrg201ResponseBody = Repository;

export type ReposCreateInOrg403ResponseBody = BasicError;

export type ReposCreateInOrg422ResponseBody = ValidationError;

export type ReposCreateInOrgRequestBody = {
  readonly name: string;
  readonly description?: string;
  readonly homepage?: string;
  readonly private?: boolean;
  readonly visibility?: 'public' | 'private' | 'internal';
  readonly has_issues?: boolean;
  readonly has_projects?: boolean;
  readonly has_wiki?: boolean;
  readonly is_template?: boolean;
  readonly team_id?: number;
  readonly auto_init?: boolean;
  readonly gitignore_template?: string;
  readonly license_template?: string;
  readonly allow_squash_merge?: boolean;
  readonly allow_merge_commit?: boolean;
  readonly allow_rebase_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly use_squash_pr_title_as_default?: boolean;
  readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
  readonly squash_merge_commit_message?:
    | 'PR_BODY'
    | 'COMMIT_MESSAGES'
    | 'BLANK';
  readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
  readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
};

export type ReposCreateInOrgRequestPath = { readonly org: string };

export type SecretScanningListAlertsForOrg200ResponseBody = ReadonlyArray<OrganizationSecretScanningAlert>;

export type SecretScanningListAlertsForOrg404ResponseBody = BasicError;

export type SecretScanningListAlertsForOrg503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SecretScanningListAlertsForOrgRequestQuery = {
  readonly state?: 'open' | 'resolved';
  readonly secret_type?: string;
  readonly resolution?: string;
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly page?: number;
  readonly per_page?: number;
  readonly before?: string;
  readonly after?: string;
};

export type SecretScanningListAlertsForOrgRequestPath = {
  readonly org: string;
};

export type OrgsListSecurityManagerTeams200ResponseBody = ReadonlyArray<TeamSimple>;

export type OrgsListSecurityManagerTeamsRequestPath = { readonly org: string };

export type OrgsAddSecurityManagerTeamRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type OrgsRemoveSecurityManagerTeamRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type ActionsBillingUsage = {
  readonly total_minutes_used: number;
  readonly total_paid_minutes_used: number;
  readonly included_minutes: number;
  readonly minutes_used_breakdown: {
    readonly UBUNTU?: number;
    readonly MACOS?: number;
    readonly WINDOWS?: number;
    readonly ubuntu_4_core?: number;
    readonly ubuntu_8_core?: number;
    readonly ubuntu_16_core?: number;
    readonly ubuntu_32_core?: number;
    readonly ubuntu_64_core?: number;
    readonly windows_4_core?: number;
    readonly windows_8_core?: number;
    readonly windows_16_core?: number;
    readonly windows_32_core?: number;
    readonly windows_64_core?: number;
    readonly total?: number;
  };
};

export type BillingGetGithubActionsBillingOrg200ResponseBody = ActionsBillingUsage;

export type BillingGetGithubActionsBillingOrgRequestPath = {
  readonly org: string;
};

export type BillingGetGithubAdvancedSecurityBillingOrg200ResponseBody = AdvancedSecurityActiveCommitters;

export type BillingGetGithubAdvancedSecurityBillingOrg403ResponseBody = BasicError;

export type BillingGetGithubAdvancedSecurityBillingOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type BillingGetGithubAdvancedSecurityBillingOrgRequestPath = {
  readonly org: string;
};

export type PackagesBillingUsage = {
  readonly total_gigabytes_bandwidth_used: number;
  readonly total_paid_gigabytes_bandwidth_used: number;
  readonly included_gigabytes_bandwidth: number;
};

export type BillingGetGithubPackagesBillingOrg200ResponseBody = PackagesBillingUsage;

export type BillingGetGithubPackagesBillingOrgRequestPath = {
  readonly org: string;
};

export type CombinedBillingUsage = {
  readonly days_left_in_billing_cycle: number;
  readonly estimated_paid_storage_for_month: number;
  readonly estimated_storage_for_month: number;
};

export type BillingGetSharedStorageBillingOrg200ResponseBody = CombinedBillingUsage;

export type BillingGetSharedStorageBillingOrgRequestPath = {
  readonly org: string;
};

export type TeamsList200ResponseBody = ReadonlyArray<Team>;

export type TeamsList403ResponseBody = BasicError;

export type TeamsListRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListRequestPath = { readonly org: string };

export type TeamOrganization = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly hooks_url: string;
  readonly issues_url: string;
  readonly members_url: string;
  readonly public_members_url: string;
  readonly avatar_url: string;
  readonly description: string | null;
  readonly name?: string;
  readonly company?: string;
  readonly blog?: string;
  readonly location?: string;
  readonly email?: string;
  readonly twitter_username?: string | null;
  readonly is_verified?: boolean;
  readonly has_organization_projects: boolean;
  readonly has_repository_projects: boolean;
  readonly public_repos: number;
  readonly public_gists: number;
  readonly followers: number;
  readonly following: number;
  readonly html_url: string;
  readonly created_at: string;
  readonly type: string;
  readonly total_private_repos?: number;
  readonly owned_private_repos?: number;
  readonly private_gists?: number | null;
  readonly disk_usage?: number | null;
  readonly collaborators?: number | null;
  readonly billing_email?: string | null;
  readonly plan?: {
    readonly name: string;
    readonly space: number;
    readonly private_repos: number;
    readonly filled_seats?: number;
    readonly seats?: number;
  };
  readonly default_repository_permission?: string | null;
  readonly members_can_create_repositories?: boolean | null;
  readonly two_factor_requirement_enabled?: boolean | null;
  readonly members_allowed_repository_creation_type?: string;
  readonly members_can_create_public_repositories?: boolean;
  readonly members_can_create_private_repositories?: boolean;
  readonly members_can_create_internal_repositories?: boolean;
  readonly members_can_create_pages?: boolean;
  readonly members_can_create_public_pages?: boolean;
  readonly members_can_create_private_pages?: boolean;
  readonly members_can_fork_private_repositories?: boolean | null;
  readonly web_commit_signoff_required?: boolean;
  readonly updated_at: string;
};

export type FullTeam = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly html_url: string;
  readonly name: string;
  readonly slug: string;
  readonly description: string | null;
  readonly privacy?: 'closed' | 'secret';
  readonly permission: string;
  readonly members_url: string;
  readonly repositories_url: string;
  readonly parent?: TeamSimple;
  readonly members_count: number;
  readonly repos_count: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly organization: TeamOrganization;
  readonly ldap_dn?: string;
};

export type TeamsCreate201ResponseBody = FullTeam;

export type TeamsCreate403ResponseBody = BasicError;

export type TeamsCreate422ResponseBody = ValidationError;

export type TeamsCreateRequestBody = {
  readonly name: string;
  readonly description?: string;
  readonly maintainers?: ReadonlyArray<string>;
  readonly repo_names?: ReadonlyArray<string>;
  readonly privacy?: 'secret' | 'closed';
  readonly permission?: 'pull' | 'push';
  readonly parent_team_id?: number;
};

export type TeamsCreateRequestPath = { readonly org: string };

export type TeamsGetByName200ResponseBody = FullTeam;

export type TeamsGetByName404ResponseBody = BasicError;

export type TeamsGetByNameRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamsUpdateInOrg200ResponseBody = FullTeam;

export type TeamsUpdateInOrg201ResponseBody = FullTeam;

export type TeamsUpdateInOrg403ResponseBody = BasicError;

export type TeamsUpdateInOrg404ResponseBody = BasicError;

export type TeamsUpdateInOrg422ResponseBody = ValidationError;

export type TeamsUpdateInOrgRequestBody = {
  readonly name?: string;
  readonly description?: string;
  readonly privacy?: 'secret' | 'closed';
  readonly permission?: 'pull' | 'push' | 'admin';
  readonly parent_team_id?: number | null;
};

export type TeamsUpdateInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamsDeleteInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamDiscussion = {
  readonly author: SimpleUser;
  readonly body: string;
  readonly body_html: string;
  readonly body_version: string;
  readonly comments_count: number;
  readonly comments_url: string;
  readonly created_at: string;
  readonly last_edited_at: string | null;
  readonly html_url: string;
  readonly node_id: string;
  readonly number: number;
  readonly pinned: boolean;
  readonly private: boolean;
  readonly team_url: string;
  readonly title: string;
  readonly updated_at: string;
  readonly url: string;
  readonly reactions?: ReactionRollup;
};

export type TeamsListDiscussionsInOrg200ResponseBody = ReadonlyArray<TeamDiscussion>;

export type TeamsListDiscussionsInOrgRequestQuery = {
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
  readonly pinned?: string;
};

export type TeamsListDiscussionsInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamsCreateDiscussionInOrg201ResponseBody = TeamDiscussion;

export type TeamsCreateDiscussionInOrgRequestBody = {
  readonly title: string;
  readonly body: string;
  readonly private?: boolean;
};

export type TeamsCreateDiscussionInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamsGetDiscussionInOrg200ResponseBody = TeamDiscussion;

export type TeamsGetDiscussionInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type TeamsUpdateDiscussionInOrg200ResponseBody = TeamDiscussion;

export type TeamsUpdateDiscussionInOrgRequestBody = {
  readonly title?: string;
  readonly body?: string;
};

export type TeamsUpdateDiscussionInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type TeamsDeleteDiscussionInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type TeamDiscussionComment = {
  readonly author: SimpleUser;
  readonly body: string;
  readonly body_html: string;
  readonly body_version: string;
  readonly created_at: string;
  readonly last_edited_at: string | null;
  readonly discussion_url: string;
  readonly html_url: string;
  readonly node_id: string;
  readonly number: number;
  readonly updated_at: string;
  readonly url: string;
  readonly reactions?: ReactionRollup;
};

export type TeamsListDiscussionCommentsInOrg200ResponseBody = ReadonlyArray<TeamDiscussionComment>;

export type TeamsListDiscussionCommentsInOrgRequestQuery = {
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListDiscussionCommentsInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type TeamsCreateDiscussionCommentInOrg201ResponseBody = TeamDiscussionComment;

export type TeamsCreateDiscussionCommentInOrgRequestBody = {
  readonly body: string;
};

export type TeamsCreateDiscussionCommentInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type TeamsGetDiscussionCommentInOrg200ResponseBody = TeamDiscussionComment;

export type TeamsGetDiscussionCommentInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type TeamsUpdateDiscussionCommentInOrg200ResponseBody = TeamDiscussionComment;

export type TeamsUpdateDiscussionCommentInOrgRequestBody = {
  readonly body: string;
};

export type TeamsUpdateDiscussionCommentInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type TeamsDeleteDiscussionCommentInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type Reaction = {
  readonly id: number;
  readonly node_id: string;
  readonly user: SimpleUser;
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly created_at: string;
};

export type ReactionsListForTeamDiscussionCommentInOrg200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForTeamDiscussionCommentInOrgRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForTeamDiscussionCommentInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type ReactionsCreateForTeamDiscussionCommentInOrg200ResponseBody = Reaction;

export type ReactionsCreateForTeamDiscussionCommentInOrg201ResponseBody = Reaction;

export type ReactionsCreateForTeamDiscussionCommentInOrgRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForTeamDiscussionCommentInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type ReactionsDeleteForTeamDiscussionCommentRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly comment_number: number;
  readonly reaction_id: number;
};

export type ReactionsListForTeamDiscussionInOrg200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForTeamDiscussionInOrgRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForTeamDiscussionInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type ReactionsCreateForTeamDiscussionInOrg200ResponseBody = Reaction;

export type ReactionsCreateForTeamDiscussionInOrg201ResponseBody = Reaction;

export type ReactionsCreateForTeamDiscussionInOrgRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForTeamDiscussionInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
};

export type ReactionsDeleteForTeamDiscussionRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly discussion_number: number;
  readonly reaction_id: number;
};

export type TeamsListPendingInvitationsInOrg200ResponseBody = ReadonlyArray<OrganizationInvitation>;

export type TeamsListPendingInvitationsInOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListPendingInvitationsInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamsListMembersInOrg200ResponseBody = ReadonlyArray<SimpleUser>;

export type TeamsListMembersInOrgRequestQuery = {
  readonly role?: 'member' | 'maintainer' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListMembersInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamMembership = {
  readonly url: string;
  readonly role: 'member' | 'maintainer';
  readonly state: 'active' | 'pending';
};

export type TeamsGetMembershipForUserInOrg200ResponseBody = TeamMembership;

export type TeamsGetMembershipForUserInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly username: string;
};

export type TeamsAddOrUpdateMembershipForUserInOrg200ResponseBody = TeamMembership;

export type TeamsAddOrUpdateMembershipForUserInOrgRequestBody = {
  readonly role?: 'member' | 'maintainer';
};

export type TeamsAddOrUpdateMembershipForUserInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly username: string;
};

export type TeamsRemoveMembershipForUserInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly username: string;
};

export type TeamProject = {
  readonly owner_url: string;
  readonly url: string;
  readonly html_url: string;
  readonly columns_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly body: string | null;
  readonly number: number;
  readonly state: string;
  readonly creator: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly organization_permission?: string;
  readonly private?: boolean;
  readonly permissions: {
    readonly read: boolean;
    readonly write: boolean;
    readonly admin: boolean;
  };
};

export type TeamsListProjectsInOrg200ResponseBody = ReadonlyArray<TeamProject>;

export type TeamsListProjectsInOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListProjectsInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamsCheckPermissionsForProjectInOrg200ResponseBody = TeamProject;

export type TeamsCheckPermissionsForProjectInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly project_id: number;
};

export type TeamsAddOrUpdateProjectPermissionsInOrg403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
};

export type TeamsAddOrUpdateProjectPermissionsInOrgRequestBody = {
  readonly permission?: 'read' | 'write' | 'admin';
} | null;

export type TeamsAddOrUpdateProjectPermissionsInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly project_id: number;
};

export type TeamsRemoveProjectInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly project_id: number;
};

export type TeamsListReposInOrg200ResponseBody = ReadonlyArray<MinimalRepository>;

export type TeamsListReposInOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListReposInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type TeamRepository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly license: LicenseSimple;
  readonly forks: number;
  readonly permissions?: {
    readonly admin: boolean;
    readonly pull: boolean;
    readonly triage?: boolean;
    readonly push: boolean;
    readonly maintain?: boolean;
  };
  readonly role_name?: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly git_url: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly ssh_url: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly clone_url: string;
  readonly mirror_url: string | null;
  readonly hooks_url: string;
  readonly svn_url: string;
  readonly homepage: string | null;
  readonly language: string | null;
  readonly forks_count: number;
  readonly stargazers_count: number;
  readonly watchers_count: number;
  readonly size: number;
  readonly default_branch: string;
  readonly open_issues_count: number;
  readonly is_template?: boolean;
  readonly topics?: ReadonlyArray<string>;
  readonly has_issues: boolean;
  readonly has_projects: boolean;
  readonly has_wiki: boolean;
  readonly has_pages: boolean;
  readonly has_downloads: boolean;
  readonly archived: boolean;
  readonly disabled: boolean;
  readonly visibility?: string;
  readonly pushed_at: string | null;
  readonly created_at: string | null;
  readonly updated_at: string | null;
  readonly allow_rebase_merge?: boolean;
  readonly template_repository?: Repository;
  readonly temp_clone_token?: string;
  readonly allow_squash_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_merge_commit?: boolean;
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
  readonly subscribers_count?: number;
  readonly network_count?: number;
  readonly open_issues: number;
  readonly watchers: number;
  readonly master_branch?: string;
};

export type TeamsCheckPermissionsForRepoInOrg200ResponseBody = TeamRepository;

export type TeamsCheckPermissionsForRepoInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly owner: string;
  readonly repo: string;
};

export type TeamsAddOrUpdateRepoPermissionsInOrgRequestBody = {
  readonly permission?: string;
};

export type TeamsAddOrUpdateRepoPermissionsInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly owner: string;
  readonly repo: string;
};

export type TeamsRemoveRepoInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
  readonly owner: string;
  readonly repo: string;
};

export type TeamsListChildInOrg200ResponseBody = ReadonlyArray<Team>;

export type TeamsListChildInOrgRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListChildInOrgRequestPath = {
  readonly org: string;
  readonly team_slug: string;
};

export type OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestPath = {
  readonly org: string;
  readonly security_product:
    | 'dependency_graph'
    | 'dependabot_alerts'
    | 'dependabot_security_updates'
    | 'advanced_security'
    | 'secret_scanning'
    | 'secret_scanning_push_protection';
  readonly enablement: 'enable_all' | 'disable_all';
};

export type ProjectCard = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly note: string | null;
  readonly creator: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly archived?: boolean;
  readonly column_name?: string;
  readonly project_id?: string;
  readonly column_url: string;
  readonly content_url?: string;
  readonly project_url: string;
};

export type ProjectsGetCard200ResponseBody = ProjectCard;

export type ProjectsGetCard401ResponseBody = BasicError;

export type ProjectsGetCard403ResponseBody = BasicError;

export type ProjectsGetCard404ResponseBody = BasicError;

export type ProjectsGetCardRequestPath = { readonly card_id: number };

export type ProjectsUpdateCard200ResponseBody = ProjectCard;

export type ProjectsUpdateCard401ResponseBody = BasicError;

export type ProjectsUpdateCard403ResponseBody = BasicError;

export type ProjectsUpdateCard404ResponseBody = BasicError;

export type ProjectsUpdateCard422ResponseBody = ValidationErrorSimple;

export type ProjectsUpdateCardRequestBody = {
  readonly note?: string | null;
  readonly archived?: boolean;
};

export type ProjectsUpdateCardRequestPath = { readonly card_id: number };

export type ProjectsDeleteCard401ResponseBody = BasicError;

export type ProjectsDeleteCard403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
  readonly errors?: ReadonlyArray<string>;
};

export type ProjectsDeleteCard404ResponseBody = BasicError;

export type ProjectsDeleteCardRequestPath = { readonly card_id: number };

export type ProjectsMoveCard201ResponseBody = {};

export type ProjectsMoveCard401ResponseBody = BasicError;

export type ProjectsMoveCard403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
  readonly errors?: ReadonlyArray<{
    readonly code?: string;
    readonly message?: string;
    readonly resource?: string;
    readonly field?: string;
  }>;
};

export type ProjectsMoveCard422ResponseBody = ValidationError;

export type ProjectsMoveCard503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
  readonly errors?: ReadonlyArray<{
    readonly code?: string;
    readonly message?: string;
  }>;
};

export type ProjectsMoveCardRequestBody = {
  readonly position: string;
  readonly column_id?: number;
};

export type ProjectsMoveCardRequestPath = { readonly card_id: number };

export type ProjectColumn = {
  readonly url: string;
  readonly project_url: string;
  readonly cards_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
};

export type ProjectsGetColumn200ResponseBody = ProjectColumn;

export type ProjectsGetColumn401ResponseBody = BasicError;

export type ProjectsGetColumn403ResponseBody = BasicError;

export type ProjectsGetColumn404ResponseBody = BasicError;

export type ProjectsGetColumnRequestPath = { readonly column_id: number };

export type ProjectsUpdateColumn200ResponseBody = ProjectColumn;

export type ProjectsUpdateColumn401ResponseBody = BasicError;

export type ProjectsUpdateColumn403ResponseBody = BasicError;

export type ProjectsUpdateColumnRequestBody = { readonly name: string };

export type ProjectsUpdateColumnRequestPath = { readonly column_id: number };

export type ProjectsDeleteColumn401ResponseBody = BasicError;

export type ProjectsDeleteColumn403ResponseBody = BasicError;

export type ProjectsDeleteColumnRequestPath = { readonly column_id: number };

export type ProjectsListCards200ResponseBody = ReadonlyArray<ProjectCard>;

export type ProjectsListCards401ResponseBody = BasicError;

export type ProjectsListCards403ResponseBody = BasicError;

export type ProjectsListCardsRequestQuery = {
  readonly archived_state?: 'all' | 'archived' | 'not_archived';
  readonly per_page?: number;
  readonly page?: number;
};

export type ProjectsListCardsRequestPath = { readonly column_id: number };

export type ProjectsCreateCard201ResponseBody = ProjectCard;

export type ProjectsCreateCard401ResponseBody = BasicError;

export type ProjectsCreateCard403ResponseBody = BasicError;

export type ProjectsCreateCard422ResponseBody =
  | ValidationError
  | ValidationErrorSimple;

export type ProjectsCreateCard503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
  readonly errors?: ReadonlyArray<{
    readonly code?: string;
    readonly message?: string;
  }>;
};

export type ProjectsCreateCardRequestBody =
  | { readonly note: string | null }
  | { readonly content_id: number; readonly content_type: string };

export type ProjectsCreateCardRequestPath = { readonly column_id: number };

export type ProjectsMoveColumn201ResponseBody = {};

export type ProjectsMoveColumn401ResponseBody = BasicError;

export type ProjectsMoveColumn403ResponseBody = BasicError;

export type ProjectsMoveColumn422ResponseBody = ValidationErrorSimple;

export type ProjectsMoveColumnRequestBody = { readonly position: string };

export type ProjectsMoveColumnRequestPath = { readonly column_id: number };

export type ProjectsGet200ResponseBody = Project;

export type ProjectsGet401ResponseBody = BasicError;

export type ProjectsGet403ResponseBody = BasicError;

export type ProjectsGetRequestPath = { readonly project_id: number };

export type ProjectsUpdate200ResponseBody = Project;

export type ProjectsUpdate401ResponseBody = BasicError;

export type ProjectsUpdate403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
  readonly errors?: ReadonlyArray<string>;
};

export type ProjectsUpdate410ResponseBody = BasicError;

export type ProjectsUpdate422ResponseBody = ValidationErrorSimple;

export type ProjectsUpdateRequestBody = {
  readonly name?: string;
  readonly body?: string | null;
  readonly state?: string;
  readonly organization_permission?: 'read' | 'write' | 'admin' | 'none';
  readonly private?: boolean;
};

export type ProjectsUpdateRequestPath = { readonly project_id: number };

export type ProjectsDelete401ResponseBody = BasicError;

export type ProjectsDelete403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
  readonly errors?: ReadonlyArray<string>;
};

export type ProjectsDelete404ResponseBody = BasicError;

export type ProjectsDelete410ResponseBody = BasicError;

export type ProjectsDeleteRequestPath = { readonly project_id: number };

export type ProjectsListCollaborators200ResponseBody = ReadonlyArray<SimpleUser>;

export type ProjectsListCollaborators401ResponseBody = BasicError;

export type ProjectsListCollaborators403ResponseBody = BasicError;

export type ProjectsListCollaborators404ResponseBody = BasicError;

export type ProjectsListCollaborators422ResponseBody = ValidationError;

export type ProjectsListCollaboratorsRequestQuery = {
  readonly affiliation?: 'outside' | 'direct' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type ProjectsListCollaboratorsRequestPath = {
  readonly project_id: number;
};

export type ProjectsAddCollaborator401ResponseBody = BasicError;

export type ProjectsAddCollaborator403ResponseBody = BasicError;

export type ProjectsAddCollaborator404ResponseBody = BasicError;

export type ProjectsAddCollaborator422ResponseBody = ValidationError;

export type ProjectsAddCollaboratorRequestBody = {
  readonly permission?: 'read' | 'write' | 'admin';
} | null;

export type ProjectsAddCollaboratorRequestPath = {
  readonly project_id: number;
  readonly username: string;
};

export type ProjectsRemoveCollaborator401ResponseBody = BasicError;

export type ProjectsRemoveCollaborator403ResponseBody = BasicError;

export type ProjectsRemoveCollaborator404ResponseBody = BasicError;

export type ProjectsRemoveCollaborator422ResponseBody = ValidationError;

export type ProjectsRemoveCollaboratorRequestPath = {
  readonly project_id: number;
  readonly username: string;
};

export type ProjectCollaboratorPermission = {
  readonly permission: string;
  readonly user: SimpleUser;
};

export type ProjectsGetPermissionForUser200ResponseBody = ProjectCollaboratorPermission;

export type ProjectsGetPermissionForUser401ResponseBody = BasicError;

export type ProjectsGetPermissionForUser403ResponseBody = BasicError;

export type ProjectsGetPermissionForUser404ResponseBody = BasicError;

export type ProjectsGetPermissionForUser422ResponseBody = ValidationError;

export type ProjectsGetPermissionForUserRequestPath = {
  readonly project_id: number;
  readonly username: string;
};

export type ProjectsListColumns200ResponseBody = ReadonlyArray<ProjectColumn>;

export type ProjectsListColumns401ResponseBody = BasicError;

export type ProjectsListColumns403ResponseBody = BasicError;

export type ProjectsListColumnsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ProjectsListColumnsRequestPath = { readonly project_id: number };

export type ProjectsCreateColumn201ResponseBody = ProjectColumn;

export type ProjectsCreateColumn401ResponseBody = BasicError;

export type ProjectsCreateColumn403ResponseBody = BasicError;

export type ProjectsCreateColumn422ResponseBody = ValidationErrorSimple;

export type ProjectsCreateColumnRequestBody = { readonly name: string };

export type ProjectsCreateColumnRequestPath = { readonly project_id: number };

export type RateLimit = {
  readonly limit: number;
  readonly remaining: number;
  readonly reset: number;
  readonly used: number;
};

export type RateLimitOverview = {
  readonly resources: {
    readonly core: RateLimit;
    readonly graphql?: RateLimit;
    readonly search: RateLimit;
    readonly source_import?: RateLimit;
    readonly integration_manifest?: RateLimit;
    readonly code_scanning_upload?: RateLimit;
    readonly actions_runner_registration?: RateLimit;
    readonly scim?: RateLimit;
    readonly dependency_snapshots?: RateLimit;
  };
  readonly rate: RateLimit;
};

export type RateLimitGet200ResponseBody = RateLimitOverview;

export type RateLimitGet404ResponseBody = BasicError;

export type CodeOfConductSimple = {
  readonly url: string;
  readonly key: string;
  readonly name: string;
  readonly html_url: string | null;
};

export type SecurityAndAnalysis = {
  readonly advanced_security?: { readonly status?: 'enabled' | 'disabled' };
  readonly secret_scanning?: { readonly status?: 'enabled' | 'disabled' };
  readonly secret_scanning_push_protection?: {
    readonly status?: 'enabled' | 'disabled';
  };
} | null;

export type FullRepository = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly archive_url: string;
  readonly assignees_url: string;
  readonly blobs_url: string;
  readonly branches_url: string;
  readonly collaborators_url: string;
  readonly comments_url: string;
  readonly commits_url: string;
  readonly compare_url: string;
  readonly contents_url: string;
  readonly contributors_url: string;
  readonly deployments_url: string;
  readonly downloads_url: string;
  readonly events_url: string;
  readonly forks_url: string;
  readonly git_commits_url: string;
  readonly git_refs_url: string;
  readonly git_tags_url: string;
  readonly git_url: string;
  readonly issue_comment_url: string;
  readonly issue_events_url: string;
  readonly issues_url: string;
  readonly keys_url: string;
  readonly labels_url: string;
  readonly languages_url: string;
  readonly merges_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly pulls_url: string;
  readonly releases_url: string;
  readonly ssh_url: string;
  readonly stargazers_url: string;
  readonly statuses_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly tags_url: string;
  readonly teams_url: string;
  readonly trees_url: string;
  readonly clone_url: string;
  readonly mirror_url: string | null;
  readonly hooks_url: string;
  readonly svn_url: string;
  readonly homepage: string | null;
  readonly language: string | null;
  readonly forks_count: number;
  readonly stargazers_count: number;
  readonly watchers_count: number;
  readonly size: number;
  readonly default_branch: string;
  readonly open_issues_count: number;
  readonly is_template?: boolean;
  readonly topics?: ReadonlyArray<string>;
  readonly has_issues: boolean;
  readonly has_projects: boolean;
  readonly has_wiki: boolean;
  readonly has_pages: boolean;
  readonly has_downloads: boolean;
  readonly archived: boolean;
  readonly disabled: boolean;
  readonly visibility?: string;
  readonly pushed_at: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly permissions?: {
    readonly admin: boolean;
    readonly maintain?: boolean;
    readonly push: boolean;
    readonly triage?: boolean;
    readonly pull: boolean;
  };
  readonly allow_rebase_merge?: boolean;
  readonly template_repository?: Repository;
  readonly temp_clone_token?: string | null;
  readonly allow_squash_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_merge_commit?: boolean;
  readonly allow_update_branch?: boolean;
  readonly use_squash_pr_title_as_default?: boolean;
  readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
  readonly squash_merge_commit_message?:
    | 'PR_BODY'
    | 'COMMIT_MESSAGES'
    | 'BLANK';
  readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
  readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
  readonly subscribers_count: number;
  readonly network_count: number;
  readonly license: LicenseSimple;
  readonly organization?: SimpleUser;
  readonly parent?: Repository;
  readonly source?: Repository;
  readonly forks: number;
  readonly master_branch?: string;
  readonly open_issues: number;
  readonly watchers: number;
  readonly anonymous_access_enabled?: boolean;
  readonly code_of_conduct?: CodeOfConductSimple;
  readonly security_and_analysis?: SecurityAndAnalysis;
};

export type ReposGet200ResponseBody = FullRepository;

export type ReposGet301ResponseBody = BasicError;

export type ReposGet403ResponseBody = BasicError;

export type ReposGet404ResponseBody = BasicError;

export type ReposGetRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposUpdate200ResponseBody = FullRepository;

export type ReposUpdate307ResponseBody = BasicError;

export type ReposUpdate403ResponseBody = BasicError;

export type ReposUpdate404ResponseBody = BasicError;

export type ReposUpdate422ResponseBody = ValidationError;

export type ReposUpdateRequestBody = {
  readonly name?: string;
  readonly description?: string;
  readonly homepage?: string;
  readonly private?: boolean;
  readonly visibility?: 'public' | 'private' | 'internal';
  readonly security_and_analysis?: {
    readonly advanced_security?: { readonly status?: string };
    readonly secret_scanning?: { readonly status?: string };
    readonly secret_scanning_push_protection?: { readonly status?: string };
  } | null;
  readonly has_issues?: boolean;
  readonly has_projects?: boolean;
  readonly has_wiki?: boolean;
  readonly is_template?: boolean;
  readonly default_branch?: string;
  readonly allow_squash_merge?: boolean;
  readonly allow_merge_commit?: boolean;
  readonly allow_rebase_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_update_branch?: boolean;
  readonly use_squash_pr_title_as_default?: boolean;
  readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
  readonly squash_merge_commit_message?:
    | 'PR_BODY'
    | 'COMMIT_MESSAGES'
    | 'BLANK';
  readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
  readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
  readonly archived?: boolean;
  readonly allow_forking?: boolean;
  readonly web_commit_signoff_required?: boolean;
};

export type ReposUpdateRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDelete307ResponseBody = BasicError;

export type ReposDelete403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
};

export type ReposDelete404ResponseBody = BasicError;

export type ReposDeleteRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type Artifact = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly size_in_bytes: number;
  readonly url: string;
  readonly archive_download_url: string;
  readonly expired: boolean;
  readonly created_at: string | null;
  readonly expires_at: string | null;
  readonly updated_at: string | null;
  readonly workflow_run?: {
    readonly id?: number;
    readonly repository_id?: number;
    readonly head_repository_id?: number;
    readonly head_branch?: string;
    readonly head_sha?: string;
  } | null;
};

export type ActionsListArtifactsForRepo200ResponseBody = {
  readonly total_count: number;
  readonly artifacts: ReadonlyArray<Artifact>;
};

export type ActionsListArtifactsForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly name?: string;
};

export type ActionsListArtifactsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetArtifact200ResponseBody = Artifact;

export type ActionsGetArtifactRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly artifact_id: number;
};

export type ActionsDeleteArtifactRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly artifact_id: number;
};

export type ActionsDownloadArtifact410ResponseBody = BasicError;

export type ActionsDownloadArtifactRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly artifact_id: number;
  readonly archive_format: string;
};

export type ActionsGetActionsCacheUsage200ResponseBody = ActionsCacheUsageByRepository;

export type ActionsGetActionsCacheUsageRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type RepositoryActionsCaches = {
  readonly total_count: number;
  readonly actions_caches: ReadonlyArray<{
    readonly id?: number;
    readonly ref?: string;
    readonly key?: string;
    readonly version?: string;
    readonly last_accessed_at?: string;
    readonly created_at?: string;
    readonly size_in_bytes?: number;
  }>;
};

export type ActionsGetActionsCacheList200ResponseBody = RepositoryActionsCaches;

export type ActionsGetActionsCacheListRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly ref?: CodeScanningRef;
  readonly key?: string;
  readonly sort?: 'created_at' | 'last_accessed_at' | 'size_in_bytes';
  readonly direction?: 'asc' | 'desc';
};

export type ActionsGetActionsCacheListRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsDeleteActionsCacheByKey200ResponseBody = RepositoryActionsCaches;

export type ActionsDeleteActionsCacheByKeyRequestQuery = {
  readonly key: string;
  readonly ref?: CodeScanningRef;
};

export type ActionsDeleteActionsCacheByKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsDeleteActionsCacheByIdRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly cache_id: number;
};

export type Job = {
  readonly id: number;
  readonly run_id: number;
  readonly run_url: string;
  readonly run_attempt?: number;
  readonly node_id: string;
  readonly head_sha: string;
  readonly url: string;
  readonly html_url: string | null;
  readonly status: 'queued' | 'in_progress' | 'completed';
  readonly conclusion:
    | 'success'
    | 'failure'
    | 'neutral'
    | 'cancelled'
    | 'skipped'
    | 'timed_out'
    | 'action_required'
    | null;
  readonly started_at: string;
  readonly completed_at: string | null;
  readonly name: string;
  readonly steps?: ReadonlyArray<{
    readonly status: 'queued' | 'in_progress' | 'completed';
    readonly conclusion: string | null;
    readonly name: string;
    readonly number: number;
    readonly started_at?: string | null;
    readonly completed_at?: string | null;
  }>;
  readonly check_run_url: string;
  readonly labels: ReadonlyArray<string>;
  readonly runner_id: number | null;
  readonly runner_name: string | null;
  readonly runner_group_id: number | null;
  readonly runner_group_name: string | null;
};

export type ActionsGetJobForWorkflowRun200ResponseBody = Job;

export type ActionsGetJobForWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly job_id: number;
};

export type ActionsDownloadJobLogsForWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly job_id: number;
};

export type ActionsReRunJobForWorkflowRun201ResponseBody = EmptyObject;

export type ActionsReRunJobForWorkflowRun403ResponseBody = BasicError;

export type ActionsReRunJobForWorkflowRunRequestBody = {
  readonly enable_debug_logging?: boolean;
} | null;

export type ActionsReRunJobForWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly job_id: number;
};

export type ActionsEnabled = boolean;

export type ActionsRepositoryPermissions = {
  readonly enabled: ActionsEnabled;
  readonly allowed_actions?: AllowedActions;
  readonly selected_actions_url?: SelectedActionsUrl;
};

export type ActionsGetGithubActionsPermissionsRepository200ResponseBody = ActionsRepositoryPermissions;

export type ActionsGetGithubActionsPermissionsRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsSetGithubActionsPermissionsRepositoryRequestBody = {
  readonly enabled: ActionsEnabled;
  readonly allowed_actions?: AllowedActions;
};

export type ActionsSetGithubActionsPermissionsRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsWorkflowAccessToRepository = {
  readonly access_level: 'none' | 'organization' | 'enterprise';
};

export type ActionsGetWorkflowAccessToRepository200ResponseBody = ActionsWorkflowAccessToRepository;

export type ActionsGetWorkflowAccessToRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsSetWorkflowAccessToRepositoryRequestBody = ActionsWorkflowAccessToRepository;

export type ActionsSetWorkflowAccessToRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetAllowedActionsRepository200ResponseBody = SelectedActions;

export type ActionsGetAllowedActionsRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsSetAllowedActionsRepositoryRequestBody = SelectedActions;

export type ActionsSetAllowedActionsRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepository200ResponseBody = ActionsGetDefaultWorkflowPermissions;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequestBody = ActionsSetDefaultWorkflowPermissions;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsListSelfHostedRunnersForRepo200ResponseBody = {
  readonly total_count: number;
  readonly runners: ReadonlyArray<SelfHostedRunners>;
};

export type ActionsListSelfHostedRunnersForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListSelfHostedRunnersForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsListRunnerApplicationsForRepo200ResponseBody = ReadonlyArray<RunnerApplication>;

export type ActionsListRunnerApplicationsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsCreateRegistrationTokenForRepo201ResponseBody = AuthenticationToken;

export type ActionsCreateRegistrationTokenForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsCreateRemoveTokenForRepo201ResponseBody = AuthenticationToken;

export type ActionsCreateRemoveTokenForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetSelfHostedRunnerForRepo200ResponseBody = SelfHostedRunners;

export type ActionsGetSelfHostedRunnerForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
};

export type ActionsDeleteSelfHostedRunnerFromRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
};

export type ActionsListLabelsForSelfHostedRunnerForRepo200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsListLabelsForSelfHostedRunnerForRepo404ResponseBody = BasicError;

export type ActionsListLabelsForSelfHostedRunnerForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
};

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepo200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepo404ResponseBody = BasicError;

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepo422ResponseBody = ValidationErrorSimple;

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestBody = {
  readonly labels: ReadonlyArray<string>;
};

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
};

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepo200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepo404ResponseBody = BasicError;

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepo422ResponseBody = ValidationErrorSimple;

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestBody = {
  readonly labels: ReadonlyArray<string>;
};

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
};

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo404ResponseBody = BasicError;

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
};

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo200ResponseBody = {
  readonly total_count: number;
  readonly labels: ReadonlyArray<SelfHostedRunnerLabel>;
};

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo404ResponseBody = BasicError;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo422ResponseBody = ValidationErrorSimple;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly runner_id: number;
  readonly name: string;
};

export type ReferencedWorkflow = {
  readonly path: string;
  readonly sha: string;
  readonly ref?: string;
};

export type PullRequestMinimal = {
  readonly id: number;
  readonly number: number;
  readonly url: string;
  readonly head: {
    readonly ref: string;
    readonly sha: string;
    readonly repo: {
      readonly id: number;
      readonly url: string;
      readonly name: string;
    };
  };
  readonly base: {
    readonly ref: string;
    readonly sha: string;
    readonly repo: {
      readonly id: number;
      readonly url: string;
      readonly name: string;
    };
  };
};

export type SimpleCommit = {
  readonly id: string;
  readonly tree_id: string;
  readonly message: string;
  readonly timestamp: string;
  readonly author: { readonly name: string; readonly email: string } | null;
  readonly committer: { readonly name: string; readonly email: string } | null;
} | null;

export type WorkflowRun = {
  readonly id: number;
  readonly name?: string | null;
  readonly node_id: string;
  readonly check_suite_id?: number;
  readonly check_suite_node_id?: string;
  readonly head_branch: string | null;
  readonly head_sha: string;
  readonly path: string;
  readonly run_number: number;
  readonly run_attempt?: number;
  readonly referenced_workflows?: ReadonlyArray<ReferencedWorkflow> | null;
  readonly event: string;
  readonly status: string | null;
  readonly conclusion: string | null;
  readonly workflow_id: number;
  readonly url: string;
  readonly html_url: string;
  readonly pull_requests: ReadonlyArray<PullRequestMinimal> | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly actor?: SimpleUser;
  readonly triggering_actor?: SimpleUser;
  readonly run_started_at?: string;
  readonly jobs_url: string;
  readonly logs_url: string;
  readonly check_suite_url: string;
  readonly artifacts_url: string;
  readonly cancel_url: string;
  readonly rerun_url: string;
  readonly previous_attempt_url?: string | null;
  readonly workflow_url: string;
  readonly head_commit: SimpleCommit;
  readonly repository: MinimalRepository;
  readonly head_repository: MinimalRepository;
  readonly head_repository_id?: number;
  readonly display_title: string;
};

export type ActionsListWorkflowRunsForRepo200ResponseBody = {
  readonly total_count: number;
  readonly workflow_runs: ReadonlyArray<WorkflowRun>;
};

export type ActionsListWorkflowRunsForRepoRequestQuery = {
  readonly actor?: string;
  readonly branch?: string;
  readonly event?: string;
  readonly status?:
    | 'completed'
    | 'action_required'
    | 'cancelled'
    | 'failure'
    | 'neutral'
    | 'skipped'
    | 'stale'
    | 'success'
    | 'timed_out'
    | 'in_progress'
    | 'queued'
    | 'requested'
    | 'waiting';
  readonly per_page?: number;
  readonly page?: number;
  readonly created?: string;
  readonly exclude_pull_requests?: boolean;
  readonly check_suite_id?: number;
  readonly head_sha?: string;
};

export type ActionsListWorkflowRunsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetWorkflowRun200ResponseBody = WorkflowRun;

export type ActionsGetWorkflowRunRequestQuery = {
  readonly exclude_pull_requests?: boolean;
};

export type ActionsGetWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsDeleteWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type EnvironmentApproval = {
  readonly environments: ReadonlyArray<{
    readonly id?: number;
    readonly node_id?: string;
    readonly name?: string;
    readonly url?: string;
    readonly html_url?: string;
    readonly created_at?: string;
    readonly updated_at?: string;
  }>;
  readonly state: 'approved' | 'rejected';
  readonly user: SimpleUser;
  readonly comment: string;
};

export type ActionsGetReviewsForRun200ResponseBody = ReadonlyArray<EnvironmentApproval>;

export type ActionsGetReviewsForRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsApproveWorkflowRun201ResponseBody = EmptyObject;

export type ActionsApproveWorkflowRun403ResponseBody = BasicError;

export type ActionsApproveWorkflowRun404ResponseBody = BasicError;

export type ActionsApproveWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsListWorkflowRunArtifacts200ResponseBody = {
  readonly total_count: number;
  readonly artifacts: ReadonlyArray<Artifact>;
};

export type ActionsListWorkflowRunArtifactsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListWorkflowRunArtifactsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsGetWorkflowRunAttempt200ResponseBody = WorkflowRun;

export type ActionsGetWorkflowRunAttemptRequestQuery = {
  readonly exclude_pull_requests?: boolean;
};

export type ActionsGetWorkflowRunAttemptRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
  readonly attempt_number: number;
};

export type ActionsListJobsForWorkflowRunAttempt200ResponseBody = {
  readonly total_count: number;
  readonly jobs: ReadonlyArray<Job>;
};

export type ActionsListJobsForWorkflowRunAttempt404ResponseBody = BasicError;

export type ActionsListJobsForWorkflowRunAttemptRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListJobsForWorkflowRunAttemptRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
  readonly attempt_number: number;
};

export type ActionsDownloadWorkflowRunAttemptLogsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
  readonly attempt_number: number;
};

export type ActionsCancelWorkflowRun202ResponseBody = EmptyObject;

export type ActionsCancelWorkflowRun409ResponseBody = BasicError;

export type ActionsCancelWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsListJobsForWorkflowRun200ResponseBody = {
  readonly total_count: number;
  readonly jobs: ReadonlyArray<Job>;
};

export type ActionsListJobsForWorkflowRunRequestQuery = {
  readonly filter?: 'latest' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListJobsForWorkflowRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsDownloadWorkflowRunLogsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsDeleteWorkflowRunLogs403ResponseBody = BasicError;

export type ActionsDeleteWorkflowRunLogs500ResponseBody = BasicError;

export type ActionsDeleteWorkflowRunLogsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type DeploymentReviewerType = 'User' | 'Team';

export type PendingDeployment = {
  readonly environment: {
    readonly id?: number;
    readonly node_id?: string;
    readonly name?: string;
    readonly url?: string;
    readonly html_url?: string;
  };
  readonly wait_timer: number;
  readonly wait_timer_started_at: string | null;
  readonly current_user_can_approve: boolean;
  readonly reviewers: ReadonlyArray<{
    readonly type?: DeploymentReviewerType;
    readonly reviewer?: SimpleUser | Team;
  }>;
};

export type ActionsGetPendingDeploymentsForRun200ResponseBody = ReadonlyArray<PendingDeployment>;

export type ActionsGetPendingDeploymentsForRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type Deployment = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly sha: string;
  readonly ref: string;
  readonly task: string;
  readonly payload: unknown | string;
  readonly original_environment?: string;
  readonly environment: string;
  readonly description: string | null;
  readonly creator: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly statuses_url: string;
  readonly repository_url: string;
  readonly transient_environment?: boolean;
  readonly production_environment?: boolean;
  readonly performed_via_github_app?: GitHubApp;
};

export type ActionsReviewPendingDeploymentsForRun200ResponseBody = ReadonlyArray<Deployment>;

export type ActionsReviewPendingDeploymentsForRunRequestBody = {
  readonly environment_ids: ReadonlyArray<number>;
  readonly state: 'approved' | 'rejected';
  readonly comment: string;
};

export type ActionsReviewPendingDeploymentsForRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsReRunWorkflow201ResponseBody = EmptyObject;

export type ActionsReRunWorkflowRequestBody = {
  readonly enable_debug_logging?: boolean;
} | null;

export type ActionsReRunWorkflowRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsReRunWorkflowFailedJobs201ResponseBody = EmptyObject;

export type ActionsReRunWorkflowFailedJobsRequestBody = {
  readonly enable_debug_logging?: boolean;
} | null;

export type ActionsReRunWorkflowFailedJobsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type WorkflowRunUsage = {
  readonly billable: {
    readonly UBUNTU?: {
      readonly total_ms: number;
      readonly jobs: number;
      readonly job_runs?: ReadonlyArray<{
        readonly job_id: number;
        readonly duration_ms: number;
      }>;
    };
    readonly MACOS?: {
      readonly total_ms: number;
      readonly jobs: number;
      readonly job_runs?: ReadonlyArray<{
        readonly job_id: number;
        readonly duration_ms: number;
      }>;
    };
    readonly WINDOWS?: {
      readonly total_ms: number;
      readonly jobs: number;
      readonly job_runs?: ReadonlyArray<{
        readonly job_id: number;
        readonly duration_ms: number;
      }>;
    };
  };
  readonly run_duration_ms?: number;
};

export type ActionsGetWorkflowRunUsage200ResponseBody = WorkflowRunUsage;

export type ActionsGetWorkflowRunUsageRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly run_id: number;
};

export type ActionsSecret = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
};

export type ActionsListRepoSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<ActionsSecret>;
};

export type ActionsListRepoSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListRepoSecretsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetRepoPublicKey200ResponseBody = ActionsPublicKey;

export type ActionsGetRepoPublicKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetRepoSecret200ResponseBody = ActionsSecret;

export type ActionsGetRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type ActionsCreateOrUpdateRepoSecret201ResponseBody = EmptyObject;

export type ActionsCreateOrUpdateRepoSecretRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id?: string;
};

export type ActionsCreateOrUpdateRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type ActionsDeleteRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type Workflow = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly path: string;
  readonly state:
    | 'active'
    | 'deleted'
    | 'disabled_fork'
    | 'disabled_inactivity'
    | 'disabled_manually';
  readonly created_at: string;
  readonly updated_at: string;
  readonly url: string;
  readonly html_url: string;
  readonly badge_url: string;
  readonly deleted_at?: string;
};

export type ActionsListRepoWorkflows200ResponseBody = {
  readonly total_count: number;
  readonly workflows: ReadonlyArray<Workflow>;
};

export type ActionsListRepoWorkflowsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListRepoWorkflowsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActionsGetWorkflow200ResponseBody = Workflow;

export type ActionsGetWorkflowRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly workflow_id: number | string;
};

export type ActionsDisableWorkflowRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly workflow_id: number | string;
};

export type ActionsCreateWorkflowDispatchRequestBody = {
  readonly ref: string;
  readonly inputs?: unknown;
};

export type ActionsCreateWorkflowDispatchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly workflow_id: number | string;
};

export type ActionsEnableWorkflowRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly workflow_id: number | string;
};

export type ActionsListWorkflowRuns200ResponseBody = {
  readonly total_count: number;
  readonly workflow_runs: ReadonlyArray<WorkflowRun>;
};

export type ActionsListWorkflowRunsRequestQuery = {
  readonly actor?: string;
  readonly branch?: string;
  readonly event?: string;
  readonly status?:
    | 'completed'
    | 'action_required'
    | 'cancelled'
    | 'failure'
    | 'neutral'
    | 'skipped'
    | 'stale'
    | 'success'
    | 'timed_out'
    | 'in_progress'
    | 'queued'
    | 'requested'
    | 'waiting';
  readonly per_page?: number;
  readonly page?: number;
  readonly created?: string;
  readonly exclude_pull_requests?: boolean;
  readonly check_suite_id?: number;
  readonly head_sha?: string;
};

export type ActionsListWorkflowRunsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly workflow_id: number | string;
};

export type WorkflowUsage = {
  readonly billable: {
    readonly UBUNTU?: { readonly total_ms?: number };
    readonly MACOS?: { readonly total_ms?: number };
    readonly WINDOWS?: { readonly total_ms?: number };
  };
};

export type ActionsGetWorkflowUsage200ResponseBody = WorkflowUsage;

export type ActionsGetWorkflowUsageRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly workflow_id: number | string;
};

export type IssuesListAssignees200ResponseBody = ReadonlyArray<SimpleUser>;

export type IssuesListAssignees404ResponseBody = BasicError;

export type IssuesListAssigneesRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListAssigneesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesCheckUserCanBeAssigned404ResponseBody = BasicError;

export type IssuesCheckUserCanBeAssignedRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly assignee: string;
};

export type AutolinkReference = {
  readonly id: number;
  readonly key_prefix: string;
  readonly url_template: string;
  readonly is_alphanumeric: boolean;
};

export type ReposListAutolinks200ResponseBody = ReadonlyArray<AutolinkReference>;

export type ReposListAutolinksRequestQuery = { readonly page?: number };

export type ReposListAutolinksRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateAutolink201ResponseBody = AutolinkReference;

export type ReposCreateAutolink422ResponseBody = ValidationError;

export type ReposCreateAutolinkRequestBody = {
  readonly key_prefix: string;
  readonly url_template: string;
  readonly is_alphanumeric?: boolean;
};

export type ReposCreateAutolinkRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetAutolink200ResponseBody = AutolinkReference;

export type ReposGetAutolink404ResponseBody = BasicError;

export type ReposGetAutolinkRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly autolink_id: number;
};

export type ReposDeleteAutolink404ResponseBody = BasicError;

export type ReposDeleteAutolinkRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly autolink_id: number;
};

export type ReposEnableAutomatedSecurityFixesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDisableAutomatedSecurityFixesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ProtectedBranchRequiredStatusCheck = {
  readonly url?: string;
  readonly enforcement_level?: string;
  readonly contexts: ReadonlyArray<string>;
  readonly checks: ReadonlyArray<{
    readonly context: string;
    readonly app_id: number | null;
  }>;
  readonly contexts_url?: string;
  readonly strict?: boolean;
};

export type ProtectedBranchAdminEnforced = {
  readonly url: string;
  readonly enabled: boolean;
};

export type ProtectedBranchPullRequestReview = {
  readonly url?: string;
  readonly dismissal_restrictions?: {
    readonly users?: ReadonlyArray<SimpleUser>;
    readonly teams?: ReadonlyArray<Team>;
    readonly apps?: ReadonlyArray<GitHubApp>;
    readonly url?: string;
    readonly users_url?: string;
    readonly teams_url?: string;
  };
  readonly bypass_pull_request_allowances?: {
    readonly users?: ReadonlyArray<SimpleUser>;
    readonly teams?: ReadonlyArray<Team>;
    readonly apps?: ReadonlyArray<GitHubApp>;
  };
  readonly dismiss_stale_reviews: boolean;
  readonly require_code_owner_reviews: boolean;
  readonly required_approving_review_count?: number;
  readonly require_last_push_approval?: boolean;
};

export type BranchRestrictionPolicy = {
  readonly url: string;
  readonly users_url: string;
  readonly teams_url: string;
  readonly apps_url: string;
  readonly users: ReadonlyArray<{
    readonly login?: string;
    readonly id?: number;
    readonly node_id?: string;
    readonly avatar_url?: string;
    readonly gravatar_id?: string;
    readonly url?: string;
    readonly html_url?: string;
    readonly followers_url?: string;
    readonly following_url?: string;
    readonly gists_url?: string;
    readonly starred_url?: string;
    readonly subscriptions_url?: string;
    readonly organizations_url?: string;
    readonly repos_url?: string;
    readonly events_url?: string;
    readonly received_events_url?: string;
    readonly type?: string;
    readonly site_admin?: boolean;
  }>;
  readonly teams: ReadonlyArray<{
    readonly id?: number;
    readonly node_id?: string;
    readonly url?: string;
    readonly html_url?: string;
    readonly name?: string;
    readonly slug?: string;
    readonly description?: string | null;
    readonly privacy?: string;
    readonly permission?: string;
    readonly members_url?: string;
    readonly repositories_url?: string;
    readonly parent?: string | null;
  }>;
  readonly apps: ReadonlyArray<{
    readonly id?: number;
    readonly slug?: string;
    readonly node_id?: string;
    readonly owner?: {
      readonly login?: string;
      readonly id?: number;
      readonly node_id?: string;
      readonly url?: string;
      readonly repos_url?: string;
      readonly events_url?: string;
      readonly hooks_url?: string;
      readonly issues_url?: string;
      readonly members_url?: string;
      readonly public_members_url?: string;
      readonly avatar_url?: string;
      readonly description?: string;
      readonly gravatar_id?: string;
      readonly html_url?: string;
      readonly followers_url?: string;
      readonly following_url?: string;
      readonly gists_url?: string;
      readonly starred_url?: string;
      readonly subscriptions_url?: string;
      readonly organizations_url?: string;
      readonly received_events_url?: string;
      readonly type?: string;
      readonly site_admin?: boolean;
    };
    readonly name?: string;
    readonly description?: string;
    readonly external_url?: string;
    readonly html_url?: string;
    readonly created_at?: string;
    readonly updated_at?: string;
    readonly permissions?: {
      readonly metadata?: string;
      readonly contents?: string;
      readonly issues?: string;
      readonly single_file?: string;
    };
    readonly events?: ReadonlyArray<string>;
  }>;
};

export type BranchProtection = {
  readonly url?: string;
  readonly enabled?: boolean;
  readonly required_status_checks?: ProtectedBranchRequiredStatusCheck;
  readonly enforce_admins?: ProtectedBranchAdminEnforced;
  readonly required_pull_request_reviews?: ProtectedBranchPullRequestReview;
  readonly restrictions?: BranchRestrictionPolicy;
  readonly required_linear_history?: { readonly enabled?: boolean };
  readonly allow_force_pushes?: { readonly enabled?: boolean };
  readonly allow_deletions?: { readonly enabled?: boolean };
  readonly block_creations?: { readonly enabled?: boolean };
  readonly required_conversation_resolution?: { readonly enabled?: boolean };
  readonly name?: string;
  readonly protection_url?: string;
  readonly required_signatures?: {
    readonly url: string;
    readonly enabled: boolean;
  };
  readonly lock_branch?: { readonly enabled?: boolean };
  readonly allow_fork_syncing?: { readonly enabled?: boolean };
};

export type ShortBranch = {
  readonly name: string;
  readonly commit: { readonly sha: string; readonly url: string };
  readonly protected: boolean;
  readonly protection?: BranchProtection;
  readonly protection_url?: string;
};

export type ReposListBranches200ResponseBody = ReadonlyArray<ShortBranch>;

export type ReposListBranches404ResponseBody = BasicError;

export type ReposListBranchesRequestQuery = {
  readonly protected?: boolean;
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListBranchesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type GitUser = {
  readonly name?: string;
  readonly email?: string;
  readonly date?: string;
} | null;

export type Verification = {
  readonly verified: boolean;
  readonly reason: string;
  readonly payload: string | null;
  readonly signature: string | null;
};

export type DiffEntry = {
  readonly sha: string;
  readonly filename: string;
  readonly status:
    | 'added'
    | 'removed'
    | 'modified'
    | 'renamed'
    | 'copied'
    | 'changed'
    | 'unchanged';
  readonly additions: number;
  readonly deletions: number;
  readonly changes: number;
  readonly blob_url: string;
  readonly raw_url: string;
  readonly contents_url: string;
  readonly patch?: string;
  readonly previous_filename?: string;
};

export type Commit = {
  readonly url: string;
  readonly sha: string;
  readonly node_id: string;
  readonly html_url: string;
  readonly comments_url: string;
  readonly commit: {
    readonly url: string;
    readonly author: GitUser;
    readonly committer: GitUser;
    readonly message: string;
    readonly comment_count: number;
    readonly tree: { readonly sha: string; readonly url: string };
    readonly verification?: Verification;
  };
  readonly author: SimpleUser;
  readonly committer: SimpleUser;
  readonly parents: ReadonlyArray<{
    readonly sha: string;
    readonly url: string;
    readonly html_url?: string;
  }>;
  readonly stats?: {
    readonly additions?: number;
    readonly deletions?: number;
    readonly total?: number;
  };
  readonly files?: ReadonlyArray<DiffEntry>;
};

export type BranchWithProtection = {
  readonly name: string;
  readonly commit: Commit;
  readonly _links: { readonly html: string; readonly self: string };
  readonly protected: boolean;
  readonly protection: BranchProtection;
  readonly protection_url: string;
  readonly pattern?: string;
  readonly required_approving_review_count?: number;
};

export type ReposGetBranch200ResponseBody = BranchWithProtection;

export type ReposGetBranch301ResponseBody = BasicError;

export type ReposGetBranch404ResponseBody = BasicError;

export type ReposGetBranchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetBranchProtection200ResponseBody = BranchProtection;

export type ReposGetBranchProtection404ResponseBody = BasicError;

export type ReposGetBranchProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type StatusCheckPolicy = {
  readonly url: string;
  readonly strict: boolean;
  readonly contexts: ReadonlyArray<string>;
  readonly checks: ReadonlyArray<{
    readonly context: string;
    readonly app_id: number | null;
  }>;
  readonly contexts_url: string;
};

export type ProtectedBranch = {
  readonly url: string;
  readonly required_status_checks?: StatusCheckPolicy;
  readonly required_pull_request_reviews?: {
    readonly url: string;
    readonly dismiss_stale_reviews?: boolean;
    readonly require_code_owner_reviews?: boolean;
    readonly required_approving_review_count?: number;
    readonly require_last_push_approval?: boolean;
    readonly dismissal_restrictions?: {
      readonly url: string;
      readonly users_url: string;
      readonly teams_url: string;
      readonly users: ReadonlyArray<SimpleUser>;
      readonly teams: ReadonlyArray<Team>;
      readonly apps?: ReadonlyArray<GitHubApp>;
    };
    readonly bypass_pull_request_allowances?: {
      readonly users: ReadonlyArray<SimpleUser>;
      readonly teams: ReadonlyArray<Team>;
      readonly apps?: ReadonlyArray<GitHubApp>;
    };
  };
  readonly required_signatures?: {
    readonly url: string;
    readonly enabled: boolean;
  };
  readonly enforce_admins?: { readonly url: string; readonly enabled: boolean };
  readonly required_linear_history?: { readonly enabled: boolean };
  readonly allow_force_pushes?: { readonly enabled: boolean };
  readonly allow_deletions?: { readonly enabled: boolean };
  readonly restrictions?: BranchRestrictionPolicy;
  readonly required_conversation_resolution?: { readonly enabled?: boolean };
  readonly block_creations?: { readonly enabled: boolean };
  readonly lock_branch?: { readonly enabled?: boolean };
  readonly allow_fork_syncing?: { readonly enabled?: boolean };
};

export type ReposUpdateBranchProtection200ResponseBody = ProtectedBranch;

export type ReposUpdateBranchProtection403ResponseBody = BasicError;

export type ReposUpdateBranchProtection404ResponseBody = BasicError;

export type ReposUpdateBranchProtection422ResponseBody = ValidationErrorSimple;

export type ReposUpdateBranchProtectionRequestBody = {
  readonly required_status_checks: {
    readonly strict: boolean;
    readonly contexts: ReadonlyArray<string>;
    readonly checks?: ReadonlyArray<{
      readonly context: string;
      readonly app_id?: number;
    }>;
  } | null;
  readonly enforce_admins: boolean | null;
  readonly required_pull_request_reviews: {
    readonly dismissal_restrictions?: {
      readonly users?: ReadonlyArray<string>;
      readonly teams?: ReadonlyArray<string>;
      readonly apps?: ReadonlyArray<string>;
    };
    readonly dismiss_stale_reviews?: boolean;
    readonly require_code_owner_reviews?: boolean;
    readonly required_approving_review_count?: number;
    readonly require_last_push_approval?: boolean;
    readonly bypass_pull_request_allowances?: {
      readonly users?: ReadonlyArray<string>;
      readonly teams?: ReadonlyArray<string>;
      readonly apps?: ReadonlyArray<string>;
    };
  } | null;
  readonly restrictions: {
    readonly users: ReadonlyArray<string>;
    readonly teams: ReadonlyArray<string>;
    readonly apps?: ReadonlyArray<string>;
  } | null;
  readonly required_linear_history?: boolean;
  readonly allow_force_pushes?: boolean | null;
  readonly allow_deletions?: boolean;
  readonly block_creations?: boolean;
  readonly required_conversation_resolution?: boolean;
  readonly lock_branch?: boolean;
  readonly allow_fork_syncing?: boolean;
};

export type ReposUpdateBranchProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposDeleteBranchProtection403ResponseBody = BasicError;

export type ReposDeleteBranchProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetAdminBranchProtection200ResponseBody = ProtectedBranchAdminEnforced;

export type ReposGetAdminBranchProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposSetAdminBranchProtection200ResponseBody = ProtectedBranchAdminEnforced;

export type ReposSetAdminBranchProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposDeleteAdminBranchProtection404ResponseBody = BasicError;

export type ReposDeleteAdminBranchProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetPullRequestReviewProtection200ResponseBody = ProtectedBranchPullRequestReview;

export type ReposGetPullRequestReviewProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposUpdatePullRequestReviewProtection200ResponseBody = ProtectedBranchPullRequestReview;

export type ReposUpdatePullRequestReviewProtection422ResponseBody = ValidationError;

export type ReposUpdatePullRequestReviewProtectionRequestBody = {
  readonly dismissal_restrictions?: {
    readonly users?: ReadonlyArray<string>;
    readonly teams?: ReadonlyArray<string>;
    readonly apps?: ReadonlyArray<string>;
  };
  readonly dismiss_stale_reviews?: boolean;
  readonly require_code_owner_reviews?: boolean;
  readonly required_approving_review_count?: number;
  readonly require_last_push_approval?: boolean;
  readonly bypass_pull_request_allowances?: {
    readonly users?: ReadonlyArray<string>;
    readonly teams?: ReadonlyArray<string>;
    readonly apps?: ReadonlyArray<string>;
  };
};

export type ReposUpdatePullRequestReviewProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposDeletePullRequestReviewProtection404ResponseBody = BasicError;

export type ReposDeletePullRequestReviewProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetCommitSignatureProtection200ResponseBody = ProtectedBranchAdminEnforced;

export type ReposGetCommitSignatureProtection404ResponseBody = BasicError;

export type ReposGetCommitSignatureProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposCreateCommitSignatureProtection200ResponseBody = ProtectedBranchAdminEnforced;

export type ReposCreateCommitSignatureProtection404ResponseBody = BasicError;

export type ReposCreateCommitSignatureProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposDeleteCommitSignatureProtection404ResponseBody = BasicError;

export type ReposDeleteCommitSignatureProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetStatusChecksProtection200ResponseBody = StatusCheckPolicy;

export type ReposGetStatusChecksProtection404ResponseBody = BasicError;

export type ReposGetStatusChecksProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposUpdateStatusCheckProtection200ResponseBody = StatusCheckPolicy;

export type ReposUpdateStatusCheckProtection404ResponseBody = BasicError;

export type ReposUpdateStatusCheckProtection422ResponseBody = ValidationError;

export type ReposUpdateStatusCheckProtectionRequestBody = {
  readonly strict?: boolean;
  readonly contexts?: ReadonlyArray<string>;
  readonly checks?: ReadonlyArray<{
    readonly context: string;
    readonly app_id?: number;
  }>;
};

export type ReposUpdateStatusCheckProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposRemoveStatusCheckProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetAllStatusCheckContexts200ResponseBody = ReadonlyArray<string>;

export type ReposGetAllStatusCheckContexts404ResponseBody = BasicError;

export type ReposGetAllStatusCheckContextsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposAddStatusCheckContexts200ResponseBody = ReadonlyArray<string>;

export type ReposAddStatusCheckContexts403ResponseBody = BasicError;

export type ReposAddStatusCheckContexts404ResponseBody = BasicError;

export type ReposAddStatusCheckContexts422ResponseBody = ValidationError;

export type ReposAddStatusCheckContextsRequestBody =
  | { readonly contexts: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposAddStatusCheckContextsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposSetStatusCheckContexts200ResponseBody = ReadonlyArray<string>;

export type ReposSetStatusCheckContexts404ResponseBody = BasicError;

export type ReposSetStatusCheckContexts422ResponseBody = ValidationError;

export type ReposSetStatusCheckContextsRequestBody =
  | { readonly contexts: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposSetStatusCheckContextsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposRemoveStatusCheckContexts200ResponseBody = ReadonlyArray<string>;

export type ReposRemoveStatusCheckContexts404ResponseBody = BasicError;

export type ReposRemoveStatusCheckContexts422ResponseBody = ValidationError;

export type ReposRemoveStatusCheckContextsRequestBody =
  | { readonly contexts: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposRemoveStatusCheckContextsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetAccessRestrictions200ResponseBody = BranchRestrictionPolicy;

export type ReposGetAccessRestrictions404ResponseBody = BasicError;

export type ReposGetAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposDeleteAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetAppsWithAccessToProtectedBranch200ResponseBody = ReadonlyArray<GitHubApp>;

export type ReposGetAppsWithAccessToProtectedBranch404ResponseBody = BasicError;

export type ReposGetAppsWithAccessToProtectedBranchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposAddAppAccessRestrictions200ResponseBody = ReadonlyArray<GitHubApp>;

export type ReposAddAppAccessRestrictions422ResponseBody = ValidationError;

export type ReposAddAppAccessRestrictionsRequestBody =
  | { readonly apps: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposAddAppAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposSetAppAccessRestrictions200ResponseBody = ReadonlyArray<GitHubApp>;

export type ReposSetAppAccessRestrictions422ResponseBody = ValidationError;

export type ReposSetAppAccessRestrictionsRequestBody =
  | { readonly apps: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposSetAppAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposRemoveAppAccessRestrictions200ResponseBody = ReadonlyArray<GitHubApp>;

export type ReposRemoveAppAccessRestrictions422ResponseBody = ValidationError;

export type ReposRemoveAppAccessRestrictionsRequestBody =
  | { readonly apps: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposRemoveAppAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetTeamsWithAccessToProtectedBranch200ResponseBody = ReadonlyArray<Team>;

export type ReposGetTeamsWithAccessToProtectedBranch404ResponseBody = BasicError;

export type ReposGetTeamsWithAccessToProtectedBranchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposAddTeamAccessRestrictions200ResponseBody = ReadonlyArray<Team>;

export type ReposAddTeamAccessRestrictions422ResponseBody = ValidationError;

export type ReposAddTeamAccessRestrictionsRequestBody =
  | { readonly teams: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposAddTeamAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposSetTeamAccessRestrictions200ResponseBody = ReadonlyArray<Team>;

export type ReposSetTeamAccessRestrictions422ResponseBody = ValidationError;

export type ReposSetTeamAccessRestrictionsRequestBody =
  | { readonly teams: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposSetTeamAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposRemoveTeamAccessRestrictions200ResponseBody = ReadonlyArray<Team>;

export type ReposRemoveTeamAccessRestrictions422ResponseBody = ValidationError;

export type ReposRemoveTeamAccessRestrictionsRequestBody =
  | { readonly teams: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposRemoveTeamAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposGetUsersWithAccessToProtectedBranch200ResponseBody = ReadonlyArray<SimpleUser>;

export type ReposGetUsersWithAccessToProtectedBranch404ResponseBody = BasicError;

export type ReposGetUsersWithAccessToProtectedBranchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposAddUserAccessRestrictions200ResponseBody = ReadonlyArray<SimpleUser>;

export type ReposAddUserAccessRestrictions422ResponseBody = ValidationError;

export type ReposAddUserAccessRestrictionsRequestBody =
  | { readonly users: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposAddUserAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposSetUserAccessRestrictions200ResponseBody = ReadonlyArray<SimpleUser>;

export type ReposSetUserAccessRestrictions422ResponseBody = ValidationError;

export type ReposSetUserAccessRestrictionsRequestBody =
  | { readonly users: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposSetUserAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposRemoveUserAccessRestrictions200ResponseBody = ReadonlyArray<SimpleUser>;

export type ReposRemoveUserAccessRestrictions422ResponseBody = ValidationError;

export type ReposRemoveUserAccessRestrictionsRequestBody =
  | { readonly users: ReadonlyArray<string> }
  | ReadonlyArray<string>;

export type ReposRemoveUserAccessRestrictionsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type ReposRenameBranch201ResponseBody = BranchWithProtection;

export type ReposRenameBranch403ResponseBody = BasicError;

export type ReposRenameBranch404ResponseBody = BasicError;

export type ReposRenameBranch422ResponseBody = ValidationError;

export type ReposRenameBranchRequestBody = { readonly new_name: string };

export type ReposRenameBranchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly branch: string;
};

export type CheckRun = {
  readonly id: number;
  readonly head_sha: string;
  readonly node_id: string;
  readonly external_id: string | null;
  readonly url: string;
  readonly html_url: string | null;
  readonly details_url: string | null;
  readonly status: 'queued' | 'in_progress' | 'completed';
  readonly conclusion:
    | 'success'
    | 'failure'
    | 'neutral'
    | 'cancelled'
    | 'skipped'
    | 'timed_out'
    | 'action_required'
    | null;
  readonly started_at: string | null;
  readonly completed_at: string | null;
  readonly output: {
    readonly title: string | null;
    readonly summary: string | null;
    readonly text: string | null;
    readonly annotations_count: number;
    readonly annotations_url: string;
  };
  readonly name: string;
  readonly check_suite: { readonly id: number } | null;
  readonly app: GitHubApp;
  readonly pull_requests: ReadonlyArray<PullRequestMinimal>;
  readonly deployment?: Deployment;
};

export type ChecksCreate201ResponseBody = CheckRun;

export type ChecksCreateRequestBody = {
  readonly name: string;
  readonly head_sha: string;
  readonly details_url?: string;
  readonly external_id?: string;
  readonly status?: 'queued' | 'in_progress' | 'completed';
  readonly started_at?: string;
  readonly conclusion?:
    | 'action_required'
    | 'cancelled'
    | 'failure'
    | 'neutral'
    | 'success'
    | 'skipped'
    | 'stale'
    | 'timed_out';
  readonly completed_at?: string;
  readonly output?: {
    readonly title: string;
    readonly summary: string;
    readonly text?: string;
    readonly annotations?: ReadonlyArray<{
      readonly path: string;
      readonly start_line: number;
      readonly end_line: number;
      readonly start_column?: number;
      readonly end_column?: number;
      readonly annotation_level: 'notice' | 'warning' | 'failure';
      readonly message: string;
      readonly title?: string;
      readonly raw_details?: string;
    }>;
    readonly images?: ReadonlyArray<{
      readonly alt: string;
      readonly image_url: string;
      readonly caption?: string;
    }>;
  };
  readonly actions?: ReadonlyArray<{
    readonly label: string;
    readonly description: string;
    readonly identifier: string;
  }>;
} & (
  | { readonly status: 'completed' }
  | { readonly status?: 'queued' | 'in_progress' }
);

export type ChecksCreateRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ChecksGet200ResponseBody = CheckRun;

export type ChecksGetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_run_id: number;
};

export type ChecksUpdate200ResponseBody = CheckRun;

export type ChecksUpdateRequestBody = {
  readonly name?: string;
  readonly details_url?: string;
  readonly external_id?: string;
  readonly started_at?: string;
  readonly status?: 'queued' | 'in_progress' | 'completed';
  readonly conclusion?:
    | 'action_required'
    | 'cancelled'
    | 'failure'
    | 'neutral'
    | 'success'
    | 'skipped'
    | 'stale'
    | 'timed_out';
  readonly completed_at?: string;
  readonly output?: {
    readonly title?: string;
    readonly summary: string;
    readonly text?: string;
    readonly annotations?: ReadonlyArray<{
      readonly path: string;
      readonly start_line: number;
      readonly end_line: number;
      readonly start_column?: number;
      readonly end_column?: number;
      readonly annotation_level: 'notice' | 'warning' | 'failure';
      readonly message: string;
      readonly title?: string;
      readonly raw_details?: string;
    }>;
    readonly images?: ReadonlyArray<{
      readonly alt: string;
      readonly image_url: string;
      readonly caption?: string;
    }>;
  };
  readonly actions?: ReadonlyArray<{
    readonly label: string;
    readonly description: string;
    readonly identifier: string;
  }>;
} & (
  | { readonly status?: 'completed' }
  | { readonly status?: 'queued' | 'in_progress' }
);

export type ChecksUpdateRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_run_id: number;
};

export type CheckAnnotation = {
  readonly path: string;
  readonly start_line: number;
  readonly end_line: number;
  readonly start_column: number | null;
  readonly end_column: number | null;
  readonly annotation_level: string | null;
  readonly title: string | null;
  readonly message: string | null;
  readonly raw_details: string | null;
  readonly blob_href: string;
};

export type ChecksListAnnotations200ResponseBody = ReadonlyArray<CheckAnnotation>;

export type ChecksListAnnotationsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ChecksListAnnotationsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_run_id: number;
};

export type ChecksRerequestRun201ResponseBody = EmptyObject;

export type ChecksRerequestRun403ResponseBody = BasicError;

export type ChecksRerequestRun404ResponseBody = BasicError;

export type ChecksRerequestRun422ResponseBody = BasicError;

export type ChecksRerequestRunRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_run_id: number;
};

export type CheckSuite = {
  readonly id: number;
  readonly node_id: string;
  readonly head_branch: string | null;
  readonly head_sha: string;
  readonly status: 'queued' | 'in_progress' | 'completed' | null;
  readonly conclusion:
    | 'success'
    | 'failure'
    | 'neutral'
    | 'cancelled'
    | 'skipped'
    | 'timed_out'
    | 'action_required'
    | null;
  readonly url: string | null;
  readonly before: string | null;
  readonly after: string | null;
  readonly pull_requests: ReadonlyArray<PullRequestMinimal> | null;
  readonly app: GitHubApp;
  readonly repository: MinimalRepository;
  readonly created_at: string | null;
  readonly updated_at: string | null;
  readonly head_commit: SimpleCommit;
  readonly latest_check_runs_count: number;
  readonly check_runs_url: string;
  readonly rerequestable?: boolean;
  readonly runs_rerequestable?: boolean;
};

export type ChecksCreateSuite200ResponseBody = CheckSuite;

export type ChecksCreateSuite201ResponseBody = CheckSuite;

export type ChecksCreateSuiteRequestBody = { readonly head_sha: string };

export type ChecksCreateSuiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CheckSuitePreference = {
  readonly preferences: {
    readonly auto_trigger_checks?: ReadonlyArray<{
      readonly app_id: number;
      readonly setting: boolean;
    }>;
  };
  readonly repository: MinimalRepository;
};

export type ChecksSetSuitesPreferences200ResponseBody = CheckSuitePreference;

export type ChecksSetSuitesPreferencesRequestBody = {
  readonly auto_trigger_checks?: ReadonlyArray<{
    readonly app_id: number;
    readonly setting: boolean;
  }>;
};

export type ChecksSetSuitesPreferencesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ChecksGetSuite200ResponseBody = CheckSuite;

export type ChecksGetSuiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_suite_id: number;
};

export type ChecksListForSuite200ResponseBody = {
  readonly total_count: number;
  readonly check_runs: ReadonlyArray<CheckRun>;
};

export type ChecksListForSuiteRequestQuery = {
  readonly check_name?: string;
  readonly status?: 'queued' | 'in_progress' | 'completed';
  readonly filter?: 'latest' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type ChecksListForSuiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_suite_id: number;
};

export type ChecksRerequestSuite201ResponseBody = EmptyObject;

export type ChecksRerequestSuiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly check_suite_id: number;
};

export type CodeScanningAlertRuleSummary = {
  readonly id?: string | null;
  readonly name?: string;
  readonly tags?: ReadonlyArray<string> | null;
  readonly severity?: 'none' | 'note' | 'warning' | 'error' | null;
  readonly description?: string;
};

export type CodeScanningAlertItems = {
  readonly number: AlertNumber;
  readonly created_at: AlertCreatedAt;
  readonly updated_at?: AlertUpdatedAt;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly instances_url: AlertInstancesUrl;
  readonly state: CodeScanningAlertState;
  readonly fixed_at?: AlertFixedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_reason: CodeScanningAlertDismissedReason;
  readonly dismissed_comment?: CodeScanningAlertDismissedComment;
  readonly rule: CodeScanningAlertRuleSummary;
  readonly tool: CodeScanningAnalysisTool;
  readonly most_recent_instance: CodeScanningAlertInstance;
};

export type CodeScanningListAlertsForRepo200ResponseBody = ReadonlyArray<CodeScanningAlertItems>;

export type CodeScanningListAlertsForRepo403ResponseBody = BasicError;

export type CodeScanningListAlertsForRepo404ResponseBody = BasicError;

export type CodeScanningListAlertsForRepo503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningListAlertsForRepoRequestQuery = {
  readonly tool_name?: CodeScanningAnalysisToolName;
  readonly tool_guid?: CodeScanningAnalysisToolGuid;
  readonly page?: number;
  readonly per_page?: number;
  readonly ref?: CodeScanningRef;
  readonly direction?: 'asc' | 'desc';
  readonly sort?: 'created' | 'updated';
  readonly state?: CodeScanningAlertState;
};

export type CodeScanningListAlertsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodeScanningAlert = {
  readonly number: AlertNumber;
  readonly created_at: AlertCreatedAt;
  readonly updated_at?: AlertUpdatedAt;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly instances_url: AlertInstancesUrl;
  readonly state: CodeScanningAlertState;
  readonly fixed_at?: AlertFixedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_reason: CodeScanningAlertDismissedReason;
  readonly dismissed_comment?: CodeScanningAlertDismissedComment;
  readonly rule: CodeScanningAlertRule;
  readonly tool: CodeScanningAnalysisTool;
  readonly most_recent_instance: CodeScanningAlertInstance;
};

export type CodeScanningGetAlert200ResponseBody = CodeScanningAlert;

export type CodeScanningGetAlert403ResponseBody = BasicError;

export type CodeScanningGetAlert404ResponseBody = BasicError;

export type CodeScanningGetAlert503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningGetAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type CodeScanningUpdateAlert200ResponseBody = CodeScanningAlert;

export type CodeScanningUpdateAlert403ResponseBody = BasicError;

export type CodeScanningUpdateAlert404ResponseBody = BasicError;

export type CodeScanningUpdateAlert503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningAlertSetState = 'open' | 'dismissed';

export type CodeScanningUpdateAlertRequestBody = {
  readonly state: CodeScanningAlertSetState;
  readonly dismissed_reason?: CodeScanningAlertDismissedReason;
  readonly dismissed_comment?: CodeScanningAlertDismissedComment;
};

export type CodeScanningUpdateAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type CodeScanningListAlertInstances200ResponseBody = ReadonlyArray<CodeScanningAlertInstance>;

export type CodeScanningListAlertInstances403ResponseBody = BasicError;

export type CodeScanningListAlertInstances404ResponseBody = BasicError;

export type CodeScanningListAlertInstances503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningListAlertInstancesRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
  readonly ref?: CodeScanningRef;
};

export type CodeScanningListAlertInstancesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type CodeScanningAnalysisCommitSha = string;

export type CodeScanningAnalysisEnvironment = string;

export type CodeScanningAnalysisCreatedAt = string;

export type CodeScanningAnalysisUrl = string;

export type CodeScanningAnalysisSarifId = string;

export type CodeScanningAnalysis = {
  readonly ref: CodeScanningRef;
  readonly commit_sha: CodeScanningAnalysisCommitSha;
  readonly analysis_key: CodeScanningAnalysisAnalysisKey;
  readonly environment: CodeScanningAnalysisEnvironment;
  readonly category?: CodeScanningAnalysisCategory;
  readonly error: string;
  readonly created_at: CodeScanningAnalysisCreatedAt;
  readonly results_count: number;
  readonly rules_count: number;
  readonly id: number;
  readonly url: CodeScanningAnalysisUrl;
  readonly sarif_id: CodeScanningAnalysisSarifId;
  readonly tool: CodeScanningAnalysisTool;
  readonly deletable: boolean;
  readonly warning: string;
};

export type CodeScanningListRecentAnalyses200ResponseBody = ReadonlyArray<CodeScanningAnalysis>;

export type CodeScanningListRecentAnalyses403ResponseBody = BasicError;

export type CodeScanningListRecentAnalyses404ResponseBody = BasicError;

export type CodeScanningListRecentAnalyses503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningListRecentAnalysesRequestQuery = {
  readonly tool_name?: CodeScanningAnalysisToolName;
  readonly tool_guid?: CodeScanningAnalysisToolGuid;
  readonly page?: number;
  readonly per_page?: number;
  readonly ref?: CodeScanningRef;
  readonly sarif_id?: CodeScanningAnalysisSarifId;
  readonly direction?: 'asc' | 'desc';
  readonly sort?: 'created';
};

export type CodeScanningListRecentAnalysesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodeScanningGetAnalysis200ResponseBody = CodeScanningAnalysis;

export type CodeScanningGetAnalysis403ResponseBody = BasicError;

export type CodeScanningGetAnalysis404ResponseBody = BasicError;

export type CodeScanningGetAnalysis503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningGetAnalysisRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly analysis_id: number;
};

export type AnalysisDeletion = {
  readonly next_analysis_url: string | null;
  readonly confirm_delete_url: string | null;
};

export type CodeScanningDeleteAnalysis200ResponseBody = AnalysisDeletion;

export type CodeScanningDeleteAnalysis400ResponseBody = BasicError;

export type CodeScanningDeleteAnalysis403ResponseBody = BasicError;

export type CodeScanningDeleteAnalysis404ResponseBody = BasicError;

export type CodeScanningDeleteAnalysis503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningDeleteAnalysisRequestQuery = {
  readonly confirm_delete?: string | null;
};

export type CodeScanningDeleteAnalysisRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly analysis_id: number;
};

export type CodeQlDatabase = {
  readonly id: number;
  readonly name: string;
  readonly language: string;
  readonly uploader: SimpleUser;
  readonly content_type: string;
  readonly size: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly url: string;
};

export type CodeScanningListCodeqlDatabases200ResponseBody = ReadonlyArray<CodeQlDatabase>;

export type CodeScanningListCodeqlDatabases403ResponseBody = BasicError;

export type CodeScanningListCodeqlDatabases404ResponseBody = BasicError;

export type CodeScanningListCodeqlDatabases503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningListCodeqlDatabasesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodeScanningGetCodeqlDatabase200ResponseBody = CodeQlDatabase;

export type CodeScanningGetCodeqlDatabase403ResponseBody = BasicError;

export type CodeScanningGetCodeqlDatabase404ResponseBody = BasicError;

export type CodeScanningGetCodeqlDatabase503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningGetCodeqlDatabaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly language: string;
};

export type CodeScanningSarifsReceipt = {
  readonly id?: CodeScanningAnalysisSarifId;
  readonly url?: string;
};

export type CodeScanningUploadSarif202ResponseBody = CodeScanningSarifsReceipt;

export type CodeScanningUploadSarif403ResponseBody = BasicError;

export type CodeScanningUploadSarif404ResponseBody = BasicError;

export type CodeScanningUploadSarif503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningAnalysisSarifFile = string;

export type CodeScanningUploadSarifRequestBody = {
  readonly commit_sha: CodeScanningAnalysisCommitSha;
  readonly ref: CodeScanningRef;
  readonly sarif: CodeScanningAnalysisSarifFile;
  readonly checkout_uri?: string;
  readonly started_at?: string;
  readonly tool_name?: string;
  readonly validate?: boolean;
};

export type CodeScanningUploadSarifRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodeScanningSarifsStatus = {
  readonly processing_status?: 'pending' | 'complete' | 'failed';
  readonly analyses_url?: string | null;
  readonly errors?: ReadonlyArray<string> | null;
};

export type CodeScanningGetSarif200ResponseBody = CodeScanningSarifsStatus;

export type CodeScanningGetSarif403ResponseBody = BasicError;

export type CodeScanningGetSarif503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodeScanningGetSarifRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly sarif_id: string;
};

export type CodeownersErrors = {
  readonly errors: ReadonlyArray<{
    readonly line: number;
    readonly column: number;
    readonly source?: string;
    readonly kind: string;
    readonly suggestion?: string | null;
    readonly message: string;
    readonly path: string;
  }>;
};

export type ReposCodeownersErrors200ResponseBody = CodeownersErrors;

export type ReposCodeownersErrorsRequestQuery = { readonly ref?: string };

export type ReposCodeownersErrorsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesListInRepositoryForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly codespaces: ReadonlyArray<Codespace>;
};

export type CodespacesListInRepositoryForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesListInRepositoryForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesListInRepositoryForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesListInRepositoryForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesListInRepositoryForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesListInRepositoryForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesCreateWithRepoForAuthenticatedUser201ResponseBody = Codespace;

export type CodespacesCreateWithRepoForAuthenticatedUser202ResponseBody = Codespace;

export type CodespacesCreateWithRepoForAuthenticatedUser400ResponseBody = BasicError;

export type CodespacesCreateWithRepoForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesCreateWithRepoForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesCreateWithRepoForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesCreateWithRepoForAuthenticatedUser503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodespacesCreateWithRepoForAuthenticatedUserRequestBody = {
  readonly ref?: string;
  readonly location?: string;
  readonly client_ip?: string;
  readonly machine?: string;
  readonly devcontainer_path?: string;
  readonly multi_repo_permissions_opt_out?: boolean;
  readonly working_directory?: string;
  readonly idle_timeout_minutes?: number;
  readonly display_name?: string;
  readonly retention_period_minutes?: number;
} | null;

export type CodespacesCreateWithRepoForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly devcontainers: ReadonlyArray<{
    readonly path: string;
    readonly name?: string;
  }>;
};

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser400ResponseBody = BasicError;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesRepoMachinesForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly machines: ReadonlyArray<CodespaceMachine>;
};

export type CodespacesRepoMachinesForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesRepoMachinesForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesRepoMachinesForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesRepoMachinesForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesRepoMachinesForAuthenticatedUserRequestQuery = {
  readonly location?: string;
  readonly client_ip?: string;
};

export type CodespacesRepoMachinesForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesPreFlightWithRepoForAuthenticatedUser200ResponseBody = {
  readonly billable_owner?: SimpleUser;
  readonly defaults?: {
    readonly location: string;
    readonly devcontainer_path: string | null;
  };
};

export type CodespacesPreFlightWithRepoForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesPreFlightWithRepoForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesPreFlightWithRepoForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesPreFlightWithRepoForAuthenticatedUserRequestQuery = {
  readonly ref?: string;
  readonly client_ip?: string;
};

export type CodespacesPreFlightWithRepoForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesListRepoSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<CodespacesSecret>;
};

export type CodespacesListRepoSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesListRepoSecretsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesGetRepoPublicKey200ResponseBody = CodespacesPublicKey;

export type CodespacesGetRepoPublicKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodespacesGetRepoSecret200ResponseBody = CodespacesSecret;

export type CodespacesGetRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type CodespacesCreateOrUpdateRepoSecret201ResponseBody = EmptyObject;

export type CodespacesCreateOrUpdateRepoSecretRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id?: string;
};

export type CodespacesCreateOrUpdateRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type CodespacesDeleteRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type Collaborator = {
  readonly login: string;
  readonly id: number;
  readonly email?: string | null;
  readonly name?: string | null;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly site_admin: boolean;
  readonly permissions?: {
    readonly pull: boolean;
    readonly triage?: boolean;
    readonly push: boolean;
    readonly maintain?: boolean;
    readonly admin: boolean;
  };
  readonly role_name: string;
};

export type ReposListCollaborators200ResponseBody = ReadonlyArray<Collaborator>;

export type ReposListCollaborators404ResponseBody = BasicError;

export type ReposListCollaboratorsRequestQuery = {
  readonly affiliation?: 'outside' | 'direct' | 'all';
  readonly permission?: 'pull' | 'triage' | 'push' | 'maintain' | 'admin';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListCollaboratorsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCheckCollaboratorRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly username: string;
};

export type RepositoryInvitation = {
  readonly id: number;
  readonly repository: MinimalRepository;
  readonly invitee: SimpleUser;
  readonly inviter: SimpleUser;
  readonly permissions: 'read' | 'write' | 'admin' | 'triage' | 'maintain';
  readonly created_at: string;
  readonly expired?: boolean;
  readonly url: string;
  readonly html_url: string;
  readonly node_id: string;
};

export type ReposAddCollaborator201ResponseBody = RepositoryInvitation;

export type ReposAddCollaborator403ResponseBody = BasicError;

export type ReposAddCollaborator422ResponseBody = ValidationError;

export type ReposAddCollaboratorRequestBody = { readonly permission?: string };

export type ReposAddCollaboratorRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly username: string;
};

export type ReposRemoveCollaboratorRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly username: string;
};

export type RepositoryCollaboratorPermission = {
  readonly permission: string;
  readonly role_name: string;
  readonly user: Collaborator;
};

export type ReposGetCollaboratorPermissionLevel200ResponseBody = RepositoryCollaboratorPermission;

export type ReposGetCollaboratorPermissionLevel404ResponseBody = BasicError;

export type ReposGetCollaboratorPermissionLevelRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly username: string;
};

export type CommitComment = {
  readonly html_url: string;
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly body: string;
  readonly path: string | null;
  readonly position: number | null;
  readonly line: number | null;
  readonly commit_id: string;
  readonly user: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly author_association: AuthorAssociation;
  readonly reactions?: ReactionRollup;
};

export type ReposListCommitCommentsForRepo200ResponseBody = ReadonlyArray<CommitComment>;

export type ReposListCommitCommentsForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListCommitCommentsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetCommitComment200ResponseBody = CommitComment;

export type ReposGetCommitComment404ResponseBody = BasicError;

export type ReposGetCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReposUpdateCommitComment200ResponseBody = CommitComment;

export type ReposUpdateCommitComment404ResponseBody = BasicError;

export type ReposUpdateCommitCommentRequestBody = { readonly body: string };

export type ReposUpdateCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReposDeleteCommitComment404ResponseBody = BasicError;

export type ReposDeleteCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsListForCommitComment200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForCommitComment404ResponseBody = BasicError;

export type ReactionsListForCommitCommentRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsCreateForCommitComment200ResponseBody = Reaction;

export type ReactionsCreateForCommitComment201ResponseBody = Reaction;

export type ReactionsCreateForCommitComment422ResponseBody = ValidationError;

export type ReactionsCreateForCommitCommentRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsDeleteForCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
  readonly reaction_id: number;
};

export type ReposListCommits200ResponseBody = ReadonlyArray<Commit>;

export type ReposListCommits400ResponseBody = BasicError;

export type ReposListCommits404ResponseBody = BasicError;

export type ReposListCommits409ResponseBody = BasicError;

export type ReposListCommits500ResponseBody = BasicError;

export type ReposListCommitsRequestQuery = {
  readonly sha?: string;
  readonly path?: string;
  readonly author?: string;
  readonly since?: string;
  readonly until?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListCommitsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type BranchShort = {
  readonly name: string;
  readonly commit: { readonly sha: string; readonly url: string };
  readonly protected: boolean;
};

export type ReposListBranchesForHeadCommit200ResponseBody = ReadonlyArray<BranchShort>;

export type ReposListBranchesForHeadCommit422ResponseBody = ValidationError;

export type ReposListBranchesForHeadCommitRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly commit_sha: string;
};

export type ReposListCommentsForCommit200ResponseBody = ReadonlyArray<CommitComment>;

export type ReposListCommentsForCommitRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListCommentsForCommitRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly commit_sha: string;
};

export type ReposCreateCommitComment201ResponseBody = CommitComment;

export type ReposCreateCommitComment403ResponseBody = BasicError;

export type ReposCreateCommitComment422ResponseBody = ValidationError;

export type ReposCreateCommitCommentRequestBody = {
  readonly body: string;
  readonly path?: string;
  readonly position?: number;
  readonly line?: number;
};

export type ReposCreateCommitCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly commit_sha: string;
};

export type Link = { readonly href: string };

export type AutoMerge = {
  readonly enabled_by: SimpleUser;
  readonly merge_method: 'merge' | 'squash' | 'rebase';
  readonly commit_title: string;
  readonly commit_message: string;
} | null;

export type PullRequestSimple = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly html_url: string;
  readonly diff_url: string;
  readonly patch_url: string;
  readonly issue_url: string;
  readonly commits_url: string;
  readonly review_comments_url: string;
  readonly review_comment_url: string;
  readonly comments_url: string;
  readonly statuses_url: string;
  readonly number: number;
  readonly state: string;
  readonly locked: boolean;
  readonly title: string;
  readonly user: SimpleUser;
  readonly body: string | null;
  readonly labels: ReadonlyArray<{
    readonly id: number;
    readonly node_id: string;
    readonly url: string;
    readonly name: string;
    readonly description: string;
    readonly color: string;
    readonly default: boolean;
  }>;
  readonly milestone: Milestone;
  readonly active_lock_reason?: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly closed_at: string | null;
  readonly merged_at: string | null;
  readonly merge_commit_sha: string | null;
  readonly assignee: SimpleUser;
  readonly assignees?: ReadonlyArray<SimpleUser> | null;
  readonly requested_reviewers?: ReadonlyArray<SimpleUser> | null;
  readonly requested_teams?: ReadonlyArray<Team> | null;
  readonly head: {
    readonly label: string;
    readonly ref: string;
    readonly repo: Repository;
    readonly sha: string;
    readonly user: SimpleUser;
  };
  readonly base: {
    readonly label: string;
    readonly ref: string;
    readonly repo: Repository;
    readonly sha: string;
    readonly user: SimpleUser;
  };
  readonly _links: {
    readonly comments: Link;
    readonly commits: Link;
    readonly statuses: Link;
    readonly html: Link;
    readonly issue: Link;
    readonly review_comments: Link;
    readonly review_comment: Link;
    readonly self: Link;
  };
  readonly author_association: AuthorAssociation;
  readonly auto_merge: AutoMerge;
  readonly draft?: boolean;
};

export type ReposListPullRequestsAssociatedWithCommit200ResponseBody = ReadonlyArray<PullRequestSimple>;

export type ReposListPullRequestsAssociatedWithCommitRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListPullRequestsAssociatedWithCommitRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly commit_sha: string;
};

export type ReposGetCommit200ResponseBody = Commit;

export type ReposGetCommit404ResponseBody = BasicError;

export type ReposGetCommit422ResponseBody = ValidationError;

export type ReposGetCommit500ResponseBody = BasicError;

export type ReposGetCommit503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type ReposGetCommitRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type ReposGetCommitRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type ChecksListForRef200ResponseBody = {
  readonly total_count: number;
  readonly check_runs: ReadonlyArray<CheckRun>;
};

export type ChecksListForRefRequestQuery = {
  readonly check_name?: string;
  readonly status?: 'queued' | 'in_progress' | 'completed';
  readonly filter?: 'latest' | 'all';
  readonly per_page?: number;
  readonly page?: number;
  readonly app_id?: number;
};

export type ChecksListForRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type ChecksListSuitesForRef200ResponseBody = {
  readonly total_count: number;
  readonly check_suites: ReadonlyArray<CheckSuite>;
};

export type ChecksListSuitesForRefRequestQuery = {
  readonly app_id?: number;
  readonly check_name?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type ChecksListSuitesForRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type SimpleCommitStatus = {
  readonly description: string | null;
  readonly id: number;
  readonly node_id: string;
  readonly state: string;
  readonly context: string;
  readonly target_url: string | null;
  readonly required?: boolean | null;
  readonly avatar_url: string | null;
  readonly url: string;
  readonly created_at: string;
  readonly updated_at: string;
};

export type CombinedCommitStatus = {
  readonly state: string;
  readonly statuses: ReadonlyArray<SimpleCommitStatus>;
  readonly sha: string;
  readonly total_count: number;
  readonly repository: MinimalRepository;
  readonly commit_url: string;
  readonly url: string;
};

export type ReposGetCombinedStatusForRef200ResponseBody = CombinedCommitStatus;

export type ReposGetCombinedStatusForRef404ResponseBody = BasicError;

export type ReposGetCombinedStatusForRefRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposGetCombinedStatusForRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type Status = {
  readonly url: string;
  readonly avatar_url: string | null;
  readonly id: number;
  readonly node_id: string;
  readonly state: string;
  readonly description: string | null;
  readonly target_url: string | null;
  readonly context: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly creator: SimpleUser;
};

export type ReposListCommitStatusesForRef200ResponseBody = ReadonlyArray<Status>;

export type ReposListCommitStatusesForRef301ResponseBody = BasicError;

export type ReposListCommitStatusesForRefRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListCommitStatusesForRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type CommunityHealthFile = {
  readonly url: string;
  readonly html_url: string;
} | null;

export type CommunityProfile = {
  readonly health_percentage: number;
  readonly description: string | null;
  readonly documentation: string | null;
  readonly files: {
    readonly code_of_conduct: CodeOfConductSimple;
    readonly code_of_conduct_file: CommunityHealthFile;
    readonly license: LicenseSimple;
    readonly contributing: CommunityHealthFile;
    readonly readme: CommunityHealthFile;
    readonly issue_template: CommunityHealthFile;
    readonly pull_request_template: CommunityHealthFile;
  };
  readonly updated_at: string | null;
  readonly content_reports_enabled?: boolean;
};

export type ReposGetCommunityProfileMetrics200ResponseBody = CommunityProfile;

export type ReposGetCommunityProfileMetricsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CommitComparison = {
  readonly url: string;
  readonly html_url: string;
  readonly permalink_url: string;
  readonly diff_url: string;
  readonly patch_url: string;
  readonly base_commit: Commit;
  readonly merge_base_commit: Commit;
  readonly status: 'diverged' | 'ahead' | 'behind' | 'identical';
  readonly ahead_by: number;
  readonly behind_by: number;
  readonly total_commits: number;
  readonly commits: ReadonlyArray<Commit>;
  readonly files?: ReadonlyArray<DiffEntry>;
};

export type ReposCompareCommits200ResponseBody = CommitComparison;

export type ReposCompareCommits404ResponseBody = BasicError;

export type ReposCompareCommits500ResponseBody = BasicError;

export type ReposCompareCommits503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type ReposCompareCommitsRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type ReposCompareCommitsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly basehead: string;
};

export type ContentDirectory = ReadonlyArray<{
  readonly type: 'dir' | 'file' | 'submodule' | 'symlink';
  readonly size: number;
  readonly name: string;
  readonly path: string;
  readonly content?: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string | null;
  readonly html_url: string | null;
  readonly download_url: string | null;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
}>;

export type ContentFile = {
  readonly type: 'file';
  readonly encoding: string;
  readonly size: number;
  readonly name: string;
  readonly path: string;
  readonly content: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string | null;
  readonly html_url: string | null;
  readonly download_url: string | null;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
  readonly target?: string;
  readonly submodule_git_url?: string;
};

export type SymlinkContent = {
  readonly type: 'symlink';
  readonly target: string;
  readonly size: number;
  readonly name: string;
  readonly path: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string | null;
  readonly html_url: string | null;
  readonly download_url: string | null;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
};

export type SubmoduleContent = {
  readonly type: 'submodule';
  readonly submodule_git_url: string;
  readonly size: number;
  readonly name: string;
  readonly path: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string | null;
  readonly html_url: string | null;
  readonly download_url: string | null;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
};

export type ReposGetContent200ResponseBody =
  | ContentDirectory
  | ContentFile
  | SymlinkContent
  | SubmoduleContent;

export type ReposGetContent403ResponseBody = BasicError;

export type ReposGetContent404ResponseBody = BasicError;

export type ReposGetContentRequestQuery = { readonly ref?: string };

export type ReposGetContentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly path: string;
};

export type FileCommit = {
  readonly content: {
    readonly name?: string;
    readonly path?: string;
    readonly sha?: string;
    readonly size?: number;
    readonly url?: string;
    readonly html_url?: string;
    readonly git_url?: string;
    readonly download_url?: string;
    readonly type?: string;
    readonly _links?: {
      readonly self?: string;
      readonly git?: string;
      readonly html?: string;
    };
  } | null;
  readonly commit: {
    readonly sha?: string;
    readonly node_id?: string;
    readonly url?: string;
    readonly html_url?: string;
    readonly author?: {
      readonly date?: string;
      readonly name?: string;
      readonly email?: string;
    };
    readonly committer?: {
      readonly date?: string;
      readonly name?: string;
      readonly email?: string;
    };
    readonly message?: string;
    readonly tree?: { readonly url?: string; readonly sha?: string };
    readonly parents?: ReadonlyArray<{
      readonly url?: string;
      readonly html_url?: string;
      readonly sha?: string;
    }>;
    readonly verification?: {
      readonly verified?: boolean;
      readonly reason?: string;
      readonly signature?: string | null;
      readonly payload?: string | null;
    };
  };
};

export type ReposCreateOrUpdateFileContents200ResponseBody = FileCommit;

export type ReposCreateOrUpdateFileContents201ResponseBody = FileCommit;

export type ReposCreateOrUpdateFileContents404ResponseBody = BasicError;

export type ReposCreateOrUpdateFileContents409ResponseBody = BasicError;

export type ReposCreateOrUpdateFileContents422ResponseBody = ValidationError;

export type ReposCreateOrUpdateFileContentsRequestBody = {
  readonly message: string;
  readonly content: string;
  readonly sha?: string;
  readonly branch?: string;
  readonly committer?: {
    readonly name: string;
    readonly email: string;
    readonly date?: string;
  };
  readonly author?: {
    readonly name: string;
    readonly email: string;
    readonly date?: string;
  };
};

export type ReposCreateOrUpdateFileContentsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly path: string;
};

export type ReposDeleteFile200ResponseBody = FileCommit;

export type ReposDeleteFile404ResponseBody = BasicError;

export type ReposDeleteFile409ResponseBody = BasicError;

export type ReposDeleteFile422ResponseBody = ValidationError;

export type ReposDeleteFile503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type ReposDeleteFileRequestBody = {
  readonly message: string;
  readonly sha: string;
  readonly branch?: string;
  readonly committer?: { readonly name?: string; readonly email?: string };
  readonly author?: { readonly name?: string; readonly email?: string };
};

export type ReposDeleteFileRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly path: string;
};

export type Contributor = {
  readonly login?: string;
  readonly id?: number;
  readonly node_id?: string;
  readonly avatar_url?: string;
  readonly gravatar_id?: string | null;
  readonly url?: string;
  readonly html_url?: string;
  readonly followers_url?: string;
  readonly following_url?: string;
  readonly gists_url?: string;
  readonly starred_url?: string;
  readonly subscriptions_url?: string;
  readonly organizations_url?: string;
  readonly repos_url?: string;
  readonly events_url?: string;
  readonly received_events_url?: string;
  readonly type: string;
  readonly site_admin?: boolean;
  readonly contributions: number;
  readonly email?: string;
  readonly name?: string;
};

export type ReposListContributors200ResponseBody = ReadonlyArray<Contributor>;

export type ReposListContributors403ResponseBody = BasicError;

export type ReposListContributors404ResponseBody = BasicError;

export type ReposListContributorsRequestQuery = {
  readonly anon?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListContributorsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type DependabotAlert = {
  readonly number: AlertNumber;
  readonly state: 'dismissed' | 'fixed' | 'open';
  readonly dependency: {
    readonly package?: DependabotAlertPackage;
    readonly manifest_path?: string;
    readonly scope?: 'development' | 'runtime' | null;
  };
  readonly security_advisory: DependabotAlertSecurityAdvisory;
  readonly security_vulnerability: DependabotAlertSecurityVulnerability;
  readonly url: AlertUrl;
  readonly html_url: AlertHtmlUrl;
  readonly created_at: AlertCreatedAt;
  readonly updated_at: AlertUpdatedAt;
  readonly dismissed_at: AlertDismissedAt;
  readonly dismissed_by: SimpleUser;
  readonly dismissed_reason:
    | 'fix_started'
    | 'inaccurate'
    | 'no_bandwidth'
    | 'not_used'
    | 'tolerable_risk'
    | null;
  readonly dismissed_comment: string | null;
  readonly fixed_at: AlertFixedAt;
};

export type DependabotListAlertsForRepo200ResponseBody = ReadonlyArray<DependabotAlert>;

export type DependabotListAlertsForRepo400ResponseBody = BasicError;

export type DependabotListAlertsForRepo403ResponseBody = BasicError;

export type DependabotListAlertsForRepo404ResponseBody = BasicError;

export type DependabotListAlertsForRepo422ResponseBody = ValidationErrorSimple;

export type DependabotListAlertsForRepoRequestQuery = {
  readonly state?: string;
  readonly severity?: string;
  readonly ecosystem?: string;
  readonly package?: string;
  readonly manifest?: string;
  readonly scope?: 'development' | 'runtime';
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly page?: number;
  readonly per_page?: number;
  readonly before?: string;
  readonly after?: string;
  readonly first?: number;
  readonly last?: number;
};

export type DependabotListAlertsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type DependabotGetAlert200ResponseBody = DependabotAlert;

export type DependabotGetAlert403ResponseBody = BasicError;

export type DependabotGetAlert404ResponseBody = BasicError;

export type DependabotGetAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type DependabotUpdateAlert200ResponseBody = DependabotAlert;

export type DependabotUpdateAlert400ResponseBody = BasicError;

export type DependabotUpdateAlert403ResponseBody = BasicError;

export type DependabotUpdateAlert404ResponseBody = BasicError;

export type DependabotUpdateAlert409ResponseBody = BasicError;

export type DependabotUpdateAlert422ResponseBody = ValidationErrorSimple;

export type DependabotUpdateAlertRequestBody = {
  readonly state: 'dismissed' | 'open';
  readonly dismissed_reason?:
    | 'fix_started'
    | 'inaccurate'
    | 'no_bandwidth'
    | 'not_used'
    | 'tolerable_risk';
  readonly dismissed_comment?: string;
};

export type DependabotUpdateAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type DependabotSecret = {
  readonly name: string;
  readonly created_at: string;
  readonly updated_at: string;
};

export type DependabotListRepoSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<DependabotSecret>;
};

export type DependabotListRepoSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type DependabotListRepoSecretsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type DependabotGetRepoPublicKey200ResponseBody = DependabotPublicKey;

export type DependabotGetRepoPublicKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type DependabotGetRepoSecret200ResponseBody = DependabotSecret;

export type DependabotGetRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type DependabotCreateOrUpdateRepoSecret201ResponseBody = EmptyObject;

export type DependabotCreateOrUpdateRepoSecretRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id?: string;
};

export type DependabotCreateOrUpdateRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type DependabotDeleteRepoSecretRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly secret_name: string;
};

export type DependencyGraphDiff = ReadonlyArray<{
  readonly change_type: 'added' | 'removed';
  readonly manifest: string;
  readonly ecosystem: string;
  readonly name: string;
  readonly version: string;
  readonly package_url: string | null;
  readonly license: string | null;
  readonly source_repository_url: string | null;
  readonly vulnerabilities: ReadonlyArray<{
    readonly severity: string;
    readonly advisory_ghsa_id: string;
    readonly advisory_summary: string;
    readonly advisory_url: string;
  }>;
  readonly scope: 'unknown' | 'runtime' | 'development';
}>;

export type DependencyGraphDiffRange200ResponseBody = DependencyGraphDiff;

export type DependencyGraphDiffRange403ResponseBody = BasicError;

export type DependencyGraphDiffRange404ResponseBody = BasicError;

export type DependencyGraphDiffRangeRequestQuery = { readonly name?: string };

export type DependencyGraphDiffRangeRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly basehead: string;
};

export type DependencyGraphCreateRepositorySnapshot201ResponseBody = {
  readonly id: number;
  readonly created_at: string;
  readonly result: string;
  readonly message: string;
};

export type Metadata = unknown;

export type Snapshot = {
  readonly version: number;
  readonly job: {
    readonly id: string;
    readonly correlator: string;
    readonly html_url?: string;
  };
  readonly sha: string;
  readonly ref: string;
  readonly detector: {
    readonly name: string;
    readonly version: string;
    readonly url: string;
  };
  readonly metadata?: Metadata;
  readonly manifests?: unknown;
  readonly scanned: string;
};

export type DependencyGraphCreateRepositorySnapshotRequestBody = Snapshot;

export type DependencyGraphCreateRepositorySnapshotRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposListDeployments200ResponseBody = ReadonlyArray<Deployment>;

export type ReposListDeploymentsRequestQuery = {
  readonly sha?: string;
  readonly ref?: string;
  readonly task?: string;
  readonly environment?: string | null;
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListDeploymentsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateDeployment201ResponseBody = Deployment;

export type ReposCreateDeployment202ResponseBody = {
  readonly message?: string;
};

export type ReposCreateDeployment422ResponseBody = ValidationError;

export type ReposCreateDeploymentRequestBody = {
  readonly ref: string;
  readonly task?: string;
  readonly auto_merge?: boolean;
  readonly required_contexts?: ReadonlyArray<string>;
  readonly payload?: unknown | string;
  readonly environment?: string;
  readonly description?: string | null;
  readonly transient_environment?: boolean;
  readonly production_environment?: boolean;
};

export type ReposCreateDeploymentRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetDeployment200ResponseBody = Deployment;

export type ReposGetDeployment404ResponseBody = BasicError;

export type ReposGetDeploymentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly deployment_id: number;
};

export type ReposDeleteDeployment404ResponseBody = BasicError;

export type ReposDeleteDeployment422ResponseBody = ValidationErrorSimple;

export type ReposDeleteDeploymentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly deployment_id: number;
};

export type DeploymentStatus = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly state:
    | 'error'
    | 'failure'
    | 'inactive'
    | 'pending'
    | 'success'
    | 'queued'
    | 'in_progress';
  readonly creator: SimpleUser;
  readonly description: string;
  readonly environment?: string;
  readonly target_url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly deployment_url: string;
  readonly repository_url: string;
  readonly environment_url?: string;
  readonly log_url?: string;
  readonly performed_via_github_app?: GitHubApp;
};

export type ReposListDeploymentStatuses200ResponseBody = ReadonlyArray<DeploymentStatus>;

export type ReposListDeploymentStatuses404ResponseBody = BasicError;

export type ReposListDeploymentStatusesRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListDeploymentStatusesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly deployment_id: number;
};

export type ReposCreateDeploymentStatus201ResponseBody = DeploymentStatus;

export type ReposCreateDeploymentStatus422ResponseBody = ValidationError;

export type ReposCreateDeploymentStatusRequestBody = {
  readonly state:
    | 'error'
    | 'failure'
    | 'inactive'
    | 'in_progress'
    | 'queued'
    | 'pending'
    | 'success';
  readonly target_url?: string;
  readonly log_url?: string;
  readonly description?: string;
  readonly environment?: 'production' | 'staging' | 'qa';
  readonly environment_url?: string;
  readonly auto_inactive?: boolean;
};

export type ReposCreateDeploymentStatusRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly deployment_id: number;
};

export type ReposGetDeploymentStatus200ResponseBody = DeploymentStatus;

export type ReposGetDeploymentStatus404ResponseBody = BasicError;

export type ReposGetDeploymentStatusRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly deployment_id: number;
  readonly status_id: number;
};

export type ReposCreateDispatchEvent422ResponseBody = ValidationError;

export type ReposCreateDispatchEventRequestBody = {
  readonly event_type: string;
  readonly client_payload?: unknown;
};

export type ReposCreateDispatchEventRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type WaitTimer = number;

export type DeploymentBranchPolicySettings = {
  readonly protected_branches: boolean;
  readonly custom_branch_policies: boolean;
} | null;

export type Environment = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly url: string;
  readonly html_url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly protection_rules?: ReadonlyArray<
    | {
        readonly id: number;
        readonly node_id: string;
        readonly type: string;
        readonly wait_timer?: WaitTimer;
      }
    | {
        readonly id: number;
        readonly node_id: string;
        readonly type: string;
        readonly reviewers?: ReadonlyArray<{
          readonly type?: DeploymentReviewerType;
          readonly reviewer?: SimpleUser | Team;
        }>;
      }
    | { readonly id: number; readonly node_id: string; readonly type: string }
  >;
  readonly deployment_branch_policy?: DeploymentBranchPolicySettings;
};

export type ReposGetAllEnvironments200ResponseBody = {
  readonly total_count?: number;
  readonly environments?: ReadonlyArray<Environment>;
};

export type ReposGetAllEnvironmentsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposGetAllEnvironmentsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetEnvironment200ResponseBody = Environment;

export type ReposGetEnvironmentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
};

export type ReposCreateOrUpdateEnvironment200ResponseBody = Environment;

export type ReposCreateOrUpdateEnvironment422ResponseBody = BasicError;

export type ReposCreateOrUpdateEnvironmentRequestBody = {
  readonly wait_timer?: WaitTimer;
  readonly reviewers?: ReadonlyArray<{
    readonly type?: DeploymentReviewerType;
    readonly id?: number;
  }> | null;
  readonly deployment_branch_policy?: DeploymentBranchPolicySettings;
} | null;

export type ReposCreateOrUpdateEnvironmentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
};

export type ReposDeleteAnEnvironmentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
};

export type DeploymentBranchPolicy = {
  readonly id?: number;
  readonly node_id?: string;
  readonly name?: string;
};

export type ReposListDeploymentBranchPolicies200ResponseBody = {
  readonly total_count: number;
  readonly branch_policies: ReadonlyArray<DeploymentBranchPolicy>;
};

export type ReposListDeploymentBranchPoliciesRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListDeploymentBranchPoliciesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
};

export type ReposCreateDeploymentBranchPolicy200ResponseBody = DeploymentBranchPolicy;

export type DeploymentBranchPolicyNamePattern = { readonly name: string };

export type ReposCreateDeploymentBranchPolicyRequestBody = DeploymentBranchPolicyNamePattern;

export type ReposCreateDeploymentBranchPolicyRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
};

export type ReposGetDeploymentBranchPolicy200ResponseBody = DeploymentBranchPolicy;

export type ReposGetDeploymentBranchPolicyRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
  readonly branch_policy_id: number;
};

export type ReposUpdateDeploymentBranchPolicy200ResponseBody = DeploymentBranchPolicy;

export type ReposUpdateDeploymentBranchPolicyRequestBody = DeploymentBranchPolicyNamePattern;

export type ReposUpdateDeploymentBranchPolicyRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
  readonly branch_policy_id: number;
};

export type ReposDeleteDeploymentBranchPolicyRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly environment_name: string;
  readonly branch_policy_id: number;
};

export type ActivityListRepoEvents200ResponseBody = ReadonlyArray<Event>;

export type ActivityListRepoEventsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListRepoEventsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposListForks200ResponseBody = ReadonlyArray<MinimalRepository>;

export type ReposListForks400ResponseBody = BasicError;

export type ReposListForksRequestQuery = {
  readonly sort?: 'newest' | 'oldest' | 'stargazers' | 'watchers';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListForksRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateFork202ResponseBody = FullRepository;

export type ReposCreateFork400ResponseBody = BasicError;

export type ReposCreateFork403ResponseBody = BasicError;

export type ReposCreateFork404ResponseBody = BasicError;

export type ReposCreateFork422ResponseBody = ValidationError;

export type ReposCreateForkRequestBody = {
  readonly organization?: string;
  readonly name?: string;
  readonly default_branch_only?: boolean;
} | null;

export type ReposCreateForkRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ShortBlob = { readonly url: string; readonly sha: string };

export type GitCreateBlob201ResponseBody = ShortBlob;

export type GitCreateBlob403ResponseBody = BasicError;

export type GitCreateBlob404ResponseBody = BasicError;

export type GitCreateBlob409ResponseBody = BasicError;

export type GitCreateBlob422ResponseBody = ValidationError;

export type GitCreateBlobRequestBody = {
  readonly content: string;
  readonly encoding?: string;
};

export type GitCreateBlobRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type Blob = {
  readonly content: string;
  readonly encoding: string;
  readonly url: string;
  readonly sha: string;
  readonly size: number | null;
  readonly node_id: string;
  readonly highlighted_content?: string;
};

export type GitGetBlob200ResponseBody = Blob;

export type GitGetBlob403ResponseBody = BasicError;

export type GitGetBlob404ResponseBody = BasicError;

export type GitGetBlob422ResponseBody = ValidationError;

export type GitGetBlobRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly file_sha: string;
};

export type GitCommit = {
  readonly sha: string;
  readonly node_id: string;
  readonly url: string;
  readonly author: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly committer: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly message: string;
  readonly tree: { readonly sha: string; readonly url: string };
  readonly parents: ReadonlyArray<{
    readonly sha: string;
    readonly url: string;
    readonly html_url: string;
  }>;
  readonly verification: {
    readonly verified: boolean;
    readonly reason: string;
    readonly signature: string | null;
    readonly payload: string | null;
  };
  readonly html_url: string;
};

export type GitCreateCommit201ResponseBody = GitCommit;

export type GitCreateCommit404ResponseBody = BasicError;

export type GitCreateCommit422ResponseBody = ValidationError;

export type GitCreateCommitRequestBody = {
  readonly message: string;
  readonly tree: string;
  readonly parents?: ReadonlyArray<string>;
  readonly author?: {
    readonly name: string;
    readonly email: string;
    readonly date?: string;
  };
  readonly committer?: {
    readonly name?: string;
    readonly email?: string;
    readonly date?: string;
  };
  readonly signature?: string;
};

export type GitCreateCommitRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type GitGetCommit200ResponseBody = GitCommit;

export type GitGetCommit404ResponseBody = BasicError;

export type GitGetCommitRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly commit_sha: string;
};

export type GitReference = {
  readonly ref: string;
  readonly node_id: string;
  readonly url: string;
  readonly object: {
    readonly type: string;
    readonly sha: string;
    readonly url: string;
  };
};

export type GitListMatchingRefs200ResponseBody = ReadonlyArray<GitReference>;

export type GitListMatchingRefsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type GitGetRef200ResponseBody = GitReference;

export type GitGetRef404ResponseBody = BasicError;

export type GitGetRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type GitCreateRef201ResponseBody = GitReference;

export type GitCreateRef422ResponseBody = ValidationError;

export type GitCreateRefRequestBody = {
  readonly ref: string;
  readonly sha: string;
  readonly key?: string;
};

export type GitCreateRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type GitUpdateRef200ResponseBody = GitReference;

export type GitUpdateRef422ResponseBody = ValidationError;

export type GitUpdateRefRequestBody = {
  readonly sha: string;
  readonly force?: boolean;
};

export type GitUpdateRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type GitDeleteRef422ResponseBody = ValidationError;

export type GitDeleteRefRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type GitTag = {
  readonly node_id: string;
  readonly tag: string;
  readonly sha: string;
  readonly url: string;
  readonly message: string;
  readonly tagger: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly object: {
    readonly sha: string;
    readonly type: string;
    readonly url: string;
  };
  readonly verification?: Verification;
};

export type GitCreateTag201ResponseBody = GitTag;

export type GitCreateTag422ResponseBody = ValidationError;

export type GitCreateTagRequestBody = {
  readonly tag: string;
  readonly message: string;
  readonly object: string;
  readonly type: 'commit' | 'tree' | 'blob';
  readonly tagger?: {
    readonly name: string;
    readonly email: string;
    readonly date?: string;
  };
};

export type GitCreateTagRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type GitGetTag200ResponseBody = GitTag;

export type GitGetTag404ResponseBody = BasicError;

export type GitGetTagRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly tag_sha: string;
};

export type GitTree = {
  readonly sha: string;
  readonly url: string;
  readonly truncated: boolean;
  readonly tree: ReadonlyArray<{
    readonly path?: string;
    readonly mode?: string;
    readonly type?: string;
    readonly sha?: string;
    readonly size?: number;
    readonly url?: string;
  }>;
};

export type GitCreateTree201ResponseBody = GitTree;

export type GitCreateTree403ResponseBody = BasicError;

export type GitCreateTree404ResponseBody = BasicError;

export type GitCreateTree422ResponseBody = ValidationError;

export type GitCreateTreeRequestBody = {
  readonly tree: ReadonlyArray<{
    readonly path?: string;
    readonly mode?: '100644' | '100755' | '040000' | '160000' | '120000';
    readonly type?: 'blob' | 'tree' | 'commit';
    readonly sha?: string | null;
    readonly content?: string;
  }>;
  readonly base_tree?: string;
};

export type GitCreateTreeRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type GitGetTree200ResponseBody = GitTree;

export type GitGetTree404ResponseBody = BasicError;

export type GitGetTree422ResponseBody = ValidationError;

export type GitGetTreeRequestQuery = { readonly recursive?: string };

export type GitGetTreeRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly tree_sha: string;
};

export type HookResponse = {
  readonly code: number | null;
  readonly status: string | null;
  readonly message: string | null;
};

export type Webhook = {
  readonly type: string;
  readonly id: number;
  readonly name: string;
  readonly active: boolean;
  readonly events: ReadonlyArray<string>;
  readonly config: {
    readonly email?: string;
    readonly password?: string;
    readonly room?: string;
    readonly subdomain?: string;
    readonly url?: WebhookConfigUrl;
    readonly insecure_ssl?: WebhookConfigInsecureSsl;
    readonly content_type?: WebhookConfigContentType;
    readonly digest?: string;
    readonly secret?: WebhookConfigSecret;
    readonly token?: string;
  };
  readonly updated_at: string;
  readonly created_at: string;
  readonly url: string;
  readonly test_url: string;
  readonly ping_url: string;
  readonly deliveries_url?: string;
  readonly last_response: HookResponse;
};

export type ReposListWebhooks200ResponseBody = ReadonlyArray<Webhook>;

export type ReposListWebhooks404ResponseBody = BasicError;

export type ReposListWebhooksRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListWebhooksRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateWebhook201ResponseBody = Webhook;

export type ReposCreateWebhook403ResponseBody = BasicError;

export type ReposCreateWebhook404ResponseBody = BasicError;

export type ReposCreateWebhook422ResponseBody = ValidationError;

export type ReposCreateWebhookRequestBody = {
  readonly name?: string;
  readonly config?: {
    readonly url?: WebhookConfigUrl;
    readonly content_type?: WebhookConfigContentType;
    readonly secret?: WebhookConfigSecret;
    readonly insecure_ssl?: WebhookConfigInsecureSsl;
    readonly token?: string;
    readonly digest?: string;
  };
  readonly events?: ReadonlyArray<string>;
  readonly active?: boolean;
} | null;

export type ReposCreateWebhookRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetWebhook200ResponseBody = Webhook;

export type ReposGetWebhook404ResponseBody = BasicError;

export type ReposGetWebhookRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposUpdateWebhook200ResponseBody = Webhook;

export type ReposUpdateWebhook404ResponseBody = BasicError;

export type ReposUpdateWebhook422ResponseBody = ValidationError;

export type ReposUpdateWebhookRequestBody = {
  readonly config?: {
    readonly url: WebhookConfigUrl;
    readonly content_type?: WebhookConfigContentType;
    readonly secret?: WebhookConfigSecret;
    readonly insecure_ssl?: WebhookConfigInsecureSsl;
    readonly address?: string;
    readonly room?: string;
  };
  readonly events?: ReadonlyArray<string>;
  readonly add_events?: ReadonlyArray<string>;
  readonly remove_events?: ReadonlyArray<string>;
  readonly active?: boolean;
};

export type ReposUpdateWebhookRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposDeleteWebhook404ResponseBody = BasicError;

export type ReposDeleteWebhookRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposGetWebhookConfigForRepo200ResponseBody = WebhookConfiguration;

export type ReposGetWebhookConfigForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposUpdateWebhookConfigForRepo200ResponseBody = WebhookConfiguration;

export type ReposUpdateWebhookConfigForRepoRequestBody = {
  readonly url?: WebhookConfigUrl;
  readonly content_type?: WebhookConfigContentType;
  readonly secret?: WebhookConfigSecret;
  readonly insecure_ssl?: WebhookConfigInsecureSsl;
};

export type ReposUpdateWebhookConfigForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposListWebhookDeliveries200ResponseBody = ReadonlyArray<SimpleWebhookDelivery>;

export type ReposListWebhookDeliveries400ResponseBody = BasicError;

export type ReposListWebhookDeliveries422ResponseBody = ValidationError;

export type ReposListWebhookDeliveriesRequestQuery = {
  readonly per_page?: number;
  readonly cursor?: string;
};

export type ReposListWebhookDeliveriesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposGetWebhookDelivery200ResponseBody = WebhookDelivery;

export type ReposGetWebhookDelivery400ResponseBody = BasicError;

export type ReposGetWebhookDelivery422ResponseBody = ValidationError;

export type ReposGetWebhookDeliveryRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
  readonly delivery_id: number;
};

export type ReposRedeliverWebhookDelivery202ResponseBody = unknown;

export type ReposRedeliverWebhookDelivery400ResponseBody = BasicError;

export type ReposRedeliverWebhookDelivery422ResponseBody = ValidationError;

export type ReposRedeliverWebhookDeliveryRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
  readonly delivery_id: number;
};

export type ReposPingWebhook404ResponseBody = BasicError;

export type ReposPingWebhookRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type ReposTestPushWebhook404ResponseBody = BasicError;

export type ReposTestPushWebhookRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly hook_id: number;
};

export type Import = {
  readonly vcs: string | null;
  readonly use_lfs?: boolean;
  readonly vcs_url: string;
  readonly svc_root?: string;
  readonly tfvc_project?: string;
  readonly status:
    | 'auth'
    | 'error'
    | 'none'
    | 'detecting'
    | 'choose'
    | 'auth_failed'
    | 'importing'
    | 'mapping'
    | 'waiting_to_push'
    | 'pushing'
    | 'complete'
    | 'setup'
    | 'unknown'
    | 'detection_found_multiple'
    | 'detection_found_nothing'
    | 'detection_needs_auth';
  readonly status_text?: string | null;
  readonly failed_step?: string | null;
  readonly error_message?: string | null;
  readonly import_percent?: number | null;
  readonly commit_count?: number | null;
  readonly push_percent?: number | null;
  readonly has_large_files?: boolean;
  readonly large_files_size?: number;
  readonly large_files_count?: number;
  readonly project_choices?: ReadonlyArray<{
    readonly vcs?: string;
    readonly tfvc_project?: string;
    readonly human_name?: string;
  }>;
  readonly message?: string;
  readonly authors_count?: number | null;
  readonly url: string;
  readonly html_url: string;
  readonly authors_url: string;
  readonly repository_url: string;
  readonly svn_root?: string;
};

export type MigrationsGetImportStatus200ResponseBody = Import;

export type MigrationsGetImportStatus404ResponseBody = BasicError;

export type MigrationsGetImportStatusRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MigrationsStartImport201ResponseBody = Import;

export type MigrationsStartImport404ResponseBody = BasicError;

export type MigrationsStartImport422ResponseBody = ValidationError;

export type MigrationsStartImportRequestBody = {
  readonly vcs_url: string;
  readonly vcs?: 'subversion' | 'git' | 'mercurial' | 'tfvc';
  readonly vcs_username?: string;
  readonly vcs_password?: string;
  readonly tfvc_project?: string;
};

export type MigrationsStartImportRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MigrationsUpdateImport200ResponseBody = Import;

export type MigrationsUpdateImportRequestBody = {
  readonly vcs_username?: string;
  readonly vcs_password?: string;
  readonly vcs?: 'subversion' | 'tfvc' | 'git' | 'mercurial';
  readonly tfvc_project?: string;
} | null;

export type MigrationsUpdateImportRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MigrationsCancelImportRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PorterAuthor = {
  readonly id: number;
  readonly remote_id: string;
  readonly remote_name: string;
  readonly email: string;
  readonly name: string;
  readonly url: string;
  readonly import_url: string;
};

export type MigrationsGetCommitAuthors200ResponseBody = ReadonlyArray<PorterAuthor>;

export type MigrationsGetCommitAuthors404ResponseBody = BasicError;

export type MigrationsGetCommitAuthorsRequestQuery = {
  readonly since?: number;
};

export type MigrationsGetCommitAuthorsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MigrationsMapCommitAuthor200ResponseBody = PorterAuthor;

export type MigrationsMapCommitAuthor404ResponseBody = BasicError;

export type MigrationsMapCommitAuthor422ResponseBody = ValidationError;

export type MigrationsMapCommitAuthorRequestBody = {
  readonly email?: string;
  readonly name?: string;
};

export type MigrationsMapCommitAuthorRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly author_id: number;
};

export type PorterLargeFile = {
  readonly ref_name: string;
  readonly path: string;
  readonly oid: string;
  readonly size: number;
};

export type MigrationsGetLargeFiles200ResponseBody = ReadonlyArray<PorterLargeFile>;

export type MigrationsGetLargeFilesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MigrationsSetLfsPreference200ResponseBody = Import;

export type MigrationsSetLfsPreference422ResponseBody = ValidationError;

export type MigrationsSetLfsPreferenceRequestBody = {
  readonly use_lfs: 'opt_in' | 'opt_out';
};

export type MigrationsSetLfsPreferenceRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type AppsGetRepoInstallation200ResponseBody = Installation;

export type AppsGetRepoInstallation301ResponseBody = BasicError;

export type AppsGetRepoInstallation404ResponseBody = BasicError;

export type AppsGetRepoInstallationRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type InteractionsGetRestrictionsForRepo200ResponseBody =
  | InteractionLimits
  | {};

export type InteractionsGetRestrictionsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type InteractionsSetRestrictionsForRepo200ResponseBody = InteractionLimits;

export type InteractionsSetRestrictionsForRepoRequestBody = InteractionRestrictions;

export type InteractionsSetRestrictionsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type InteractionsRemoveRestrictionsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposListInvitations200ResponseBody = ReadonlyArray<RepositoryInvitation>;

export type ReposListInvitationsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListInvitationsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposUpdateInvitation200ResponseBody = RepositoryInvitation;

export type ReposUpdateInvitationRequestBody = {
  readonly permissions?: 'read' | 'write' | 'maintain' | 'triage' | 'admin';
};

export type ReposUpdateInvitationRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly invitation_id: number;
};

export type ReposDeleteInvitationRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly invitation_id: number;
};

export type IssuesListForRepo200ResponseBody = ReadonlyArray<Issue>;

export type IssuesListForRepo301ResponseBody = BasicError;

export type IssuesListForRepo404ResponseBody = BasicError;

export type IssuesListForRepo422ResponseBody = ValidationError;

export type IssuesListForRepoRequestQuery = {
  readonly milestone?: string;
  readonly state?: 'open' | 'closed' | 'all';
  readonly assignee?: string;
  readonly creator?: string;
  readonly mentioned?: string;
  readonly labels?: string;
  readonly sort?: 'created' | 'updated' | 'comments';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesCreate201ResponseBody = Issue;

export type IssuesCreate403ResponseBody = BasicError;

export type IssuesCreate404ResponseBody = BasicError;

export type IssuesCreate410ResponseBody = BasicError;

export type IssuesCreate422ResponseBody = ValidationError;

export type IssuesCreate503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type IssuesCreateRequestBody = {
  readonly title: string | number;
  readonly body?: string;
  readonly assignee?: string | null;
  readonly milestone?: string | number | null;
  readonly labels?: ReadonlyArray<
    | string
    | {
        readonly id?: number;
        readonly name?: string;
        readonly description?: string | null;
        readonly color?: string | null;
      }
  >;
  readonly assignees?: ReadonlyArray<string>;
};

export type IssuesCreateRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesListCommentsForRepo200ResponseBody = ReadonlyArray<IssueComment>;

export type IssuesListCommentsForRepo404ResponseBody = BasicError;

export type IssuesListCommentsForRepo422ResponseBody = ValidationError;

export type IssuesListCommentsForRepoRequestQuery = {
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListCommentsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesGetComment200ResponseBody = IssueComment;

export type IssuesGetComment404ResponseBody = BasicError;

export type IssuesGetCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type IssuesUpdateComment200ResponseBody = IssueComment;

export type IssuesUpdateComment422ResponseBody = ValidationError;

export type IssuesUpdateCommentRequestBody = { readonly body: string };

export type IssuesUpdateCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type IssuesDeleteCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsListForIssueComment200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForIssueComment404ResponseBody = BasicError;

export type ReactionsListForIssueCommentRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForIssueCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsCreateForIssueComment200ResponseBody = Reaction;

export type ReactionsCreateForIssueComment201ResponseBody = Reaction;

export type ReactionsCreateForIssueComment422ResponseBody = ValidationError;

export type ReactionsCreateForIssueCommentRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForIssueCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsDeleteForIssueCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
  readonly reaction_id: number;
};

export type IssueEventLabel = {
  readonly name: string | null;
  readonly color: string | null;
};

export type IssueEventDismissedReview = {
  readonly state: string;
  readonly review_id: number;
  readonly dismissal_message: string | null;
  readonly dismissal_commit_id?: string | null;
};

export type IssueEventMilestone = { readonly title: string };

export type IssueEventProjectCard = {
  readonly url: string;
  readonly id: number;
  readonly project_url: string;
  readonly project_id: number;
  readonly column_name: string;
  readonly previous_column_name?: string;
};

export type IssueEventRename = { readonly from: string; readonly to: string };

export type IssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly issue?: Issue;
  readonly label?: IssueEventLabel;
  readonly assignee?: SimpleUser;
  readonly assigner?: SimpleUser;
  readonly review_requester?: SimpleUser;
  readonly requested_reviewer?: SimpleUser;
  readonly requested_team?: Team;
  readonly dismissed_review?: IssueEventDismissedReview;
  readonly milestone?: IssueEventMilestone;
  readonly project_card?: IssueEventProjectCard;
  readonly rename?: IssueEventRename;
  readonly author_association?: AuthorAssociation;
  readonly lock_reason?: string | null;
  readonly performed_via_github_app?: GitHubApp;
};

export type IssuesListEventsForRepo200ResponseBody = ReadonlyArray<IssueEvent>;

export type IssuesListEventsForRepo422ResponseBody = ValidationError;

export type IssuesListEventsForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListEventsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesGetEvent200ResponseBody = IssueEvent;

export type IssuesGetEvent403ResponseBody = BasicError;

export type IssuesGetEvent404ResponseBody = BasicError;

export type IssuesGetEvent410ResponseBody = BasicError;

export type IssuesGetEventRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly event_id: number;
};

export type IssuesGet200ResponseBody = Issue;

export type IssuesGet301ResponseBody = BasicError;

export type IssuesGet404ResponseBody = BasicError;

export type IssuesGet410ResponseBody = BasicError;

export type IssuesGetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesUpdate200ResponseBody = Issue;

export type IssuesUpdate301ResponseBody = BasicError;

export type IssuesUpdate403ResponseBody = BasicError;

export type IssuesUpdate404ResponseBody = BasicError;

export type IssuesUpdate410ResponseBody = BasicError;

export type IssuesUpdate422ResponseBody = ValidationError;

export type IssuesUpdate503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type IssuesUpdateRequestBody = {
  readonly title?: string | number | null;
  readonly body?: string | null;
  readonly assignee?: string | null;
  readonly state?: 'open' | 'closed';
  readonly state_reason?: 'completed' | 'not_planned' | 'reopened' | null;
  readonly milestone?: string | number | null;
  readonly labels?: ReadonlyArray<
    | string
    | {
        readonly id?: number;
        readonly name?: string;
        readonly description?: string | null;
        readonly color?: string | null;
      }
  >;
  readonly assignees?: ReadonlyArray<string>;
};

export type IssuesUpdateRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesAddAssignees201ResponseBody = Issue;

export type IssuesAddAssigneesRequestBody = {
  readonly assignees?: ReadonlyArray<string>;
};

export type IssuesAddAssigneesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesRemoveAssignees200ResponseBody = Issue;

export type IssuesRemoveAssigneesRequestBody = {
  readonly assignees?: ReadonlyArray<string>;
};

export type IssuesRemoveAssigneesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesListComments200ResponseBody = ReadonlyArray<IssueComment>;

export type IssuesListComments404ResponseBody = BasicError;

export type IssuesListComments410ResponseBody = BasicError;

export type IssuesListCommentsRequestQuery = {
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListCommentsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesCreateComment201ResponseBody = IssueComment;

export type IssuesCreateComment403ResponseBody = BasicError;

export type IssuesCreateComment404ResponseBody = BasicError;

export type IssuesCreateComment410ResponseBody = BasicError;

export type IssuesCreateComment422ResponseBody = ValidationError;

export type IssuesCreateCommentRequestBody = { readonly body: string };

export type IssuesCreateCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type LabeledIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly label: { readonly name: string; readonly color: string };
};

export type UnlabeledIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly label: { readonly name: string; readonly color: string };
};

export type AssignedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly assignee: SimpleUser;
  readonly assigner: SimpleUser;
};

export type UnassignedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly assignee: SimpleUser;
  readonly assigner: SimpleUser;
};

export type MilestonedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly milestone: { readonly title: string };
};

export type DemilestonedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly milestone: { readonly title: string };
};

export type RenamedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly rename: { readonly from: string; readonly to: string };
};

export type ReviewRequestedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly review_requester: SimpleUser;
  readonly requested_team?: Team;
  readonly requested_reviewer?: SimpleUser;
};

export type ReviewRequestRemovedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly review_requester: SimpleUser;
  readonly requested_team?: Team;
  readonly requested_reviewer?: SimpleUser;
};

export type ReviewDismissedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly dismissed_review: {
    readonly state: string;
    readonly review_id: number;
    readonly dismissal_message: string | null;
    readonly dismissal_commit_id?: string;
  };
};

export type LockedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly lock_reason: string | null;
};

export type AddedToProjectIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly project_card?: {
    readonly id: number;
    readonly url: string;
    readonly project_id: number;
    readonly project_url: string;
    readonly column_name: string;
    readonly previous_column_name?: string;
  };
};

export type MovedColumnInProjectIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly project_card?: {
    readonly id: number;
    readonly url: string;
    readonly project_id: number;
    readonly project_url: string;
    readonly column_name: string;
    readonly previous_column_name?: string;
  };
};

export type RemovedFromProjectIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly project_card?: {
    readonly id: number;
    readonly url: string;
    readonly project_id: number;
    readonly project_url: string;
    readonly column_name: string;
    readonly previous_column_name?: string;
  };
};

export type ConvertedNoteToIssueIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly project_card?: {
    readonly id: number;
    readonly url: string;
    readonly project_id: number;
    readonly project_url: string;
    readonly column_name: string;
    readonly previous_column_name?: string;
  };
};

export type IssueEventForIssue =
  | LabeledIssueEvent
  | UnlabeledIssueEvent
  | AssignedIssueEvent
  | UnassignedIssueEvent
  | MilestonedIssueEvent
  | DemilestonedIssueEvent
  | RenamedIssueEvent
  | ReviewRequestedIssueEvent
  | ReviewRequestRemovedIssueEvent
  | ReviewDismissedIssueEvent
  | LockedIssueEvent
  | AddedToProjectIssueEvent
  | MovedColumnInProjectIssueEvent
  | RemovedFromProjectIssueEvent
  | ConvertedNoteToIssueIssueEvent;

export type IssuesListEvents200ResponseBody = ReadonlyArray<IssueEventForIssue>;

export type IssuesListEvents410ResponseBody = BasicError;

export type IssuesListEventsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListEventsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type Label = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly name: string;
  readonly description: string | null;
  readonly color: string;
  readonly default: boolean;
};

export type IssuesListLabelsOnIssue200ResponseBody = ReadonlyArray<Label>;

export type IssuesListLabelsOnIssue301ResponseBody = BasicError;

export type IssuesListLabelsOnIssue404ResponseBody = BasicError;

export type IssuesListLabelsOnIssue410ResponseBody = BasicError;

export type IssuesListLabelsOnIssueRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListLabelsOnIssueRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesAddLabels200ResponseBody = ReadonlyArray<Label>;

export type IssuesAddLabels301ResponseBody = BasicError;

export type IssuesAddLabels404ResponseBody = BasicError;

export type IssuesAddLabels410ResponseBody = BasicError;

export type IssuesAddLabels422ResponseBody = ValidationError;

export type IssuesAddLabelsRequestBody =
  | { readonly labels?: ReadonlyArray<string> }
  | ReadonlyArray<string>
  | { readonly labels?: ReadonlyArray<{ readonly name: string }> }
  | ReadonlyArray<{ readonly name: string }>
  | string;

export type IssuesAddLabelsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesSetLabels200ResponseBody = ReadonlyArray<Label>;

export type IssuesSetLabels301ResponseBody = BasicError;

export type IssuesSetLabels404ResponseBody = BasicError;

export type IssuesSetLabels410ResponseBody = BasicError;

export type IssuesSetLabels422ResponseBody = ValidationError;

export type IssuesSetLabelsRequestBody =
  | { readonly labels?: ReadonlyArray<string> }
  | ReadonlyArray<string>
  | { readonly labels?: ReadonlyArray<{ readonly name: string }> }
  | ReadonlyArray<{ readonly name: string }>
  | string;

export type IssuesSetLabelsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesRemoveAllLabels301ResponseBody = BasicError;

export type IssuesRemoveAllLabels404ResponseBody = BasicError;

export type IssuesRemoveAllLabels410ResponseBody = BasicError;

export type IssuesRemoveAllLabelsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesRemoveLabel200ResponseBody = ReadonlyArray<Label>;

export type IssuesRemoveLabel301ResponseBody = BasicError;

export type IssuesRemoveLabel404ResponseBody = BasicError;

export type IssuesRemoveLabel410ResponseBody = BasicError;

export type IssuesRemoveLabelRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
  readonly name: string;
};

export type IssuesLock403ResponseBody = BasicError;

export type IssuesLock404ResponseBody = BasicError;

export type IssuesLock410ResponseBody = BasicError;

export type IssuesLock422ResponseBody = ValidationError;

export type IssuesLockRequestBody = {
  readonly lock_reason?: 'off-topic' | 'too heated' | 'resolved' | 'spam';
} | null;

export type IssuesLockRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type IssuesUnlock403ResponseBody = BasicError;

export type IssuesUnlock404ResponseBody = BasicError;

export type IssuesUnlockRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type ReactionsListForIssue200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForIssue404ResponseBody = BasicError;

export type ReactionsListForIssue410ResponseBody = BasicError;

export type ReactionsListForIssueRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForIssueRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type ReactionsCreateForIssue200ResponseBody = Reaction;

export type ReactionsCreateForIssue201ResponseBody = Reaction;

export type ReactionsCreateForIssue422ResponseBody = ValidationError;

export type ReactionsCreateForIssueRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForIssueRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type ReactionsDeleteForIssueRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
  readonly reaction_id: number;
};

export type TimelineCommentEvent = {
  readonly event: string;
  readonly actor: SimpleUser;
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly body?: string;
  readonly body_text?: string;
  readonly body_html?: string;
  readonly html_url: string;
  readonly user: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly issue_url: string;
  readonly author_association: AuthorAssociation;
  readonly performed_via_github_app?: GitHubApp;
  readonly reactions?: ReactionRollup;
};

export type TimelineCrossReferencedEvent = {
  readonly event: string;
  readonly actor?: SimpleUser;
  readonly created_at: string;
  readonly updated_at: string;
  readonly source: { readonly type?: string; readonly issue?: Issue };
};

export type TimelineCommittedEvent = {
  readonly event?: string;
  readonly sha: string;
  readonly node_id: string;
  readonly url: string;
  readonly author: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly committer: {
    readonly date: string;
    readonly email: string;
    readonly name: string;
  };
  readonly message: string;
  readonly tree: { readonly sha: string; readonly url: string };
  readonly parents: ReadonlyArray<{
    readonly sha: string;
    readonly url: string;
    readonly html_url: string;
  }>;
  readonly verification: {
    readonly verified: boolean;
    readonly reason: string;
    readonly signature: string | null;
    readonly payload: string | null;
  };
  readonly html_url: string;
};

export type TimelineReviewedEvent = {
  readonly event: string;
  readonly id: number;
  readonly node_id: string;
  readonly user: SimpleUser;
  readonly body: string | null;
  readonly state: string;
  readonly html_url: string;
  readonly pull_request_url: string;
  readonly _links: {
    readonly html: { readonly href: string };
    readonly pull_request: { readonly href: string };
  };
  readonly submitted_at?: string;
  readonly commit_id: string;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly author_association: AuthorAssociation;
};

export type PullRequestReviewComment = {
  readonly url: string;
  readonly pull_request_review_id: number | null;
  readonly id: number;
  readonly node_id: string;
  readonly diff_hunk: string;
  readonly path: string;
  readonly position: number;
  readonly original_position: number;
  readonly commit_id: string;
  readonly original_commit_id: string;
  readonly in_reply_to_id?: number;
  readonly user: SimpleUser;
  readonly body: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly html_url: string;
  readonly pull_request_url: string;
  readonly author_association: AuthorAssociation;
  readonly _links: {
    readonly self: { readonly href: string };
    readonly html: { readonly href: string };
    readonly pull_request: { readonly href: string };
  };
  readonly start_line?: number | null;
  readonly original_start_line?: number | null;
  readonly start_side?: 'LEFT' | 'RIGHT' | null;
  readonly line?: number;
  readonly original_line?: number;
  readonly side?: 'LEFT' | 'RIGHT';
  readonly reactions?: ReactionRollup;
  readonly body_html?: string;
  readonly body_text?: string;
};

export type TimelineLineCommentedEvent = {
  readonly event?: string;
  readonly node_id?: string;
  readonly comments?: ReadonlyArray<PullRequestReviewComment>;
};

export type TimelineCommitCommentedEvent = {
  readonly event?: string;
  readonly node_id?: string;
  readonly commit_id?: string;
  readonly comments?: ReadonlyArray<CommitComment>;
};

export type TimelineAssignedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly assignee: SimpleUser;
};

export type TimelineUnassignedIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly assignee: SimpleUser;
};

export type StateChangeIssueEvent = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly actor: SimpleUser;
  readonly event: string;
  readonly commit_id: string | null;
  readonly commit_url: string | null;
  readonly created_at: string;
  readonly performed_via_github_app: GitHubApp;
  readonly state_reason?: string | null;
};

export type TimelineEvent = unknown &
  (
    | LabeledIssueEvent
    | UnlabeledIssueEvent
    | MilestonedIssueEvent
    | DemilestonedIssueEvent
    | RenamedIssueEvent
    | ReviewRequestedIssueEvent
    | ReviewRequestRemovedIssueEvent
    | ReviewDismissedIssueEvent
    | LockedIssueEvent
    | AddedToProjectIssueEvent
    | MovedColumnInProjectIssueEvent
    | RemovedFromProjectIssueEvent
    | ConvertedNoteToIssueIssueEvent
    | TimelineCommentEvent
    | TimelineCrossReferencedEvent
    | TimelineCommittedEvent
    | TimelineReviewedEvent
    | TimelineLineCommentedEvent
    | TimelineCommitCommentedEvent
    | TimelineAssignedIssueEvent
    | TimelineUnassignedIssueEvent
    | StateChangeIssueEvent
  );

export type IssuesListEventsForTimeline200ResponseBody = ReadonlyArray<TimelineEvent>;

export type IssuesListEventsForTimeline404ResponseBody = BasicError;

export type IssuesListEventsForTimeline410ResponseBody = BasicError;

export type IssuesListEventsForTimelineRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListEventsForTimelineRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly issue_number: number;
};

export type DeployKey = {
  readonly id: number;
  readonly key: string;
  readonly url: string;
  readonly title: string;
  readonly verified: boolean;
  readonly created_at: string;
  readonly read_only: boolean;
  readonly added_by?: string | null;
  readonly last_used?: string | null;
};

export type ReposListDeployKeys200ResponseBody = ReadonlyArray<DeployKey>;

export type ReposListDeployKeysRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListDeployKeysRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateDeployKey201ResponseBody = DeployKey;

export type ReposCreateDeployKey422ResponseBody = ValidationError;

export type ReposCreateDeployKeyRequestBody = {
  readonly title?: string;
  readonly key: string;
  readonly read_only?: boolean;
};

export type ReposCreateDeployKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetDeployKey200ResponseBody = DeployKey;

export type ReposGetDeployKey404ResponseBody = BasicError;

export type ReposGetDeployKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly key_id: number;
};

export type ReposDeleteDeployKeyRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly key_id: number;
};

export type IssuesListLabelsForRepo200ResponseBody = ReadonlyArray<Label>;

export type IssuesListLabelsForRepo404ResponseBody = BasicError;

export type IssuesListLabelsForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListLabelsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesCreateLabel201ResponseBody = Label;

export type IssuesCreateLabel404ResponseBody = BasicError;

export type IssuesCreateLabel422ResponseBody = ValidationError;

export type IssuesCreateLabelRequestBody = {
  readonly name: string;
  readonly color?: string;
  readonly description?: string;
};

export type IssuesCreateLabelRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesGetLabel200ResponseBody = Label;

export type IssuesGetLabel404ResponseBody = BasicError;

export type IssuesGetLabelRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly name: string;
};

export type IssuesUpdateLabel200ResponseBody = Label;

export type IssuesUpdateLabelRequestBody = {
  readonly new_name?: string;
  readonly color?: string;
  readonly description?: string;
};

export type IssuesUpdateLabelRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly name: string;
};

export type IssuesDeleteLabelRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly name: string;
};

export type Language = unknown;

export type ReposListLanguages200ResponseBody = Language;

export type ReposListLanguagesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposEnableLfsForRepo202ResponseBody = unknown;

export type ReposEnableLfsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDisableLfsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type LicenseContent = {
  readonly name: string;
  readonly path: string;
  readonly sha: string;
  readonly size: number;
  readonly url: string;
  readonly html_url: string | null;
  readonly git_url: string | null;
  readonly download_url: string | null;
  readonly type: string;
  readonly content: string;
  readonly encoding: string;
  readonly _links: {
    readonly git: string | null;
    readonly html: string | null;
    readonly self: string;
  };
  readonly license: LicenseSimple;
};

export type LicensesGetForRepo200ResponseBody = LicenseContent;

export type LicensesGetForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type MergedUpstream = {
  readonly message?: string;
  readonly merge_type?: 'merge' | 'fast-forward' | 'none';
  readonly base_branch?: string;
};

export type ReposMergeUpstream200ResponseBody = MergedUpstream;

export type ReposMergeUpstreamRequestBody = { readonly branch: string };

export type ReposMergeUpstreamRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposMerge201ResponseBody = Commit;

export type ReposMerge403ResponseBody = BasicError;

export type ReposMerge422ResponseBody = ValidationError;

export type ReposMergeRequestBody = {
  readonly base: string;
  readonly head: string;
  readonly commit_message?: string;
};

export type ReposMergeRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesListMilestones200ResponseBody = ReadonlyArray<Milestone>;

export type IssuesListMilestones404ResponseBody = BasicError;

export type IssuesListMilestonesRequestQuery = {
  readonly state?: 'open' | 'closed' | 'all';
  readonly sort?: 'due_on' | 'completeness';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListMilestonesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesCreateMilestone201ResponseBody = Milestone;

export type IssuesCreateMilestone404ResponseBody = BasicError;

export type IssuesCreateMilestone422ResponseBody = ValidationError;

export type IssuesCreateMilestoneRequestBody = {
  readonly title: string;
  readonly state?: 'open' | 'closed';
  readonly description?: string;
  readonly due_on?: string;
};

export type IssuesCreateMilestoneRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type IssuesGetMilestone200ResponseBody = Milestone;

export type IssuesGetMilestone404ResponseBody = BasicError;

export type IssuesGetMilestoneRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly milestone_number: number;
};

export type IssuesUpdateMilestone200ResponseBody = Milestone;

export type IssuesUpdateMilestoneRequestBody = {
  readonly title?: string;
  readonly state?: 'open' | 'closed';
  readonly description?: string;
  readonly due_on?: string;
};

export type IssuesUpdateMilestoneRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly milestone_number: number;
};

export type IssuesDeleteMilestone404ResponseBody = BasicError;

export type IssuesDeleteMilestoneRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly milestone_number: number;
};

export type IssuesListLabelsForMilestone200ResponseBody = ReadonlyArray<Label>;

export type IssuesListLabelsForMilestoneRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type IssuesListLabelsForMilestoneRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly milestone_number: number;
};

export type ActivityListRepoNotificationsForAuthenticatedUser200ResponseBody = ReadonlyArray<Thread>;

export type ActivityListRepoNotificationsForAuthenticatedUserRequestQuery = {
  readonly all?: boolean;
  readonly participating?: boolean;
  readonly since?: string;
  readonly before?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListRepoNotificationsForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivityMarkRepoNotificationsAsRead202ResponseBody = {
  readonly message?: string;
  readonly url?: string;
};

export type ActivityMarkRepoNotificationsAsReadRequestBody = {
  readonly last_read_at?: string;
};

export type ActivityMarkRepoNotificationsAsReadRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PagesSourceHash = {
  readonly branch: string;
  readonly path: string;
};

export type PagesHttpsCertificate = {
  readonly state:
    | 'new'
    | 'authorization_created'
    | 'authorization_pending'
    | 'authorized'
    | 'authorization_revoked'
    | 'issued'
    | 'uploaded'
    | 'approved'
    | 'errored'
    | 'bad_authz'
    | 'destroy_pending'
    | 'dns_changed';
  readonly description: string;
  readonly domains: ReadonlyArray<string>;
  readonly expires_at?: string;
};

export type GitHubPages = {
  readonly url: string;
  readonly status: 'built' | 'building' | 'errored' | null;
  readonly cname: string | null;
  readonly protected_domain_state?:
    | 'pending'
    | 'verified'
    | 'unverified'
    | null;
  readonly pending_domain_unverified_at?: string | null;
  readonly custom_404: boolean;
  readonly html_url?: string;
  readonly build_type?: 'legacy' | 'workflow' | null;
  readonly source?: PagesSourceHash;
  readonly public: boolean;
  readonly https_certificate?: PagesHttpsCertificate;
  readonly https_enforced?: boolean;
};

export type ReposGetPages200ResponseBody = GitHubPages;

export type ReposGetPages404ResponseBody = BasicError;

export type ReposGetPagesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreatePagesSite201ResponseBody = GitHubPages;

export type ReposCreatePagesSite409ResponseBody = BasicError;

export type ReposCreatePagesSite422ResponseBody = ValidationError;

export type ReposCreatePagesSiteRequestBody =
  | ({
      readonly build_type?: 'legacy' | 'workflow';
      readonly source?: {
        readonly branch: string;
        readonly path?: '/' | '/docs';
      };
    } & (unknown | unknown))
  | null;

export type ReposCreatePagesSiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposUpdateInformationAboutPagesSite400ResponseBody = BasicError;

export type ReposUpdateInformationAboutPagesSite409ResponseBody = BasicError;

export type ReposUpdateInformationAboutPagesSite422ResponseBody = ValidationError;

export type ReposUpdateInformationAboutPagesSiteRequestBody = {
  readonly cname?: string | null;
  readonly https_enforced?: boolean;
  readonly public?: boolean;
  readonly build_type?: 'legacy' | 'workflow';
  readonly source?:
    | 'gh-pages'
    | 'master'
    | 'master /docs'
    | { readonly branch: string; readonly path: '/' | '/docs' };
} & (unknown | unknown | unknown | unknown | unknown);

export type ReposUpdateInformationAboutPagesSiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDeletePagesSite404ResponseBody = BasicError;

export type ReposDeletePagesSite409ResponseBody = BasicError;

export type ReposDeletePagesSite422ResponseBody = ValidationError;

export type ReposDeletePagesSiteRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PageBuild = {
  readonly url: string;
  readonly status: string;
  readonly error: { readonly message: string | null };
  readonly pusher: SimpleUser;
  readonly commit: string;
  readonly duration: number;
  readonly created_at: string;
  readonly updated_at: string;
};

export type ReposListPagesBuilds200ResponseBody = ReadonlyArray<PageBuild>;

export type ReposListPagesBuildsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListPagesBuildsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PageBuildStatus = { readonly url: string; readonly status: string };

export type ReposRequestPagesBuild201ResponseBody = PageBuildStatus;

export type ReposRequestPagesBuildRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetLatestPagesBuild200ResponseBody = PageBuild;

export type ReposGetLatestPagesBuildRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetPagesBuild200ResponseBody = PageBuild;

export type ReposGetPagesBuildRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly build_id: number;
};

export type ReposCreatePagesDeployment200ResponseBody = GitHubPages;

export type ReposCreatePagesDeployment400ResponseBody = BasicError;

export type ReposCreatePagesDeployment404ResponseBody = BasicError;

export type ReposCreatePagesDeployment422ResponseBody = ValidationError;

export type ReposCreatePagesDeploymentRequestBody = {
  readonly artifact_url: string;
  readonly environment?: string;
  readonly pages_build_version: string;
  readonly oidc_token: string;
};

export type ReposCreatePagesDeploymentRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PagesHealthCheckStatus = {
  readonly domain?: {
    readonly host?: string;
    readonly uri?: string;
    readonly nameservers?: string;
    readonly dns_resolves?: boolean;
    readonly is_proxied?: boolean | null;
    readonly is_cloudflare_ip?: boolean | null;
    readonly is_fastly_ip?: boolean | null;
    readonly is_old_ip_address?: boolean | null;
    readonly is_a_record?: boolean | null;
    readonly has_cname_record?: boolean | null;
    readonly has_mx_records_present?: boolean | null;
    readonly is_valid_domain?: boolean;
    readonly is_apex_domain?: boolean;
    readonly should_be_a_record?: boolean | null;
    readonly is_cname_to_github_user_domain?: boolean | null;
    readonly is_cname_to_pages_dot_github_dot_com?: boolean | null;
    readonly is_cname_to_fastly?: boolean | null;
    readonly is_pointed_to_github_pages_ip?: boolean | null;
    readonly is_non_github_pages_ip_present?: boolean | null;
    readonly is_pages_domain?: boolean;
    readonly is_served_by_pages?: boolean | null;
    readonly is_valid?: boolean;
    readonly reason?: string | null;
    readonly responds_to_https?: boolean;
    readonly enforces_https?: boolean;
    readonly https_error?: string | null;
    readonly is_https_eligible?: boolean | null;
    readonly caa_error?: string | null;
  };
  readonly alt_domain?: {
    readonly host?: string;
    readonly uri?: string;
    readonly nameservers?: string;
    readonly dns_resolves?: boolean;
    readonly is_proxied?: boolean | null;
    readonly is_cloudflare_ip?: boolean | null;
    readonly is_fastly_ip?: boolean | null;
    readonly is_old_ip_address?: boolean | null;
    readonly is_a_record?: boolean | null;
    readonly has_cname_record?: boolean | null;
    readonly has_mx_records_present?: boolean | null;
    readonly is_valid_domain?: boolean;
    readonly is_apex_domain?: boolean;
    readonly should_be_a_record?: boolean | null;
    readonly is_cname_to_github_user_domain?: boolean | null;
    readonly is_cname_to_pages_dot_github_dot_com?: boolean | null;
    readonly is_cname_to_fastly?: boolean | null;
    readonly is_pointed_to_github_pages_ip?: boolean | null;
    readonly is_non_github_pages_ip_present?: boolean | null;
    readonly is_pages_domain?: boolean;
    readonly is_served_by_pages?: boolean | null;
    readonly is_valid?: boolean;
    readonly reason?: string | null;
    readonly responds_to_https?: boolean;
    readonly enforces_https?: boolean;
    readonly https_error?: string | null;
    readonly is_https_eligible?: boolean | null;
    readonly caa_error?: string | null;
  } | null;
};

export type ReposGetPagesHealthCheck200ResponseBody = PagesHealthCheckStatus;

export type ReposGetPagesHealthCheck202ResponseBody = EmptyObject;

export type ReposGetPagesHealthCheck404ResponseBody = BasicError;

export type ReposGetPagesHealthCheckRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ProjectsListForRepo200ResponseBody = ReadonlyArray<Project>;

export type ProjectsListForRepo401ResponseBody = BasicError;

export type ProjectsListForRepo403ResponseBody = BasicError;

export type ProjectsListForRepo404ResponseBody = BasicError;

export type ProjectsListForRepo410ResponseBody = BasicError;

export type ProjectsListForRepo422ResponseBody = ValidationErrorSimple;

export type ProjectsListForRepoRequestQuery = {
  readonly state?: 'open' | 'closed' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type ProjectsListForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ProjectsCreateForRepo201ResponseBody = Project;

export type ProjectsCreateForRepo401ResponseBody = BasicError;

export type ProjectsCreateForRepo403ResponseBody = BasicError;

export type ProjectsCreateForRepo404ResponseBody = BasicError;

export type ProjectsCreateForRepo410ResponseBody = BasicError;

export type ProjectsCreateForRepo422ResponseBody = ValidationErrorSimple;

export type ProjectsCreateForRepoRequestBody = {
  readonly name: string;
  readonly body?: string;
};

export type ProjectsCreateForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PullsList200ResponseBody = ReadonlyArray<PullRequestSimple>;

export type PullsList422ResponseBody = ValidationError;

export type PullsListRequestQuery = {
  readonly state?: 'open' | 'closed' | 'all';
  readonly head?: string;
  readonly base?: string;
  readonly sort?: 'created' | 'updated' | 'popularity' | 'long-running';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PullRequest = {
  readonly url: string;
  readonly id: number;
  readonly node_id: string;
  readonly html_url: string;
  readonly diff_url: string;
  readonly patch_url: string;
  readonly issue_url: string;
  readonly commits_url: string;
  readonly review_comments_url: string;
  readonly review_comment_url: string;
  readonly comments_url: string;
  readonly statuses_url: string;
  readonly number: number;
  readonly state: 'open' | 'closed';
  readonly locked: boolean;
  readonly title: string;
  readonly user: SimpleUser;
  readonly body: string | null;
  readonly labels: ReadonlyArray<{
    readonly id: number;
    readonly node_id: string;
    readonly url: string;
    readonly name: string;
    readonly description: string | null;
    readonly color: string;
    readonly default: boolean;
  }>;
  readonly milestone: Milestone;
  readonly active_lock_reason?: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly closed_at: string | null;
  readonly merged_at: string | null;
  readonly merge_commit_sha: string | null;
  readonly assignee: SimpleUser;
  readonly assignees?: ReadonlyArray<SimpleUser> | null;
  readonly requested_reviewers?: ReadonlyArray<SimpleUser> | null;
  readonly requested_teams?: ReadonlyArray<TeamSimple> | null;
  readonly head: {
    readonly label: string;
    readonly ref: string;
    readonly repo: {
      readonly archive_url: string;
      readonly assignees_url: string;
      readonly blobs_url: string;
      readonly branches_url: string;
      readonly collaborators_url: string;
      readonly comments_url: string;
      readonly commits_url: string;
      readonly compare_url: string;
      readonly contents_url: string;
      readonly contributors_url: string;
      readonly deployments_url: string;
      readonly description: string | null;
      readonly downloads_url: string;
      readonly events_url: string;
      readonly fork: boolean;
      readonly forks_url: string;
      readonly full_name: string;
      readonly git_commits_url: string;
      readonly git_refs_url: string;
      readonly git_tags_url: string;
      readonly hooks_url: string;
      readonly html_url: string;
      readonly id: number;
      readonly node_id: string;
      readonly issue_comment_url: string;
      readonly issue_events_url: string;
      readonly issues_url: string;
      readonly keys_url: string;
      readonly labels_url: string;
      readonly languages_url: string;
      readonly merges_url: string;
      readonly milestones_url: string;
      readonly name: string;
      readonly notifications_url: string;
      readonly owner: {
        readonly avatar_url: string;
        readonly events_url: string;
        readonly followers_url: string;
        readonly following_url: string;
        readonly gists_url: string;
        readonly gravatar_id: string | null;
        readonly html_url: string;
        readonly id: number;
        readonly node_id: string;
        readonly login: string;
        readonly organizations_url: string;
        readonly received_events_url: string;
        readonly repos_url: string;
        readonly site_admin: boolean;
        readonly starred_url: string;
        readonly subscriptions_url: string;
        readonly type: string;
        readonly url: string;
      };
      readonly private: boolean;
      readonly pulls_url: string;
      readonly releases_url: string;
      readonly stargazers_url: string;
      readonly statuses_url: string;
      readonly subscribers_url: string;
      readonly subscription_url: string;
      readonly tags_url: string;
      readonly teams_url: string;
      readonly trees_url: string;
      readonly url: string;
      readonly clone_url: string;
      readonly default_branch: string;
      readonly forks: number;
      readonly forks_count: number;
      readonly git_url: string;
      readonly has_downloads: boolean;
      readonly has_issues: boolean;
      readonly has_projects: boolean;
      readonly has_wiki: boolean;
      readonly has_pages: boolean;
      readonly homepage: string | null;
      readonly language: string | null;
      readonly master_branch?: string;
      readonly archived: boolean;
      readonly disabled: boolean;
      readonly visibility?: string;
      readonly mirror_url: string | null;
      readonly open_issues: number;
      readonly open_issues_count: number;
      readonly permissions?: {
        readonly admin: boolean;
        readonly maintain?: boolean;
        readonly push: boolean;
        readonly triage?: boolean;
        readonly pull: boolean;
      };
      readonly temp_clone_token?: string;
      readonly allow_merge_commit?: boolean;
      readonly allow_squash_merge?: boolean;
      readonly allow_rebase_merge?: boolean;
      readonly license: {
        readonly key: string;
        readonly name: string;
        readonly url: string | null;
        readonly spdx_id: string | null;
        readonly node_id: string;
      } | null;
      readonly pushed_at: string;
      readonly size: number;
      readonly ssh_url: string;
      readonly stargazers_count: number;
      readonly svn_url: string;
      readonly topics?: ReadonlyArray<string>;
      readonly watchers: number;
      readonly watchers_count: number;
      readonly created_at: string;
      readonly updated_at: string;
      readonly allow_forking?: boolean;
      readonly is_template?: boolean;
      readonly web_commit_signoff_required?: boolean;
    } | null;
    readonly sha: string;
    readonly user: {
      readonly avatar_url: string;
      readonly events_url: string;
      readonly followers_url: string;
      readonly following_url: string;
      readonly gists_url: string;
      readonly gravatar_id: string | null;
      readonly html_url: string;
      readonly id: number;
      readonly node_id: string;
      readonly login: string;
      readonly organizations_url: string;
      readonly received_events_url: string;
      readonly repos_url: string;
      readonly site_admin: boolean;
      readonly starred_url: string;
      readonly subscriptions_url: string;
      readonly type: string;
      readonly url: string;
    };
  };
  readonly base: {
    readonly label: string;
    readonly ref: string;
    readonly repo: {
      readonly archive_url: string;
      readonly assignees_url: string;
      readonly blobs_url: string;
      readonly branches_url: string;
      readonly collaborators_url: string;
      readonly comments_url: string;
      readonly commits_url: string;
      readonly compare_url: string;
      readonly contents_url: string;
      readonly contributors_url: string;
      readonly deployments_url: string;
      readonly description: string | null;
      readonly downloads_url: string;
      readonly events_url: string;
      readonly fork: boolean;
      readonly forks_url: string;
      readonly full_name: string;
      readonly git_commits_url: string;
      readonly git_refs_url: string;
      readonly git_tags_url: string;
      readonly hooks_url: string;
      readonly html_url: string;
      readonly id: number;
      readonly is_template?: boolean;
      readonly node_id: string;
      readonly issue_comment_url: string;
      readonly issue_events_url: string;
      readonly issues_url: string;
      readonly keys_url: string;
      readonly labels_url: string;
      readonly languages_url: string;
      readonly merges_url: string;
      readonly milestones_url: string;
      readonly name: string;
      readonly notifications_url: string;
      readonly owner: {
        readonly avatar_url: string;
        readonly events_url: string;
        readonly followers_url: string;
        readonly following_url: string;
        readonly gists_url: string;
        readonly gravatar_id: string | null;
        readonly html_url: string;
        readonly id: number;
        readonly node_id: string;
        readonly login: string;
        readonly organizations_url: string;
        readonly received_events_url: string;
        readonly repos_url: string;
        readonly site_admin: boolean;
        readonly starred_url: string;
        readonly subscriptions_url: string;
        readonly type: string;
        readonly url: string;
      };
      readonly private: boolean;
      readonly pulls_url: string;
      readonly releases_url: string;
      readonly stargazers_url: string;
      readonly statuses_url: string;
      readonly subscribers_url: string;
      readonly subscription_url: string;
      readonly tags_url: string;
      readonly teams_url: string;
      readonly trees_url: string;
      readonly url: string;
      readonly clone_url: string;
      readonly default_branch: string;
      readonly forks: number;
      readonly forks_count: number;
      readonly git_url: string;
      readonly has_downloads: boolean;
      readonly has_issues: boolean;
      readonly has_projects: boolean;
      readonly has_wiki: boolean;
      readonly has_pages: boolean;
      readonly homepage: string | null;
      readonly language: string | null;
      readonly master_branch?: string;
      readonly archived: boolean;
      readonly disabled: boolean;
      readonly visibility?: string;
      readonly mirror_url: string | null;
      readonly open_issues: number;
      readonly open_issues_count: number;
      readonly permissions?: {
        readonly admin: boolean;
        readonly maintain?: boolean;
        readonly push: boolean;
        readonly triage?: boolean;
        readonly pull: boolean;
      };
      readonly temp_clone_token?: string;
      readonly allow_merge_commit?: boolean;
      readonly allow_squash_merge?: boolean;
      readonly allow_rebase_merge?: boolean;
      readonly license: LicenseSimple;
      readonly pushed_at: string;
      readonly size: number;
      readonly ssh_url: string;
      readonly stargazers_count: number;
      readonly svn_url: string;
      readonly topics?: ReadonlyArray<string>;
      readonly watchers: number;
      readonly watchers_count: number;
      readonly created_at: string;
      readonly updated_at: string;
      readonly allow_forking?: boolean;
      readonly web_commit_signoff_required?: boolean;
    };
    readonly sha: string;
    readonly user: {
      readonly avatar_url: string;
      readonly events_url: string;
      readonly followers_url: string;
      readonly following_url: string;
      readonly gists_url: string;
      readonly gravatar_id: string | null;
      readonly html_url: string;
      readonly id: number;
      readonly node_id: string;
      readonly login: string;
      readonly organizations_url: string;
      readonly received_events_url: string;
      readonly repos_url: string;
      readonly site_admin: boolean;
      readonly starred_url: string;
      readonly subscriptions_url: string;
      readonly type: string;
      readonly url: string;
    };
  };
  readonly _links: {
    readonly comments: Link;
    readonly commits: Link;
    readonly statuses: Link;
    readonly html: Link;
    readonly issue: Link;
    readonly review_comments: Link;
    readonly review_comment: Link;
    readonly self: Link;
  };
  readonly author_association: AuthorAssociation;
  readonly auto_merge: AutoMerge;
  readonly draft?: boolean;
  readonly merged: boolean;
  readonly mergeable: boolean | null;
  readonly rebaseable?: boolean | null;
  readonly mergeable_state: string;
  readonly merged_by: SimpleUser;
  readonly comments: number;
  readonly review_comments: number;
  readonly maintainer_can_modify: boolean;
  readonly commits: number;
  readonly additions: number;
  readonly deletions: number;
  readonly changed_files: number;
};

export type PullsCreate201ResponseBody = PullRequest;

export type PullsCreate403ResponseBody = BasicError;

export type PullsCreate422ResponseBody = ValidationError;

export type PullsCreateRequestBody = {
  readonly title?: string;
  readonly head: string;
  readonly base: string;
  readonly body?: string;
  readonly maintainer_can_modify?: boolean;
  readonly draft?: boolean;
  readonly issue?: number;
};

export type PullsCreateRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PullsListReviewCommentsForRepo200ResponseBody = ReadonlyArray<PullRequestReviewComment>;

export type PullsListReviewCommentsForRepoRequestQuery = {
  readonly sort?: 'created' | 'updated' | 'created_at';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListReviewCommentsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type PullsGetReviewComment200ResponseBody = PullRequestReviewComment;

export type PullsGetReviewComment404ResponseBody = BasicError;

export type PullsGetReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type PullsUpdateReviewComment200ResponseBody = PullRequestReviewComment;

export type PullsUpdateReviewCommentRequestBody = { readonly body: string };

export type PullsUpdateReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type PullsDeleteReviewComment404ResponseBody = BasicError;

export type PullsDeleteReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsListForPullRequestReviewComment200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForPullRequestReviewComment404ResponseBody = BasicError;

export type ReactionsListForPullRequestReviewCommentRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForPullRequestReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsCreateForPullRequestReviewComment200ResponseBody = Reaction;

export type ReactionsCreateForPullRequestReviewComment201ResponseBody = Reaction;

export type ReactionsCreateForPullRequestReviewComment422ResponseBody = ValidationError;

export type ReactionsCreateForPullRequestReviewCommentRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForPullRequestReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
};

export type ReactionsDeleteForPullRequestCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly comment_id: number;
  readonly reaction_id: number;
};

export type PullsGet200ResponseBody = PullRequest;

export type PullsGet404ResponseBody = BasicError;

export type PullsGet500ResponseBody = BasicError;

export type PullsGet503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type PullsGetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsUpdate200ResponseBody = PullRequest;

export type PullsUpdate403ResponseBody = BasicError;

export type PullsUpdate422ResponseBody = ValidationError;

export type PullsUpdateRequestBody = {
  readonly title?: string;
  readonly body?: string;
  readonly state?: 'open' | 'closed';
  readonly base?: string;
  readonly maintainer_can_modify?: boolean;
};

export type PullsUpdateRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type CodespacesCreateWithPrForAuthenticatedUser201ResponseBody = Codespace;

export type CodespacesCreateWithPrForAuthenticatedUser202ResponseBody = Codespace;

export type CodespacesCreateWithPrForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesCreateWithPrForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesCreateWithPrForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesCreateWithPrForAuthenticatedUser503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodespacesCreateWithPrForAuthenticatedUserRequestBody = {
  readonly location?: string;
  readonly client_ip?: string;
  readonly machine?: string;
  readonly devcontainer_path?: string;
  readonly multi_repo_permissions_opt_out?: boolean;
  readonly working_directory?: string;
  readonly idle_timeout_minutes?: number;
  readonly display_name?: string;
  readonly retention_period_minutes?: number;
} | null;

export type CodespacesCreateWithPrForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsListReviewComments200ResponseBody = ReadonlyArray<PullRequestReviewComment>;

export type PullsListReviewCommentsRequestQuery = {
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListReviewCommentsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsCreateReviewComment201ResponseBody = PullRequestReviewComment;

export type PullsCreateReviewComment403ResponseBody = BasicError;

export type PullsCreateReviewComment422ResponseBody = ValidationError;

export type PullsCreateReviewCommentRequestBody = {
  readonly body: string;
  readonly commit_id: string;
  readonly path: string;
  readonly position?: number;
  readonly side?: 'LEFT' | 'RIGHT';
  readonly line: number;
  readonly start_line?: number;
  readonly start_side?: 'LEFT' | 'RIGHT' | 'side';
  readonly in_reply_to?: number;
};

export type PullsCreateReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsCreateReplyForReviewComment201ResponseBody = PullRequestReviewComment;

export type PullsCreateReplyForReviewComment404ResponseBody = BasicError;

export type PullsCreateReplyForReviewCommentRequestBody = {
  readonly body: string;
};

export type PullsCreateReplyForReviewCommentRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly comment_id: number;
};

export type PullsListCommits200ResponseBody = ReadonlyArray<Commit>;

export type PullsListCommitsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListCommitsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsListFiles200ResponseBody = ReadonlyArray<DiffEntry>;

export type PullsListFiles422ResponseBody = ValidationError;

export type PullsListFiles500ResponseBody = BasicError;

export type PullsListFiles503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type PullsListFilesRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListFilesRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsCheckIfMergedRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullRequestMergeResult = {
  readonly sha: string;
  readonly merged: boolean;
  readonly message: string;
};

export type PullsMerge200ResponseBody = PullRequestMergeResult;

export type PullsMerge403ResponseBody = BasicError;

export type PullsMerge404ResponseBody = BasicError;

export type PullsMerge405ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
};

export type PullsMerge409ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
};

export type PullsMerge422ResponseBody = ValidationError;

export type PullsMergeRequestBody = {
  readonly commit_title?: string;
  readonly commit_message?: string;
  readonly sha?: string;
  readonly merge_method?: 'merge' | 'squash' | 'rebase';
} | null;

export type PullsMergeRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullRequestReviewRequest = {
  readonly users: ReadonlyArray<SimpleUser>;
  readonly teams: ReadonlyArray<Team>;
};

export type PullsListRequestedReviewers200ResponseBody = PullRequestReviewRequest;

export type PullsListRequestedReviewersRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsRequestReviewers201ResponseBody = PullRequestSimple;

export type PullsRequestReviewers403ResponseBody = BasicError;

export type PullsRequestReviewersRequestBody = {
  readonly reviewers?: ReadonlyArray<string>;
  readonly team_reviewers?: ReadonlyArray<string>;
} & (unknown | unknown);

export type PullsRequestReviewersRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsRemoveRequestedReviewers200ResponseBody = PullRequestSimple;

export type PullsRemoveRequestedReviewers422ResponseBody = ValidationError;

export type PullsRemoveRequestedReviewersRequestBody = {
  readonly reviewers: ReadonlyArray<string>;
  readonly team_reviewers?: ReadonlyArray<string>;
};

export type PullsRemoveRequestedReviewersRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullRequestReview = {
  readonly id: number;
  readonly node_id: string;
  readonly user: SimpleUser;
  readonly body: string;
  readonly state: string;
  readonly html_url: string;
  readonly pull_request_url: string;
  readonly _links: {
    readonly html: { readonly href: string };
    readonly pull_request: { readonly href: string };
  };
  readonly submitted_at?: string;
  readonly commit_id: string;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly author_association: AuthorAssociation;
};

export type PullsListReviews200ResponseBody = ReadonlyArray<PullRequestReview>;

export type PullsListReviewsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListReviewsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsCreateReview200ResponseBody = PullRequestReview;

export type PullsCreateReview403ResponseBody = BasicError;

export type PullsCreateReview422ResponseBody = ValidationErrorSimple;

export type PullsCreateReviewRequestBody = {
  readonly commit_id?: string;
  readonly body?: string;
  readonly event?: 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT';
  readonly comments?: ReadonlyArray<{
    readonly path: string;
    readonly position?: number;
    readonly body: string;
    readonly line?: number;
    readonly side?: string;
    readonly start_line?: number;
    readonly start_side?: string;
  }>;
};

export type PullsCreateReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type PullsGetReview200ResponseBody = PullRequestReview;

export type PullsGetReview404ResponseBody = BasicError;

export type PullsGetReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly review_id: number;
};

export type PullsUpdateReview200ResponseBody = PullRequestReview;

export type PullsUpdateReview422ResponseBody = ValidationErrorSimple;

export type PullsUpdateReviewRequestBody = { readonly body: string };

export type PullsUpdateReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly review_id: number;
};

export type PullsDeletePendingReview200ResponseBody = PullRequestReview;

export type PullsDeletePendingReview404ResponseBody = BasicError;

export type PullsDeletePendingReview422ResponseBody = ValidationErrorSimple;

export type PullsDeletePendingReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly review_id: number;
};

export type LegacyReviewComment = {
  readonly url: string;
  readonly pull_request_review_id: number | null;
  readonly id: number;
  readonly node_id: string;
  readonly diff_hunk: string;
  readonly path: string;
  readonly position: number | null;
  readonly original_position: number;
  readonly commit_id: string;
  readonly original_commit_id: string;
  readonly in_reply_to_id?: number;
  readonly user: SimpleUser;
  readonly body: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly html_url: string;
  readonly pull_request_url: string;
  readonly author_association: AuthorAssociation;
  readonly _links: {
    readonly self: Link;
    readonly html: Link;
    readonly pull_request: Link;
  };
  readonly body_text?: string;
  readonly body_html?: string;
  readonly reactions?: ReactionRollup;
  readonly side?: 'LEFT' | 'RIGHT';
  readonly start_side?: 'LEFT' | 'RIGHT' | null;
  readonly line?: number;
  readonly original_line?: number;
  readonly start_line?: number | null;
  readonly original_start_line?: number | null;
};

export type PullsListCommentsForReview200ResponseBody = ReadonlyArray<LegacyReviewComment>;

export type PullsListCommentsForReview404ResponseBody = BasicError;

export type PullsListCommentsForReviewRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type PullsListCommentsForReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly review_id: number;
};

export type PullsDismissReview200ResponseBody = PullRequestReview;

export type PullsDismissReview404ResponseBody = BasicError;

export type PullsDismissReview422ResponseBody = ValidationErrorSimple;

export type PullsDismissReviewRequestBody = {
  readonly message: string;
  readonly event?: 'DISMISS';
};

export type PullsDismissReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly review_id: number;
};

export type PullsSubmitReview200ResponseBody = PullRequestReview;

export type PullsSubmitReview403ResponseBody = BasicError;

export type PullsSubmitReview404ResponseBody = BasicError;

export type PullsSubmitReview422ResponseBody = ValidationErrorSimple;

export type PullsSubmitReviewRequestBody = {
  readonly body?: string;
  readonly event: 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT';
};

export type PullsSubmitReviewRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
  readonly review_id: number;
};

export type PullsUpdateBranch202ResponseBody = {
  readonly message?: string;
  readonly url?: string;
};

export type PullsUpdateBranch403ResponseBody = BasicError;

export type PullsUpdateBranch422ResponseBody = ValidationError;

export type PullsUpdateBranchRequestBody = {
  readonly expected_head_sha?: string;
} | null;

export type PullsUpdateBranchRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly pull_number: number;
};

export type ReposGetReadme200ResponseBody = ContentFile;

export type ReposGetReadme404ResponseBody = BasicError;

export type ReposGetReadme422ResponseBody = ValidationError;

export type ReposGetReadmeRequestQuery = { readonly ref?: string };

export type ReposGetReadmeRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetReadmeInDirectory200ResponseBody = ContentFile;

export type ReposGetReadmeInDirectory404ResponseBody = BasicError;

export type ReposGetReadmeInDirectory422ResponseBody = ValidationError;

export type ReposGetReadmeInDirectoryRequestQuery = { readonly ref?: string };

export type ReposGetReadmeInDirectoryRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly dir: string;
};

export type ReleaseAsset = {
  readonly url: string;
  readonly browser_download_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly label: string | null;
  readonly state: 'uploaded' | 'open';
  readonly content_type: string;
  readonly size: number;
  readonly download_count: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly uploader: SimpleUser;
};

export type Release = {
  readonly url: string;
  readonly html_url: string;
  readonly assets_url: string;
  readonly upload_url: string;
  readonly tarball_url: string | null;
  readonly zipball_url: string | null;
  readonly id: number;
  readonly node_id: string;
  readonly tag_name: string;
  readonly target_commitish: string;
  readonly name: string | null;
  readonly body?: string | null;
  readonly draft: boolean;
  readonly prerelease: boolean;
  readonly created_at: string;
  readonly published_at: string | null;
  readonly author: SimpleUser;
  readonly assets: ReadonlyArray<ReleaseAsset>;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly mentions_count?: number;
  readonly discussion_url?: string;
  readonly reactions?: ReactionRollup;
};

export type ReposListReleases200ResponseBody = ReadonlyArray<Release>;

export type ReposListReleases404ResponseBody = BasicError;

export type ReposListReleasesRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListReleasesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateRelease201ResponseBody = Release;

export type ReposCreateRelease404ResponseBody = BasicError;

export type ReposCreateRelease422ResponseBody = ValidationError;

export type ReposCreateReleaseRequestBody = {
  readonly tag_name: string;
  readonly target_commitish?: string;
  readonly name?: string;
  readonly body?: string;
  readonly draft?: boolean;
  readonly prerelease?: boolean;
  readonly discussion_category_name?: string;
  readonly generate_release_notes?: boolean;
};

export type ReposCreateReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetReleaseAsset200ResponseBody = ReleaseAsset;

export type ReposGetReleaseAsset404ResponseBody = BasicError;

export type ReposGetReleaseAssetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly asset_id: number;
};

export type ReposUpdateReleaseAsset200ResponseBody = ReleaseAsset;

export type ReposUpdateReleaseAssetRequestBody = {
  readonly name?: string;
  readonly label?: string;
  readonly state?: string;
};

export type ReposUpdateReleaseAssetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly asset_id: number;
};

export type ReposDeleteReleaseAssetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly asset_id: number;
};

export type GeneratedReleaseNotesContent = {
  readonly name: string;
  readonly body: string;
};

export type ReposGenerateReleaseNotes200ResponseBody = GeneratedReleaseNotesContent;

export type ReposGenerateReleaseNotes404ResponseBody = BasicError;

export type ReposGenerateReleaseNotesRequestBody = {
  readonly tag_name: string;
  readonly target_commitish?: string;
  readonly previous_tag_name?: string;
  readonly configuration_file_path?: string;
};

export type ReposGenerateReleaseNotesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetLatestRelease200ResponseBody = Release;

export type ReposGetLatestReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetReleaseByTag200ResponseBody = Release;

export type ReposGetReleaseByTag404ResponseBody = BasicError;

export type ReposGetReleaseByTagRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly tag: string;
};

export type ReposGetRelease200ResponseBody = Release;

export type ReposGetRelease404ResponseBody = BasicError;

export type ReposGetReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReposUpdateRelease200ResponseBody = Release;

export type ReposUpdateRelease404ResponseBody = BasicError;

export type ReposUpdateReleaseRequestBody = {
  readonly tag_name?: string;
  readonly target_commitish?: string;
  readonly name?: string;
  readonly body?: string;
  readonly draft?: boolean;
  readonly prerelease?: boolean;
  readonly discussion_category_name?: string;
};

export type ReposUpdateReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReposDeleteReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReposListReleaseAssets200ResponseBody = ReadonlyArray<ReleaseAsset>;

export type ReposListReleaseAssetsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListReleaseAssetsRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReposUploadReleaseAsset201ResponseBody = ReleaseAsset;

export type ReposUploadReleaseAssetRequestQuery = {
  readonly name: string;
  readonly label?: string;
};

export type ReposUploadReleaseAssetRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReactionsListForRelease200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForRelease404ResponseBody = BasicError;

export type ReactionsListForReleaseRequestQuery = {
  readonly content?: '+1' | 'laugh' | 'heart' | 'hooray' | 'rocket' | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReactionsCreateForRelease200ResponseBody = Reaction;

export type ReactionsCreateForRelease201ResponseBody = Reaction;

export type ReactionsCreateForRelease422ResponseBody = ValidationError;

export type ReactionsCreateForReleaseRequestBody = {
  readonly content: '+1' | 'laugh' | 'heart' | 'hooray' | 'rocket' | 'eyes';
};

export type ReactionsCreateForReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
};

export type ReactionsDeleteForReleaseRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly release_id: number;
  readonly reaction_id: number;
};

export type SecretScanningAlert = {
  readonly number?: AlertNumber;
  readonly created_at?: AlertCreatedAt;
  readonly updated_at?: AlertUpdatedAt;
  readonly url?: AlertUrl;
  readonly html_url?: AlertHtmlUrl;
  readonly locations_url?: string;
  readonly state?: SecretScanningAlertState;
  readonly resolution?: SecretScanningAlertResolution;
  readonly resolved_at?: string | null;
  readonly resolved_by?: SimpleUser;
  readonly resolution_comment?: string | null;
  readonly secret_type?: string;
  readonly secret_type_display_name?: string;
  readonly secret?: string;
  readonly push_protection_bypassed?: boolean | null;
  readonly push_protection_bypassed_by?: SimpleUser;
  readonly push_protection_bypassed_at?: string | null;
};

export type SecretScanningListAlertsForRepo200ResponseBody = ReadonlyArray<SecretScanningAlert>;

export type SecretScanningListAlertsForRepo503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SecretScanningListAlertsForRepoRequestQuery = {
  readonly state?: 'open' | 'resolved';
  readonly secret_type?: string;
  readonly resolution?: string;
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly page?: number;
  readonly per_page?: number;
  readonly before?: string;
  readonly after?: string;
};

export type SecretScanningListAlertsForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type SecretScanningGetAlert200ResponseBody = SecretScanningAlert;

export type SecretScanningGetAlert503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SecretScanningGetAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type SecretScanningUpdateAlert200ResponseBody = SecretScanningAlert;

export type SecretScanningUpdateAlert503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SecretScanningAlertResolutionComment = string | null;

export type SecretScanningUpdateAlertRequestBody = {
  readonly state: SecretScanningAlertState;
  readonly resolution?: SecretScanningAlertResolution;
  readonly resolution_comment?: SecretScanningAlertResolutionComment;
};

export type SecretScanningUpdateAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type SecretScanningLocationCommit = {
  readonly path: string;
  readonly start_line: number;
  readonly end_line: number;
  readonly start_column: number;
  readonly end_column: number;
  readonly blob_sha: string;
  readonly blob_url: string;
  readonly commit_sha: string;
  readonly commit_url: string;
};

export type SecretScanningLocation = {
  readonly type: 'commit';
  readonly details: SecretScanningLocationCommit;
};

export type SecretScanningListLocationsForAlert200ResponseBody = ReadonlyArray<SecretScanningLocation>;

export type SecretScanningListLocationsForAlert503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SecretScanningListLocationsForAlertRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type SecretScanningListLocationsForAlertRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly alert_number: AlertNumber;
};

export type Stargazer = {
  readonly starred_at: string;
  readonly user: SimpleUser;
};

export type ActivityListStargazersForRepo200ResponseBody =
  | ReadonlyArray<SimpleUser>
  | ReadonlyArray<Stargazer>;

export type ActivityListStargazersForRepo422ResponseBody = ValidationError;

export type ActivityListStargazersForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListStargazersForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CodeFrequencyStat = ReadonlyArray<number>;

export type ReposGetCodeFrequencyStats200ResponseBody = ReadonlyArray<CodeFrequencyStat>;

export type ReposGetCodeFrequencyStats202ResponseBody = unknown;

export type ReposGetCodeFrequencyStatsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type CommitActivity = {
  readonly days: ReadonlyArray<number>;
  readonly total: number;
  readonly week: number;
};

export type ReposGetCommitActivityStats200ResponseBody = ReadonlyArray<CommitActivity>;

export type ReposGetCommitActivityStats202ResponseBody = unknown;

export type ReposGetCommitActivityStatsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ContributorActivity = {
  readonly author: SimpleUser;
  readonly total: number;
  readonly weeks: ReadonlyArray<{
    readonly w?: number;
    readonly a?: number;
    readonly d?: number;
    readonly c?: number;
  }>;
};

export type ReposGetContributorsStats200ResponseBody = ReadonlyArray<ContributorActivity>;

export type ReposGetContributorsStats202ResponseBody = unknown;

export type ReposGetContributorsStatsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ParticipationStats = {
  readonly all: ReadonlyArray<number>;
  readonly owner: ReadonlyArray<number>;
};

export type ReposGetParticipationStats200ResponseBody = ParticipationStats;

export type ReposGetParticipationStats404ResponseBody = BasicError;

export type ReposGetParticipationStatsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposGetPunchCardStats200ResponseBody = ReadonlyArray<CodeFrequencyStat>;

export type ReposGetPunchCardStatsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateCommitStatus201ResponseBody = Status;

export type ReposCreateCommitStatusRequestBody = {
  readonly state: 'error' | 'failure' | 'pending' | 'success';
  readonly target_url?: string | null;
  readonly description?: string | null;
  readonly context?: string;
};

export type ReposCreateCommitStatusRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly sha: string;
};

export type ActivityListWatchersForRepo200ResponseBody = ReadonlyArray<SimpleUser>;

export type ActivityListWatchersForRepoRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListWatchersForRepoRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivityGetRepoSubscription200ResponseBody = RepositoryInvitation;

export type ActivityGetRepoSubscription403ResponseBody = BasicError;

export type ActivityGetRepoSubscriptionRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivitySetRepoSubscription200ResponseBody = RepositoryInvitation;

export type ActivitySetRepoSubscriptionRequestBody = {
  readonly subscribed?: boolean;
  readonly ignored?: boolean;
};

export type ActivitySetRepoSubscriptionRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivityDeleteRepoSubscriptionRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type Tag = {
  readonly name: string;
  readonly commit: { readonly sha: string; readonly url: string };
  readonly zipball_url: string;
  readonly tarball_url: string;
  readonly node_id: string;
};

export type ReposListTags200ResponseBody = ReadonlyArray<Tag>;

export type ReposListTagsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListTagsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type TagProtection = {
  readonly id?: number;
  readonly created_at?: string;
  readonly updated_at?: string;
  readonly enabled?: boolean;
  readonly pattern: string;
};

export type ReposListTagProtection200ResponseBody = ReadonlyArray<TagProtection>;

export type ReposListTagProtection403ResponseBody = BasicError;

export type ReposListTagProtection404ResponseBody = BasicError;

export type ReposListTagProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCreateTagProtection201ResponseBody = TagProtection;

export type ReposCreateTagProtection403ResponseBody = BasicError;

export type ReposCreateTagProtection404ResponseBody = BasicError;

export type ReposCreateTagProtectionRequestBody = { readonly pattern: string };

export type ReposCreateTagProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDeleteTagProtection403ResponseBody = BasicError;

export type ReposDeleteTagProtection404ResponseBody = BasicError;

export type ReposDeleteTagProtectionRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly tag_protection_id: number;
};

export type ReposDownloadTarballArchiveRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type ReposListTeams200ResponseBody = ReadonlyArray<Team>;

export type ReposListTeamsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListTeamsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type Topic = { readonly names: ReadonlyArray<string> };

export type ReposGetAllTopics200ResponseBody = Topic;

export type ReposGetAllTopics404ResponseBody = BasicError;

export type ReposGetAllTopicsRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
};

export type ReposGetAllTopicsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposReplaceAllTopics200ResponseBody = Topic;

export type ReposReplaceAllTopics404ResponseBody = BasicError;

export type ReposReplaceAllTopics422ResponseBody = ValidationErrorSimple;

export type ReposReplaceAllTopicsRequestBody = {
  readonly names: ReadonlyArray<string>;
};

export type ReposReplaceAllTopicsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type Traffic = {
  readonly timestamp: string;
  readonly uniques: number;
  readonly count: number;
};

export type CloneTraffic = {
  readonly count: number;
  readonly uniques: number;
  readonly clones: ReadonlyArray<Traffic>;
};

export type ReposGetClones200ResponseBody = CloneTraffic;

export type ReposGetClones403ResponseBody = BasicError;

export type ReposGetClonesRequestQuery = { readonly per?: '' | 'day' | 'week' };

export type ReposGetClonesRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ContentTraffic = {
  readonly path: string;
  readonly title: string;
  readonly count: number;
  readonly uniques: number;
};

export type ReposGetTopPaths200ResponseBody = ReadonlyArray<ContentTraffic>;

export type ReposGetTopPaths403ResponseBody = BasicError;

export type ReposGetTopPathsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReferrerTraffic = {
  readonly referrer: string;
  readonly count: number;
  readonly uniques: number;
};

export type ReposGetTopReferrers200ResponseBody = ReadonlyArray<ReferrerTraffic>;

export type ReposGetTopReferrers403ResponseBody = BasicError;

export type ReposGetTopReferrersRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ViewTraffic = {
  readonly count: number;
  readonly uniques: number;
  readonly views: ReadonlyArray<Traffic>;
};

export type ReposGetViews200ResponseBody = ViewTraffic;

export type ReposGetViews403ResponseBody = BasicError;

export type ReposGetViewsRequestQuery = { readonly per?: '' | 'day' | 'week' };

export type ReposGetViewsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposTransfer202ResponseBody = MinimalRepository;

export type ReposTransferRequestBody = {
  readonly new_owner: string;
  readonly team_ids?: ReadonlyArray<number>;
};

export type ReposTransferRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposCheckVulnerabilityAlertsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposEnableVulnerabilityAlertsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDisableVulnerabilityAlertsRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ReposDownloadZipballArchiveRequestPath = {
  readonly owner: string;
  readonly repo: string;
  readonly ref: string;
};

export type ReposCreateUsingTemplate201ResponseBody = Repository;

export type ReposCreateUsingTemplateRequestBody = {
  readonly owner?: string;
  readonly name: string;
  readonly description?: string;
  readonly include_all_branches?: boolean;
  readonly private?: boolean;
};

export type ReposCreateUsingTemplateRequestPath = {
  readonly template_owner: string;
  readonly template_repo: string;
};

export type ReposListPublic200ResponseBody = ReadonlyArray<MinimalRepository>;

export type ReposListPublic422ResponseBody = ValidationError;

export type ReposListPublicRequestQuery = { readonly since?: number };

export type ActionsListEnvironmentSecrets200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<ActionsSecret>;
};

export type ActionsListEnvironmentSecretsRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActionsListEnvironmentSecretsRequestPath = {
  readonly repository_id: number;
  readonly environment_name: string;
};

export type ActionsGetEnvironmentPublicKey200ResponseBody = ActionsPublicKey;

export type ActionsGetEnvironmentPublicKeyRequestPath = {
  readonly repository_id: number;
  readonly environment_name: string;
};

export type ActionsGetEnvironmentSecret200ResponseBody = ActionsSecret;

export type ActionsGetEnvironmentSecretRequestPath = {
  readonly repository_id: number;
  readonly environment_name: string;
  readonly secret_name: string;
};

export type ActionsCreateOrUpdateEnvironmentSecret201ResponseBody = EmptyObject;

export type ActionsCreateOrUpdateEnvironmentSecretRequestBody = {
  readonly encrypted_value: string;
  readonly key_id: string;
};

export type ActionsCreateOrUpdateEnvironmentSecretRequestPath = {
  readonly repository_id: number;
  readonly environment_name: string;
  readonly secret_name: string;
};

export type ActionsDeleteEnvironmentSecretRequestPath = {
  readonly repository_id: number;
  readonly environment_name: string;
  readonly secret_name: string;
};

export type SearchResultTextMatches = ReadonlyArray<{
  readonly object_url?: string;
  readonly object_type?: string | null;
  readonly property?: string;
  readonly fragment?: string;
  readonly matches?: ReadonlyArray<{
    readonly text?: string;
    readonly indices?: ReadonlyArray<number>;
  }>;
}>;

export type CodeSearchResultItem = {
  readonly name: string;
  readonly path: string;
  readonly sha: string;
  readonly url: string;
  readonly git_url: string;
  readonly html_url: string;
  readonly repository: MinimalRepository;
  readonly score: number;
  readonly file_size?: number;
  readonly language?: string | null;
  readonly last_modified_at?: string;
  readonly line_numbers?: ReadonlyArray<string>;
  readonly text_matches?: SearchResultTextMatches;
};

export type SearchCode200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<CodeSearchResultItem>;
};

export type SearchCode403ResponseBody = BasicError;

export type SearchCode422ResponseBody = ValidationError;

export type SearchCode503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SearchCodeRequestQuery = {
  readonly q: string;
  readonly sort?: 'indexed';
  readonly order?: 'desc' | 'asc';
  readonly per_page?: number;
  readonly page?: number;
};

export type CommitSearchResultItem = {
  readonly url: string;
  readonly sha: string;
  readonly html_url: string;
  readonly comments_url: string;
  readonly commit: {
    readonly author: {
      readonly name: string;
      readonly email: string;
      readonly date: string;
    };
    readonly committer: GitUser;
    readonly comment_count: number;
    readonly message: string;
    readonly tree: { readonly sha: string; readonly url: string };
    readonly url: string;
    readonly verification?: Verification;
  };
  readonly author: SimpleUser;
  readonly committer: GitUser;
  readonly parents: ReadonlyArray<{
    readonly url?: string;
    readonly html_url?: string;
    readonly sha?: string;
  }>;
  readonly repository: MinimalRepository;
  readonly score: number;
  readonly node_id: string;
  readonly text_matches?: SearchResultTextMatches;
};

export type SearchCommits200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<CommitSearchResultItem>;
};

export type SearchCommitsRequestQuery = {
  readonly q: string;
  readonly sort?: 'author-date' | 'committer-date';
  readonly order?: 'desc' | 'asc';
  readonly per_page?: number;
  readonly page?: number;
};

export type IssueSearchResultItem = {
  readonly url: string;
  readonly repository_url: string;
  readonly labels_url: string;
  readonly comments_url: string;
  readonly events_url: string;
  readonly html_url: string;
  readonly id: number;
  readonly node_id: string;
  readonly number: number;
  readonly title: string;
  readonly locked: boolean;
  readonly active_lock_reason?: string | null;
  readonly assignees?: ReadonlyArray<SimpleUser> | null;
  readonly user: SimpleUser;
  readonly labels: ReadonlyArray<{
    readonly id?: number;
    readonly node_id?: string;
    readonly url?: string;
    readonly name?: string;
    readonly color?: string;
    readonly default?: boolean;
    readonly description?: string | null;
  }>;
  readonly state: string;
  readonly state_reason?: string | null;
  readonly assignee: SimpleUser;
  readonly milestone: Milestone;
  readonly comments: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly closed_at: string | null;
  readonly text_matches?: SearchResultTextMatches;
  readonly pull_request?: {
    readonly merged_at?: string | null;
    readonly diff_url: string | null;
    readonly html_url: string | null;
    readonly patch_url: string | null;
    readonly url: string | null;
  };
  readonly body?: string;
  readonly score: number;
  readonly author_association: AuthorAssociation;
  readonly draft?: boolean;
  readonly repository?: Repository;
  readonly body_html?: string;
  readonly body_text?: string;
  readonly timeline_url?: string;
  readonly performed_via_github_app?: GitHubApp;
  readonly reactions?: ReactionRollup;
};

export type SearchIssuesAndPullRequests200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<IssueSearchResultItem>;
};

export type SearchIssuesAndPullRequests403ResponseBody = BasicError;

export type SearchIssuesAndPullRequests422ResponseBody = ValidationError;

export type SearchIssuesAndPullRequests503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SearchIssuesAndPullRequestsRequestQuery = {
  readonly q: string;
  readonly sort?:
    | 'comments'
    | 'reactions'
    | 'reactions-+1'
    | 'reactions--1'
    | 'reactions-smile'
    | 'reactions-thinking_face'
    | 'reactions-heart'
    | 'reactions-tada'
    | 'interactions'
    | 'created'
    | 'updated';
  readonly order?: 'desc' | 'asc';
  readonly per_page?: number;
  readonly page?: number;
};

export type LabelSearchResultItem = {
  readonly id: number;
  readonly node_id: string;
  readonly url: string;
  readonly name: string;
  readonly color: string;
  readonly default: boolean;
  readonly description: string | null;
  readonly score: number;
  readonly text_matches?: SearchResultTextMatches;
};

export type SearchLabels200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<LabelSearchResultItem>;
};

export type SearchLabels403ResponseBody = BasicError;

export type SearchLabels404ResponseBody = BasicError;

export type SearchLabels422ResponseBody = ValidationError;

export type SearchLabelsRequestQuery = {
  readonly repository_id: number;
  readonly q: string;
  readonly sort?: 'created' | 'updated';
  readonly order?: 'desc' | 'asc';
  readonly per_page?: number;
  readonly page?: number;
};

export type RepoSearchResultItem = {
  readonly id: number;
  readonly node_id: string;
  readonly name: string;
  readonly full_name: string;
  readonly owner: SimpleUser;
  readonly private: boolean;
  readonly html_url: string;
  readonly description: string | null;
  readonly fork: boolean;
  readonly url: string;
  readonly created_at: string;
  readonly updated_at: string;
  readonly pushed_at: string;
  readonly homepage: string | null;
  readonly size: number;
  readonly stargazers_count: number;
  readonly watchers_count: number;
  readonly language: string | null;
  readonly forks_count: number;
  readonly open_issues_count: number;
  readonly master_branch?: string;
  readonly default_branch: string;
  readonly score: number;
  readonly forks_url: string;
  readonly keys_url: string;
  readonly collaborators_url: string;
  readonly teams_url: string;
  readonly hooks_url: string;
  readonly issue_events_url: string;
  readonly events_url: string;
  readonly assignees_url: string;
  readonly branches_url: string;
  readonly tags_url: string;
  readonly blobs_url: string;
  readonly git_tags_url: string;
  readonly git_refs_url: string;
  readonly trees_url: string;
  readonly statuses_url: string;
  readonly languages_url: string;
  readonly stargazers_url: string;
  readonly contributors_url: string;
  readonly subscribers_url: string;
  readonly subscription_url: string;
  readonly commits_url: string;
  readonly git_commits_url: string;
  readonly comments_url: string;
  readonly issue_comment_url: string;
  readonly contents_url: string;
  readonly compare_url: string;
  readonly merges_url: string;
  readonly archive_url: string;
  readonly downloads_url: string;
  readonly issues_url: string;
  readonly pulls_url: string;
  readonly milestones_url: string;
  readonly notifications_url: string;
  readonly labels_url: string;
  readonly releases_url: string;
  readonly deployments_url: string;
  readonly git_url: string;
  readonly ssh_url: string;
  readonly clone_url: string;
  readonly svn_url: string;
  readonly forks: number;
  readonly open_issues: number;
  readonly watchers: number;
  readonly topics?: ReadonlyArray<string>;
  readonly mirror_url: string | null;
  readonly has_issues: boolean;
  readonly has_projects: boolean;
  readonly has_pages: boolean;
  readonly has_wiki: boolean;
  readonly has_downloads: boolean;
  readonly archived: boolean;
  readonly disabled: boolean;
  readonly visibility?: string;
  readonly license: LicenseSimple;
  readonly permissions?: {
    readonly admin: boolean;
    readonly maintain?: boolean;
    readonly push: boolean;
    readonly triage?: boolean;
    readonly pull: boolean;
  };
  readonly text_matches?: SearchResultTextMatches;
  readonly temp_clone_token?: string;
  readonly allow_merge_commit?: boolean;
  readonly allow_squash_merge?: boolean;
  readonly allow_rebase_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly allow_forking?: boolean;
  readonly is_template?: boolean;
  readonly web_commit_signoff_required?: boolean;
};

export type SearchRepos200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<RepoSearchResultItem>;
};

export type SearchRepos422ResponseBody = ValidationError;

export type SearchRepos503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SearchReposRequestQuery = {
  readonly q: string;
  readonly sort?: 'stars' | 'forks' | 'help-wanted-issues' | 'updated';
  readonly order?: 'desc' | 'asc';
  readonly per_page?: number;
  readonly page?: number;
};

export type TopicSearchResultItem = {
  readonly name: string;
  readonly display_name: string | null;
  readonly short_description: string | null;
  readonly description: string | null;
  readonly created_by: string | null;
  readonly released: string | null;
  readonly created_at: string;
  readonly updated_at: string;
  readonly featured: boolean;
  readonly curated: boolean;
  readonly score: number;
  readonly repository_count?: number | null;
  readonly logo_url?: string | null;
  readonly text_matches?: SearchResultTextMatches;
  readonly related?: ReadonlyArray<{
    readonly topic_relation?: {
      readonly id?: number;
      readonly name?: string;
      readonly topic_id?: number;
      readonly relation_type?: string;
    };
  }> | null;
  readonly aliases?: ReadonlyArray<{
    readonly topic_relation?: {
      readonly id?: number;
      readonly name?: string;
      readonly topic_id?: number;
      readonly relation_type?: string;
    };
  }> | null;
};

export type SearchTopics200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<TopicSearchResultItem>;
};

export type SearchTopicsRequestQuery = {
  readonly q: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type UserSearchResultItem = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly score: number;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly events_url: string;
  readonly public_repos?: number;
  readonly public_gists?: number;
  readonly followers?: number;
  readonly following?: number;
  readonly created_at?: string;
  readonly updated_at?: string;
  readonly name?: string | null;
  readonly bio?: string | null;
  readonly email?: string | null;
  readonly location?: string | null;
  readonly site_admin: boolean;
  readonly hireable?: boolean | null;
  readonly text_matches?: SearchResultTextMatches;
  readonly blog?: string | null;
  readonly company?: string | null;
  readonly suspended_at?: string | null;
};

export type SearchUsers200ResponseBody = {
  readonly total_count: number;
  readonly incomplete_results: boolean;
  readonly items: ReadonlyArray<UserSearchResultItem>;
};

export type SearchUsers422ResponseBody = ValidationError;

export type SearchUsers503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type SearchUsersRequestQuery = {
  readonly q: string;
  readonly sort?: 'followers' | 'repositories' | 'joined';
  readonly order?: 'desc' | 'asc';
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsGetLegacy200ResponseBody = FullTeam;

export type TeamsGetLegacy404ResponseBody = BasicError;

export type TeamsGetLegacyRequestPath = { readonly team_id: number };

export type TeamsUpdateLegacy200ResponseBody = FullTeam;

export type TeamsUpdateLegacy201ResponseBody = FullTeam;

export type TeamsUpdateLegacy403ResponseBody = BasicError;

export type TeamsUpdateLegacy404ResponseBody = BasicError;

export type TeamsUpdateLegacy422ResponseBody = ValidationError;

export type TeamsUpdateLegacyRequestBody = {
  readonly name: string;
  readonly description?: string;
  readonly privacy?: 'secret' | 'closed';
  readonly permission?: 'pull' | 'push' | 'admin';
  readonly parent_team_id?: number | null;
};

export type TeamsUpdateLegacyRequestPath = { readonly team_id: number };

export type TeamsDeleteLegacy404ResponseBody = BasicError;

export type TeamsDeleteLegacy422ResponseBody = ValidationError;

export type TeamsDeleteLegacyRequestPath = { readonly team_id: number };

export type TeamsListDiscussionsLegacy200ResponseBody = ReadonlyArray<TeamDiscussion>;

export type TeamsListDiscussionsLegacyRequestQuery = {
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListDiscussionsLegacyRequestPath = {
  readonly team_id: number;
};

export type TeamsCreateDiscussionLegacy201ResponseBody = TeamDiscussion;

export type TeamsCreateDiscussionLegacyRequestBody = {
  readonly title: string;
  readonly body: string;
  readonly private?: boolean;
};

export type TeamsCreateDiscussionLegacyRequestPath = {
  readonly team_id: number;
};

export type TeamsGetDiscussionLegacy200ResponseBody = TeamDiscussion;

export type TeamsGetDiscussionLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type TeamsUpdateDiscussionLegacy200ResponseBody = TeamDiscussion;

export type TeamsUpdateDiscussionLegacyRequestBody = {
  readonly title?: string;
  readonly body?: string;
};

export type TeamsUpdateDiscussionLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type TeamsDeleteDiscussionLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type TeamsListDiscussionCommentsLegacy200ResponseBody = ReadonlyArray<TeamDiscussionComment>;

export type TeamsListDiscussionCommentsLegacyRequestQuery = {
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListDiscussionCommentsLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type TeamsCreateDiscussionCommentLegacy201ResponseBody = TeamDiscussionComment;

export type TeamsCreateDiscussionCommentLegacyRequestBody = {
  readonly body: string;
};

export type TeamsCreateDiscussionCommentLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type TeamsGetDiscussionCommentLegacy200ResponseBody = TeamDiscussionComment;

export type TeamsGetDiscussionCommentLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type TeamsUpdateDiscussionCommentLegacy200ResponseBody = TeamDiscussionComment;

export type TeamsUpdateDiscussionCommentLegacyRequestBody = {
  readonly body: string;
};

export type TeamsUpdateDiscussionCommentLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type TeamsDeleteDiscussionCommentLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type ReactionsListForTeamDiscussionCommentLegacy200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForTeamDiscussionCommentLegacyRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForTeamDiscussionCommentLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type ReactionsCreateForTeamDiscussionCommentLegacy201ResponseBody = Reaction;

export type ReactionsCreateForTeamDiscussionCommentLegacyRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForTeamDiscussionCommentLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
  readonly comment_number: number;
};

export type ReactionsListForTeamDiscussionLegacy200ResponseBody = ReadonlyArray<Reaction>;

export type ReactionsListForTeamDiscussionLegacyRequestQuery = {
  readonly content?:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReactionsListForTeamDiscussionLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type ReactionsCreateForTeamDiscussionLegacy201ResponseBody = Reaction;

export type ReactionsCreateForTeamDiscussionLegacyRequestBody = {
  readonly content:
    | '+1'
    | '-1'
    | 'laugh'
    | 'confused'
    | 'heart'
    | 'hooray'
    | 'rocket'
    | 'eyes';
};

export type ReactionsCreateForTeamDiscussionLegacyRequestPath = {
  readonly team_id: number;
  readonly discussion_number: number;
};

export type TeamsListPendingInvitationsLegacy200ResponseBody = ReadonlyArray<OrganizationInvitation>;

export type TeamsListPendingInvitationsLegacyRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListPendingInvitationsLegacyRequestPath = {
  readonly team_id: number;
};

export type TeamsListMembersLegacy200ResponseBody = ReadonlyArray<SimpleUser>;

export type TeamsListMembersLegacy404ResponseBody = BasicError;

export type TeamsListMembersLegacyRequestQuery = {
  readonly role?: 'member' | 'maintainer' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListMembersLegacyRequestPath = { readonly team_id: number };

export type TeamsGetMemberLegacyRequestPath = {
  readonly team_id: number;
  readonly username: string;
};

export type TeamsAddMemberLegacy403ResponseBody = BasicError;

export type TeamsAddMemberLegacyRequestPath = {
  readonly team_id: number;
  readonly username: string;
};

export type TeamsRemoveMemberLegacyRequestPath = {
  readonly team_id: number;
  readonly username: string;
};

export type TeamsGetMembershipForUserLegacy200ResponseBody = TeamMembership;

export type TeamsGetMembershipForUserLegacy404ResponseBody = BasicError;

export type TeamsGetMembershipForUserLegacyRequestPath = {
  readonly team_id: number;
  readonly username: string;
};

export type TeamsAddOrUpdateMembershipForUserLegacy200ResponseBody = TeamMembership;

export type TeamsAddOrUpdateMembershipForUserLegacy404ResponseBody = BasicError;

export type TeamsAddOrUpdateMembershipForUserLegacyRequestBody = {
  readonly role?: 'member' | 'maintainer';
};

export type TeamsAddOrUpdateMembershipForUserLegacyRequestPath = {
  readonly team_id: number;
  readonly username: string;
};

export type TeamsRemoveMembershipForUserLegacyRequestPath = {
  readonly team_id: number;
  readonly username: string;
};

export type TeamsListProjectsLegacy200ResponseBody = ReadonlyArray<TeamProject>;

export type TeamsListProjectsLegacy404ResponseBody = BasicError;

export type TeamsListProjectsLegacyRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListProjectsLegacyRequestPath = { readonly team_id: number };

export type TeamsCheckPermissionsForProjectLegacy200ResponseBody = TeamProject;

export type TeamsCheckPermissionsForProjectLegacyRequestPath = {
  readonly team_id: number;
  readonly project_id: number;
};

export type TeamsAddOrUpdateProjectPermissionsLegacy403ResponseBody = {
  readonly message?: string;
  readonly documentation_url?: string;
};

export type TeamsAddOrUpdateProjectPermissionsLegacy404ResponseBody = BasicError;

export type TeamsAddOrUpdateProjectPermissionsLegacy422ResponseBody = ValidationError;

export type TeamsAddOrUpdateProjectPermissionsLegacyRequestBody = {
  readonly permission?: 'read' | 'write' | 'admin';
};

export type TeamsAddOrUpdateProjectPermissionsLegacyRequestPath = {
  readonly team_id: number;
  readonly project_id: number;
};

export type TeamsRemoveProjectLegacy404ResponseBody = BasicError;

export type TeamsRemoveProjectLegacy422ResponseBody = ValidationError;

export type TeamsRemoveProjectLegacyRequestPath = {
  readonly team_id: number;
  readonly project_id: number;
};

export type TeamsListReposLegacy200ResponseBody = ReadonlyArray<MinimalRepository>;

export type TeamsListReposLegacy404ResponseBody = BasicError;

export type TeamsListReposLegacyRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListReposLegacyRequestPath = { readonly team_id: number };

export type TeamsCheckPermissionsForRepoLegacy200ResponseBody = TeamRepository;

export type TeamsCheckPermissionsForRepoLegacyRequestPath = {
  readonly team_id: number;
  readonly owner: string;
  readonly repo: string;
};

export type TeamsAddOrUpdateRepoPermissionsLegacy403ResponseBody = BasicError;

export type TeamsAddOrUpdateRepoPermissionsLegacy422ResponseBody = ValidationError;

export type TeamsAddOrUpdateRepoPermissionsLegacyRequestBody = {
  readonly permission?: 'pull' | 'push' | 'admin';
};

export type TeamsAddOrUpdateRepoPermissionsLegacyRequestPath = {
  readonly team_id: number;
  readonly owner: string;
  readonly repo: string;
};

export type TeamsRemoveRepoLegacyRequestPath = {
  readonly team_id: number;
  readonly owner: string;
  readonly repo: string;
};

export type TeamsListChildLegacy200ResponseBody = ReadonlyArray<Team>;

export type TeamsListChildLegacy403ResponseBody = BasicError;

export type TeamsListChildLegacy404ResponseBody = BasicError;

export type TeamsListChildLegacy422ResponseBody = ValidationError;

export type TeamsListChildLegacyRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListChildLegacyRequestPath = { readonly team_id: number };

export type PrivateUser = {
  readonly login: string;
  readonly id: number;
  readonly node_id: string;
  readonly avatar_url: string;
  readonly gravatar_id: string | null;
  readonly url: string;
  readonly html_url: string;
  readonly followers_url: string;
  readonly following_url: string;
  readonly gists_url: string;
  readonly starred_url: string;
  readonly subscriptions_url: string;
  readonly organizations_url: string;
  readonly repos_url: string;
  readonly events_url: string;
  readonly received_events_url: string;
  readonly type: string;
  readonly site_admin: boolean;
  readonly name: string | null;
  readonly company: string | null;
  readonly blog: string | null;
  readonly location: string | null;
  readonly email: string | null;
  readonly hireable: boolean | null;
  readonly bio: string | null;
  readonly twitter_username?: string | null;
  readonly public_repos: number;
  readonly public_gists: number;
  readonly followers: number;
  readonly following: number;
  readonly created_at: string;
  readonly updated_at: string;
  readonly private_gists: number;
  readonly total_private_repos: number;
  readonly owned_private_repos: number;
  readonly disk_usage: number;
  readonly collaborators: number;
  readonly two_factor_authentication: boolean;
  readonly plan?: {
    readonly collaborators: number;
    readonly name: string;
    readonly space: number;
    readonly private_repos: number;
  };
  readonly suspended_at?: string | null;
  readonly business_plus?: boolean;
  readonly ldap_dn?: string;
};

export type UsersGetAuthenticated200ResponseBody = PrivateUser | PublicUser;

export type UsersGetAuthenticated401ResponseBody = BasicError;

export type UsersGetAuthenticated403ResponseBody = BasicError;

export type UsersUpdateAuthenticated200ResponseBody = PrivateUser;

export type UsersUpdateAuthenticated401ResponseBody = BasicError;

export type UsersUpdateAuthenticated403ResponseBody = BasicError;

export type UsersUpdateAuthenticated404ResponseBody = BasicError;

export type UsersUpdateAuthenticated422ResponseBody = ValidationError;

export type UsersUpdateAuthenticatedRequestBody = {
  readonly name?: string;
  readonly email?: string;
  readonly blog?: string;
  readonly twitter_username?: string | null;
  readonly company?: string;
  readonly location?: string;
  readonly hireable?: boolean;
  readonly bio?: string;
};

export type UsersListBlockedByAuthenticatedUser200ResponseBody = ReadonlyArray<SimpleUser>;

export type UsersListBlockedByAuthenticatedUser401ResponseBody = BasicError;

export type UsersListBlockedByAuthenticatedUser403ResponseBody = BasicError;

export type UsersListBlockedByAuthenticatedUser404ResponseBody = BasicError;

export type UsersListBlockedByAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersCheckBlocked401ResponseBody = BasicError;

export type UsersCheckBlocked403ResponseBody = BasicError;

export type UsersCheckBlocked404ResponseBody = BasicError;

export type UsersCheckBlockedRequestPath = { readonly username: string };

export type UsersBlock401ResponseBody = BasicError;

export type UsersBlock403ResponseBody = BasicError;

export type UsersBlock404ResponseBody = BasicError;

export type UsersBlock422ResponseBody = ValidationError;

export type UsersBlockRequestPath = { readonly username: string };

export type UsersUnblock401ResponseBody = BasicError;

export type UsersUnblock403ResponseBody = BasicError;

export type UsersUnblock404ResponseBody = BasicError;

export type UsersUnblockRequestPath = { readonly username: string };

export type CodespacesListForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly codespaces: ReadonlyArray<Codespace>;
};

export type CodespacesListForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesListForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesListForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesListForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesListForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
  readonly repository_id?: number;
};

export type CodespacesCreateForAuthenticatedUser201ResponseBody = Codespace;

export type CodespacesCreateForAuthenticatedUser202ResponseBody = Codespace;

export type CodespacesCreateForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesCreateForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesCreateForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesCreateForAuthenticatedUser503ResponseBody = {
  readonly code?: string;
  readonly message?: string;
  readonly documentation_url?: string;
};

export type CodespacesCreateForAuthenticatedUserRequestBody =
  | {
      readonly repository_id: number;
      readonly ref?: string;
      readonly location?: string;
      readonly client_ip?: string;
      readonly machine?: string;
      readonly devcontainer_path?: string;
      readonly multi_repo_permissions_opt_out?: boolean;
      readonly working_directory?: string;
      readonly idle_timeout_minutes?: number;
      readonly display_name?: string;
      readonly retention_period_minutes?: number;
    }
  | {
      readonly pull_request: {
        readonly pull_request_number: number;
        readonly repository_id: number;
      };
      readonly location?: string;
      readonly machine?: string;
      readonly devcontainer_path?: string;
      readonly working_directory?: string;
      readonly idle_timeout_minutes?: number;
    };

export type CodespacesListSecretsForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly secrets: ReadonlyArray<CodespacesSecret>;
};

export type CodespacesListSecretsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type CodespacesUserPublicKey = {
  readonly key_id: string;
  readonly key: string;
};

export type CodespacesGetPublicKeyForAuthenticatedUser200ResponseBody = CodespacesUserPublicKey;

export type CodespacesGetSecretForAuthenticatedUser200ResponseBody = CodespacesSecret;

export type CodespacesGetSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
};

export type CodespacesCreateOrUpdateSecretForAuthenticatedUser201ResponseBody = EmptyObject;

export type CodespacesCreateOrUpdateSecretForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesCreateOrUpdateSecretForAuthenticatedUser422ResponseBody = ValidationError;

export type CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestBody = {
  readonly encrypted_value?: string;
  readonly key_id: string;
  readonly selected_repository_ids?: ReadonlyArray<string>;
};

export type CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
};

export type CodespacesDeleteSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
};

export type CodespacesListRepositoriesForSecretForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly repositories: ReadonlyArray<MinimalRepository>;
};

export type CodespacesListRepositoriesForSecretForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesListRepositoriesForSecretForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesListRepositoriesForSecretForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesListRepositoriesForSecretForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesListRepositoriesForSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
};

export type CodespacesSetRepositoriesForSecretForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesSetRepositoriesForSecretForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesSetRepositoriesForSecretForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesSetRepositoriesForSecretForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestBody = {
  readonly selected_repository_ids: ReadonlyArray<number>;
};

export type CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
};

export type CodespacesAddRepositoryForSecretForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesAddRepositoryForSecretForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesAddRepositoryForSecretForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesAddRepositoryForSecretForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesAddRepositoryForSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
  readonly repository_id: number;
};

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUserRequestPath = {
  readonly secret_name: string;
  readonly repository_id: number;
};

export type CodespacesGetForAuthenticatedUser200ResponseBody = Codespace;

export type CodespacesGetForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesGetForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesGetForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesGetForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesGetForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type CodespacesUpdateForAuthenticatedUser200ResponseBody = Codespace;

export type CodespacesUpdateForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesUpdateForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesUpdateForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesUpdateForAuthenticatedUserRequestBody = {
  readonly machine?: string;
  readonly display_name?: string;
  readonly recent_folders?: ReadonlyArray<string>;
};

export type CodespacesUpdateForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type CodespacesDeleteForAuthenticatedUser202ResponseBody = unknown;

export type CodespacesDeleteForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesDeleteForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesDeleteForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesDeleteForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesDeleteForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type FetchesInformationAboutAnExportOfACodespace = {
  readonly state?: string | null;
  readonly completed_at?: string | null;
  readonly branch?: string | null;
  readonly sha?: string | null;
  readonly id?: string;
  readonly export_url?: string;
  readonly html_url?: string | null;
};

export type CodespacesExportForAuthenticatedUser202ResponseBody = FetchesInformationAboutAnExportOfACodespace;

export type CodespacesExportForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesExportForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesExportForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesExportForAuthenticatedUser422ResponseBody = ValidationError;

export type CodespacesExportForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesExportForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type CodespacesGetExportDetailsForAuthenticatedUser200ResponseBody = FetchesInformationAboutAnExportOfACodespace;

export type CodespacesGetExportDetailsForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesGetExportDetailsForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
  readonly export_id: string;
};

export type CodespacesCodespaceMachinesForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly machines: ReadonlyArray<CodespaceMachine>;
};

export type CodespacesCodespaceMachinesForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesCodespaceMachinesForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesCodespaceMachinesForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesCodespaceMachinesForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesCodespaceMachinesForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type CodespacesStartForAuthenticatedUser200ResponseBody = Codespace;

export type CodespacesStartForAuthenticatedUser400ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUser402ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUser409ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesStartForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type CodespacesStopForAuthenticatedUser200ResponseBody = Codespace;

export type CodespacesStopForAuthenticatedUser401ResponseBody = BasicError;

export type CodespacesStopForAuthenticatedUser403ResponseBody = BasicError;

export type CodespacesStopForAuthenticatedUser404ResponseBody = BasicError;

export type CodespacesStopForAuthenticatedUser500ResponseBody = BasicError;

export type CodespacesStopForAuthenticatedUserRequestPath = {
  readonly codespace_name: string;
};

export type Email = {
  readonly email: string;
  readonly primary: boolean;
  readonly verified: boolean;
  readonly visibility: string | null;
};

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUser200ResponseBody = ReadonlyArray<Email>;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUser401ResponseBody = BasicError;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUser403ResponseBody = BasicError;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUser404ResponseBody = BasicError;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestBody = {
  readonly visibility: 'public' | 'private';
};

export type UsersListEmailsForAuthenticatedUser200ResponseBody = ReadonlyArray<Email>;

export type UsersListEmailsForAuthenticatedUser401ResponseBody = BasicError;

export type UsersListEmailsForAuthenticatedUser403ResponseBody = BasicError;

export type UsersListEmailsForAuthenticatedUser404ResponseBody = BasicError;

export type UsersListEmailsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersAddEmailForAuthenticatedUser201ResponseBody = ReadonlyArray<Email>;

export type UsersAddEmailForAuthenticatedUser401ResponseBody = BasicError;

export type UsersAddEmailForAuthenticatedUser403ResponseBody = BasicError;

export type UsersAddEmailForAuthenticatedUser404ResponseBody = BasicError;

export type UsersAddEmailForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersAddEmailForAuthenticatedUserRequestBody =
  | { readonly emails: ReadonlyArray<string> }
  | ReadonlyArray<string>
  | string;

export type UsersDeleteEmailForAuthenticatedUser401ResponseBody = BasicError;

export type UsersDeleteEmailForAuthenticatedUser403ResponseBody = BasicError;

export type UsersDeleteEmailForAuthenticatedUser404ResponseBody = BasicError;

export type UsersDeleteEmailForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersDeleteEmailForAuthenticatedUserRequestBody =
  | { readonly emails: ReadonlyArray<string> }
  | ReadonlyArray<string>
  | string;

export type UsersListFollowersForAuthenticatedUser200ResponseBody = ReadonlyArray<SimpleUser>;

export type UsersListFollowersForAuthenticatedUser401ResponseBody = BasicError;

export type UsersListFollowersForAuthenticatedUser403ResponseBody = BasicError;

export type UsersListFollowersForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersListFollowedByAuthenticatedUser200ResponseBody = ReadonlyArray<SimpleUser>;

export type UsersListFollowedByAuthenticatedUser401ResponseBody = BasicError;

export type UsersListFollowedByAuthenticatedUser403ResponseBody = BasicError;

export type UsersListFollowedByAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersCheckPersonIsFollowedByAuthenticated401ResponseBody = BasicError;

export type UsersCheckPersonIsFollowedByAuthenticated403ResponseBody = BasicError;

export type UsersCheckPersonIsFollowedByAuthenticated404ResponseBody = BasicError;

export type UsersCheckPersonIsFollowedByAuthenticatedRequestPath = {
  readonly username: string;
};

export type UsersFollow401ResponseBody = BasicError;

export type UsersFollow403ResponseBody = BasicError;

export type UsersFollow404ResponseBody = BasicError;

export type UsersFollowRequestPath = { readonly username: string };

export type UsersUnfollow401ResponseBody = BasicError;

export type UsersUnfollow403ResponseBody = BasicError;

export type UsersUnfollow404ResponseBody = BasicError;

export type UsersUnfollowRequestPath = { readonly username: string };

export type GpgKey = {
  readonly id: number;
  readonly name?: string | null;
  readonly primary_key_id: number | null;
  readonly key_id: string;
  readonly public_key: string;
  readonly emails: ReadonlyArray<{
    readonly email?: string;
    readonly verified?: boolean;
  }>;
  readonly subkeys: ReadonlyArray<{
    readonly id?: number;
    readonly primary_key_id?: number;
    readonly key_id?: string;
    readonly public_key?: string;
    readonly emails?: ReadonlyArray<unknown>;
    readonly subkeys?: ReadonlyArray<unknown>;
    readonly can_sign?: boolean;
    readonly can_encrypt_comms?: boolean;
    readonly can_encrypt_storage?: boolean;
    readonly can_certify?: boolean;
    readonly created_at?: string;
    readonly expires_at?: string | null;
    readonly raw_key?: string | null;
    readonly revoked?: boolean;
  }>;
  readonly can_sign: boolean;
  readonly can_encrypt_comms: boolean;
  readonly can_encrypt_storage: boolean;
  readonly can_certify: boolean;
  readonly created_at: string;
  readonly expires_at: string | null;
  readonly revoked: boolean;
  readonly raw_key: string | null;
};

export type UsersListGpgKeysForAuthenticatedUser200ResponseBody = ReadonlyArray<GpgKey>;

export type UsersListGpgKeysForAuthenticatedUser401ResponseBody = BasicError;

export type UsersListGpgKeysForAuthenticatedUser403ResponseBody = BasicError;

export type UsersListGpgKeysForAuthenticatedUser404ResponseBody = BasicError;

export type UsersListGpgKeysForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersCreateGpgKeyForAuthenticatedUser201ResponseBody = GpgKey;

export type UsersCreateGpgKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersCreateGpgKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersCreateGpgKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersCreateGpgKeyForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersCreateGpgKeyForAuthenticatedUserRequestBody = {
  readonly name?: string;
  readonly armored_public_key: string;
};

export type UsersGetGpgKeyForAuthenticatedUser200ResponseBody = GpgKey;

export type UsersGetGpgKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersGetGpgKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersGetGpgKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersGetGpgKeyForAuthenticatedUserRequestPath = {
  readonly gpg_key_id: number;
};

export type UsersDeleteGpgKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersDeleteGpgKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersDeleteGpgKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersDeleteGpgKeyForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersDeleteGpgKeyForAuthenticatedUserRequestPath = {
  readonly gpg_key_id: number;
};

export type AppsListInstallationsForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly installations: ReadonlyArray<Installation>;
};

export type AppsListInstallationsForAuthenticatedUser401ResponseBody = BasicError;

export type AppsListInstallationsForAuthenticatedUser403ResponseBody = BasicError;

export type AppsListInstallationsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListInstallationReposForAuthenticatedUser200ResponseBody = {
  readonly total_count: number;
  readonly repository_selection?: string;
  readonly repositories: ReadonlyArray<Repository>;
};

export type AppsListInstallationReposForAuthenticatedUser403ResponseBody = BasicError;

export type AppsListInstallationReposForAuthenticatedUser404ResponseBody = BasicError;

export type AppsListInstallationReposForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListInstallationReposForAuthenticatedUserRequestPath = {
  readonly installation_id: number;
};

export type AppsAddRepoToInstallationForAuthenticatedUser403ResponseBody = BasicError;

export type AppsAddRepoToInstallationForAuthenticatedUser404ResponseBody = BasicError;

export type AppsAddRepoToInstallationForAuthenticatedUserRequestPath = {
  readonly installation_id: number;
  readonly repository_id: number;
};

export type AppsRemoveRepoFromInstallationForAuthenticatedUser403ResponseBody = BasicError;

export type AppsRemoveRepoFromInstallationForAuthenticatedUser404ResponseBody = BasicError;

export type AppsRemoveRepoFromInstallationForAuthenticatedUserRequestPath = {
  readonly installation_id: number;
  readonly repository_id: number;
};

export type InteractionsGetRestrictionsForAuthenticatedUser200ResponseBody =
  | InteractionLimits
  | {};

export type InteractionsSetRestrictionsForAuthenticatedUser200ResponseBody = InteractionLimits;

export type InteractionsSetRestrictionsForAuthenticatedUser422ResponseBody = ValidationError;

export type InteractionsSetRestrictionsForAuthenticatedUserRequestBody = InteractionRestrictions;

export type IssuesListForAuthenticatedUser200ResponseBody = ReadonlyArray<Issue>;

export type IssuesListForAuthenticatedUser404ResponseBody = BasicError;

export type IssuesListForAuthenticatedUserRequestQuery = {
  readonly filter?:
    | 'assigned'
    | 'created'
    | 'mentioned'
    | 'subscribed'
    | 'repos'
    | 'all';
  readonly state?: 'open' | 'closed' | 'all';
  readonly labels?: string;
  readonly sort?: 'created' | 'updated' | 'comments';
  readonly direction?: 'asc' | 'desc';
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type Key = {
  readonly key: string;
  readonly id: number;
  readonly url: string;
  readonly title: string;
  readonly created_at: string;
  readonly verified: boolean;
  readonly read_only: boolean;
};

export type UsersListPublicSshKeysForAuthenticatedUser200ResponseBody = ReadonlyArray<Key>;

export type UsersListPublicSshKeysForAuthenticatedUser401ResponseBody = BasicError;

export type UsersListPublicSshKeysForAuthenticatedUser403ResponseBody = BasicError;

export type UsersListPublicSshKeysForAuthenticatedUser404ResponseBody = BasicError;

export type UsersListPublicSshKeysForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersCreatePublicSshKeyForAuthenticatedUser201ResponseBody = Key;

export type UsersCreatePublicSshKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersCreatePublicSshKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersCreatePublicSshKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersCreatePublicSshKeyForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersCreatePublicSshKeyForAuthenticatedUserRequestBody = {
  readonly title?: string;
  readonly key: string;
};

export type UsersGetPublicSshKeyForAuthenticatedUser200ResponseBody = Key;

export type UsersGetPublicSshKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersGetPublicSshKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersGetPublicSshKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersGetPublicSshKeyForAuthenticatedUserRequestPath = {
  readonly key_id: number;
};

export type UsersDeletePublicSshKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersDeletePublicSshKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersDeletePublicSshKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersDeletePublicSshKeyForAuthenticatedUserRequestPath = {
  readonly key_id: number;
};

export type MarketplaceAccount = {
  readonly url: string;
  readonly id: number;
  readonly type: string;
  readonly node_id?: string;
  readonly login: string;
  readonly email?: string | null;
  readonly organization_billing_email?: string | null;
};

export type UserMarketplacePurchase = {
  readonly billing_cycle: string;
  readonly next_billing_date: string | null;
  readonly unit_count: number | null;
  readonly on_free_trial: boolean;
  readonly free_trial_ends_on: string | null;
  readonly updated_at: string | null;
  readonly account: MarketplaceAccount;
  readonly plan: MarketplaceListingPlan;
};

export type AppsListSubscriptionsForAuthenticatedUser200ResponseBody = ReadonlyArray<UserMarketplacePurchase>;

export type AppsListSubscriptionsForAuthenticatedUser401ResponseBody = BasicError;

export type AppsListSubscriptionsForAuthenticatedUser404ResponseBody = BasicError;

export type AppsListSubscriptionsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type AppsListSubscriptionsForAuthenticatedUserStubbed200ResponseBody = ReadonlyArray<UserMarketplacePurchase>;

export type AppsListSubscriptionsForAuthenticatedUserStubbed401ResponseBody = BasicError;

export type AppsListSubscriptionsForAuthenticatedUserStubbedRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListMembershipsForAuthenticatedUser200ResponseBody = ReadonlyArray<OrgMembership>;

export type OrgsListMembershipsForAuthenticatedUser401ResponseBody = BasicError;

export type OrgsListMembershipsForAuthenticatedUser403ResponseBody = BasicError;

export type OrgsListMembershipsForAuthenticatedUser422ResponseBody = ValidationError;

export type OrgsListMembershipsForAuthenticatedUserRequestQuery = {
  readonly state?: 'active' | 'pending';
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsGetMembershipForAuthenticatedUser200ResponseBody = OrgMembership;

export type OrgsGetMembershipForAuthenticatedUser403ResponseBody = BasicError;

export type OrgsGetMembershipForAuthenticatedUser404ResponseBody = BasicError;

export type OrgsGetMembershipForAuthenticatedUserRequestPath = {
  readonly org: string;
};

export type OrgsUpdateMembershipForAuthenticatedUser200ResponseBody = OrgMembership;

export type OrgsUpdateMembershipForAuthenticatedUser403ResponseBody = BasicError;

export type OrgsUpdateMembershipForAuthenticatedUser404ResponseBody = BasicError;

export type OrgsUpdateMembershipForAuthenticatedUser422ResponseBody = ValidationError;

export type OrgsUpdateMembershipForAuthenticatedUserRequestBody = {
  readonly state: 'active';
};

export type OrgsUpdateMembershipForAuthenticatedUserRequestPath = {
  readonly org: string;
};

export type MigrationsListForAuthenticatedUser200ResponseBody = ReadonlyArray<Migration>;

export type MigrationsListForAuthenticatedUser401ResponseBody = BasicError;

export type MigrationsListForAuthenticatedUser403ResponseBody = BasicError;

export type MigrationsListForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type MigrationsStartForAuthenticatedUser201ResponseBody = Migration;

export type MigrationsStartForAuthenticatedUser401ResponseBody = BasicError;

export type MigrationsStartForAuthenticatedUser403ResponseBody = BasicError;

export type MigrationsStartForAuthenticatedUser422ResponseBody = ValidationError;

export type MigrationsStartForAuthenticatedUserRequestBody = {
  readonly lock_repositories?: boolean;
  readonly exclude_metadata?: boolean;
  readonly exclude_git_data?: boolean;
  readonly exclude_attachments?: boolean;
  readonly exclude_releases?: boolean;
  readonly exclude_owner_projects?: boolean;
  readonly org_metadata_only?: boolean;
  readonly exclude?: ReadonlyArray<'repositories'>;
  readonly repositories: ReadonlyArray<string>;
};

export type MigrationsGetStatusForAuthenticatedUser200ResponseBody = Migration;

export type MigrationsGetStatusForAuthenticatedUser401ResponseBody = BasicError;

export type MigrationsGetStatusForAuthenticatedUser403ResponseBody = BasicError;

export type MigrationsGetStatusForAuthenticatedUser404ResponseBody = BasicError;

export type MigrationsGetStatusForAuthenticatedUserRequestQuery = {
  readonly exclude?: ReadonlyArray<string> | string;
};

export type MigrationsGetStatusForAuthenticatedUserRequestPath = {
  readonly migration_id: number;
};

export type MigrationsGetArchiveForAuthenticatedUser401ResponseBody = BasicError;

export type MigrationsGetArchiveForAuthenticatedUser403ResponseBody = BasicError;

export type MigrationsGetArchiveForAuthenticatedUserRequestPath = {
  readonly migration_id: number;
};

export type MigrationsDeleteArchiveForAuthenticatedUser401ResponseBody = BasicError;

export type MigrationsDeleteArchiveForAuthenticatedUser403ResponseBody = BasicError;

export type MigrationsDeleteArchiveForAuthenticatedUser404ResponseBody = BasicError;

export type MigrationsDeleteArchiveForAuthenticatedUserRequestPath = {
  readonly migration_id: number;
};

export type MigrationsUnlockRepoForAuthenticatedUser401ResponseBody = BasicError;

export type MigrationsUnlockRepoForAuthenticatedUser403ResponseBody = BasicError;

export type MigrationsUnlockRepoForAuthenticatedUser404ResponseBody = BasicError;

export type MigrationsUnlockRepoForAuthenticatedUserRequestPath = {
  readonly migration_id: number;
  readonly repo_name: string;
};

export type MigrationsListReposForAuthenticatedUser200ResponseBody = ReadonlyArray<MinimalRepository>;

export type MigrationsListReposForAuthenticatedUser404ResponseBody = BasicError;

export type MigrationsListReposForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type MigrationsListReposForAuthenticatedUserRequestPath = {
  readonly migration_id: number;
};

export type OrgsListForAuthenticatedUser200ResponseBody = ReadonlyArray<OrganizationSimple>;

export type OrgsListForAuthenticatedUser401ResponseBody = BasicError;

export type OrgsListForAuthenticatedUser403ResponseBody = BasicError;

export type OrgsListForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type PackagesListPackagesForAuthenticatedUser200ResponseBody = ReadonlyArray<Package>;

export type PackagesListPackagesForAuthenticatedUserRequestQuery = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly visibility?: 'public' | 'private' | 'internal';
};

export type PackagesGetPackageForAuthenticatedUser200ResponseBody = Package;

export type PackagesGetPackageForAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
};

export type PackagesDeletePackageForAuthenticatedUser401ResponseBody = BasicError;

export type PackagesDeletePackageForAuthenticatedUser403ResponseBody = BasicError;

export type PackagesDeletePackageForAuthenticatedUser404ResponseBody = BasicError;

export type PackagesDeletePackageForAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
};

export type PackagesRestorePackageForAuthenticatedUser401ResponseBody = BasicError;

export type PackagesRestorePackageForAuthenticatedUser403ResponseBody = BasicError;

export type PackagesRestorePackageForAuthenticatedUser404ResponseBody = BasicError;

export type PackagesRestorePackageForAuthenticatedUserRequestQuery = {
  readonly token?: string;
};

export type PackagesRestorePackageForAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
};

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser200ResponseBody = ReadonlyArray<PackageVersion>;

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser401ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser403ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser404ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequestQuery = {
  readonly page?: number;
  readonly per_page?: number;
  readonly state?: 'active' | 'deleted';
};

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
};

export type PackagesGetPackageVersionForAuthenticatedUser200ResponseBody = PackageVersion;

export type PackagesGetPackageVersionForAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly package_version_id: number;
};

export type PackagesDeletePackageVersionForAuthenticatedUser401ResponseBody = BasicError;

export type PackagesDeletePackageVersionForAuthenticatedUser403ResponseBody = BasicError;

export type PackagesDeletePackageVersionForAuthenticatedUser404ResponseBody = BasicError;

export type PackagesDeletePackageVersionForAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly package_version_id: number;
};

export type PackagesRestorePackageVersionForAuthenticatedUser401ResponseBody = BasicError;

export type PackagesRestorePackageVersionForAuthenticatedUser403ResponseBody = BasicError;

export type PackagesRestorePackageVersionForAuthenticatedUser404ResponseBody = BasicError;

export type PackagesRestorePackageVersionForAuthenticatedUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly package_version_id: number;
};

export type ProjectsCreateForAuthenticatedUser201ResponseBody = Project;

export type ProjectsCreateForAuthenticatedUser401ResponseBody = BasicError;

export type ProjectsCreateForAuthenticatedUser403ResponseBody = BasicError;

export type ProjectsCreateForAuthenticatedUser422ResponseBody = ValidationErrorSimple;

export type ProjectsCreateForAuthenticatedUserRequestBody = {
  readonly name: string;
  readonly body?: string | null;
};

export type UsersListPublicEmailsForAuthenticatedUser200ResponseBody = ReadonlyArray<Email>;

export type UsersListPublicEmailsForAuthenticatedUser401ResponseBody = BasicError;

export type UsersListPublicEmailsForAuthenticatedUser403ResponseBody = BasicError;

export type UsersListPublicEmailsForAuthenticatedUser404ResponseBody = BasicError;

export type UsersListPublicEmailsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListForAuthenticatedUser200ResponseBody = ReadonlyArray<Repository>;

export type ReposListForAuthenticatedUser401ResponseBody = BasicError;

export type ReposListForAuthenticatedUser403ResponseBody = BasicError;

export type ReposListForAuthenticatedUser422ResponseBody = ValidationError;

export type ReposListForAuthenticatedUserRequestQuery = {
  readonly visibility?: 'all' | 'public' | 'private';
  readonly affiliation?: string;
  readonly type?: 'all' | 'owner' | 'public' | 'private' | 'member';
  readonly sort?: 'created' | 'updated' | 'pushed' | 'full_name';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
  readonly since?: string;
  readonly before?: string;
};

export type ReposCreateForAuthenticatedUser201ResponseBody = Repository;

export type ReposCreateForAuthenticatedUser400ResponseBody = BasicError;

export type ReposCreateForAuthenticatedUser401ResponseBody = BasicError;

export type ReposCreateForAuthenticatedUser403ResponseBody = BasicError;

export type ReposCreateForAuthenticatedUser404ResponseBody = BasicError;

export type ReposCreateForAuthenticatedUser422ResponseBody = ValidationError;

export type ReposCreateForAuthenticatedUserRequestBody = {
  readonly name: string;
  readonly description?: string;
  readonly homepage?: string;
  readonly private?: boolean;
  readonly has_issues?: boolean;
  readonly has_projects?: boolean;
  readonly has_wiki?: boolean;
  readonly team_id?: number;
  readonly auto_init?: boolean;
  readonly gitignore_template?: string;
  readonly license_template?: string;
  readonly allow_squash_merge?: boolean;
  readonly allow_merge_commit?: boolean;
  readonly allow_rebase_merge?: boolean;
  readonly allow_auto_merge?: boolean;
  readonly delete_branch_on_merge?: boolean;
  readonly squash_merge_commit_title?: 'PR_TITLE' | 'COMMIT_OR_PR_TITLE';
  readonly squash_merge_commit_message?:
    | 'PR_BODY'
    | 'COMMIT_MESSAGES'
    | 'BLANK';
  readonly merge_commit_title?: 'PR_TITLE' | 'MERGE_MESSAGE';
  readonly merge_commit_message?: 'PR_BODY' | 'PR_TITLE' | 'BLANK';
  readonly has_downloads?: boolean;
  readonly is_template?: boolean;
};

export type ReposListInvitationsForAuthenticatedUser200ResponseBody = ReadonlyArray<RepositoryInvitation>;

export type ReposListInvitationsForAuthenticatedUser401ResponseBody = BasicError;

export type ReposListInvitationsForAuthenticatedUser403ResponseBody = BasicError;

export type ReposListInvitationsForAuthenticatedUser404ResponseBody = BasicError;

export type ReposListInvitationsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposAcceptInvitationForAuthenticatedUser403ResponseBody = BasicError;

export type ReposAcceptInvitationForAuthenticatedUser404ResponseBody = BasicError;

export type ReposAcceptInvitationForAuthenticatedUser409ResponseBody = BasicError;

export type ReposAcceptInvitationForAuthenticatedUserRequestPath = {
  readonly invitation_id: number;
};

export type ReposDeclineInvitationForAuthenticatedUser403ResponseBody = BasicError;

export type ReposDeclineInvitationForAuthenticatedUser404ResponseBody = BasicError;

export type ReposDeclineInvitationForAuthenticatedUser409ResponseBody = BasicError;

export type ReposDeclineInvitationForAuthenticatedUserRequestPath = {
  readonly invitation_id: number;
};

export type SshSigningKey = {
  readonly key: string;
  readonly id: number;
  readonly title: string;
  readonly created_at: string;
};

export type UsersListSshSigningKeysForAuthenticatedUser200ResponseBody = ReadonlyArray<SshSigningKey>;

export type UsersListSshSigningKeysForAuthenticatedUser401ResponseBody = BasicError;

export type UsersListSshSigningKeysForAuthenticatedUser403ResponseBody = BasicError;

export type UsersListSshSigningKeysForAuthenticatedUser404ResponseBody = BasicError;

export type UsersListSshSigningKeysForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersCreateSshSigningKeyForAuthenticatedUser201ResponseBody = SshSigningKey;

export type UsersCreateSshSigningKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersCreateSshSigningKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersCreateSshSigningKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersCreateSshSigningKeyForAuthenticatedUser422ResponseBody = ValidationError;

export type UsersCreateSshSigningKeyForAuthenticatedUserRequestBody = {
  readonly title?: string;
  readonly key: string;
};

export type UsersGetSshSigningKeyForAuthenticatedUser200ResponseBody = SshSigningKey;

export type UsersGetSshSigningKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersGetSshSigningKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersGetSshSigningKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersGetSshSigningKeyForAuthenticatedUserRequestPath = {
  readonly ssh_signing_key_id: number;
};

export type UsersDeleteSshSigningKeyForAuthenticatedUser401ResponseBody = BasicError;

export type UsersDeleteSshSigningKeyForAuthenticatedUser403ResponseBody = BasicError;

export type UsersDeleteSshSigningKeyForAuthenticatedUser404ResponseBody = BasicError;

export type UsersDeleteSshSigningKeyForAuthenticatedUserRequestPath = {
  readonly ssh_signing_key_id: number;
};

export type ActivityListReposStarredByAuthenticatedUser200ResponseBody = ReadonlyArray<Repository>;

export type ActivityListReposStarredByAuthenticatedUser401ResponseBody = BasicError;

export type ActivityListReposStarredByAuthenticatedUser403ResponseBody = BasicError;

export type ActivityListReposStarredByAuthenticatedUserRequestQuery = {
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityCheckRepoIsStarredByAuthenticatedUser401ResponseBody = BasicError;

export type ActivityCheckRepoIsStarredByAuthenticatedUser403ResponseBody = BasicError;

export type ActivityCheckRepoIsStarredByAuthenticatedUser404ResponseBody = BasicError;

export type ActivityCheckRepoIsStarredByAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivityStarRepoForAuthenticatedUser401ResponseBody = BasicError;

export type ActivityStarRepoForAuthenticatedUser403ResponseBody = BasicError;

export type ActivityStarRepoForAuthenticatedUser404ResponseBody = BasicError;

export type ActivityStarRepoForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivityUnstarRepoForAuthenticatedUser401ResponseBody = BasicError;

export type ActivityUnstarRepoForAuthenticatedUser403ResponseBody = BasicError;

export type ActivityUnstarRepoForAuthenticatedUser404ResponseBody = BasicError;

export type ActivityUnstarRepoForAuthenticatedUserRequestPath = {
  readonly owner: string;
  readonly repo: string;
};

export type ActivityListWatchedReposForAuthenticatedUser200ResponseBody = ReadonlyArray<MinimalRepository>;

export type ActivityListWatchedReposForAuthenticatedUser401ResponseBody = BasicError;

export type ActivityListWatchedReposForAuthenticatedUser403ResponseBody = BasicError;

export type ActivityListWatchedReposForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type TeamsListForAuthenticatedUser200ResponseBody = ReadonlyArray<FullTeam>;

export type TeamsListForAuthenticatedUser403ResponseBody = BasicError;

export type TeamsListForAuthenticatedUser404ResponseBody = BasicError;

export type TeamsListForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersList200ResponseBody = ReadonlyArray<SimpleUser>;

export type UsersListRequestQuery = {
  readonly since?: number;
  readonly per_page?: number;
};

export type UsersGetByUsername200ResponseBody = PrivateUser | PublicUser;

export type UsersGetByUsername404ResponseBody = BasicError;

export type UsersGetByUsernameRequestPath = { readonly username: string };

export type ActivityListEventsForAuthenticatedUser200ResponseBody = ReadonlyArray<Event>;

export type ActivityListEventsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListEventsForAuthenticatedUserRequestPath = {
  readonly username: string;
};

export type ActivityListOrgEventsForAuthenticatedUser200ResponseBody = ReadonlyArray<Event>;

export type ActivityListOrgEventsForAuthenticatedUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListOrgEventsForAuthenticatedUserRequestPath = {
  readonly username: string;
  readonly org: string;
};

export type ActivityListPublicEventsForUser200ResponseBody = ReadonlyArray<Event>;

export type ActivityListPublicEventsForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListPublicEventsForUserRequestPath = {
  readonly username: string;
};

export type UsersListFollowersForUser200ResponseBody = ReadonlyArray<SimpleUser>;

export type UsersListFollowersForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersListFollowersForUserRequestPath = {
  readonly username: string;
};

export type UsersListFollowingForUser200ResponseBody = ReadonlyArray<SimpleUser>;

export type UsersListFollowingForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersListFollowingForUserRequestPath = {
  readonly username: string;
};

export type UsersCheckFollowingForUserRequestPath = {
  readonly username: string;
  readonly target_user: string;
};

export type GistsListForUser200ResponseBody = ReadonlyArray<BaseGist>;

export type GistsListForUser422ResponseBody = ValidationError;

export type GistsListForUserRequestQuery = {
  readonly since?: string;
  readonly per_page?: number;
  readonly page?: number;
};

export type GistsListForUserRequestPath = { readonly username: string };

export type UsersListGpgKeysForUser200ResponseBody = ReadonlyArray<GpgKey>;

export type UsersListGpgKeysForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersListGpgKeysForUserRequestPath = { readonly username: string };

export type Hovercard = {
  readonly contexts: ReadonlyArray<{
    readonly message: string;
    readonly octicon: string;
  }>;
};

export type UsersGetContextForUser200ResponseBody = Hovercard;

export type UsersGetContextForUser404ResponseBody = BasicError;

export type UsersGetContextForUser422ResponseBody = ValidationError;

export type UsersGetContextForUserRequestQuery = {
  readonly subject_type?:
    | 'organization'
    | 'repository'
    | 'issue'
    | 'pull_request';
  readonly subject_id?: string;
};

export type UsersGetContextForUserRequestPath = { readonly username: string };

export type AppsGetUserInstallation200ResponseBody = Installation;

export type AppsGetUserInstallationRequestPath = { readonly username: string };

export type KeySimple = { readonly id: number; readonly key: string };

export type UsersListPublicKeysForUser200ResponseBody = ReadonlyArray<KeySimple>;

export type UsersListPublicKeysForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersListPublicKeysForUserRequestPath = {
  readonly username: string;
};

export type OrgsListForUser200ResponseBody = ReadonlyArray<OrganizationSimple>;

export type OrgsListForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type OrgsListForUserRequestPath = { readonly username: string };

export type PackagesListPackagesForUser200ResponseBody = ReadonlyArray<Package>;

export type PackagesListPackagesForUser401ResponseBody = BasicError;

export type PackagesListPackagesForUser403ResponseBody = BasicError;

export type PackagesListPackagesForUserRequestQuery = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly visibility?: 'public' | 'private' | 'internal';
};

export type PackagesListPackagesForUserRequestPath = {
  readonly username: string;
};

export type PackagesGetPackageForUser200ResponseBody = Package;

export type PackagesGetPackageForUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly username: string;
};

export type PackagesDeletePackageForUser401ResponseBody = BasicError;

export type PackagesDeletePackageForUser403ResponseBody = BasicError;

export type PackagesDeletePackageForUser404ResponseBody = BasicError;

export type PackagesDeletePackageForUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly username: string;
};

export type PackagesRestorePackageForUser401ResponseBody = BasicError;

export type PackagesRestorePackageForUser403ResponseBody = BasicError;

export type PackagesRestorePackageForUser404ResponseBody = BasicError;

export type PackagesRestorePackageForUserRequestQuery = {
  readonly token?: string;
};

export type PackagesRestorePackageForUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly username: string;
};

export type PackagesGetAllPackageVersionsForPackageOwnedByUser200ResponseBody = ReadonlyArray<PackageVersion>;

export type PackagesGetAllPackageVersionsForPackageOwnedByUser401ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByUser403ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByUser404ResponseBody = BasicError;

export type PackagesGetAllPackageVersionsForPackageOwnedByUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly username: string;
};

export type PackagesGetPackageVersionForUser200ResponseBody = PackageVersion;

export type PackagesGetPackageVersionForUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly package_version_id: number;
  readonly username: string;
};

export type PackagesDeletePackageVersionForUser401ResponseBody = BasicError;

export type PackagesDeletePackageVersionForUser403ResponseBody = BasicError;

export type PackagesDeletePackageVersionForUser404ResponseBody = BasicError;

export type PackagesDeletePackageVersionForUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly username: string;
  readonly package_version_id: number;
};

export type PackagesRestorePackageVersionForUser401ResponseBody = BasicError;

export type PackagesRestorePackageVersionForUser403ResponseBody = BasicError;

export type PackagesRestorePackageVersionForUser404ResponseBody = BasicError;

export type PackagesRestorePackageVersionForUserRequestPath = {
  readonly package_type:
    | 'npm'
    | 'maven'
    | 'rubygems'
    | 'docker'
    | 'nuget'
    | 'container';
  readonly package_name: string;
  readonly username: string;
  readonly package_version_id: number;
};

export type ProjectsListForUser200ResponseBody = ReadonlyArray<Project>;

export type ProjectsListForUser422ResponseBody = ValidationError;

export type ProjectsListForUserRequestQuery = {
  readonly state?: 'open' | 'closed' | 'all';
  readonly per_page?: number;
  readonly page?: number;
};

export type ProjectsListForUserRequestPath = { readonly username: string };

export type ActivityListReceivedEventsForUser200ResponseBody = ReadonlyArray<Event>;

export type ActivityListReceivedEventsForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListReceivedEventsForUserRequestPath = {
  readonly username: string;
};

export type ActivityListReceivedPublicEventsForUser200ResponseBody = ReadonlyArray<Event>;

export type ActivityListReceivedPublicEventsForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListReceivedPublicEventsForUserRequestPath = {
  readonly username: string;
};

export type ReposListForUser200ResponseBody = ReadonlyArray<MinimalRepository>;

export type ReposListForUserRequestQuery = {
  readonly type?: 'all' | 'owner' | 'member';
  readonly sort?: 'created' | 'updated' | 'pushed' | 'full_name';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type ReposListForUserRequestPath = { readonly username: string };

export type BillingGetGithubActionsBillingUser200ResponseBody = ActionsBillingUsage;

export type BillingGetGithubActionsBillingUserRequestPath = {
  readonly username: string;
};

export type BillingGetGithubPackagesBillingUser200ResponseBody = PackagesBillingUsage;

export type BillingGetGithubPackagesBillingUserRequestPath = {
  readonly username: string;
};

export type BillingGetSharedStorageBillingUser200ResponseBody = CombinedBillingUsage;

export type BillingGetSharedStorageBillingUserRequestPath = {
  readonly username: string;
};

export type UsersListSshSigningKeysForUser200ResponseBody = ReadonlyArray<SshSigningKey>;

export type UsersListSshSigningKeysForUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type UsersListSshSigningKeysForUserRequestPath = {
  readonly username: string;
};

export type StarredRepository = {
  readonly starred_at: string;
  readonly repo: Repository;
};

export type ActivityListReposStarredByUser200ResponseBody =
  | ReadonlyArray<StarredRepository>
  | ReadonlyArray<Repository>;

export type ActivityListReposStarredByUserRequestQuery = {
  readonly sort?: 'created' | 'updated';
  readonly direction?: 'asc' | 'desc';
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListReposStarredByUserRequestPath = {
  readonly username: string;
};

export type ActivityListReposWatchedByUser200ResponseBody = ReadonlyArray<MinimalRepository>;

export type ActivityListReposWatchedByUserRequestQuery = {
  readonly per_page?: number;
  readonly page?: number;
};

export type ActivityListReposWatchedByUserRequestPath = {
  readonly username: string;
};

export const Handlers = {
  MetaRootHandler: 'MetaRootHandler',
  AppsGetAuthenticatedHandler: 'AppsGetAuthenticatedHandler',
  AppsCreateFromManifestHandler: 'AppsCreateFromManifestHandler',
  AppsGetWebhookConfigForAppHandler: 'AppsGetWebhookConfigForAppHandler',
  AppsUpdateWebhookConfigForAppHandler: 'AppsUpdateWebhookConfigForAppHandler',
  AppsListWebhookDeliveriesHandler: 'AppsListWebhookDeliveriesHandler',
  AppsGetWebhookDeliveryHandler: 'AppsGetWebhookDeliveryHandler',
  AppsRedeliverWebhookDeliveryHandler: 'AppsRedeliverWebhookDeliveryHandler',
  AppsListInstallationsHandler: 'AppsListInstallationsHandler',
  AppsGetInstallationHandler: 'AppsGetInstallationHandler',
  AppsDeleteInstallationHandler: 'AppsDeleteInstallationHandler',
  AppsCreateInstallationAccessTokenHandler:
    'AppsCreateInstallationAccessTokenHandler',
  AppsSuspendInstallationHandler: 'AppsSuspendInstallationHandler',
  AppsUnsuspendInstallationHandler: 'AppsUnsuspendInstallationHandler',
  AppsDeleteAuthorizationHandler: 'AppsDeleteAuthorizationHandler',
  AppsCheckTokenHandler: 'AppsCheckTokenHandler',
  AppsResetTokenHandler: 'AppsResetTokenHandler',
  AppsDeleteTokenHandler: 'AppsDeleteTokenHandler',
  AppsScopeTokenHandler: 'AppsScopeTokenHandler',
  AppsGetBySlugHandler: 'AppsGetBySlugHandler',
  CodesOfConductGetAllCodesOfConductHandler:
    'CodesOfConductGetAllCodesOfConductHandler',
  CodesOfConductGetConductCodeHandler: 'CodesOfConductGetConductCodeHandler',
  EmojisGetHandler: 'EmojisGetHandler',
  EnterpriseAdminGetServerStatisticsHandler:
    'EnterpriseAdminGetServerStatisticsHandler',
  ActionsGetActionsCacheUsageForEnterpriseHandler:
    'ActionsGetActionsCacheUsageForEnterpriseHandler',
  EnterpriseAdminGetGithubActionsPermissionsEnterpriseHandler:
    'EnterpriseAdminGetGithubActionsPermissionsEnterpriseHandler',
  EnterpriseAdminSetGithubActionsPermissionsEnterpriseHandler:
    'EnterpriseAdminSetGithubActionsPermissionsEnterpriseHandler',
  EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseHandler:
    'EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseHandler',
  EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseHandler:
    'EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseHandler',
  EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseHandler:
    'EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseHandler',
  EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseHandler:
    'EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseHandler',
  EnterpriseAdminGetAllowedActionsEnterpriseHandler:
    'EnterpriseAdminGetAllowedActionsEnterpriseHandler',
  EnterpriseAdminSetAllowedActionsEnterpriseHandler:
    'EnterpriseAdminSetAllowedActionsEnterpriseHandler',
  ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler:
    'ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler',
  ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler:
    'ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler',
  EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseHandler:
    'EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseHandler',
  EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseHandler:
    'EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseHandler',
  EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseHandler:
    'EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseHandler',
  EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseHandler:
    'EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseHandler',
  EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseHandler:
    'EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseHandler',
  EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler:
    'EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler',
  EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler:
    'EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler',
  EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler:
    'EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler',
  EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler:
    'EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler',
  EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseHandler:
    'EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseHandler',
  EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseHandler:
    'EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseHandler',
  EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseHandler:
    'EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseHandler',
  EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseHandler:
    'EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseHandler',
  EnterpriseAdminListSelfHostedRunnersForEnterpriseHandler:
    'EnterpriseAdminListSelfHostedRunnersForEnterpriseHandler',
  EnterpriseAdminListRunnerApplicationsForEnterpriseHandler:
    'EnterpriseAdminListRunnerApplicationsForEnterpriseHandler',
  EnterpriseAdminCreateRegistrationTokenForEnterpriseHandler:
    'EnterpriseAdminCreateRegistrationTokenForEnterpriseHandler',
  EnterpriseAdminCreateRemoveTokenForEnterpriseHandler:
    'EnterpriseAdminCreateRemoveTokenForEnterpriseHandler',
  EnterpriseAdminGetSelfHostedRunnerForEnterpriseHandler:
    'EnterpriseAdminGetSelfHostedRunnerForEnterpriseHandler',
  EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseHandler:
    'EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseHandler',
  EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseHandler:
    'EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseHandler',
  EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseHandler:
    'EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseHandler',
  EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseHandler:
    'EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseHandler',
  EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseHandler:
    'EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseHandler',
  EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseHandler:
    'EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseHandler',
  CodeScanningListAlertsForEnterpriseHandler:
    'CodeScanningListAlertsForEnterpriseHandler',
  SecretScanningListAlertsForEnterpriseHandler:
    'SecretScanningListAlertsForEnterpriseHandler',
  BillingGetGithubAdvancedSecurityBillingGheHandler:
    'BillingGetGithubAdvancedSecurityBillingGheHandler',
  ActivityListPublicEventsHandler: 'ActivityListPublicEventsHandler',
  ActivityGetFeedsHandler: 'ActivityGetFeedsHandler',
  GistsListHandler: 'GistsListHandler',
  GistsCreateHandler: 'GistsCreateHandler',
  GistsListPublicHandler: 'GistsListPublicHandler',
  GistsListStarredHandler: 'GistsListStarredHandler',
  GistsGetHandler: 'GistsGetHandler',
  GistsUpdateHandler: 'GistsUpdateHandler',
  GistsDeleteHandler: 'GistsDeleteHandler',
  GistsListCommentsHandler: 'GistsListCommentsHandler',
  GistsCreateCommentHandler: 'GistsCreateCommentHandler',
  GistsGetCommentHandler: 'GistsGetCommentHandler',
  GistsUpdateCommentHandler: 'GistsUpdateCommentHandler',
  GistsDeleteCommentHandler: 'GistsDeleteCommentHandler',
  GistsListCommitsHandler: 'GistsListCommitsHandler',
  GistsListForksHandler: 'GistsListForksHandler',
  GistsForkHandler: 'GistsForkHandler',
  GistsCheckIsStarredHandler: 'GistsCheckIsStarredHandler',
  GistsStarHandler: 'GistsStarHandler',
  GistsUnstarHandler: 'GistsUnstarHandler',
  GistsGetRevisionHandler: 'GistsGetRevisionHandler',
  GitignoreGetAllTemplatesHandler: 'GitignoreGetAllTemplatesHandler',
  GitignoreGetTemplateHandler: 'GitignoreGetTemplateHandler',
  AppsListReposAccessibleToInstallationHandler:
    'AppsListReposAccessibleToInstallationHandler',
  AppsRevokeInstallationAccessTokenHandler:
    'AppsRevokeInstallationAccessTokenHandler',
  IssuesListHandler: 'IssuesListHandler',
  LicensesGetAllCommonlyUsedHandler: 'LicensesGetAllCommonlyUsedHandler',
  LicensesGetHandler: 'LicensesGetHandler',
  MarkdownRenderHandler: 'MarkdownRenderHandler',
  MarkdownRenderRawHandler: 'MarkdownRenderRawHandler',
  AppsGetSubscriptionPlanForAccountHandler:
    'AppsGetSubscriptionPlanForAccountHandler',
  AppsListPlansHandler: 'AppsListPlansHandler',
  AppsListAccountsForPlanHandler: 'AppsListAccountsForPlanHandler',
  AppsGetSubscriptionPlanForAccountStubbedHandler:
    'AppsGetSubscriptionPlanForAccountStubbedHandler',
  AppsListPlansStubbedHandler: 'AppsListPlansStubbedHandler',
  AppsListAccountsForPlanStubbedHandler:
    'AppsListAccountsForPlanStubbedHandler',
  MetaGetHandler: 'MetaGetHandler',
  ActivityListPublicEventsForRepoNetworkHandler:
    'ActivityListPublicEventsForRepoNetworkHandler',
  ActivityListNotificationsForAuthenticatedUserHandler:
    'ActivityListNotificationsForAuthenticatedUserHandler',
  ActivityMarkNotificationsAsReadHandler:
    'ActivityMarkNotificationsAsReadHandler',
  ActivityGetThreadHandler: 'ActivityGetThreadHandler',
  ActivityMarkThreadAsReadHandler: 'ActivityMarkThreadAsReadHandler',
  ActivityGetThreadSubscriptionForAuthenticatedUserHandler:
    'ActivityGetThreadSubscriptionForAuthenticatedUserHandler',
  ActivitySetThreadSubscriptionHandler: 'ActivitySetThreadSubscriptionHandler',
  ActivityDeleteThreadSubscriptionHandler:
    'ActivityDeleteThreadSubscriptionHandler',
  MetaGetOctocatHandler: 'MetaGetOctocatHandler',
  OrgsListHandler: 'OrgsListHandler',
  OrgsListCustomRolesHandler: 'OrgsListCustomRolesHandler',
  OrgsGetHandler: 'OrgsGetHandler',
  OrgsUpdateHandler: 'OrgsUpdateHandler',
  ActionsGetActionsCacheUsageForOrgHandler:
    'ActionsGetActionsCacheUsageForOrgHandler',
  ActionsGetActionsCacheUsageByRepoForOrgHandler:
    'ActionsGetActionsCacheUsageByRepoForOrgHandler',
  ActionsGetGithubActionsPermissionsOrganizationHandler:
    'ActionsGetGithubActionsPermissionsOrganizationHandler',
  ActionsSetGithubActionsPermissionsOrganizationHandler:
    'ActionsSetGithubActionsPermissionsOrganizationHandler',
  ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationHandler:
    'ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationHandler',
  ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationHandler:
    'ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationHandler',
  ActionsEnableSelectedRepositoryGithubActionsOrganizationHandler:
    'ActionsEnableSelectedRepositoryGithubActionsOrganizationHandler',
  ActionsDisableSelectedRepositoryGithubActionsOrganizationHandler:
    'ActionsDisableSelectedRepositoryGithubActionsOrganizationHandler',
  ActionsGetAllowedActionsOrganizationHandler:
    'ActionsGetAllowedActionsOrganizationHandler',
  ActionsSetAllowedActionsOrganizationHandler:
    'ActionsSetAllowedActionsOrganizationHandler',
  ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationHandler:
    'ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationHandler',
  ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationHandler:
    'ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationHandler',
  ActionsListSelfHostedRunnerGroupsForOrgHandler:
    'ActionsListSelfHostedRunnerGroupsForOrgHandler',
  ActionsCreateSelfHostedRunnerGroupForOrgHandler:
    'ActionsCreateSelfHostedRunnerGroupForOrgHandler',
  ActionsGetSelfHostedRunnerGroupForOrgHandler:
    'ActionsGetSelfHostedRunnerGroupForOrgHandler',
  ActionsUpdateSelfHostedRunnerGroupForOrgHandler:
    'ActionsUpdateSelfHostedRunnerGroupForOrgHandler',
  ActionsDeleteSelfHostedRunnerGroupFromOrgHandler:
    'ActionsDeleteSelfHostedRunnerGroupFromOrgHandler',
  ActionsListRepoAccessToSelfHostedRunnerGroupInOrgHandler:
    'ActionsListRepoAccessToSelfHostedRunnerGroupInOrgHandler',
  ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgHandler:
    'ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgHandler',
  ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgHandler:
    'ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgHandler',
  ActionsListSelfHostedRunnersInGroupForOrgHandler:
    'ActionsListSelfHostedRunnersInGroupForOrgHandler',
  ActionsSetSelfHostedRunnersInGroupForOrgHandler:
    'ActionsSetSelfHostedRunnersInGroupForOrgHandler',
  ActionsAddSelfHostedRunnerToGroupForOrgHandler:
    'ActionsAddSelfHostedRunnerToGroupForOrgHandler',
  ActionsRemoveSelfHostedRunnerFromGroupForOrgHandler:
    'ActionsRemoveSelfHostedRunnerFromGroupForOrgHandler',
  ActionsListSelfHostedRunnersForOrgHandler:
    'ActionsListSelfHostedRunnersForOrgHandler',
  ActionsListRunnerApplicationsForOrgHandler:
    'ActionsListRunnerApplicationsForOrgHandler',
  ActionsCreateRegistrationTokenForOrgHandler:
    'ActionsCreateRegistrationTokenForOrgHandler',
  ActionsCreateRemoveTokenForOrgHandler:
    'ActionsCreateRemoveTokenForOrgHandler',
  ActionsGetSelfHostedRunnerForOrgHandler:
    'ActionsGetSelfHostedRunnerForOrgHandler',
  ActionsDeleteSelfHostedRunnerFromOrgHandler:
    'ActionsDeleteSelfHostedRunnerFromOrgHandler',
  ActionsListLabelsForSelfHostedRunnerForOrgHandler:
    'ActionsListLabelsForSelfHostedRunnerForOrgHandler',
  ActionsAddCustomLabelsToSelfHostedRunnerForOrgHandler:
    'ActionsAddCustomLabelsToSelfHostedRunnerForOrgHandler',
  ActionsSetCustomLabelsForSelfHostedRunnerForOrgHandler:
    'ActionsSetCustomLabelsForSelfHostedRunnerForOrgHandler',
  ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgHandler:
    'ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgHandler',
  ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgHandler:
    'ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgHandler',
  ActionsListOrgSecretsHandler: 'ActionsListOrgSecretsHandler',
  ActionsGetOrgPublicKeyHandler: 'ActionsGetOrgPublicKeyHandler',
  ActionsGetOrgSecretHandler: 'ActionsGetOrgSecretHandler',
  ActionsCreateOrUpdateOrgSecretHandler:
    'ActionsCreateOrUpdateOrgSecretHandler',
  ActionsDeleteOrgSecretHandler: 'ActionsDeleteOrgSecretHandler',
  ActionsListSelectedReposForOrgSecretHandler:
    'ActionsListSelectedReposForOrgSecretHandler',
  ActionsSetSelectedReposForOrgSecretHandler:
    'ActionsSetSelectedReposForOrgSecretHandler',
  ActionsAddSelectedRepoToOrgSecretHandler:
    'ActionsAddSelectedRepoToOrgSecretHandler',
  ActionsRemoveSelectedRepoFromOrgSecretHandler:
    'ActionsRemoveSelectedRepoFromOrgSecretHandler',
  OrgsListBlockedUsersHandler: 'OrgsListBlockedUsersHandler',
  OrgsCheckBlockedUserHandler: 'OrgsCheckBlockedUserHandler',
  OrgsBlockUserHandler: 'OrgsBlockUserHandler',
  OrgsUnblockUserHandler: 'OrgsUnblockUserHandler',
  CodeScanningListAlertsForOrgHandler: 'CodeScanningListAlertsForOrgHandler',
  CodespacesListInOrganizationHandler: 'CodespacesListInOrganizationHandler',
  CodespacesSetCodespacesBillingHandler:
    'CodespacesSetCodespacesBillingHandler',
  CodespacesListOrgSecretsHandler: 'CodespacesListOrgSecretsHandler',
  CodespacesGetOrgPublicKeyHandler: 'CodespacesGetOrgPublicKeyHandler',
  CodespacesGetOrgSecretHandler: 'CodespacesGetOrgSecretHandler',
  CodespacesCreateOrUpdateOrgSecretHandler:
    'CodespacesCreateOrUpdateOrgSecretHandler',
  CodespacesDeleteOrgSecretHandler: 'CodespacesDeleteOrgSecretHandler',
  CodespacesListSelectedReposForOrgSecretHandler:
    'CodespacesListSelectedReposForOrgSecretHandler',
  CodespacesSetSelectedReposForOrgSecretHandler:
    'CodespacesSetSelectedReposForOrgSecretHandler',
  CodespacesAddSelectedRepoToOrgSecretHandler:
    'CodespacesAddSelectedRepoToOrgSecretHandler',
  CodespacesRemoveSelectedRepoFromOrgSecretHandler:
    'CodespacesRemoveSelectedRepoFromOrgSecretHandler',
  OrgsCreateCustomRoleHandler: 'OrgsCreateCustomRoleHandler',
  OrgsGetCustomRoleHandler: 'OrgsGetCustomRoleHandler',
  OrgsUpdateCustomRoleHandler: 'OrgsUpdateCustomRoleHandler',
  OrgsDeleteCustomRoleHandler: 'OrgsDeleteCustomRoleHandler',
  DependabotListAlertsForOrgHandler: 'DependabotListAlertsForOrgHandler',
  DependabotListOrgSecretsHandler: 'DependabotListOrgSecretsHandler',
  DependabotGetOrgPublicKeyHandler: 'DependabotGetOrgPublicKeyHandler',
  DependabotGetOrgSecretHandler: 'DependabotGetOrgSecretHandler',
  DependabotCreateOrUpdateOrgSecretHandler:
    'DependabotCreateOrUpdateOrgSecretHandler',
  DependabotDeleteOrgSecretHandler: 'DependabotDeleteOrgSecretHandler',
  DependabotListSelectedReposForOrgSecretHandler:
    'DependabotListSelectedReposForOrgSecretHandler',
  DependabotSetSelectedReposForOrgSecretHandler:
    'DependabotSetSelectedReposForOrgSecretHandler',
  DependabotAddSelectedRepoToOrgSecretHandler:
    'DependabotAddSelectedRepoToOrgSecretHandler',
  DependabotRemoveSelectedRepoFromOrgSecretHandler:
    'DependabotRemoveSelectedRepoFromOrgSecretHandler',
  ActivityListPublicOrgEventsHandler: 'ActivityListPublicOrgEventsHandler',
  OrgsListFailedInvitationsHandler: 'OrgsListFailedInvitationsHandler',
  OrgsListFineGrainedPermissionsHandler:
    'OrgsListFineGrainedPermissionsHandler',
  OrgsListWebhooksHandler: 'OrgsListWebhooksHandler',
  OrgsCreateWebhookHandler: 'OrgsCreateWebhookHandler',
  OrgsGetWebhookHandler: 'OrgsGetWebhookHandler',
  OrgsUpdateWebhookHandler: 'OrgsUpdateWebhookHandler',
  OrgsDeleteWebhookHandler: 'OrgsDeleteWebhookHandler',
  OrgsGetWebhookConfigForOrgHandler: 'OrgsGetWebhookConfigForOrgHandler',
  OrgsUpdateWebhookConfigForOrgHandler: 'OrgsUpdateWebhookConfigForOrgHandler',
  OrgsListWebhookDeliveriesHandler: 'OrgsListWebhookDeliveriesHandler',
  OrgsGetWebhookDeliveryHandler: 'OrgsGetWebhookDeliveryHandler',
  OrgsRedeliverWebhookDeliveryHandler: 'OrgsRedeliverWebhookDeliveryHandler',
  OrgsPingWebhookHandler: 'OrgsPingWebhookHandler',
  AppsGetOrgInstallationHandler: 'AppsGetOrgInstallationHandler',
  OrgsListAppInstallationsHandler: 'OrgsListAppInstallationsHandler',
  InteractionsGetRestrictionsForOrgHandler:
    'InteractionsGetRestrictionsForOrgHandler',
  InteractionsSetRestrictionsForOrgHandler:
    'InteractionsSetRestrictionsForOrgHandler',
  InteractionsRemoveRestrictionsForOrgHandler:
    'InteractionsRemoveRestrictionsForOrgHandler',
  OrgsListPendingInvitationsHandler: 'OrgsListPendingInvitationsHandler',
  OrgsCreateInvitationHandler: 'OrgsCreateInvitationHandler',
  OrgsCancelInvitationHandler: 'OrgsCancelInvitationHandler',
  OrgsListInvitationTeamsHandler: 'OrgsListInvitationTeamsHandler',
  IssuesListForOrgHandler: 'IssuesListForOrgHandler',
  OrgsListMembersHandler: 'OrgsListMembersHandler',
  OrgsCheckMembershipForUserHandler: 'OrgsCheckMembershipForUserHandler',
  OrgsRemoveMemberHandler: 'OrgsRemoveMemberHandler',
  CodespacesGetCodespacesForUserInOrgHandler:
    'CodespacesGetCodespacesForUserInOrgHandler',
  CodespacesDeleteFromOrganizationHandler:
    'CodespacesDeleteFromOrganizationHandler',
  CodespacesStopInOrganizationHandler: 'CodespacesStopInOrganizationHandler',
  OrgsGetMembershipForUserHandler: 'OrgsGetMembershipForUserHandler',
  OrgsSetMembershipForUserHandler: 'OrgsSetMembershipForUserHandler',
  OrgsRemoveMembershipForUserHandler: 'OrgsRemoveMembershipForUserHandler',
  MigrationsListForOrgHandler: 'MigrationsListForOrgHandler',
  MigrationsStartForOrgHandler: 'MigrationsStartForOrgHandler',
  MigrationsGetStatusForOrgHandler: 'MigrationsGetStatusForOrgHandler',
  MigrationsDownloadArchiveForOrgHandler:
    'MigrationsDownloadArchiveForOrgHandler',
  MigrationsDeleteArchiveForOrgHandler: 'MigrationsDeleteArchiveForOrgHandler',
  MigrationsUnlockRepoForOrgHandler: 'MigrationsUnlockRepoForOrgHandler',
  MigrationsListReposForOrgHandler: 'MigrationsListReposForOrgHandler',
  OrgsListOutsideCollaboratorsHandler: 'OrgsListOutsideCollaboratorsHandler',
  OrgsConvertMemberToOutsideCollaboratorHandler:
    'OrgsConvertMemberToOutsideCollaboratorHandler',
  OrgsRemoveOutsideCollaboratorHandler: 'OrgsRemoveOutsideCollaboratorHandler',
  PackagesListPackagesForOrganizationHandler:
    'PackagesListPackagesForOrganizationHandler',
  PackagesGetPackageForOrganizationHandler:
    'PackagesGetPackageForOrganizationHandler',
  PackagesDeletePackageForOrgHandler: 'PackagesDeletePackageForOrgHandler',
  PackagesRestorePackageForOrgHandler: 'PackagesRestorePackageForOrgHandler',
  PackagesGetAllPackageVersionsForPackageOwnedByOrgHandler:
    'PackagesGetAllPackageVersionsForPackageOwnedByOrgHandler',
  PackagesGetPackageVersionForOrganizationHandler:
    'PackagesGetPackageVersionForOrganizationHandler',
  PackagesDeletePackageVersionForOrgHandler:
    'PackagesDeletePackageVersionForOrgHandler',
  PackagesRestorePackageVersionForOrgHandler:
    'PackagesRestorePackageVersionForOrgHandler',
  ProjectsListForOrgHandler: 'ProjectsListForOrgHandler',
  ProjectsCreateForOrgHandler: 'ProjectsCreateForOrgHandler',
  OrgsListPublicMembersHandler: 'OrgsListPublicMembersHandler',
  OrgsCheckPublicMembershipForUserHandler:
    'OrgsCheckPublicMembershipForUserHandler',
  OrgsSetPublicMembershipForAuthenticatedUserHandler:
    'OrgsSetPublicMembershipForAuthenticatedUserHandler',
  OrgsRemovePublicMembershipForAuthenticatedUserHandler:
    'OrgsRemovePublicMembershipForAuthenticatedUserHandler',
  ReposListForOrgHandler: 'ReposListForOrgHandler',
  ReposCreateInOrgHandler: 'ReposCreateInOrgHandler',
  SecretScanningListAlertsForOrgHandler:
    'SecretScanningListAlertsForOrgHandler',
  OrgsListSecurityManagerTeamsHandler: 'OrgsListSecurityManagerTeamsHandler',
  OrgsAddSecurityManagerTeamHandler: 'OrgsAddSecurityManagerTeamHandler',
  OrgsRemoveSecurityManagerTeamHandler: 'OrgsRemoveSecurityManagerTeamHandler',
  BillingGetGithubActionsBillingOrgHandler:
    'BillingGetGithubActionsBillingOrgHandler',
  BillingGetGithubAdvancedSecurityBillingOrgHandler:
    'BillingGetGithubAdvancedSecurityBillingOrgHandler',
  BillingGetGithubPackagesBillingOrgHandler:
    'BillingGetGithubPackagesBillingOrgHandler',
  BillingGetSharedStorageBillingOrgHandler:
    'BillingGetSharedStorageBillingOrgHandler',
  TeamsListHandler: 'TeamsListHandler',
  TeamsCreateHandler: 'TeamsCreateHandler',
  TeamsGetByNameHandler: 'TeamsGetByNameHandler',
  TeamsUpdateInOrgHandler: 'TeamsUpdateInOrgHandler',
  TeamsDeleteInOrgHandler: 'TeamsDeleteInOrgHandler',
  TeamsListDiscussionsInOrgHandler: 'TeamsListDiscussionsInOrgHandler',
  TeamsCreateDiscussionInOrgHandler: 'TeamsCreateDiscussionInOrgHandler',
  TeamsGetDiscussionInOrgHandler: 'TeamsGetDiscussionInOrgHandler',
  TeamsUpdateDiscussionInOrgHandler: 'TeamsUpdateDiscussionInOrgHandler',
  TeamsDeleteDiscussionInOrgHandler: 'TeamsDeleteDiscussionInOrgHandler',
  TeamsListDiscussionCommentsInOrgHandler:
    'TeamsListDiscussionCommentsInOrgHandler',
  TeamsCreateDiscussionCommentInOrgHandler:
    'TeamsCreateDiscussionCommentInOrgHandler',
  TeamsGetDiscussionCommentInOrgHandler:
    'TeamsGetDiscussionCommentInOrgHandler',
  TeamsUpdateDiscussionCommentInOrgHandler:
    'TeamsUpdateDiscussionCommentInOrgHandler',
  TeamsDeleteDiscussionCommentInOrgHandler:
    'TeamsDeleteDiscussionCommentInOrgHandler',
  ReactionsListForTeamDiscussionCommentInOrgHandler:
    'ReactionsListForTeamDiscussionCommentInOrgHandler',
  ReactionsCreateForTeamDiscussionCommentInOrgHandler:
    'ReactionsCreateForTeamDiscussionCommentInOrgHandler',
  ReactionsDeleteForTeamDiscussionCommentHandler:
    'ReactionsDeleteForTeamDiscussionCommentHandler',
  ReactionsListForTeamDiscussionInOrgHandler:
    'ReactionsListForTeamDiscussionInOrgHandler',
  ReactionsCreateForTeamDiscussionInOrgHandler:
    'ReactionsCreateForTeamDiscussionInOrgHandler',
  ReactionsDeleteForTeamDiscussionHandler:
    'ReactionsDeleteForTeamDiscussionHandler',
  TeamsListPendingInvitationsInOrgHandler:
    'TeamsListPendingInvitationsInOrgHandler',
  TeamsListMembersInOrgHandler: 'TeamsListMembersInOrgHandler',
  TeamsGetMembershipForUserInOrgHandler:
    'TeamsGetMembershipForUserInOrgHandler',
  TeamsAddOrUpdateMembershipForUserInOrgHandler:
    'TeamsAddOrUpdateMembershipForUserInOrgHandler',
  TeamsRemoveMembershipForUserInOrgHandler:
    'TeamsRemoveMembershipForUserInOrgHandler',
  TeamsListProjectsInOrgHandler: 'TeamsListProjectsInOrgHandler',
  TeamsCheckPermissionsForProjectInOrgHandler:
    'TeamsCheckPermissionsForProjectInOrgHandler',
  TeamsAddOrUpdateProjectPermissionsInOrgHandler:
    'TeamsAddOrUpdateProjectPermissionsInOrgHandler',
  TeamsRemoveProjectInOrgHandler: 'TeamsRemoveProjectInOrgHandler',
  TeamsListReposInOrgHandler: 'TeamsListReposInOrgHandler',
  TeamsCheckPermissionsForRepoInOrgHandler:
    'TeamsCheckPermissionsForRepoInOrgHandler',
  TeamsAddOrUpdateRepoPermissionsInOrgHandler:
    'TeamsAddOrUpdateRepoPermissionsInOrgHandler',
  TeamsRemoveRepoInOrgHandler: 'TeamsRemoveRepoInOrgHandler',
  TeamsListChildInOrgHandler: 'TeamsListChildInOrgHandler',
  OrgsEnableOrDisableSecurityProductOnAllOrgReposHandler:
    'OrgsEnableOrDisableSecurityProductOnAllOrgReposHandler',
  ProjectsGetCardHandler: 'ProjectsGetCardHandler',
  ProjectsUpdateCardHandler: 'ProjectsUpdateCardHandler',
  ProjectsDeleteCardHandler: 'ProjectsDeleteCardHandler',
  ProjectsMoveCardHandler: 'ProjectsMoveCardHandler',
  ProjectsGetColumnHandler: 'ProjectsGetColumnHandler',
  ProjectsUpdateColumnHandler: 'ProjectsUpdateColumnHandler',
  ProjectsDeleteColumnHandler: 'ProjectsDeleteColumnHandler',
  ProjectsListCardsHandler: 'ProjectsListCardsHandler',
  ProjectsCreateCardHandler: 'ProjectsCreateCardHandler',
  ProjectsMoveColumnHandler: 'ProjectsMoveColumnHandler',
  ProjectsGetHandler: 'ProjectsGetHandler',
  ProjectsUpdateHandler: 'ProjectsUpdateHandler',
  ProjectsDeleteHandler: 'ProjectsDeleteHandler',
  ProjectsListCollaboratorsHandler: 'ProjectsListCollaboratorsHandler',
  ProjectsAddCollaboratorHandler: 'ProjectsAddCollaboratorHandler',
  ProjectsRemoveCollaboratorHandler: 'ProjectsRemoveCollaboratorHandler',
  ProjectsGetPermissionForUserHandler: 'ProjectsGetPermissionForUserHandler',
  ProjectsListColumnsHandler: 'ProjectsListColumnsHandler',
  ProjectsCreateColumnHandler: 'ProjectsCreateColumnHandler',
  RateLimitGetHandler: 'RateLimitGetHandler',
  ReposGetHandler: 'ReposGetHandler',
  ReposUpdateHandler: 'ReposUpdateHandler',
  ReposDeleteHandler: 'ReposDeleteHandler',
  ActionsListArtifactsForRepoHandler: 'ActionsListArtifactsForRepoHandler',
  ActionsGetArtifactHandler: 'ActionsGetArtifactHandler',
  ActionsDeleteArtifactHandler: 'ActionsDeleteArtifactHandler',
  ActionsDownloadArtifactHandler: 'ActionsDownloadArtifactHandler',
  ActionsGetActionsCacheUsageHandler: 'ActionsGetActionsCacheUsageHandler',
  ActionsGetActionsCacheListHandler: 'ActionsGetActionsCacheListHandler',
  ActionsDeleteActionsCacheByKeyHandler:
    'ActionsDeleteActionsCacheByKeyHandler',
  ActionsDeleteActionsCacheByIdHandler: 'ActionsDeleteActionsCacheByIdHandler',
  ActionsGetJobForWorkflowRunHandler: 'ActionsGetJobForWorkflowRunHandler',
  ActionsDownloadJobLogsForWorkflowRunHandler:
    'ActionsDownloadJobLogsForWorkflowRunHandler',
  ActionsReRunJobForWorkflowRunHandler: 'ActionsReRunJobForWorkflowRunHandler',
  ActionsGetGithubActionsPermissionsRepositoryHandler:
    'ActionsGetGithubActionsPermissionsRepositoryHandler',
  ActionsSetGithubActionsPermissionsRepositoryHandler:
    'ActionsSetGithubActionsPermissionsRepositoryHandler',
  ActionsGetWorkflowAccessToRepositoryHandler:
    'ActionsGetWorkflowAccessToRepositoryHandler',
  ActionsSetWorkflowAccessToRepositoryHandler:
    'ActionsSetWorkflowAccessToRepositoryHandler',
  ActionsGetAllowedActionsRepositoryHandler:
    'ActionsGetAllowedActionsRepositoryHandler',
  ActionsSetAllowedActionsRepositoryHandler:
    'ActionsSetAllowedActionsRepositoryHandler',
  ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryHandler:
    'ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryHandler',
  ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryHandler:
    'ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryHandler',
  ActionsListSelfHostedRunnersForRepoHandler:
    'ActionsListSelfHostedRunnersForRepoHandler',
  ActionsListRunnerApplicationsForRepoHandler:
    'ActionsListRunnerApplicationsForRepoHandler',
  ActionsCreateRegistrationTokenForRepoHandler:
    'ActionsCreateRegistrationTokenForRepoHandler',
  ActionsCreateRemoveTokenForRepoHandler:
    'ActionsCreateRemoveTokenForRepoHandler',
  ActionsGetSelfHostedRunnerForRepoHandler:
    'ActionsGetSelfHostedRunnerForRepoHandler',
  ActionsDeleteSelfHostedRunnerFromRepoHandler:
    'ActionsDeleteSelfHostedRunnerFromRepoHandler',
  ActionsListLabelsForSelfHostedRunnerForRepoHandler:
    'ActionsListLabelsForSelfHostedRunnerForRepoHandler',
  ActionsAddCustomLabelsToSelfHostedRunnerForRepoHandler:
    'ActionsAddCustomLabelsToSelfHostedRunnerForRepoHandler',
  ActionsSetCustomLabelsForSelfHostedRunnerForRepoHandler:
    'ActionsSetCustomLabelsForSelfHostedRunnerForRepoHandler',
  ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoHandler:
    'ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoHandler',
  ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoHandler:
    'ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoHandler',
  ActionsListWorkflowRunsForRepoHandler:
    'ActionsListWorkflowRunsForRepoHandler',
  ActionsGetWorkflowRunHandler: 'ActionsGetWorkflowRunHandler',
  ActionsDeleteWorkflowRunHandler: 'ActionsDeleteWorkflowRunHandler',
  ActionsGetReviewsForRunHandler: 'ActionsGetReviewsForRunHandler',
  ActionsApproveWorkflowRunHandler: 'ActionsApproveWorkflowRunHandler',
  ActionsListWorkflowRunArtifactsHandler:
    'ActionsListWorkflowRunArtifactsHandler',
  ActionsGetWorkflowRunAttemptHandler: 'ActionsGetWorkflowRunAttemptHandler',
  ActionsListJobsForWorkflowRunAttemptHandler:
    'ActionsListJobsForWorkflowRunAttemptHandler',
  ActionsDownloadWorkflowRunAttemptLogsHandler:
    'ActionsDownloadWorkflowRunAttemptLogsHandler',
  ActionsCancelWorkflowRunHandler: 'ActionsCancelWorkflowRunHandler',
  ActionsListJobsForWorkflowRunHandler: 'ActionsListJobsForWorkflowRunHandler',
  ActionsDownloadWorkflowRunLogsHandler:
    'ActionsDownloadWorkflowRunLogsHandler',
  ActionsDeleteWorkflowRunLogsHandler: 'ActionsDeleteWorkflowRunLogsHandler',
  ActionsGetPendingDeploymentsForRunHandler:
    'ActionsGetPendingDeploymentsForRunHandler',
  ActionsReviewPendingDeploymentsForRunHandler:
    'ActionsReviewPendingDeploymentsForRunHandler',
  ActionsReRunWorkflowHandler: 'ActionsReRunWorkflowHandler',
  ActionsReRunWorkflowFailedJobsHandler:
    'ActionsReRunWorkflowFailedJobsHandler',
  ActionsGetWorkflowRunUsageHandler: 'ActionsGetWorkflowRunUsageHandler',
  ActionsListRepoSecretsHandler: 'ActionsListRepoSecretsHandler',
  ActionsGetRepoPublicKeyHandler: 'ActionsGetRepoPublicKeyHandler',
  ActionsGetRepoSecretHandler: 'ActionsGetRepoSecretHandler',
  ActionsCreateOrUpdateRepoSecretHandler:
    'ActionsCreateOrUpdateRepoSecretHandler',
  ActionsDeleteRepoSecretHandler: 'ActionsDeleteRepoSecretHandler',
  ActionsListRepoWorkflowsHandler: 'ActionsListRepoWorkflowsHandler',
  ActionsGetWorkflowHandler: 'ActionsGetWorkflowHandler',
  ActionsDisableWorkflowHandler: 'ActionsDisableWorkflowHandler',
  ActionsCreateWorkflowDispatchHandler: 'ActionsCreateWorkflowDispatchHandler',
  ActionsEnableWorkflowHandler: 'ActionsEnableWorkflowHandler',
  ActionsListWorkflowRunsHandler: 'ActionsListWorkflowRunsHandler',
  ActionsGetWorkflowUsageHandler: 'ActionsGetWorkflowUsageHandler',
  IssuesListAssigneesHandler: 'IssuesListAssigneesHandler',
  IssuesCheckUserCanBeAssignedHandler: 'IssuesCheckUserCanBeAssignedHandler',
  ReposListAutolinksHandler: 'ReposListAutolinksHandler',
  ReposCreateAutolinkHandler: 'ReposCreateAutolinkHandler',
  ReposGetAutolinkHandler: 'ReposGetAutolinkHandler',
  ReposDeleteAutolinkHandler: 'ReposDeleteAutolinkHandler',
  ReposEnableAutomatedSecurityFixesHandler:
    'ReposEnableAutomatedSecurityFixesHandler',
  ReposDisableAutomatedSecurityFixesHandler:
    'ReposDisableAutomatedSecurityFixesHandler',
  ReposListBranchesHandler: 'ReposListBranchesHandler',
  ReposGetBranchHandler: 'ReposGetBranchHandler',
  ReposGetBranchProtectionHandler: 'ReposGetBranchProtectionHandler',
  ReposUpdateBranchProtectionHandler: 'ReposUpdateBranchProtectionHandler',
  ReposDeleteBranchProtectionHandler: 'ReposDeleteBranchProtectionHandler',
  ReposGetAdminBranchProtectionHandler: 'ReposGetAdminBranchProtectionHandler',
  ReposSetAdminBranchProtectionHandler: 'ReposSetAdminBranchProtectionHandler',
  ReposDeleteAdminBranchProtectionHandler:
    'ReposDeleteAdminBranchProtectionHandler',
  ReposGetPullRequestReviewProtectionHandler:
    'ReposGetPullRequestReviewProtectionHandler',
  ReposUpdatePullRequestReviewProtectionHandler:
    'ReposUpdatePullRequestReviewProtectionHandler',
  ReposDeletePullRequestReviewProtectionHandler:
    'ReposDeletePullRequestReviewProtectionHandler',
  ReposGetCommitSignatureProtectionHandler:
    'ReposGetCommitSignatureProtectionHandler',
  ReposCreateCommitSignatureProtectionHandler:
    'ReposCreateCommitSignatureProtectionHandler',
  ReposDeleteCommitSignatureProtectionHandler:
    'ReposDeleteCommitSignatureProtectionHandler',
  ReposGetStatusChecksProtectionHandler:
    'ReposGetStatusChecksProtectionHandler',
  ReposUpdateStatusCheckProtectionHandler:
    'ReposUpdateStatusCheckProtectionHandler',
  ReposRemoveStatusCheckProtectionHandler:
    'ReposRemoveStatusCheckProtectionHandler',
  ReposGetAllStatusCheckContextsHandler:
    'ReposGetAllStatusCheckContextsHandler',
  ReposAddStatusCheckContextsHandler: 'ReposAddStatusCheckContextsHandler',
  ReposSetStatusCheckContextsHandler: 'ReposSetStatusCheckContextsHandler',
  ReposRemoveStatusCheckContextsHandler:
    'ReposRemoveStatusCheckContextsHandler',
  ReposGetAccessRestrictionsHandler: 'ReposGetAccessRestrictionsHandler',
  ReposDeleteAccessRestrictionsHandler: 'ReposDeleteAccessRestrictionsHandler',
  ReposGetAppsWithAccessToProtectedBranchHandler:
    'ReposGetAppsWithAccessToProtectedBranchHandler',
  ReposAddAppAccessRestrictionsHandler: 'ReposAddAppAccessRestrictionsHandler',
  ReposSetAppAccessRestrictionsHandler: 'ReposSetAppAccessRestrictionsHandler',
  ReposRemoveAppAccessRestrictionsHandler:
    'ReposRemoveAppAccessRestrictionsHandler',
  ReposGetTeamsWithAccessToProtectedBranchHandler:
    'ReposGetTeamsWithAccessToProtectedBranchHandler',
  ReposAddTeamAccessRestrictionsHandler:
    'ReposAddTeamAccessRestrictionsHandler',
  ReposSetTeamAccessRestrictionsHandler:
    'ReposSetTeamAccessRestrictionsHandler',
  ReposRemoveTeamAccessRestrictionsHandler:
    'ReposRemoveTeamAccessRestrictionsHandler',
  ReposGetUsersWithAccessToProtectedBranchHandler:
    'ReposGetUsersWithAccessToProtectedBranchHandler',
  ReposAddUserAccessRestrictionsHandler:
    'ReposAddUserAccessRestrictionsHandler',
  ReposSetUserAccessRestrictionsHandler:
    'ReposSetUserAccessRestrictionsHandler',
  ReposRemoveUserAccessRestrictionsHandler:
    'ReposRemoveUserAccessRestrictionsHandler',
  ReposRenameBranchHandler: 'ReposRenameBranchHandler',
  ChecksCreateHandler: 'ChecksCreateHandler',
  ChecksGetHandler: 'ChecksGetHandler',
  ChecksUpdateHandler: 'ChecksUpdateHandler',
  ChecksListAnnotationsHandler: 'ChecksListAnnotationsHandler',
  ChecksRerequestRunHandler: 'ChecksRerequestRunHandler',
  ChecksCreateSuiteHandler: 'ChecksCreateSuiteHandler',
  ChecksSetSuitesPreferencesHandler: 'ChecksSetSuitesPreferencesHandler',
  ChecksGetSuiteHandler: 'ChecksGetSuiteHandler',
  ChecksListForSuiteHandler: 'ChecksListForSuiteHandler',
  ChecksRerequestSuiteHandler: 'ChecksRerequestSuiteHandler',
  CodeScanningListAlertsForRepoHandler: 'CodeScanningListAlertsForRepoHandler',
  CodeScanningGetAlertHandler: 'CodeScanningGetAlertHandler',
  CodeScanningUpdateAlertHandler: 'CodeScanningUpdateAlertHandler',
  CodeScanningListAlertInstancesHandler:
    'CodeScanningListAlertInstancesHandler',
  CodeScanningListRecentAnalysesHandler:
    'CodeScanningListRecentAnalysesHandler',
  CodeScanningGetAnalysisHandler: 'CodeScanningGetAnalysisHandler',
  CodeScanningDeleteAnalysisHandler: 'CodeScanningDeleteAnalysisHandler',
  CodeScanningListCodeqlDatabasesHandler:
    'CodeScanningListCodeqlDatabasesHandler',
  CodeScanningGetCodeqlDatabaseHandler: 'CodeScanningGetCodeqlDatabaseHandler',
  CodeScanningUploadSarifHandler: 'CodeScanningUploadSarifHandler',
  CodeScanningGetSarifHandler: 'CodeScanningGetSarifHandler',
  ReposCodeownersErrorsHandler: 'ReposCodeownersErrorsHandler',
  CodespacesListInRepositoryForAuthenticatedUserHandler:
    'CodespacesListInRepositoryForAuthenticatedUserHandler',
  CodespacesCreateWithRepoForAuthenticatedUserHandler:
    'CodespacesCreateWithRepoForAuthenticatedUserHandler',
  CodespacesListDevcontainersInRepositoryForAuthenticatedUserHandler:
    'CodespacesListDevcontainersInRepositoryForAuthenticatedUserHandler',
  CodespacesRepoMachinesForAuthenticatedUserHandler:
    'CodespacesRepoMachinesForAuthenticatedUserHandler',
  CodespacesPreFlightWithRepoForAuthenticatedUserHandler:
    'CodespacesPreFlightWithRepoForAuthenticatedUserHandler',
  CodespacesListRepoSecretsHandler: 'CodespacesListRepoSecretsHandler',
  CodespacesGetRepoPublicKeyHandler: 'CodespacesGetRepoPublicKeyHandler',
  CodespacesGetRepoSecretHandler: 'CodespacesGetRepoSecretHandler',
  CodespacesCreateOrUpdateRepoSecretHandler:
    'CodespacesCreateOrUpdateRepoSecretHandler',
  CodespacesDeleteRepoSecretHandler: 'CodespacesDeleteRepoSecretHandler',
  ReposListCollaboratorsHandler: 'ReposListCollaboratorsHandler',
  ReposCheckCollaboratorHandler: 'ReposCheckCollaboratorHandler',
  ReposAddCollaboratorHandler: 'ReposAddCollaboratorHandler',
  ReposRemoveCollaboratorHandler: 'ReposRemoveCollaboratorHandler',
  ReposGetCollaboratorPermissionLevelHandler:
    'ReposGetCollaboratorPermissionLevelHandler',
  ReposListCommitCommentsForRepoHandler:
    'ReposListCommitCommentsForRepoHandler',
  ReposGetCommitCommentHandler: 'ReposGetCommitCommentHandler',
  ReposUpdateCommitCommentHandler: 'ReposUpdateCommitCommentHandler',
  ReposDeleteCommitCommentHandler: 'ReposDeleteCommitCommentHandler',
  ReactionsListForCommitCommentHandler: 'ReactionsListForCommitCommentHandler',
  ReactionsCreateForCommitCommentHandler:
    'ReactionsCreateForCommitCommentHandler',
  ReactionsDeleteForCommitCommentHandler:
    'ReactionsDeleteForCommitCommentHandler',
  ReposListCommitsHandler: 'ReposListCommitsHandler',
  ReposListBranchesForHeadCommitHandler:
    'ReposListBranchesForHeadCommitHandler',
  ReposListCommentsForCommitHandler: 'ReposListCommentsForCommitHandler',
  ReposCreateCommitCommentHandler: 'ReposCreateCommitCommentHandler',
  ReposListPullRequestsAssociatedWithCommitHandler:
    'ReposListPullRequestsAssociatedWithCommitHandler',
  ReposGetCommitHandler: 'ReposGetCommitHandler',
  ChecksListForRefHandler: 'ChecksListForRefHandler',
  ChecksListSuitesForRefHandler: 'ChecksListSuitesForRefHandler',
  ReposGetCombinedStatusForRefHandler: 'ReposGetCombinedStatusForRefHandler',
  ReposListCommitStatusesForRefHandler: 'ReposListCommitStatusesForRefHandler',
  ReposGetCommunityProfileMetricsHandler:
    'ReposGetCommunityProfileMetricsHandler',
  ReposCompareCommitsHandler: 'ReposCompareCommitsHandler',
  ReposGetContentHandler: 'ReposGetContentHandler',
  ReposCreateOrUpdateFileContentsHandler:
    'ReposCreateOrUpdateFileContentsHandler',
  ReposDeleteFileHandler: 'ReposDeleteFileHandler',
  ReposListContributorsHandler: 'ReposListContributorsHandler',
  DependabotListAlertsForRepoHandler: 'DependabotListAlertsForRepoHandler',
  DependabotGetAlertHandler: 'DependabotGetAlertHandler',
  DependabotUpdateAlertHandler: 'DependabotUpdateAlertHandler',
  DependabotListRepoSecretsHandler: 'DependabotListRepoSecretsHandler',
  DependabotGetRepoPublicKeyHandler: 'DependabotGetRepoPublicKeyHandler',
  DependabotGetRepoSecretHandler: 'DependabotGetRepoSecretHandler',
  DependabotCreateOrUpdateRepoSecretHandler:
    'DependabotCreateOrUpdateRepoSecretHandler',
  DependabotDeleteRepoSecretHandler: 'DependabotDeleteRepoSecretHandler',
  DependencyGraphDiffRangeHandler: 'DependencyGraphDiffRangeHandler',
  DependencyGraphCreateRepositorySnapshotHandler:
    'DependencyGraphCreateRepositorySnapshotHandler',
  ReposListDeploymentsHandler: 'ReposListDeploymentsHandler',
  ReposCreateDeploymentHandler: 'ReposCreateDeploymentHandler',
  ReposGetDeploymentHandler: 'ReposGetDeploymentHandler',
  ReposDeleteDeploymentHandler: 'ReposDeleteDeploymentHandler',
  ReposListDeploymentStatusesHandler: 'ReposListDeploymentStatusesHandler',
  ReposCreateDeploymentStatusHandler: 'ReposCreateDeploymentStatusHandler',
  ReposGetDeploymentStatusHandler: 'ReposGetDeploymentStatusHandler',
  ReposCreateDispatchEventHandler: 'ReposCreateDispatchEventHandler',
  ReposGetAllEnvironmentsHandler: 'ReposGetAllEnvironmentsHandler',
  ReposGetEnvironmentHandler: 'ReposGetEnvironmentHandler',
  ReposCreateOrUpdateEnvironmentHandler:
    'ReposCreateOrUpdateEnvironmentHandler',
  ReposDeleteAnEnvironmentHandler: 'ReposDeleteAnEnvironmentHandler',
  ReposListDeploymentBranchPoliciesHandler:
    'ReposListDeploymentBranchPoliciesHandler',
  ReposCreateDeploymentBranchPolicyHandler:
    'ReposCreateDeploymentBranchPolicyHandler',
  ReposGetDeploymentBranchPolicyHandler:
    'ReposGetDeploymentBranchPolicyHandler',
  ReposUpdateDeploymentBranchPolicyHandler:
    'ReposUpdateDeploymentBranchPolicyHandler',
  ReposDeleteDeploymentBranchPolicyHandler:
    'ReposDeleteDeploymentBranchPolicyHandler',
  ActivityListRepoEventsHandler: 'ActivityListRepoEventsHandler',
  ReposListForksHandler: 'ReposListForksHandler',
  ReposCreateForkHandler: 'ReposCreateForkHandler',
  GitCreateBlobHandler: 'GitCreateBlobHandler',
  GitGetBlobHandler: 'GitGetBlobHandler',
  GitCreateCommitHandler: 'GitCreateCommitHandler',
  GitGetCommitHandler: 'GitGetCommitHandler',
  GitListMatchingRefsHandler: 'GitListMatchingRefsHandler',
  GitGetRefHandler: 'GitGetRefHandler',
  GitCreateRefHandler: 'GitCreateRefHandler',
  GitUpdateRefHandler: 'GitUpdateRefHandler',
  GitDeleteRefHandler: 'GitDeleteRefHandler',
  GitCreateTagHandler: 'GitCreateTagHandler',
  GitGetTagHandler: 'GitGetTagHandler',
  GitCreateTreeHandler: 'GitCreateTreeHandler',
  GitGetTreeHandler: 'GitGetTreeHandler',
  ReposListWebhooksHandler: 'ReposListWebhooksHandler',
  ReposCreateWebhookHandler: 'ReposCreateWebhookHandler',
  ReposGetWebhookHandler: 'ReposGetWebhookHandler',
  ReposUpdateWebhookHandler: 'ReposUpdateWebhookHandler',
  ReposDeleteWebhookHandler: 'ReposDeleteWebhookHandler',
  ReposGetWebhookConfigForRepoHandler: 'ReposGetWebhookConfigForRepoHandler',
  ReposUpdateWebhookConfigForRepoHandler:
    'ReposUpdateWebhookConfigForRepoHandler',
  ReposListWebhookDeliveriesHandler: 'ReposListWebhookDeliveriesHandler',
  ReposGetWebhookDeliveryHandler: 'ReposGetWebhookDeliveryHandler',
  ReposRedeliverWebhookDeliveryHandler: 'ReposRedeliverWebhookDeliveryHandler',
  ReposPingWebhookHandler: 'ReposPingWebhookHandler',
  ReposTestPushWebhookHandler: 'ReposTestPushWebhookHandler',
  MigrationsGetImportStatusHandler: 'MigrationsGetImportStatusHandler',
  MigrationsStartImportHandler: 'MigrationsStartImportHandler',
  MigrationsUpdateImportHandler: 'MigrationsUpdateImportHandler',
  MigrationsCancelImportHandler: 'MigrationsCancelImportHandler',
  MigrationsGetCommitAuthorsHandler: 'MigrationsGetCommitAuthorsHandler',
  MigrationsMapCommitAuthorHandler: 'MigrationsMapCommitAuthorHandler',
  MigrationsGetLargeFilesHandler: 'MigrationsGetLargeFilesHandler',
  MigrationsSetLfsPreferenceHandler: 'MigrationsSetLfsPreferenceHandler',
  AppsGetRepoInstallationHandler: 'AppsGetRepoInstallationHandler',
  InteractionsGetRestrictionsForRepoHandler:
    'InteractionsGetRestrictionsForRepoHandler',
  InteractionsSetRestrictionsForRepoHandler:
    'InteractionsSetRestrictionsForRepoHandler',
  InteractionsRemoveRestrictionsForRepoHandler:
    'InteractionsRemoveRestrictionsForRepoHandler',
  ReposListInvitationsHandler: 'ReposListInvitationsHandler',
  ReposUpdateInvitationHandler: 'ReposUpdateInvitationHandler',
  ReposDeleteInvitationHandler: 'ReposDeleteInvitationHandler',
  IssuesListForRepoHandler: 'IssuesListForRepoHandler',
  IssuesCreateHandler: 'IssuesCreateHandler',
  IssuesListCommentsForRepoHandler: 'IssuesListCommentsForRepoHandler',
  IssuesGetCommentHandler: 'IssuesGetCommentHandler',
  IssuesUpdateCommentHandler: 'IssuesUpdateCommentHandler',
  IssuesDeleteCommentHandler: 'IssuesDeleteCommentHandler',
  ReactionsListForIssueCommentHandler: 'ReactionsListForIssueCommentHandler',
  ReactionsCreateForIssueCommentHandler:
    'ReactionsCreateForIssueCommentHandler',
  ReactionsDeleteForIssueCommentHandler:
    'ReactionsDeleteForIssueCommentHandler',
  IssuesListEventsForRepoHandler: 'IssuesListEventsForRepoHandler',
  IssuesGetEventHandler: 'IssuesGetEventHandler',
  IssuesGetHandler: 'IssuesGetHandler',
  IssuesUpdateHandler: 'IssuesUpdateHandler',
  IssuesAddAssigneesHandler: 'IssuesAddAssigneesHandler',
  IssuesRemoveAssigneesHandler: 'IssuesRemoveAssigneesHandler',
  IssuesListCommentsHandler: 'IssuesListCommentsHandler',
  IssuesCreateCommentHandler: 'IssuesCreateCommentHandler',
  IssuesListEventsHandler: 'IssuesListEventsHandler',
  IssuesListLabelsOnIssueHandler: 'IssuesListLabelsOnIssueHandler',
  IssuesAddLabelsHandler: 'IssuesAddLabelsHandler',
  IssuesSetLabelsHandler: 'IssuesSetLabelsHandler',
  IssuesRemoveAllLabelsHandler: 'IssuesRemoveAllLabelsHandler',
  IssuesRemoveLabelHandler: 'IssuesRemoveLabelHandler',
  IssuesLockHandler: 'IssuesLockHandler',
  IssuesUnlockHandler: 'IssuesUnlockHandler',
  ReactionsListForIssueHandler: 'ReactionsListForIssueHandler',
  ReactionsCreateForIssueHandler: 'ReactionsCreateForIssueHandler',
  ReactionsDeleteForIssueHandler: 'ReactionsDeleteForIssueHandler',
  IssuesListEventsForTimelineHandler: 'IssuesListEventsForTimelineHandler',
  ReposListDeployKeysHandler: 'ReposListDeployKeysHandler',
  ReposCreateDeployKeyHandler: 'ReposCreateDeployKeyHandler',
  ReposGetDeployKeyHandler: 'ReposGetDeployKeyHandler',
  ReposDeleteDeployKeyHandler: 'ReposDeleteDeployKeyHandler',
  IssuesListLabelsForRepoHandler: 'IssuesListLabelsForRepoHandler',
  IssuesCreateLabelHandler: 'IssuesCreateLabelHandler',
  IssuesGetLabelHandler: 'IssuesGetLabelHandler',
  IssuesUpdateLabelHandler: 'IssuesUpdateLabelHandler',
  IssuesDeleteLabelHandler: 'IssuesDeleteLabelHandler',
  ReposListLanguagesHandler: 'ReposListLanguagesHandler',
  ReposEnableLfsForRepoHandler: 'ReposEnableLfsForRepoHandler',
  ReposDisableLfsForRepoHandler: 'ReposDisableLfsForRepoHandler',
  LicensesGetForRepoHandler: 'LicensesGetForRepoHandler',
  ReposMergeUpstreamHandler: 'ReposMergeUpstreamHandler',
  ReposMergeHandler: 'ReposMergeHandler',
  IssuesListMilestonesHandler: 'IssuesListMilestonesHandler',
  IssuesCreateMilestoneHandler: 'IssuesCreateMilestoneHandler',
  IssuesGetMilestoneHandler: 'IssuesGetMilestoneHandler',
  IssuesUpdateMilestoneHandler: 'IssuesUpdateMilestoneHandler',
  IssuesDeleteMilestoneHandler: 'IssuesDeleteMilestoneHandler',
  IssuesListLabelsForMilestoneHandler: 'IssuesListLabelsForMilestoneHandler',
  ActivityListRepoNotificationsForAuthenticatedUserHandler:
    'ActivityListRepoNotificationsForAuthenticatedUserHandler',
  ActivityMarkRepoNotificationsAsReadHandler:
    'ActivityMarkRepoNotificationsAsReadHandler',
  ReposGetPagesHandler: 'ReposGetPagesHandler',
  ReposCreatePagesSiteHandler: 'ReposCreatePagesSiteHandler',
  ReposUpdateInformationAboutPagesSiteHandler:
    'ReposUpdateInformationAboutPagesSiteHandler',
  ReposDeletePagesSiteHandler: 'ReposDeletePagesSiteHandler',
  ReposListPagesBuildsHandler: 'ReposListPagesBuildsHandler',
  ReposRequestPagesBuildHandler: 'ReposRequestPagesBuildHandler',
  ReposGetLatestPagesBuildHandler: 'ReposGetLatestPagesBuildHandler',
  ReposGetPagesBuildHandler: 'ReposGetPagesBuildHandler',
  ReposCreatePagesDeploymentHandler: 'ReposCreatePagesDeploymentHandler',
  ReposGetPagesHealthCheckHandler: 'ReposGetPagesHealthCheckHandler',
  ProjectsListForRepoHandler: 'ProjectsListForRepoHandler',
  ProjectsCreateForRepoHandler: 'ProjectsCreateForRepoHandler',
  PullsListHandler: 'PullsListHandler',
  PullsCreateHandler: 'PullsCreateHandler',
  PullsListReviewCommentsForRepoHandler:
    'PullsListReviewCommentsForRepoHandler',
  PullsGetReviewCommentHandler: 'PullsGetReviewCommentHandler',
  PullsUpdateReviewCommentHandler: 'PullsUpdateReviewCommentHandler',
  PullsDeleteReviewCommentHandler: 'PullsDeleteReviewCommentHandler',
  ReactionsListForPullRequestReviewCommentHandler:
    'ReactionsListForPullRequestReviewCommentHandler',
  ReactionsCreateForPullRequestReviewCommentHandler:
    'ReactionsCreateForPullRequestReviewCommentHandler',
  ReactionsDeleteForPullRequestCommentHandler:
    'ReactionsDeleteForPullRequestCommentHandler',
  PullsGetHandler: 'PullsGetHandler',
  PullsUpdateHandler: 'PullsUpdateHandler',
  CodespacesCreateWithPrForAuthenticatedUserHandler:
    'CodespacesCreateWithPrForAuthenticatedUserHandler',
  PullsListReviewCommentsHandler: 'PullsListReviewCommentsHandler',
  PullsCreateReviewCommentHandler: 'PullsCreateReviewCommentHandler',
  PullsCreateReplyForReviewCommentHandler:
    'PullsCreateReplyForReviewCommentHandler',
  PullsListCommitsHandler: 'PullsListCommitsHandler',
  PullsListFilesHandler: 'PullsListFilesHandler',
  PullsCheckIfMergedHandler: 'PullsCheckIfMergedHandler',
  PullsMergeHandler: 'PullsMergeHandler',
  PullsListRequestedReviewersHandler: 'PullsListRequestedReviewersHandler',
  PullsRequestReviewersHandler: 'PullsRequestReviewersHandler',
  PullsRemoveRequestedReviewersHandler: 'PullsRemoveRequestedReviewersHandler',
  PullsListReviewsHandler: 'PullsListReviewsHandler',
  PullsCreateReviewHandler: 'PullsCreateReviewHandler',
  PullsGetReviewHandler: 'PullsGetReviewHandler',
  PullsUpdateReviewHandler: 'PullsUpdateReviewHandler',
  PullsDeletePendingReviewHandler: 'PullsDeletePendingReviewHandler',
  PullsListCommentsForReviewHandler: 'PullsListCommentsForReviewHandler',
  PullsDismissReviewHandler: 'PullsDismissReviewHandler',
  PullsSubmitReviewHandler: 'PullsSubmitReviewHandler',
  PullsUpdateBranchHandler: 'PullsUpdateBranchHandler',
  ReposGetReadmeHandler: 'ReposGetReadmeHandler',
  ReposGetReadmeInDirectoryHandler: 'ReposGetReadmeInDirectoryHandler',
  ReposListReleasesHandler: 'ReposListReleasesHandler',
  ReposCreateReleaseHandler: 'ReposCreateReleaseHandler',
  ReposGetReleaseAssetHandler: 'ReposGetReleaseAssetHandler',
  ReposUpdateReleaseAssetHandler: 'ReposUpdateReleaseAssetHandler',
  ReposDeleteReleaseAssetHandler: 'ReposDeleteReleaseAssetHandler',
  ReposGenerateReleaseNotesHandler: 'ReposGenerateReleaseNotesHandler',
  ReposGetLatestReleaseHandler: 'ReposGetLatestReleaseHandler',
  ReposGetReleaseByTagHandler: 'ReposGetReleaseByTagHandler',
  ReposGetReleaseHandler: 'ReposGetReleaseHandler',
  ReposUpdateReleaseHandler: 'ReposUpdateReleaseHandler',
  ReposDeleteReleaseHandler: 'ReposDeleteReleaseHandler',
  ReposListReleaseAssetsHandler: 'ReposListReleaseAssetsHandler',
  ReposUploadReleaseAssetHandler: 'ReposUploadReleaseAssetHandler',
  ReactionsListForReleaseHandler: 'ReactionsListForReleaseHandler',
  ReactionsCreateForReleaseHandler: 'ReactionsCreateForReleaseHandler',
  ReactionsDeleteForReleaseHandler: 'ReactionsDeleteForReleaseHandler',
  SecretScanningListAlertsForRepoHandler:
    'SecretScanningListAlertsForRepoHandler',
  SecretScanningGetAlertHandler: 'SecretScanningGetAlertHandler',
  SecretScanningUpdateAlertHandler: 'SecretScanningUpdateAlertHandler',
  SecretScanningListLocationsForAlertHandler:
    'SecretScanningListLocationsForAlertHandler',
  ActivityListStargazersForRepoHandler: 'ActivityListStargazersForRepoHandler',
  ReposGetCodeFrequencyStatsHandler: 'ReposGetCodeFrequencyStatsHandler',
  ReposGetCommitActivityStatsHandler: 'ReposGetCommitActivityStatsHandler',
  ReposGetContributorsStatsHandler: 'ReposGetContributorsStatsHandler',
  ReposGetParticipationStatsHandler: 'ReposGetParticipationStatsHandler',
  ReposGetPunchCardStatsHandler: 'ReposGetPunchCardStatsHandler',
  ReposCreateCommitStatusHandler: 'ReposCreateCommitStatusHandler',
  ActivityListWatchersForRepoHandler: 'ActivityListWatchersForRepoHandler',
  ActivityGetRepoSubscriptionHandler: 'ActivityGetRepoSubscriptionHandler',
  ActivitySetRepoSubscriptionHandler: 'ActivitySetRepoSubscriptionHandler',
  ActivityDeleteRepoSubscriptionHandler:
    'ActivityDeleteRepoSubscriptionHandler',
  ReposListTagsHandler: 'ReposListTagsHandler',
  ReposListTagProtectionHandler: 'ReposListTagProtectionHandler',
  ReposCreateTagProtectionHandler: 'ReposCreateTagProtectionHandler',
  ReposDeleteTagProtectionHandler: 'ReposDeleteTagProtectionHandler',
  ReposDownloadTarballArchiveHandler: 'ReposDownloadTarballArchiveHandler',
  ReposListTeamsHandler: 'ReposListTeamsHandler',
  ReposGetAllTopicsHandler: 'ReposGetAllTopicsHandler',
  ReposReplaceAllTopicsHandler: 'ReposReplaceAllTopicsHandler',
  ReposGetClonesHandler: 'ReposGetClonesHandler',
  ReposGetTopPathsHandler: 'ReposGetTopPathsHandler',
  ReposGetTopReferrersHandler: 'ReposGetTopReferrersHandler',
  ReposGetViewsHandler: 'ReposGetViewsHandler',
  ReposTransferHandler: 'ReposTransferHandler',
  ReposCheckVulnerabilityAlertsHandler: 'ReposCheckVulnerabilityAlertsHandler',
  ReposEnableVulnerabilityAlertsHandler:
    'ReposEnableVulnerabilityAlertsHandler',
  ReposDisableVulnerabilityAlertsHandler:
    'ReposDisableVulnerabilityAlertsHandler',
  ReposDownloadZipballArchiveHandler: 'ReposDownloadZipballArchiveHandler',
  ReposCreateUsingTemplateHandler: 'ReposCreateUsingTemplateHandler',
  ReposListPublicHandler: 'ReposListPublicHandler',
  ActionsListEnvironmentSecretsHandler: 'ActionsListEnvironmentSecretsHandler',
  ActionsGetEnvironmentPublicKeyHandler:
    'ActionsGetEnvironmentPublicKeyHandler',
  ActionsGetEnvironmentSecretHandler: 'ActionsGetEnvironmentSecretHandler',
  ActionsCreateOrUpdateEnvironmentSecretHandler:
    'ActionsCreateOrUpdateEnvironmentSecretHandler',
  ActionsDeleteEnvironmentSecretHandler:
    'ActionsDeleteEnvironmentSecretHandler',
  SearchCodeHandler: 'SearchCodeHandler',
  SearchCommitsHandler: 'SearchCommitsHandler',
  SearchIssuesAndPullRequestsHandler: 'SearchIssuesAndPullRequestsHandler',
  SearchLabelsHandler: 'SearchLabelsHandler',
  SearchReposHandler: 'SearchReposHandler',
  SearchTopicsHandler: 'SearchTopicsHandler',
  SearchUsersHandler: 'SearchUsersHandler',
  TeamsGetLegacyHandler: 'TeamsGetLegacyHandler',
  TeamsUpdateLegacyHandler: 'TeamsUpdateLegacyHandler',
  TeamsDeleteLegacyHandler: 'TeamsDeleteLegacyHandler',
  TeamsListDiscussionsLegacyHandler: 'TeamsListDiscussionsLegacyHandler',
  TeamsCreateDiscussionLegacyHandler: 'TeamsCreateDiscussionLegacyHandler',
  TeamsGetDiscussionLegacyHandler: 'TeamsGetDiscussionLegacyHandler',
  TeamsUpdateDiscussionLegacyHandler: 'TeamsUpdateDiscussionLegacyHandler',
  TeamsDeleteDiscussionLegacyHandler: 'TeamsDeleteDiscussionLegacyHandler',
  TeamsListDiscussionCommentsLegacyHandler:
    'TeamsListDiscussionCommentsLegacyHandler',
  TeamsCreateDiscussionCommentLegacyHandler:
    'TeamsCreateDiscussionCommentLegacyHandler',
  TeamsGetDiscussionCommentLegacyHandler:
    'TeamsGetDiscussionCommentLegacyHandler',
  TeamsUpdateDiscussionCommentLegacyHandler:
    'TeamsUpdateDiscussionCommentLegacyHandler',
  TeamsDeleteDiscussionCommentLegacyHandler:
    'TeamsDeleteDiscussionCommentLegacyHandler',
  ReactionsListForTeamDiscussionCommentLegacyHandler:
    'ReactionsListForTeamDiscussionCommentLegacyHandler',
  ReactionsCreateForTeamDiscussionCommentLegacyHandler:
    'ReactionsCreateForTeamDiscussionCommentLegacyHandler',
  ReactionsListForTeamDiscussionLegacyHandler:
    'ReactionsListForTeamDiscussionLegacyHandler',
  ReactionsCreateForTeamDiscussionLegacyHandler:
    'ReactionsCreateForTeamDiscussionLegacyHandler',
  TeamsListPendingInvitationsLegacyHandler:
    'TeamsListPendingInvitationsLegacyHandler',
  TeamsListMembersLegacyHandler: 'TeamsListMembersLegacyHandler',
  TeamsGetMemberLegacyHandler: 'TeamsGetMemberLegacyHandler',
  TeamsAddMemberLegacyHandler: 'TeamsAddMemberLegacyHandler',
  TeamsRemoveMemberLegacyHandler: 'TeamsRemoveMemberLegacyHandler',
  TeamsGetMembershipForUserLegacyHandler:
    'TeamsGetMembershipForUserLegacyHandler',
  TeamsAddOrUpdateMembershipForUserLegacyHandler:
    'TeamsAddOrUpdateMembershipForUserLegacyHandler',
  TeamsRemoveMembershipForUserLegacyHandler:
    'TeamsRemoveMembershipForUserLegacyHandler',
  TeamsListProjectsLegacyHandler: 'TeamsListProjectsLegacyHandler',
  TeamsCheckPermissionsForProjectLegacyHandler:
    'TeamsCheckPermissionsForProjectLegacyHandler',
  TeamsAddOrUpdateProjectPermissionsLegacyHandler:
    'TeamsAddOrUpdateProjectPermissionsLegacyHandler',
  TeamsRemoveProjectLegacyHandler: 'TeamsRemoveProjectLegacyHandler',
  TeamsListReposLegacyHandler: 'TeamsListReposLegacyHandler',
  TeamsCheckPermissionsForRepoLegacyHandler:
    'TeamsCheckPermissionsForRepoLegacyHandler',
  TeamsAddOrUpdateRepoPermissionsLegacyHandler:
    'TeamsAddOrUpdateRepoPermissionsLegacyHandler',
  TeamsRemoveRepoLegacyHandler: 'TeamsRemoveRepoLegacyHandler',
  TeamsListChildLegacyHandler: 'TeamsListChildLegacyHandler',
  UsersGetAuthenticatedHandler: 'UsersGetAuthenticatedHandler',
  UsersUpdateAuthenticatedHandler: 'UsersUpdateAuthenticatedHandler',
  UsersListBlockedByAuthenticatedUserHandler:
    'UsersListBlockedByAuthenticatedUserHandler',
  UsersCheckBlockedHandler: 'UsersCheckBlockedHandler',
  UsersBlockHandler: 'UsersBlockHandler',
  UsersUnblockHandler: 'UsersUnblockHandler',
  CodespacesListForAuthenticatedUserHandler:
    'CodespacesListForAuthenticatedUserHandler',
  CodespacesCreateForAuthenticatedUserHandler:
    'CodespacesCreateForAuthenticatedUserHandler',
  CodespacesListSecretsForAuthenticatedUserHandler:
    'CodespacesListSecretsForAuthenticatedUserHandler',
  CodespacesGetPublicKeyForAuthenticatedUserHandler:
    'CodespacesGetPublicKeyForAuthenticatedUserHandler',
  CodespacesGetSecretForAuthenticatedUserHandler:
    'CodespacesGetSecretForAuthenticatedUserHandler',
  CodespacesCreateOrUpdateSecretForAuthenticatedUserHandler:
    'CodespacesCreateOrUpdateSecretForAuthenticatedUserHandler',
  CodespacesDeleteSecretForAuthenticatedUserHandler:
    'CodespacesDeleteSecretForAuthenticatedUserHandler',
  CodespacesListRepositoriesForSecretForAuthenticatedUserHandler:
    'CodespacesListRepositoriesForSecretForAuthenticatedUserHandler',
  CodespacesSetRepositoriesForSecretForAuthenticatedUserHandler:
    'CodespacesSetRepositoriesForSecretForAuthenticatedUserHandler',
  CodespacesAddRepositoryForSecretForAuthenticatedUserHandler:
    'CodespacesAddRepositoryForSecretForAuthenticatedUserHandler',
  CodespacesRemoveRepositoryForSecretForAuthenticatedUserHandler:
    'CodespacesRemoveRepositoryForSecretForAuthenticatedUserHandler',
  CodespacesGetForAuthenticatedUserHandler:
    'CodespacesGetForAuthenticatedUserHandler',
  CodespacesUpdateForAuthenticatedUserHandler:
    'CodespacesUpdateForAuthenticatedUserHandler',
  CodespacesDeleteForAuthenticatedUserHandler:
    'CodespacesDeleteForAuthenticatedUserHandler',
  CodespacesExportForAuthenticatedUserHandler:
    'CodespacesExportForAuthenticatedUserHandler',
  CodespacesGetExportDetailsForAuthenticatedUserHandler:
    'CodespacesGetExportDetailsForAuthenticatedUserHandler',
  CodespacesCodespaceMachinesForAuthenticatedUserHandler:
    'CodespacesCodespaceMachinesForAuthenticatedUserHandler',
  CodespacesStartForAuthenticatedUserHandler:
    'CodespacesStartForAuthenticatedUserHandler',
  CodespacesStopForAuthenticatedUserHandler:
    'CodespacesStopForAuthenticatedUserHandler',
  UsersSetPrimaryEmailVisibilityForAuthenticatedUserHandler:
    'UsersSetPrimaryEmailVisibilityForAuthenticatedUserHandler',
  UsersListEmailsForAuthenticatedUserHandler:
    'UsersListEmailsForAuthenticatedUserHandler',
  UsersAddEmailForAuthenticatedUserHandler:
    'UsersAddEmailForAuthenticatedUserHandler',
  UsersDeleteEmailForAuthenticatedUserHandler:
    'UsersDeleteEmailForAuthenticatedUserHandler',
  UsersListFollowersForAuthenticatedUserHandler:
    'UsersListFollowersForAuthenticatedUserHandler',
  UsersListFollowedByAuthenticatedUserHandler:
    'UsersListFollowedByAuthenticatedUserHandler',
  UsersCheckPersonIsFollowedByAuthenticatedHandler:
    'UsersCheckPersonIsFollowedByAuthenticatedHandler',
  UsersFollowHandler: 'UsersFollowHandler',
  UsersUnfollowHandler: 'UsersUnfollowHandler',
  UsersListGpgKeysForAuthenticatedUserHandler:
    'UsersListGpgKeysForAuthenticatedUserHandler',
  UsersCreateGpgKeyForAuthenticatedUserHandler:
    'UsersCreateGpgKeyForAuthenticatedUserHandler',
  UsersGetGpgKeyForAuthenticatedUserHandler:
    'UsersGetGpgKeyForAuthenticatedUserHandler',
  UsersDeleteGpgKeyForAuthenticatedUserHandler:
    'UsersDeleteGpgKeyForAuthenticatedUserHandler',
  AppsListInstallationsForAuthenticatedUserHandler:
    'AppsListInstallationsForAuthenticatedUserHandler',
  AppsListInstallationReposForAuthenticatedUserHandler:
    'AppsListInstallationReposForAuthenticatedUserHandler',
  AppsAddRepoToInstallationForAuthenticatedUserHandler:
    'AppsAddRepoToInstallationForAuthenticatedUserHandler',
  AppsRemoveRepoFromInstallationForAuthenticatedUserHandler:
    'AppsRemoveRepoFromInstallationForAuthenticatedUserHandler',
  InteractionsGetRestrictionsForAuthenticatedUserHandler:
    'InteractionsGetRestrictionsForAuthenticatedUserHandler',
  InteractionsSetRestrictionsForAuthenticatedUserHandler:
    'InteractionsSetRestrictionsForAuthenticatedUserHandler',
  InteractionsRemoveRestrictionsForAuthenticatedUserHandler:
    'InteractionsRemoveRestrictionsForAuthenticatedUserHandler',
  IssuesListForAuthenticatedUserHandler:
    'IssuesListForAuthenticatedUserHandler',
  UsersListPublicSshKeysForAuthenticatedUserHandler:
    'UsersListPublicSshKeysForAuthenticatedUserHandler',
  UsersCreatePublicSshKeyForAuthenticatedUserHandler:
    'UsersCreatePublicSshKeyForAuthenticatedUserHandler',
  UsersGetPublicSshKeyForAuthenticatedUserHandler:
    'UsersGetPublicSshKeyForAuthenticatedUserHandler',
  UsersDeletePublicSshKeyForAuthenticatedUserHandler:
    'UsersDeletePublicSshKeyForAuthenticatedUserHandler',
  AppsListSubscriptionsForAuthenticatedUserHandler:
    'AppsListSubscriptionsForAuthenticatedUserHandler',
  AppsListSubscriptionsForAuthenticatedUserStubbedHandler:
    'AppsListSubscriptionsForAuthenticatedUserStubbedHandler',
  OrgsListMembershipsForAuthenticatedUserHandler:
    'OrgsListMembershipsForAuthenticatedUserHandler',
  OrgsGetMembershipForAuthenticatedUserHandler:
    'OrgsGetMembershipForAuthenticatedUserHandler',
  OrgsUpdateMembershipForAuthenticatedUserHandler:
    'OrgsUpdateMembershipForAuthenticatedUserHandler',
  MigrationsListForAuthenticatedUserHandler:
    'MigrationsListForAuthenticatedUserHandler',
  MigrationsStartForAuthenticatedUserHandler:
    'MigrationsStartForAuthenticatedUserHandler',
  MigrationsGetStatusForAuthenticatedUserHandler:
    'MigrationsGetStatusForAuthenticatedUserHandler',
  MigrationsGetArchiveForAuthenticatedUserHandler:
    'MigrationsGetArchiveForAuthenticatedUserHandler',
  MigrationsDeleteArchiveForAuthenticatedUserHandler:
    'MigrationsDeleteArchiveForAuthenticatedUserHandler',
  MigrationsUnlockRepoForAuthenticatedUserHandler:
    'MigrationsUnlockRepoForAuthenticatedUserHandler',
  MigrationsListReposForAuthenticatedUserHandler:
    'MigrationsListReposForAuthenticatedUserHandler',
  OrgsListForAuthenticatedUserHandler: 'OrgsListForAuthenticatedUserHandler',
  PackagesListPackagesForAuthenticatedUserHandler:
    'PackagesListPackagesForAuthenticatedUserHandler',
  PackagesGetPackageForAuthenticatedUserHandler:
    'PackagesGetPackageForAuthenticatedUserHandler',
  PackagesDeletePackageForAuthenticatedUserHandler:
    'PackagesDeletePackageForAuthenticatedUserHandler',
  PackagesRestorePackageForAuthenticatedUserHandler:
    'PackagesRestorePackageForAuthenticatedUserHandler',
  PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserHandler:
    'PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserHandler',
  PackagesGetPackageVersionForAuthenticatedUserHandler:
    'PackagesGetPackageVersionForAuthenticatedUserHandler',
  PackagesDeletePackageVersionForAuthenticatedUserHandler:
    'PackagesDeletePackageVersionForAuthenticatedUserHandler',
  PackagesRestorePackageVersionForAuthenticatedUserHandler:
    'PackagesRestorePackageVersionForAuthenticatedUserHandler',
  ProjectsCreateForAuthenticatedUserHandler:
    'ProjectsCreateForAuthenticatedUserHandler',
  UsersListPublicEmailsForAuthenticatedUserHandler:
    'UsersListPublicEmailsForAuthenticatedUserHandler',
  ReposListForAuthenticatedUserHandler: 'ReposListForAuthenticatedUserHandler',
  ReposCreateForAuthenticatedUserHandler:
    'ReposCreateForAuthenticatedUserHandler',
  ReposListInvitationsForAuthenticatedUserHandler:
    'ReposListInvitationsForAuthenticatedUserHandler',
  ReposAcceptInvitationForAuthenticatedUserHandler:
    'ReposAcceptInvitationForAuthenticatedUserHandler',
  ReposDeclineInvitationForAuthenticatedUserHandler:
    'ReposDeclineInvitationForAuthenticatedUserHandler',
  UsersListSshSigningKeysForAuthenticatedUserHandler:
    'UsersListSshSigningKeysForAuthenticatedUserHandler',
  UsersCreateSshSigningKeyForAuthenticatedUserHandler:
    'UsersCreateSshSigningKeyForAuthenticatedUserHandler',
  UsersGetSshSigningKeyForAuthenticatedUserHandler:
    'UsersGetSshSigningKeyForAuthenticatedUserHandler',
  UsersDeleteSshSigningKeyForAuthenticatedUserHandler:
    'UsersDeleteSshSigningKeyForAuthenticatedUserHandler',
  ActivityListReposStarredByAuthenticatedUserHandler:
    'ActivityListReposStarredByAuthenticatedUserHandler',
  ActivityCheckRepoIsStarredByAuthenticatedUserHandler:
    'ActivityCheckRepoIsStarredByAuthenticatedUserHandler',
  ActivityStarRepoForAuthenticatedUserHandler:
    'ActivityStarRepoForAuthenticatedUserHandler',
  ActivityUnstarRepoForAuthenticatedUserHandler:
    'ActivityUnstarRepoForAuthenticatedUserHandler',
  ActivityListWatchedReposForAuthenticatedUserHandler:
    'ActivityListWatchedReposForAuthenticatedUserHandler',
  TeamsListForAuthenticatedUserHandler: 'TeamsListForAuthenticatedUserHandler',
  UsersListHandler: 'UsersListHandler',
  UsersGetByUsernameHandler: 'UsersGetByUsernameHandler',
  ActivityListEventsForAuthenticatedUserHandler:
    'ActivityListEventsForAuthenticatedUserHandler',
  ActivityListOrgEventsForAuthenticatedUserHandler:
    'ActivityListOrgEventsForAuthenticatedUserHandler',
  ActivityListPublicEventsForUserHandler:
    'ActivityListPublicEventsForUserHandler',
  UsersListFollowersForUserHandler: 'UsersListFollowersForUserHandler',
  UsersListFollowingForUserHandler: 'UsersListFollowingForUserHandler',
  UsersCheckFollowingForUserHandler: 'UsersCheckFollowingForUserHandler',
  GistsListForUserHandler: 'GistsListForUserHandler',
  UsersListGpgKeysForUserHandler: 'UsersListGpgKeysForUserHandler',
  UsersGetContextForUserHandler: 'UsersGetContextForUserHandler',
  AppsGetUserInstallationHandler: 'AppsGetUserInstallationHandler',
  UsersListPublicKeysForUserHandler: 'UsersListPublicKeysForUserHandler',
  OrgsListForUserHandler: 'OrgsListForUserHandler',
  PackagesListPackagesForUserHandler: 'PackagesListPackagesForUserHandler',
  PackagesGetPackageForUserHandler: 'PackagesGetPackageForUserHandler',
  PackagesDeletePackageForUserHandler: 'PackagesDeletePackageForUserHandler',
  PackagesRestorePackageForUserHandler: 'PackagesRestorePackageForUserHandler',
  PackagesGetAllPackageVersionsForPackageOwnedByUserHandler:
    'PackagesGetAllPackageVersionsForPackageOwnedByUserHandler',
  PackagesGetPackageVersionForUserHandler:
    'PackagesGetPackageVersionForUserHandler',
  PackagesDeletePackageVersionForUserHandler:
    'PackagesDeletePackageVersionForUserHandler',
  PackagesRestorePackageVersionForUserHandler:
    'PackagesRestorePackageVersionForUserHandler',
  ProjectsListForUserHandler: 'ProjectsListForUserHandler',
  ActivityListReceivedEventsForUserHandler:
    'ActivityListReceivedEventsForUserHandler',
  ActivityListReceivedPublicEventsForUserHandler:
    'ActivityListReceivedPublicEventsForUserHandler',
  ReposListForUserHandler: 'ReposListForUserHandler',
  BillingGetGithubActionsBillingUserHandler:
    'BillingGetGithubActionsBillingUserHandler',
  BillingGetGithubPackagesBillingUserHandler:
    'BillingGetGithubPackagesBillingUserHandler',
  BillingGetSharedStorageBillingUserHandler:
    'BillingGetSharedStorageBillingUserHandler',
  UsersListSshSigningKeysForUserHandler:
    'UsersListSshSigningKeysForUserHandler',
  ActivityListReposStarredByUserHandler:
    'ActivityListReposStarredByUserHandler',
  ActivityListReposWatchedByUserHandler:
    'ActivityListReposWatchedByUserHandler',
  MetaGetZenHandler: 'MetaGetZenHandler'
};

export type MetaRootRequest = Request<
  ParamsDictionary,
  MetaRoot200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MetaRootResponse = Response<
  MetaRoot200ResponseBody,
  Record<string, any>,
  200
>;

export interface MetaRootHandler {
  metaRoot(
    req: MetaRootRequest,
    res: MetaRootResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsGetAuthenticatedRequest = Request<
  ParamsDictionary,
  AppsGetAuthenticated200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetAuthenticatedResponse = Response<
  AppsGetAuthenticated200ResponseBody,
  Record<string, any>,
  200
>;

export interface AppsGetAuthenticatedHandler {
  appsGetAuthenticated(
    req: AppsGetAuthenticatedRequest,
    res: AppsGetAuthenticatedResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsCreateFromManifestRequest = Request<
  AppsCreateFromManifestRequestPath,
  | AppsCreateFromManifest201ResponseBody
  | AppsCreateFromManifest404ResponseBody
  | AppsCreateFromManifest422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsCreateFromManifestResponse = Response<
  | AppsCreateFromManifest201ResponseBody
  | AppsCreateFromManifest404ResponseBody
  | AppsCreateFromManifest422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export interface AppsCreateFromManifestHandler {
  appsCreateFromManifest(
    req: AppsCreateFromManifestRequest,
    res: AppsCreateFromManifestResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsGetWebhookConfigForAppRequest = Request<
  ParamsDictionary,
  AppsGetWebhookConfigForApp200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetWebhookConfigForAppResponse = Response<
  AppsGetWebhookConfigForApp200ResponseBody,
  Record<string, any>,
  200
>;

export interface AppsGetWebhookConfigForAppHandler {
  appsGetWebhookConfigForApp(
    req: AppsGetWebhookConfigForAppRequest,
    res: AppsGetWebhookConfigForAppResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsUpdateWebhookConfigForAppRequest = Request<
  ParamsDictionary,
  AppsUpdateWebhookConfigForApp200ResponseBody,
  AppsUpdateWebhookConfigForAppRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsUpdateWebhookConfigForAppResponse = Response<
  AppsUpdateWebhookConfigForApp200ResponseBody,
  Record<string, any>,
  200
>;

export interface AppsUpdateWebhookConfigForAppHandler {
  appsUpdateWebhookConfigForApp(
    req: AppsUpdateWebhookConfigForAppRequest,
    res: AppsUpdateWebhookConfigForAppResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsListWebhookDeliveriesRequest = Request<
  ParamsDictionary,
  | AppsListWebhookDeliveries200ResponseBody
  | AppsListWebhookDeliveries400ResponseBody
  | AppsListWebhookDeliveries422ResponseBody,
  unknown,
  AppsListWebhookDeliveriesRequestQuery,
  Record<string, any>
>;

export type AppsListWebhookDeliveriesResponse = Response<
  | AppsListWebhookDeliveries200ResponseBody
  | AppsListWebhookDeliveries400ResponseBody
  | AppsListWebhookDeliveries422ResponseBody,
  Record<string, any>,
  200 | 400 | 422
>;

export interface AppsListWebhookDeliveriesHandler {
  appsListWebhookDeliveries(
    req: AppsListWebhookDeliveriesRequest,
    res: AppsListWebhookDeliveriesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsGetWebhookDeliveryRequest = Request<
  AppsGetWebhookDeliveryRequestPath,
  | AppsGetWebhookDelivery200ResponseBody
  | AppsGetWebhookDelivery400ResponseBody
  | AppsGetWebhookDelivery422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetWebhookDeliveryResponse = Response<
  | AppsGetWebhookDelivery200ResponseBody
  | AppsGetWebhookDelivery400ResponseBody
  | AppsGetWebhookDelivery422ResponseBody,
  Record<string, any>,
  200 | 400 | 422
>;

export interface AppsGetWebhookDeliveryHandler {
  appsGetWebhookDelivery(
    req: AppsGetWebhookDeliveryRequest,
    res: AppsGetWebhookDeliveryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsRedeliverWebhookDeliveryRequest = Request<
  AppsRedeliverWebhookDeliveryRequestPath,
  | AppsRedeliverWebhookDelivery202ResponseBody
  | AppsRedeliverWebhookDelivery400ResponseBody
  | AppsRedeliverWebhookDelivery422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsRedeliverWebhookDeliveryResponse = Response<
  | AppsRedeliverWebhookDelivery202ResponseBody
  | AppsRedeliverWebhookDelivery400ResponseBody
  | AppsRedeliverWebhookDelivery422ResponseBody,
  Record<string, any>,
  202 | 400 | 422
>;

export interface AppsRedeliverWebhookDeliveryHandler {
  appsRedeliverWebhookDelivery(
    req: AppsRedeliverWebhookDeliveryRequest,
    res: AppsRedeliverWebhookDeliveryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsListInstallationsRequest = Request<
  ParamsDictionary,
  AppsListInstallations200ResponseBody,
  unknown,
  AppsListInstallationsRequestQuery,
  Record<string, any>
>;

export type AppsListInstallationsResponse = Response<
  AppsListInstallations200ResponseBody,
  Record<string, any>,
  200
>;

export interface AppsListInstallationsHandler {
  appsListInstallations(
    req: AppsListInstallationsRequest,
    res: AppsListInstallationsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsGetInstallationRequest = Request<
  AppsGetInstallationRequestPath,
  AppsGetInstallation200ResponseBody | AppsGetInstallation404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetInstallationResponse = Response<
  AppsGetInstallation200ResponseBody | AppsGetInstallation404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface AppsGetInstallationHandler {
  appsGetInstallation(
    req: AppsGetInstallationRequest,
    res: AppsGetInstallationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsDeleteInstallationRequest = Request<
  AppsDeleteInstallationRequestPath,
  AppsDeleteInstallation404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsDeleteInstallationResponse = Response<
  AppsDeleteInstallation404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface AppsDeleteInstallationHandler {
  appsDeleteInstallation(
    req: AppsDeleteInstallationRequest,
    res: AppsDeleteInstallationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsCreateInstallationAccessTokenRequest = Request<
  AppsCreateInstallationAccessTokenRequestPath,
  | AppsCreateInstallationAccessToken201ResponseBody
  | AppsCreateInstallationAccessToken401ResponseBody
  | AppsCreateInstallationAccessToken403ResponseBody
  | AppsCreateInstallationAccessToken404ResponseBody
  | AppsCreateInstallationAccessToken422ResponseBody,
  AppsCreateInstallationAccessTokenRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsCreateInstallationAccessTokenResponse = Response<
  | AppsCreateInstallationAccessToken201ResponseBody
  | AppsCreateInstallationAccessToken401ResponseBody
  | AppsCreateInstallationAccessToken403ResponseBody
  | AppsCreateInstallationAccessToken404ResponseBody
  | AppsCreateInstallationAccessToken422ResponseBody,
  Record<string, any>,
  201 | 401 | 403 | 404 | 422
>;

export interface AppsCreateInstallationAccessTokenHandler {
  appsCreateInstallationAccessToken(
    req: AppsCreateInstallationAccessTokenRequest,
    res: AppsCreateInstallationAccessTokenResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsSuspendInstallationRequest = Request<
  AppsSuspendInstallationRequestPath,
  AppsSuspendInstallation404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsSuspendInstallationResponse = Response<
  AppsSuspendInstallation404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface AppsSuspendInstallationHandler {
  appsSuspendInstallation(
    req: AppsSuspendInstallationRequest,
    res: AppsSuspendInstallationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsUnsuspendInstallationRequest = Request<
  AppsUnsuspendInstallationRequestPath,
  AppsUnsuspendInstallation404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsUnsuspendInstallationResponse = Response<
  AppsUnsuspendInstallation404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface AppsUnsuspendInstallationHandler {
  appsUnsuspendInstallation(
    req: AppsUnsuspendInstallationRequest,
    res: AppsUnsuspendInstallationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsDeleteAuthorizationRequest = Request<
  AppsDeleteAuthorizationRequestPath,
  AppsDeleteAuthorization422ResponseBody,
  AppsDeleteAuthorizationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsDeleteAuthorizationResponse = Response<
  AppsDeleteAuthorization422ResponseBody,
  Record<string, any>,
  204 | 422
>;

export interface AppsDeleteAuthorizationHandler {
  appsDeleteAuthorization(
    req: AppsDeleteAuthorizationRequest,
    res: AppsDeleteAuthorizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsCheckTokenRequest = Request<
  AppsCheckTokenRequestPath,
  | AppsCheckToken200ResponseBody
  | AppsCheckToken404ResponseBody
  | AppsCheckToken422ResponseBody,
  AppsCheckTokenRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsCheckTokenResponse = Response<
  | AppsCheckToken200ResponseBody
  | AppsCheckToken404ResponseBody
  | AppsCheckToken422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface AppsCheckTokenHandler {
  appsCheckToken(
    req: AppsCheckTokenRequest,
    res: AppsCheckTokenResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsResetTokenRequest = Request<
  AppsResetTokenRequestPath,
  AppsResetToken200ResponseBody | AppsResetToken422ResponseBody,
  AppsResetTokenRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsResetTokenResponse = Response<
  AppsResetToken200ResponseBody | AppsResetToken422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface AppsResetTokenHandler {
  appsResetToken(
    req: AppsResetTokenRequest,
    res: AppsResetTokenResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsDeleteTokenRequest = Request<
  AppsDeleteTokenRequestPath,
  AppsDeleteToken422ResponseBody,
  AppsDeleteTokenRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsDeleteTokenResponse = Response<
  AppsDeleteToken422ResponseBody,
  Record<string, any>,
  204 | 422
>;

export interface AppsDeleteTokenHandler {
  appsDeleteToken(
    req: AppsDeleteTokenRequest,
    res: AppsDeleteTokenResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsScopeTokenRequest = Request<
  AppsScopeTokenRequestPath,
  | AppsScopeToken200ResponseBody
  | AppsScopeToken401ResponseBody
  | AppsScopeToken403ResponseBody
  | AppsScopeToken404ResponseBody
  | AppsScopeToken422ResponseBody,
  AppsScopeTokenRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type AppsScopeTokenResponse = Response<
  | AppsScopeToken200ResponseBody
  | AppsScopeToken401ResponseBody
  | AppsScopeToken403ResponseBody
  | AppsScopeToken404ResponseBody
  | AppsScopeToken422ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404 | 422
>;

export interface AppsScopeTokenHandler {
  appsScopeToken(
    req: AppsScopeTokenRequest,
    res: AppsScopeTokenResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsGetBySlugRequest = Request<
  AppsGetBySlugRequestPath,
  | AppsGetBySlug200ResponseBody
  | AppsGetBySlug403ResponseBody
  | AppsGetBySlug404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetBySlugResponse = Response<
  | AppsGetBySlug200ResponseBody
  | AppsGetBySlug403ResponseBody
  | AppsGetBySlug404ResponseBody,
  Record<string, any>,
  200 | 403 | 404
>;

export interface AppsGetBySlugHandler {
  appsGetBySlug(
    req: AppsGetBySlugRequest,
    res: AppsGetBySlugResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodesOfConductGetAllCodesOfConductRequest = Request<
  ParamsDictionary,
  CodesOfConductGetAllCodesOfConduct200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodesOfConductGetAllCodesOfConductResponse = Response<
  CodesOfConductGetAllCodesOfConduct200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export interface CodesOfConductGetAllCodesOfConductHandler {
  codesOfConductGetAllCodesOfConduct(
    req: CodesOfConductGetAllCodesOfConductRequest,
    res: CodesOfConductGetAllCodesOfConductResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodesOfConductGetConductCodeRequest = Request<
  CodesOfConductGetConductCodeRequestPath,
  | CodesOfConductGetConductCode200ResponseBody
  | CodesOfConductGetConductCode404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodesOfConductGetConductCodeResponse = Response<
  | CodesOfConductGetConductCode200ResponseBody
  | CodesOfConductGetConductCode404ResponseBody,
  Record<string, any>,
  200 | 304 | 404
>;

export interface CodesOfConductGetConductCodeHandler {
  codesOfConductGetConductCode(
    req: CodesOfConductGetConductCodeRequest,
    res: CodesOfConductGetConductCodeResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EmojisGetRequest = Request<
  ParamsDictionary,
  EmojisGet200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EmojisGetResponse = Response<
  EmojisGet200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export interface EmojisGetHandler {
  emojisGet(
    req: EmojisGetRequest,
    res: EmojisGetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminGetServerStatisticsRequest = Request<
  EnterpriseAdminGetServerStatisticsRequestPath,
  EnterpriseAdminGetServerStatistics200ResponseBody,
  unknown,
  EnterpriseAdminGetServerStatisticsRequestQuery,
  Record<string, any>
>;

export type EnterpriseAdminGetServerStatisticsResponse = Response<
  EnterpriseAdminGetServerStatistics200ResponseBody,
  Record<string, any>,
  200
>;

export interface EnterpriseAdminGetServerStatisticsHandler {
  enterpriseAdminGetServerStatistics(
    req: EnterpriseAdminGetServerStatisticsRequest,
    res: EnterpriseAdminGetServerStatisticsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetActionsCacheUsageForEnterpriseRequest = Request<
  ActionsGetActionsCacheUsageForEnterpriseRequestPath,
  ActionsGetActionsCacheUsageForEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetActionsCacheUsageForEnterpriseResponse = Response<
  ActionsGetActionsCacheUsageForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetActionsCacheUsageForEnterpriseHandler {
  actionsGetActionsCacheUsageForEnterprise(
    req: ActionsGetActionsCacheUsageForEnterpriseRequest,
    res: ActionsGetActionsCacheUsageForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest = Request<
  EnterpriseAdminGetGithubActionsPermissionsEnterpriseRequestPath,
  EnterpriseAdminGetGithubActionsPermissionsEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse = Response<
  EnterpriseAdminGetGithubActionsPermissionsEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export interface EnterpriseAdminGetGithubActionsPermissionsEnterpriseHandler {
  enterpriseAdminGetGithubActionsPermissionsEnterprise(
    req: EnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest,
    res: EnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest = Request<
  EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequestPath,
  unknown,
  EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface EnterpriseAdminSetGithubActionsPermissionsEnterpriseHandler {
  enterpriseAdminSetGithubActionsPermissionsEnterprise(
    req: EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest,
    res: EnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest = Request<
  EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequestPath,
  EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200ResponseBody,
  unknown,
  EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequestQuery,
  Record<string, any>
>;

export type EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse = Response<
  EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export interface EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseHandler {
  enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(
    req: EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest,
    res: EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest = Request<
  EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequestPath,
  unknown,
  EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseHandler {
  enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(
    req: EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest,
    res: EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest = Request<
  EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseHandler {
  enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(
    req: EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest,
    res: EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest = Request<
  EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseHandler {
  enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(
    req: EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest,
    res: EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminGetAllowedActionsEnterpriseRequest = Request<
  EnterpriseAdminGetAllowedActionsEnterpriseRequestPath,
  EnterpriseAdminGetAllowedActionsEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminGetAllowedActionsEnterpriseResponse = Response<
  EnterpriseAdminGetAllowedActionsEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export interface EnterpriseAdminGetAllowedActionsEnterpriseHandler {
  enterpriseAdminGetAllowedActionsEnterprise(
    req: EnterpriseAdminGetAllowedActionsEnterpriseRequest,
    res: EnterpriseAdminGetAllowedActionsEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminSetAllowedActionsEnterpriseRequest = Request<
  EnterpriseAdminSetAllowedActionsEnterpriseRequestPath,
  unknown,
  EnterpriseAdminSetAllowedActionsEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminSetAllowedActionsEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface EnterpriseAdminSetAllowedActionsEnterpriseHandler {
  enterpriseAdminSetAllowedActionsEnterprise(
    req: EnterpriseAdminSetAllowedActionsEnterpriseRequest,
    res: EnterpriseAdminSetAllowedActionsEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest = Request<
  ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestPath,
  ActionsGetGithubActionsDefaultWorkflowPermissionsEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse = Response<
  ActionsGetGithubActionsDefaultWorkflowPermissionsEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler {
  actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise(
    req: ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest,
    res: ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest = Request<
  ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestPath,
  unknown,
  ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler {
  actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise(
    req: ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest,
    res: ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest = Request<
  EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequestPath,
  EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200ResponseBody,
  unknown,
  EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequestQuery,
  Record<string, any>
>;

export type EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse = Response<
  EnterpriseAdminListSelfHostedRunnerGroupsForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export interface EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseHandler {
  enterpriseAdminListSelfHostedRunnerGroupsForEnterprise(
    req: EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest,
    res: EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest = Request<
  EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequestPath,
  EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise201ResponseBody,
  EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse = Response<
  EnterpriseAdminCreateSelfHostedRunnerGroupForEnterprise201ResponseBody,
  Record<string, any>,
  201
>;

export interface EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseHandler {
  enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(
    req: EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest,
    res: EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest = Request<
  EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequestPath,
  EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse = Response<
  EnterpriseAdminGetSelfHostedRunnerGroupForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export interface EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseHandler {
  enterpriseAdminGetSelfHostedRunnerGroupForEnterprise(
    req: EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest,
    res: EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest = Request<
  EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequestPath,
  EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise200ResponseBody,
  EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse = Response<
  EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export interface EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseHandler {
  enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(
    req: EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest,
    res: EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest = Request<
  EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseHandler {
  enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(
    req: EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest,
    res: EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest = Request<
  EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath,
  EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise200ResponseBody,
  unknown,
  EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestQuery,
  Record<string, any>
>;

export type EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse = Response<
  EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export interface EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler {
  enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(
    req: EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
    res: EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest = Request<
  EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath,
  unknown,
  EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler {
  enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(
    req: EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
    res: EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest = Request<
  EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler {
  enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(
    req: EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
    res: EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest = Request<
  EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler {
  enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(
    req: EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
    res: EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest = Request<
  EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequestPath,
  EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200ResponseBody,
  unknown,
  EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequestQuery,
  Record<string, any>
>;

export type EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse = Response<
  EnterpriseAdminListSelfHostedRunnersInGroupForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export interface EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseHandler {
  enterpriseAdminListSelfHostedRunnersInGroupForEnterprise(
    req: EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest,
    res: EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest = Request<
  EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequestPath,
  unknown,
  EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseHandler {
  enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(
    req: EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest,
    res: EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest = Request<
  EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseHandler {
  enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(
    req: EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest,
    res: EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest = Request<
  EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseHandler {
  enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(
    req: EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest,
    res: EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminListSelfHostedRunnersForEnterpriseRequest = Request<
  EnterpriseAdminListSelfHostedRunnersForEnterpriseRequestPath,
  EnterpriseAdminListSelfHostedRunnersForEnterprise200ResponseBody,
  unknown,
  EnterpriseAdminListSelfHostedRunnersForEnterpriseRequestQuery,
  Record<string, any>
>;

export type EnterpriseAdminListSelfHostedRunnersForEnterpriseResponse = Response<
  EnterpriseAdminListSelfHostedRunnersForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export interface EnterpriseAdminListSelfHostedRunnersForEnterpriseHandler {
  enterpriseAdminListSelfHostedRunnersForEnterprise(
    req: EnterpriseAdminListSelfHostedRunnersForEnterpriseRequest,
    res: EnterpriseAdminListSelfHostedRunnersForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminListRunnerApplicationsForEnterpriseRequest = Request<
  EnterpriseAdminListRunnerApplicationsForEnterpriseRequestPath,
  EnterpriseAdminListRunnerApplicationsForEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminListRunnerApplicationsForEnterpriseResponse = Response<
  EnterpriseAdminListRunnerApplicationsForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export interface EnterpriseAdminListRunnerApplicationsForEnterpriseHandler {
  enterpriseAdminListRunnerApplicationsForEnterprise(
    req: EnterpriseAdminListRunnerApplicationsForEnterpriseRequest,
    res: EnterpriseAdminListRunnerApplicationsForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminCreateRegistrationTokenForEnterpriseRequest = Request<
  EnterpriseAdminCreateRegistrationTokenForEnterpriseRequestPath,
  EnterpriseAdminCreateRegistrationTokenForEnterprise201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminCreateRegistrationTokenForEnterpriseResponse = Response<
  EnterpriseAdminCreateRegistrationTokenForEnterprise201ResponseBody,
  Record<string, any>,
  201
>;

export interface EnterpriseAdminCreateRegistrationTokenForEnterpriseHandler {
  enterpriseAdminCreateRegistrationTokenForEnterprise(
    req: EnterpriseAdminCreateRegistrationTokenForEnterpriseRequest,
    res: EnterpriseAdminCreateRegistrationTokenForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminCreateRemoveTokenForEnterpriseRequest = Request<
  EnterpriseAdminCreateRemoveTokenForEnterpriseRequestPath,
  EnterpriseAdminCreateRemoveTokenForEnterprise201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminCreateRemoveTokenForEnterpriseResponse = Response<
  EnterpriseAdminCreateRemoveTokenForEnterprise201ResponseBody,
  Record<string, any>,
  201
>;

export interface EnterpriseAdminCreateRemoveTokenForEnterpriseHandler {
  enterpriseAdminCreateRemoveTokenForEnterprise(
    req: EnterpriseAdminCreateRemoveTokenForEnterpriseRequest,
    res: EnterpriseAdminCreateRemoveTokenForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest = Request<
  EnterpriseAdminGetSelfHostedRunnerForEnterpriseRequestPath,
  EnterpriseAdminGetSelfHostedRunnerForEnterprise200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse = Response<
  EnterpriseAdminGetSelfHostedRunnerForEnterprise200ResponseBody,
  Record<string, any>,
  200
>;

export interface EnterpriseAdminGetSelfHostedRunnerForEnterpriseHandler {
  enterpriseAdminGetSelfHostedRunnerForEnterprise(
    req: EnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest,
    res: EnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest = Request<
  EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseHandler {
  enterpriseAdminDeleteSelfHostedRunnerFromEnterprise(
    req: EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest,
    res: EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseRequest = Request<
  EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseRequestPath,
  | EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseResponse = Response<
  | EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminListLabelsForSelfHostedRunnerForEnterprise404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseHandler {
  enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise(
    req: EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseRequest,
    res: EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest = Request<
  EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequestPath,
  | EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise422ResponseBody,
  EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseResponse = Response<
  | EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseHandler {
  enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise(
    req: EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest,
    res: EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest = Request<
  EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequestPath,
  | EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise422ResponseBody,
  EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseResponse = Response<
  | EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseHandler {
  enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise(
    req: EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest,
    res: EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequest = Request<
  EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequestPath,
  | EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse = Response<
  | EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseHandler {
  enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise(
    req: EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequest,
    res: EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseRequest = Request<
  EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseRequestPath,
  | EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse = Response<
  | EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise200ResponseBody
  | EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise404ResponseBody
  | EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseHandler {
  enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise(
    req: EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseRequest,
    res: EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodeScanningListAlertsForEnterpriseRequest = Request<
  CodeScanningListAlertsForEnterpriseRequestPath,
  | CodeScanningListAlertsForEnterprise200ResponseBody
  | CodeScanningListAlertsForEnterprise404ResponseBody
  | CodeScanningListAlertsForEnterprise503ResponseBody,
  unknown,
  CodeScanningListAlertsForEnterpriseRequestQuery,
  Record<string, any>
>;

export type CodeScanningListAlertsForEnterpriseResponse = Response<
  | CodeScanningListAlertsForEnterprise200ResponseBody
  | CodeScanningListAlertsForEnterprise404ResponseBody
  | CodeScanningListAlertsForEnterprise503ResponseBody,
  Record<string, any>,
  200 | 404 | 503
>;

export interface CodeScanningListAlertsForEnterpriseHandler {
  codeScanningListAlertsForEnterprise(
    req: CodeScanningListAlertsForEnterpriseRequest,
    res: CodeScanningListAlertsForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type SecretScanningListAlertsForEnterpriseRequest = Request<
  SecretScanningListAlertsForEnterpriseRequestPath,
  | SecretScanningListAlertsForEnterprise200ResponseBody
  | SecretScanningListAlertsForEnterprise404ResponseBody
  | SecretScanningListAlertsForEnterprise503ResponseBody,
  unknown,
  SecretScanningListAlertsForEnterpriseRequestQuery,
  Record<string, any>
>;

export type SecretScanningListAlertsForEnterpriseResponse = Response<
  | SecretScanningListAlertsForEnterprise200ResponseBody
  | SecretScanningListAlertsForEnterprise404ResponseBody
  | SecretScanningListAlertsForEnterprise503ResponseBody,
  Record<string, any>,
  200 | 404 | 503
>;

export interface SecretScanningListAlertsForEnterpriseHandler {
  secretScanningListAlertsForEnterprise(
    req: SecretScanningListAlertsForEnterpriseRequest,
    res: SecretScanningListAlertsForEnterpriseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type BillingGetGithubAdvancedSecurityBillingGheRequest = Request<
  BillingGetGithubAdvancedSecurityBillingGheRequestPath,
  | BillingGetGithubAdvancedSecurityBillingGhe200ResponseBody
  | BillingGetGithubAdvancedSecurityBillingGhe403ResponseBody,
  unknown,
  BillingGetGithubAdvancedSecurityBillingGheRequestQuery,
  Record<string, any>
>;

export type BillingGetGithubAdvancedSecurityBillingGheResponse = Response<
  | BillingGetGithubAdvancedSecurityBillingGhe200ResponseBody
  | BillingGetGithubAdvancedSecurityBillingGhe403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export interface BillingGetGithubAdvancedSecurityBillingGheHandler {
  billingGetGithubAdvancedSecurityBillingGhe(
    req: BillingGetGithubAdvancedSecurityBillingGheRequest,
    res: BillingGetGithubAdvancedSecurityBillingGheResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListPublicEventsRequest = Request<
  ParamsDictionary,
  | ActivityListPublicEvents200ResponseBody
  | ActivityListPublicEvents403ResponseBody
  | ActivityListPublicEvents503ResponseBody,
  unknown,
  ActivityListPublicEventsRequestQuery,
  Record<string, any>
>;

export type ActivityListPublicEventsResponse = Response<
  | ActivityListPublicEvents200ResponseBody
  | ActivityListPublicEvents403ResponseBody
  | ActivityListPublicEvents503ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 503
>;

export interface ActivityListPublicEventsHandler {
  activityListPublicEvents(
    req: ActivityListPublicEventsRequest,
    res: ActivityListPublicEventsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityGetFeedsRequest = Request<
  ParamsDictionary,
  ActivityGetFeeds200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityGetFeedsResponse = Response<
  ActivityGetFeeds200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActivityGetFeedsHandler {
  activityGetFeeds(
    req: ActivityGetFeedsRequest,
    res: ActivityGetFeedsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsListRequest = Request<
  ParamsDictionary,
  GistsList200ResponseBody | GistsList403ResponseBody,
  unknown,
  GistsListRequestQuery,
  Record<string, any>
>;

export type GistsListResponse = Response<
  GistsList200ResponseBody | GistsList403ResponseBody,
  Record<string, any>,
  200 | 304 | 403
>;

export interface GistsListHandler {
  gistsList(
    req: GistsListRequest,
    res: GistsListResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsCreateRequest = Request<
  ParamsDictionary,
  | GistsCreate201ResponseBody
  | GistsCreate403ResponseBody
  | GistsCreate404ResponseBody
  | GistsCreate422ResponseBody,
  GistsCreateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GistsCreateResponse = Response<
  | GistsCreate201ResponseBody
  | GistsCreate403ResponseBody
  | GistsCreate404ResponseBody
  | GistsCreate422ResponseBody,
  Record<string, any>,
  201 | 304 | 403 | 404 | 422
>;

export interface GistsCreateHandler {
  gistsCreate(
    req: GistsCreateRequest,
    res: GistsCreateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsListPublicRequest = Request<
  ParamsDictionary,
  | GistsListPublic200ResponseBody
  | GistsListPublic403ResponseBody
  | GistsListPublic422ResponseBody,
  unknown,
  GistsListPublicRequestQuery,
  Record<string, any>
>;

export type GistsListPublicResponse = Response<
  | GistsListPublic200ResponseBody
  | GistsListPublic403ResponseBody
  | GistsListPublic422ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 422
>;

export interface GistsListPublicHandler {
  gistsListPublic(
    req: GistsListPublicRequest,
    res: GistsListPublicResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsListStarredRequest = Request<
  ParamsDictionary,
  | GistsListStarred200ResponseBody
  | GistsListStarred401ResponseBody
  | GistsListStarred403ResponseBody,
  unknown,
  GistsListStarredRequestQuery,
  Record<string, any>
>;

export type GistsListStarredResponse = Response<
  | GistsListStarred200ResponseBody
  | GistsListStarred401ResponseBody
  | GistsListStarred403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface GistsListStarredHandler {
  gistsListStarred(
    req: GistsListStarredRequest,
    res: GistsListStarredResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsGetRequest = Request<
  GistsGetRequestPath,
  GistsGet200ResponseBody | GistsGet403ResponseBody | GistsGet404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsGetResponse = Response<
  GistsGet200ResponseBody | GistsGet403ResponseBody | GistsGet404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export interface GistsGetHandler {
  gistsGet(
    req: GistsGetRequest,
    res: GistsGetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsUpdateRequest = Request<
  GistsUpdateRequestPath,
  | GistsUpdate200ResponseBody
  | GistsUpdate404ResponseBody
  | GistsUpdate422ResponseBody,
  GistsUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GistsUpdateResponse = Response<
  | GistsUpdate200ResponseBody
  | GistsUpdate404ResponseBody
  | GistsUpdate422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface GistsUpdateHandler {
  gistsUpdate(
    req: GistsUpdateRequest,
    res: GistsUpdateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsDeleteRequest = Request<
  GistsDeleteRequestPath,
  GistsDelete403ResponseBody | GistsDelete404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsDeleteResponse = Response<
  GistsDelete403ResponseBody | GistsDelete404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export interface GistsDeleteHandler {
  gistsDelete(
    req: GistsDeleteRequest,
    res: GistsDeleteResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsListCommentsRequest = Request<
  GistsListCommentsRequestPath,
  | GistsListComments200ResponseBody
  | GistsListComments403ResponseBody
  | GistsListComments404ResponseBody,
  unknown,
  GistsListCommentsRequestQuery,
  Record<string, any>
>;

export type GistsListCommentsResponse = Response<
  | GistsListComments200ResponseBody
  | GistsListComments403ResponseBody
  | GistsListComments404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export interface GistsListCommentsHandler {
  gistsListComments(
    req: GistsListCommentsRequest,
    res: GistsListCommentsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsCreateCommentRequest = Request<
  GistsCreateCommentRequestPath,
  | GistsCreateComment201ResponseBody
  | GistsCreateComment403ResponseBody
  | GistsCreateComment404ResponseBody,
  GistsCreateCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GistsCreateCommentResponse = Response<
  | GistsCreateComment201ResponseBody
  | GistsCreateComment403ResponseBody
  | GistsCreateComment404ResponseBody,
  Record<string, any>,
  201 | 304 | 403 | 404
>;

export interface GistsCreateCommentHandler {
  gistsCreateComment(
    req: GistsCreateCommentRequest,
    res: GistsCreateCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsGetCommentRequest = Request<
  GistsGetCommentRequestPath,
  | GistsGetComment200ResponseBody
  | GistsGetComment403ResponseBody
  | GistsGetComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsGetCommentResponse = Response<
  | GistsGetComment200ResponseBody
  | GistsGetComment403ResponseBody
  | GistsGetComment404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export interface GistsGetCommentHandler {
  gistsGetComment(
    req: GistsGetCommentRequest,
    res: GistsGetCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsUpdateCommentRequest = Request<
  GistsUpdateCommentRequestPath,
  GistsUpdateComment200ResponseBody | GistsUpdateComment404ResponseBody,
  GistsUpdateCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GistsUpdateCommentResponse = Response<
  GistsUpdateComment200ResponseBody | GistsUpdateComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface GistsUpdateCommentHandler {
  gistsUpdateComment(
    req: GistsUpdateCommentRequest,
    res: GistsUpdateCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsDeleteCommentRequest = Request<
  GistsDeleteCommentRequestPath,
  GistsDeleteComment403ResponseBody | GistsDeleteComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsDeleteCommentResponse = Response<
  GistsDeleteComment403ResponseBody | GistsDeleteComment404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export interface GistsDeleteCommentHandler {
  gistsDeleteComment(
    req: GistsDeleteCommentRequest,
    res: GistsDeleteCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsListCommitsRequest = Request<
  GistsListCommitsRequestPath,
  | GistsListCommits200ResponseBody
  | GistsListCommits403ResponseBody
  | GistsListCommits404ResponseBody,
  unknown,
  GistsListCommitsRequestQuery,
  Record<string, any>
>;

export type GistsListCommitsResponse = Response<
  | GistsListCommits200ResponseBody
  | GistsListCommits403ResponseBody
  | GistsListCommits404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export interface GistsListCommitsHandler {
  gistsListCommits(
    req: GistsListCommitsRequest,
    res: GistsListCommitsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsListForksRequest = Request<
  GistsListForksRequestPath,
  | GistsListForks200ResponseBody
  | GistsListForks403ResponseBody
  | GistsListForks404ResponseBody,
  unknown,
  GistsListForksRequestQuery,
  Record<string, any>
>;

export type GistsListForksResponse = Response<
  | GistsListForks200ResponseBody
  | GistsListForks403ResponseBody
  | GistsListForks404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export interface GistsListForksHandler {
  gistsListForks(
    req: GistsListForksRequest,
    res: GistsListForksResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsForkRequest = Request<
  GistsForkRequestPath,
  | GistsFork201ResponseBody
  | GistsFork403ResponseBody
  | GistsFork404ResponseBody
  | GistsFork422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsForkResponse = Response<
  | GistsFork201ResponseBody
  | GistsFork403ResponseBody
  | GistsFork404ResponseBody
  | GistsFork422ResponseBody,
  Record<string, any>,
  201 | 304 | 403 | 404 | 422
>;

export interface GistsForkHandler {
  gistsFork(
    req: GistsForkRequest,
    res: GistsForkResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsCheckIsStarredRequest = Request<
  GistsCheckIsStarredRequestPath,
  GistsCheckIsStarred403ResponseBody | GistsCheckIsStarred404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsCheckIsStarredResponse = Response<
  GistsCheckIsStarred403ResponseBody | GistsCheckIsStarred404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export interface GistsCheckIsStarredHandler {
  gistsCheckIsStarred(
    req: GistsCheckIsStarredRequest,
    res: GistsCheckIsStarredResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsStarRequest = Request<
  GistsStarRequestPath,
  GistsStar403ResponseBody | GistsStar404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsStarResponse = Response<
  GistsStar403ResponseBody | GistsStar404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export interface GistsStarHandler {
  gistsStar(
    req: GistsStarRequest,
    res: GistsStarResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsUnstarRequest = Request<
  GistsUnstarRequestPath,
  GistsUnstar403ResponseBody | GistsUnstar404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsUnstarResponse = Response<
  GistsUnstar403ResponseBody | GistsUnstar404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export interface GistsUnstarHandler {
  gistsUnstar(
    req: GistsUnstarRequest,
    res: GistsUnstarResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsGetRevisionRequest = Request<
  GistsGetRevisionRequestPath,
  | GistsGetRevision200ResponseBody
  | GistsGetRevision403ResponseBody
  | GistsGetRevision404ResponseBody
  | GistsGetRevision422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GistsGetRevisionResponse = Response<
  | GistsGetRevision200ResponseBody
  | GistsGetRevision403ResponseBody
  | GistsGetRevision404ResponseBody
  | GistsGetRevision422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export interface GistsGetRevisionHandler {
  gistsGetRevision(
    req: GistsGetRevisionRequest,
    res: GistsGetRevisionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitignoreGetAllTemplatesRequest = Request<
  ParamsDictionary,
  GitignoreGetAllTemplates200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitignoreGetAllTemplatesResponse = Response<
  GitignoreGetAllTemplates200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export interface GitignoreGetAllTemplatesHandler {
  gitignoreGetAllTemplates(
    req: GitignoreGetAllTemplatesRequest,
    res: GitignoreGetAllTemplatesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitignoreGetTemplateRequest = Request<
  GitignoreGetTemplateRequestPath,
  GitignoreGetTemplate200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitignoreGetTemplateResponse = Response<
  GitignoreGetTemplate200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export interface GitignoreGetTemplateHandler {
  gitignoreGetTemplate(
    req: GitignoreGetTemplateRequest,
    res: GitignoreGetTemplateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsListReposAccessibleToInstallationRequest = Request<
  ParamsDictionary,
  | AppsListReposAccessibleToInstallation200ResponseBody
  | AppsListReposAccessibleToInstallation401ResponseBody
  | AppsListReposAccessibleToInstallation403ResponseBody,
  unknown,
  AppsListReposAccessibleToInstallationRequestQuery,
  Record<string, any>
>;

export type AppsListReposAccessibleToInstallationResponse = Response<
  | AppsListReposAccessibleToInstallation200ResponseBody
  | AppsListReposAccessibleToInstallation401ResponseBody
  | AppsListReposAccessibleToInstallation403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface AppsListReposAccessibleToInstallationHandler {
  appsListReposAccessibleToInstallation(
    req: AppsListReposAccessibleToInstallationRequest,
    res: AppsListReposAccessibleToInstallationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsRevokeInstallationAccessTokenRequest = Request<
  ParamsDictionary,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsRevokeInstallationAccessTokenResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface AppsRevokeInstallationAccessTokenHandler {
  appsRevokeInstallationAccessToken(
    req: AppsRevokeInstallationAccessTokenRequest,
    res: AppsRevokeInstallationAccessTokenResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListRequest = Request<
  ParamsDictionary,
  | IssuesList200ResponseBody
  | IssuesList404ResponseBody
  | IssuesList422ResponseBody,
  unknown,
  IssuesListRequestQuery,
  Record<string, any>
>;

export type IssuesListResponse = Response<
  | IssuesList200ResponseBody
  | IssuesList404ResponseBody
  | IssuesList422ResponseBody,
  Record<string, any>,
  200 | 304 | 404 | 422
>;

export interface IssuesListHandler {
  issuesList(
    req: IssuesListRequest,
    res: IssuesListResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type LicensesGetAllCommonlyUsedRequest = Request<
  ParamsDictionary,
  LicensesGetAllCommonlyUsed200ResponseBody,
  unknown,
  LicensesGetAllCommonlyUsedRequestQuery,
  Record<string, any>
>;

export type LicensesGetAllCommonlyUsedResponse = Response<
  LicensesGetAllCommonlyUsed200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export interface LicensesGetAllCommonlyUsedHandler {
  licensesGetAllCommonlyUsed(
    req: LicensesGetAllCommonlyUsedRequest,
    res: LicensesGetAllCommonlyUsedResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type LicensesGetRequest = Request<
  LicensesGetRequestPath,
  | LicensesGet200ResponseBody
  | LicensesGet403ResponseBody
  | LicensesGet404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type LicensesGetResponse = Response<
  | LicensesGet200ResponseBody
  | LicensesGet403ResponseBody
  | LicensesGet404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export interface LicensesGetHandler {
  licensesGet(
    req: LicensesGetRequest,
    res: LicensesGetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MarkdownRenderRequest = Request<
  ParamsDictionary,
  unknown,
  MarkdownRenderRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MarkdownRenderResponse = Response<
  unknown,
  Record<string, any>,
  200 | 304
>;

export interface MarkdownRenderHandler {
  markdownRender(
    req: MarkdownRenderRequest,
    res: MarkdownRenderResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MarkdownRenderRawRequest = Request<
  ParamsDictionary,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MarkdownRenderRawResponse = Response<
  unknown,
  Record<string, any>,
  200 | 304
>;

export interface MarkdownRenderRawHandler {
  markdownRenderRaw(
    req: MarkdownRenderRawRequest,
    res: MarkdownRenderRawResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsGetSubscriptionPlanForAccountRequest = Request<
  AppsGetSubscriptionPlanForAccountRequestPath,
  | AppsGetSubscriptionPlanForAccount200ResponseBody
  | AppsGetSubscriptionPlanForAccount401ResponseBody
  | AppsGetSubscriptionPlanForAccount404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetSubscriptionPlanForAccountResponse = Response<
  | AppsGetSubscriptionPlanForAccount200ResponseBody
  | AppsGetSubscriptionPlanForAccount401ResponseBody
  | AppsGetSubscriptionPlanForAccount404ResponseBody,
  Record<string, any>,
  200 | 401 | 404
>;

export interface AppsGetSubscriptionPlanForAccountHandler {
  appsGetSubscriptionPlanForAccount(
    req: AppsGetSubscriptionPlanForAccountRequest,
    res: AppsGetSubscriptionPlanForAccountResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsListPlansRequest = Request<
  ParamsDictionary,
  | AppsListPlans200ResponseBody
  | AppsListPlans401ResponseBody
  | AppsListPlans404ResponseBody,
  unknown,
  AppsListPlansRequestQuery,
  Record<string, any>
>;

export type AppsListPlansResponse = Response<
  | AppsListPlans200ResponseBody
  | AppsListPlans401ResponseBody
  | AppsListPlans404ResponseBody,
  Record<string, any>,
  200 | 401 | 404
>;

export interface AppsListPlansHandler {
  appsListPlans(
    req: AppsListPlansRequest,
    res: AppsListPlansResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsListAccountsForPlanRequest = Request<
  AppsListAccountsForPlanRequestPath,
  | AppsListAccountsForPlan200ResponseBody
  | AppsListAccountsForPlan401ResponseBody
  | AppsListAccountsForPlan404ResponseBody
  | AppsListAccountsForPlan422ResponseBody,
  unknown,
  AppsListAccountsForPlanRequestQuery,
  Record<string, any>
>;

export type AppsListAccountsForPlanResponse = Response<
  | AppsListAccountsForPlan200ResponseBody
  | AppsListAccountsForPlan401ResponseBody
  | AppsListAccountsForPlan404ResponseBody
  | AppsListAccountsForPlan422ResponseBody,
  Record<string, any>,
  200 | 401 | 404 | 422
>;

export interface AppsListAccountsForPlanHandler {
  appsListAccountsForPlan(
    req: AppsListAccountsForPlanRequest,
    res: AppsListAccountsForPlanResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsGetSubscriptionPlanForAccountStubbedRequest = Request<
  AppsGetSubscriptionPlanForAccountStubbedRequestPath,
  | AppsGetSubscriptionPlanForAccountStubbed200ResponseBody
  | AppsGetSubscriptionPlanForAccountStubbed401ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetSubscriptionPlanForAccountStubbedResponse = Response<
  | AppsGetSubscriptionPlanForAccountStubbed200ResponseBody
  | AppsGetSubscriptionPlanForAccountStubbed401ResponseBody,
  Record<string, any>,
  200 | 401 | 404
>;

export interface AppsGetSubscriptionPlanForAccountStubbedHandler {
  appsGetSubscriptionPlanForAccountStubbed(
    req: AppsGetSubscriptionPlanForAccountStubbedRequest,
    res: AppsGetSubscriptionPlanForAccountStubbedResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsListPlansStubbedRequest = Request<
  ParamsDictionary,
  AppsListPlansStubbed200ResponseBody | AppsListPlansStubbed401ResponseBody,
  unknown,
  AppsListPlansStubbedRequestQuery,
  Record<string, any>
>;

export type AppsListPlansStubbedResponse = Response<
  AppsListPlansStubbed200ResponseBody | AppsListPlansStubbed401ResponseBody,
  Record<string, any>,
  200 | 401
>;

export interface AppsListPlansStubbedHandler {
  appsListPlansStubbed(
    req: AppsListPlansStubbedRequest,
    res: AppsListPlansStubbedResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsListAccountsForPlanStubbedRequest = Request<
  AppsListAccountsForPlanStubbedRequestPath,
  | AppsListAccountsForPlanStubbed200ResponseBody
  | AppsListAccountsForPlanStubbed401ResponseBody,
  unknown,
  AppsListAccountsForPlanStubbedRequestQuery,
  Record<string, any>
>;

export type AppsListAccountsForPlanStubbedResponse = Response<
  | AppsListAccountsForPlanStubbed200ResponseBody
  | AppsListAccountsForPlanStubbed401ResponseBody,
  Record<string, any>,
  200 | 401
>;

export interface AppsListAccountsForPlanStubbedHandler {
  appsListAccountsForPlanStubbed(
    req: AppsListAccountsForPlanStubbedRequest,
    res: AppsListAccountsForPlanStubbedResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MetaGetRequest = Request<
  ParamsDictionary,
  MetaGet200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MetaGetResponse = Response<
  MetaGet200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export interface MetaGetHandler {
  metaGet(
    req: MetaGetRequest,
    res: MetaGetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListPublicEventsForRepoNetworkRequest = Request<
  ActivityListPublicEventsForRepoNetworkRequestPath,
  | ActivityListPublicEventsForRepoNetwork200ResponseBody
  | ActivityListPublicEventsForRepoNetwork301ResponseBody
  | ActivityListPublicEventsForRepoNetwork403ResponseBody
  | ActivityListPublicEventsForRepoNetwork404ResponseBody,
  unknown,
  ActivityListPublicEventsForRepoNetworkRequestQuery,
  Record<string, any>
>;

export type ActivityListPublicEventsForRepoNetworkResponse = Response<
  | ActivityListPublicEventsForRepoNetwork200ResponseBody
  | ActivityListPublicEventsForRepoNetwork301ResponseBody
  | ActivityListPublicEventsForRepoNetwork403ResponseBody
  | ActivityListPublicEventsForRepoNetwork404ResponseBody,
  Record<string, any>,
  200 | 301 | 304 | 403 | 404
>;

export interface ActivityListPublicEventsForRepoNetworkHandler {
  activityListPublicEventsForRepoNetwork(
    req: ActivityListPublicEventsForRepoNetworkRequest,
    res: ActivityListPublicEventsForRepoNetworkResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListNotificationsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ActivityListNotificationsForAuthenticatedUser200ResponseBody
  | ActivityListNotificationsForAuthenticatedUser401ResponseBody
  | ActivityListNotificationsForAuthenticatedUser403ResponseBody
  | ActivityListNotificationsForAuthenticatedUser422ResponseBody,
  unknown,
  ActivityListNotificationsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ActivityListNotificationsForAuthenticatedUserResponse = Response<
  | ActivityListNotificationsForAuthenticatedUser200ResponseBody
  | ActivityListNotificationsForAuthenticatedUser401ResponseBody
  | ActivityListNotificationsForAuthenticatedUser403ResponseBody
  | ActivityListNotificationsForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 422
>;

export interface ActivityListNotificationsForAuthenticatedUserHandler {
  activityListNotificationsForAuthenticatedUser(
    req: ActivityListNotificationsForAuthenticatedUserRequest,
    res: ActivityListNotificationsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityMarkNotificationsAsReadRequest = Request<
  ParamsDictionary,
  | ActivityMarkNotificationsAsRead202ResponseBody
  | ActivityMarkNotificationsAsRead401ResponseBody
  | ActivityMarkNotificationsAsRead403ResponseBody,
  ActivityMarkNotificationsAsReadRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActivityMarkNotificationsAsReadResponse = Response<
  | ActivityMarkNotificationsAsRead202ResponseBody
  | ActivityMarkNotificationsAsRead401ResponseBody
  | ActivityMarkNotificationsAsRead403ResponseBody,
  Record<string, any>,
  202 | 205 | 304 | 401 | 403
>;

export interface ActivityMarkNotificationsAsReadHandler {
  activityMarkNotificationsAsRead(
    req: ActivityMarkNotificationsAsReadRequest,
    res: ActivityMarkNotificationsAsReadResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityGetThreadRequest = Request<
  ActivityGetThreadRequestPath,
  | ActivityGetThread200ResponseBody
  | ActivityGetThread401ResponseBody
  | ActivityGetThread403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityGetThreadResponse = Response<
  | ActivityGetThread200ResponseBody
  | ActivityGetThread401ResponseBody
  | ActivityGetThread403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface ActivityGetThreadHandler {
  activityGetThread(
    req: ActivityGetThreadRequest,
    res: ActivityGetThreadResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityMarkThreadAsReadRequest = Request<
  ActivityMarkThreadAsReadRequestPath,
  ActivityMarkThreadAsRead403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityMarkThreadAsReadResponse = Response<
  ActivityMarkThreadAsRead403ResponseBody,
  Record<string, any>,
  205 | 304 | 403
>;

export interface ActivityMarkThreadAsReadHandler {
  activityMarkThreadAsRead(
    req: ActivityMarkThreadAsReadRequest,
    res: ActivityMarkThreadAsReadResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityGetThreadSubscriptionForAuthenticatedUserRequest = Request<
  ActivityGetThreadSubscriptionForAuthenticatedUserRequestPath,
  | ActivityGetThreadSubscriptionForAuthenticatedUser200ResponseBody
  | ActivityGetThreadSubscriptionForAuthenticatedUser401ResponseBody
  | ActivityGetThreadSubscriptionForAuthenticatedUser403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityGetThreadSubscriptionForAuthenticatedUserResponse = Response<
  | ActivityGetThreadSubscriptionForAuthenticatedUser200ResponseBody
  | ActivityGetThreadSubscriptionForAuthenticatedUser401ResponseBody
  | ActivityGetThreadSubscriptionForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface ActivityGetThreadSubscriptionForAuthenticatedUserHandler {
  activityGetThreadSubscriptionForAuthenticatedUser(
    req: ActivityGetThreadSubscriptionForAuthenticatedUserRequest,
    res: ActivityGetThreadSubscriptionForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivitySetThreadSubscriptionRequest = Request<
  ActivitySetThreadSubscriptionRequestPath,
  | ActivitySetThreadSubscription200ResponseBody
  | ActivitySetThreadSubscription401ResponseBody
  | ActivitySetThreadSubscription403ResponseBody,
  ActivitySetThreadSubscriptionRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActivitySetThreadSubscriptionResponse = Response<
  | ActivitySetThreadSubscription200ResponseBody
  | ActivitySetThreadSubscription401ResponseBody
  | ActivitySetThreadSubscription403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface ActivitySetThreadSubscriptionHandler {
  activitySetThreadSubscription(
    req: ActivitySetThreadSubscriptionRequest,
    res: ActivitySetThreadSubscriptionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityDeleteThreadSubscriptionRequest = Request<
  ActivityDeleteThreadSubscriptionRequestPath,
  | ActivityDeleteThreadSubscription401ResponseBody
  | ActivityDeleteThreadSubscription403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityDeleteThreadSubscriptionResponse = Response<
  | ActivityDeleteThreadSubscription401ResponseBody
  | ActivityDeleteThreadSubscription403ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403
>;

export interface ActivityDeleteThreadSubscriptionHandler {
  activityDeleteThreadSubscription(
    req: ActivityDeleteThreadSubscriptionRequest,
    res: ActivityDeleteThreadSubscriptionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MetaGetOctocatRequest = Request<
  ParamsDictionary,
  unknown,
  unknown,
  MetaGetOctocatRequestQuery,
  Record<string, any>
>;

export type MetaGetOctocatResponse = Response<
  unknown,
  Record<string, any>,
  200
>;

export interface MetaGetOctocatHandler {
  metaGetOctocat(
    req: MetaGetOctocatRequest,
    res: MetaGetOctocatResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListRequest = Request<
  ParamsDictionary,
  OrgsList200ResponseBody,
  unknown,
  OrgsListRequestQuery,
  Record<string, any>
>;

export type OrgsListResponse = Response<
  OrgsList200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export interface OrgsListHandler {
  orgsList(
    req: OrgsListRequest,
    res: OrgsListResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListCustomRolesRequest = Request<
  OrgsListCustomRolesRequestPath,
  OrgsListCustomRoles200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsListCustomRolesResponse = Response<
  OrgsListCustomRoles200ResponseBody,
  Record<string, any>,
  200
>;

export interface OrgsListCustomRolesHandler {
  orgsListCustomRoles(
    req: OrgsListCustomRolesRequest,
    res: OrgsListCustomRolesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsGetRequest = Request<
  OrgsGetRequestPath,
  OrgsGet200ResponseBody | OrgsGet404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetResponse = Response<
  OrgsGet200ResponseBody | OrgsGet404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface OrgsGetHandler {
  orgsGet(
    req: OrgsGetRequest,
    res: OrgsGetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsUpdateRequest = Request<
  OrgsUpdateRequestPath,
  | OrgsUpdate200ResponseBody
  | OrgsUpdate409ResponseBody
  | OrgsUpdate422ResponseBody,
  OrgsUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsUpdateResponse = Response<
  | OrgsUpdate200ResponseBody
  | OrgsUpdate409ResponseBody
  | OrgsUpdate422ResponseBody,
  Record<string, any>,
  200 | 409 | 422
>;

export interface OrgsUpdateHandler {
  orgsUpdate(
    req: OrgsUpdateRequest,
    res: OrgsUpdateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetActionsCacheUsageForOrgRequest = Request<
  ActionsGetActionsCacheUsageForOrgRequestPath,
  ActionsGetActionsCacheUsageForOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetActionsCacheUsageForOrgResponse = Response<
  ActionsGetActionsCacheUsageForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetActionsCacheUsageForOrgHandler {
  actionsGetActionsCacheUsageForOrg(
    req: ActionsGetActionsCacheUsageForOrgRequest,
    res: ActionsGetActionsCacheUsageForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetActionsCacheUsageByRepoForOrgRequest = Request<
  ActionsGetActionsCacheUsageByRepoForOrgRequestPath,
  ActionsGetActionsCacheUsageByRepoForOrg200ResponseBody,
  unknown,
  ActionsGetActionsCacheUsageByRepoForOrgRequestQuery,
  Record<string, any>
>;

export type ActionsGetActionsCacheUsageByRepoForOrgResponse = Response<
  ActionsGetActionsCacheUsageByRepoForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetActionsCacheUsageByRepoForOrgHandler {
  actionsGetActionsCacheUsageByRepoForOrg(
    req: ActionsGetActionsCacheUsageByRepoForOrgRequest,
    res: ActionsGetActionsCacheUsageByRepoForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetGithubActionsPermissionsOrganizationRequest = Request<
  ActionsGetGithubActionsPermissionsOrganizationRequestPath,
  ActionsGetGithubActionsPermissionsOrganization200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetGithubActionsPermissionsOrganizationResponse = Response<
  ActionsGetGithubActionsPermissionsOrganization200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetGithubActionsPermissionsOrganizationHandler {
  actionsGetGithubActionsPermissionsOrganization(
    req: ActionsGetGithubActionsPermissionsOrganizationRequest,
    res: ActionsGetGithubActionsPermissionsOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetGithubActionsPermissionsOrganizationRequest = Request<
  ActionsSetGithubActionsPermissionsOrganizationRequestPath,
  unknown,
  ActionsSetGithubActionsPermissionsOrganizationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetGithubActionsPermissionsOrganizationResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsSetGithubActionsPermissionsOrganizationHandler {
  actionsSetGithubActionsPermissionsOrganization(
    req: ActionsSetGithubActionsPermissionsOrganizationRequest,
    res: ActionsSetGithubActionsPermissionsOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest = Request<
  ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequestPath,
  ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200ResponseBody,
  unknown,
  ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequestQuery,
  Record<string, any>
>;

export type ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse = Response<
  ActionsListSelectedRepositoriesEnabledGithubActionsOrganization200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationHandler {
  actionsListSelectedRepositoriesEnabledGithubActionsOrganization(
    req: ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest,
    res: ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest = Request<
  ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestPath,
  unknown,
  ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationHandler {
  actionsSetSelectedRepositoriesEnabledGithubActionsOrganization(
    req: ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest,
    res: ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsEnableSelectedRepositoryGithubActionsOrganizationRequest = Request<
  ActionsEnableSelectedRepositoryGithubActionsOrganizationRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsEnableSelectedRepositoryGithubActionsOrganizationResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsEnableSelectedRepositoryGithubActionsOrganizationHandler {
  actionsEnableSelectedRepositoryGithubActionsOrganization(
    req: ActionsEnableSelectedRepositoryGithubActionsOrganizationRequest,
    res: ActionsEnableSelectedRepositoryGithubActionsOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDisableSelectedRepositoryGithubActionsOrganizationRequest = Request<
  ActionsDisableSelectedRepositoryGithubActionsOrganizationRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDisableSelectedRepositoryGithubActionsOrganizationResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsDisableSelectedRepositoryGithubActionsOrganizationHandler {
  actionsDisableSelectedRepositoryGithubActionsOrganization(
    req: ActionsDisableSelectedRepositoryGithubActionsOrganizationRequest,
    res: ActionsDisableSelectedRepositoryGithubActionsOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetAllowedActionsOrganizationRequest = Request<
  ActionsGetAllowedActionsOrganizationRequestPath,
  ActionsGetAllowedActionsOrganization200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetAllowedActionsOrganizationResponse = Response<
  ActionsGetAllowedActionsOrganization200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetAllowedActionsOrganizationHandler {
  actionsGetAllowedActionsOrganization(
    req: ActionsGetAllowedActionsOrganizationRequest,
    res: ActionsGetAllowedActionsOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetAllowedActionsOrganizationRequest = Request<
  ActionsSetAllowedActionsOrganizationRequestPath,
  unknown,
  ActionsSetAllowedActionsOrganizationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetAllowedActionsOrganizationResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsSetAllowedActionsOrganizationHandler {
  actionsSetAllowedActionsOrganization(
    req: ActionsSetAllowedActionsOrganizationRequest,
    res: ActionsSetAllowedActionsOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest = Request<
  ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequestPath,
  ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse = Response<
  ActionsGetGithubActionsDefaultWorkflowPermissionsOrganization200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationHandler {
  actionsGetGithubActionsDefaultWorkflowPermissionsOrganization(
    req: ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest,
    res: ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest = Request<
  ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequestPath,
  unknown,
  ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export interface ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationHandler {
  actionsSetGithubActionsDefaultWorkflowPermissionsOrganization(
    req: ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest,
    res: ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListSelfHostedRunnerGroupsForOrgRequest = Request<
  ActionsListSelfHostedRunnerGroupsForOrgRequestPath,
  ActionsListSelfHostedRunnerGroupsForOrg200ResponseBody,
  unknown,
  ActionsListSelfHostedRunnerGroupsForOrgRequestQuery,
  Record<string, any>
>;

export type ActionsListSelfHostedRunnerGroupsForOrgResponse = Response<
  ActionsListSelfHostedRunnerGroupsForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListSelfHostedRunnerGroupsForOrgHandler {
  actionsListSelfHostedRunnerGroupsForOrg(
    req: ActionsListSelfHostedRunnerGroupsForOrgRequest,
    res: ActionsListSelfHostedRunnerGroupsForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsCreateSelfHostedRunnerGroupForOrgRequest = Request<
  ActionsCreateSelfHostedRunnerGroupForOrgRequestPath,
  ActionsCreateSelfHostedRunnerGroupForOrg201ResponseBody,
  ActionsCreateSelfHostedRunnerGroupForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateSelfHostedRunnerGroupForOrgResponse = Response<
  ActionsCreateSelfHostedRunnerGroupForOrg201ResponseBody,
  Record<string, any>,
  201
>;

export interface ActionsCreateSelfHostedRunnerGroupForOrgHandler {
  actionsCreateSelfHostedRunnerGroupForOrg(
    req: ActionsCreateSelfHostedRunnerGroupForOrgRequest,
    res: ActionsCreateSelfHostedRunnerGroupForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetSelfHostedRunnerGroupForOrgRequest = Request<
  ActionsGetSelfHostedRunnerGroupForOrgRequestPath,
  ActionsGetSelfHostedRunnerGroupForOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetSelfHostedRunnerGroupForOrgResponse = Response<
  ActionsGetSelfHostedRunnerGroupForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetSelfHostedRunnerGroupForOrgHandler {
  actionsGetSelfHostedRunnerGroupForOrg(
    req: ActionsGetSelfHostedRunnerGroupForOrgRequest,
    res: ActionsGetSelfHostedRunnerGroupForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsUpdateSelfHostedRunnerGroupForOrgRequest = Request<
  ActionsUpdateSelfHostedRunnerGroupForOrgRequestPath,
  ActionsUpdateSelfHostedRunnerGroupForOrg200ResponseBody,
  ActionsUpdateSelfHostedRunnerGroupForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsUpdateSelfHostedRunnerGroupForOrgResponse = Response<
  ActionsUpdateSelfHostedRunnerGroupForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsUpdateSelfHostedRunnerGroupForOrgHandler {
  actionsUpdateSelfHostedRunnerGroupForOrg(
    req: ActionsUpdateSelfHostedRunnerGroupForOrgRequest,
    res: ActionsUpdateSelfHostedRunnerGroupForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDeleteSelfHostedRunnerGroupFromOrgRequest = Request<
  ActionsDeleteSelfHostedRunnerGroupFromOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteSelfHostedRunnerGroupFromOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsDeleteSelfHostedRunnerGroupFromOrgHandler {
  actionsDeleteSelfHostedRunnerGroupFromOrg(
    req: ActionsDeleteSelfHostedRunnerGroupFromOrgRequest,
    res: ActionsDeleteSelfHostedRunnerGroupFromOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest = Request<
  ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequestPath,
  ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200ResponseBody,
  unknown,
  ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequestQuery,
  Record<string, any>
>;

export type ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse = Response<
  ActionsListRepoAccessToSelfHostedRunnerGroupInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListRepoAccessToSelfHostedRunnerGroupInOrgHandler {
  actionsListRepoAccessToSelfHostedRunnerGroupInOrg(
    req: ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest,
    res: ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest = Request<
  ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestPath,
  unknown,
  ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgHandler {
  actionsSetRepoAccessToSelfHostedRunnerGroupInOrg(
    req: ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest,
    res: ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest = Request<
  ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgHandler {
  actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(
    req: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest,
    res: ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListSelfHostedRunnersInGroupForOrgRequest = Request<
  ActionsListSelfHostedRunnersInGroupForOrgRequestPath,
  ActionsListSelfHostedRunnersInGroupForOrg200ResponseBody,
  unknown,
  ActionsListSelfHostedRunnersInGroupForOrgRequestQuery,
  Record<string, any>
>;

export type ActionsListSelfHostedRunnersInGroupForOrgResponse = Response<
  ActionsListSelfHostedRunnersInGroupForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListSelfHostedRunnersInGroupForOrgHandler {
  actionsListSelfHostedRunnersInGroupForOrg(
    req: ActionsListSelfHostedRunnersInGroupForOrgRequest,
    res: ActionsListSelfHostedRunnersInGroupForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetSelfHostedRunnersInGroupForOrgRequest = Request<
  ActionsSetSelfHostedRunnersInGroupForOrgRequestPath,
  unknown,
  ActionsSetSelfHostedRunnersInGroupForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetSelfHostedRunnersInGroupForOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsSetSelfHostedRunnersInGroupForOrgHandler {
  actionsSetSelfHostedRunnersInGroupForOrg(
    req: ActionsSetSelfHostedRunnersInGroupForOrgRequest,
    res: ActionsSetSelfHostedRunnersInGroupForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsAddSelfHostedRunnerToGroupForOrgRequest = Request<
  ActionsAddSelfHostedRunnerToGroupForOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsAddSelfHostedRunnerToGroupForOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsAddSelfHostedRunnerToGroupForOrgHandler {
  actionsAddSelfHostedRunnerToGroupForOrg(
    req: ActionsAddSelfHostedRunnerToGroupForOrgRequest,
    res: ActionsAddSelfHostedRunnerToGroupForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsRemoveSelfHostedRunnerFromGroupForOrgRequest = Request<
  ActionsRemoveSelfHostedRunnerFromGroupForOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveSelfHostedRunnerFromGroupForOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsRemoveSelfHostedRunnerFromGroupForOrgHandler {
  actionsRemoveSelfHostedRunnerFromGroupForOrg(
    req: ActionsRemoveSelfHostedRunnerFromGroupForOrgRequest,
    res: ActionsRemoveSelfHostedRunnerFromGroupForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListSelfHostedRunnersForOrgRequest = Request<
  ActionsListSelfHostedRunnersForOrgRequestPath,
  ActionsListSelfHostedRunnersForOrg200ResponseBody,
  unknown,
  ActionsListSelfHostedRunnersForOrgRequestQuery,
  Record<string, any>
>;

export type ActionsListSelfHostedRunnersForOrgResponse = Response<
  ActionsListSelfHostedRunnersForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListSelfHostedRunnersForOrgHandler {
  actionsListSelfHostedRunnersForOrg(
    req: ActionsListSelfHostedRunnersForOrgRequest,
    res: ActionsListSelfHostedRunnersForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListRunnerApplicationsForOrgRequest = Request<
  ActionsListRunnerApplicationsForOrgRequestPath,
  ActionsListRunnerApplicationsForOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsListRunnerApplicationsForOrgResponse = Response<
  ActionsListRunnerApplicationsForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListRunnerApplicationsForOrgHandler {
  actionsListRunnerApplicationsForOrg(
    req: ActionsListRunnerApplicationsForOrgRequest,
    res: ActionsListRunnerApplicationsForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsCreateRegistrationTokenForOrgRequest = Request<
  ActionsCreateRegistrationTokenForOrgRequestPath,
  ActionsCreateRegistrationTokenForOrg201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateRegistrationTokenForOrgResponse = Response<
  ActionsCreateRegistrationTokenForOrg201ResponseBody,
  Record<string, any>,
  201
>;

export interface ActionsCreateRegistrationTokenForOrgHandler {
  actionsCreateRegistrationTokenForOrg(
    req: ActionsCreateRegistrationTokenForOrgRequest,
    res: ActionsCreateRegistrationTokenForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsCreateRemoveTokenForOrgRequest = Request<
  ActionsCreateRemoveTokenForOrgRequestPath,
  ActionsCreateRemoveTokenForOrg201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateRemoveTokenForOrgResponse = Response<
  ActionsCreateRemoveTokenForOrg201ResponseBody,
  Record<string, any>,
  201
>;

export interface ActionsCreateRemoveTokenForOrgHandler {
  actionsCreateRemoveTokenForOrg(
    req: ActionsCreateRemoveTokenForOrgRequest,
    res: ActionsCreateRemoveTokenForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetSelfHostedRunnerForOrgRequest = Request<
  ActionsGetSelfHostedRunnerForOrgRequestPath,
  ActionsGetSelfHostedRunnerForOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetSelfHostedRunnerForOrgResponse = Response<
  ActionsGetSelfHostedRunnerForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetSelfHostedRunnerForOrgHandler {
  actionsGetSelfHostedRunnerForOrg(
    req: ActionsGetSelfHostedRunnerForOrgRequest,
    res: ActionsGetSelfHostedRunnerForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDeleteSelfHostedRunnerFromOrgRequest = Request<
  ActionsDeleteSelfHostedRunnerFromOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteSelfHostedRunnerFromOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsDeleteSelfHostedRunnerFromOrgHandler {
  actionsDeleteSelfHostedRunnerFromOrg(
    req: ActionsDeleteSelfHostedRunnerFromOrgRequest,
    res: ActionsDeleteSelfHostedRunnerFromOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListLabelsForSelfHostedRunnerForOrgRequest = Request<
  ActionsListLabelsForSelfHostedRunnerForOrgRequestPath,
  | ActionsListLabelsForSelfHostedRunnerForOrg200ResponseBody
  | ActionsListLabelsForSelfHostedRunnerForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsListLabelsForSelfHostedRunnerForOrgResponse = Response<
  | ActionsListLabelsForSelfHostedRunnerForOrg200ResponseBody
  | ActionsListLabelsForSelfHostedRunnerForOrg404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ActionsListLabelsForSelfHostedRunnerForOrgHandler {
  actionsListLabelsForSelfHostedRunnerForOrg(
    req: ActionsListLabelsForSelfHostedRunnerForOrgRequest,
    res: ActionsListLabelsForSelfHostedRunnerForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest = Request<
  ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestPath,
  | ActionsAddCustomLabelsToSelfHostedRunnerForOrg200ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForOrg404ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForOrg422ResponseBody,
  ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse = Response<
  | ActionsAddCustomLabelsToSelfHostedRunnerForOrg200ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForOrg404ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForOrg422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface ActionsAddCustomLabelsToSelfHostedRunnerForOrgHandler {
  actionsAddCustomLabelsToSelfHostedRunnerForOrg(
    req: ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest,
    res: ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest = Request<
  ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestPath,
  | ActionsSetCustomLabelsForSelfHostedRunnerForOrg200ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForOrg404ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForOrg422ResponseBody,
  ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse = Response<
  | ActionsSetCustomLabelsForSelfHostedRunnerForOrg200ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForOrg404ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForOrg422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface ActionsSetCustomLabelsForSelfHostedRunnerForOrgHandler {
  actionsSetCustomLabelsForSelfHostedRunnerForOrg(
    req: ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest,
    res: ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest = Request<
  ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequestPath,
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg200ResponseBody
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse = Response<
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg200ResponseBody
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgHandler {
  actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg(
    req: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest,
    res: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest = Request<
  ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequestPath,
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg200ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg404ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse = Response<
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg200ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg404ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForOrg422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgHandler {
  actionsRemoveCustomLabelFromSelfHostedRunnerForOrg(
    req: ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest,
    res: ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListOrgSecretsRequest = Request<
  ActionsListOrgSecretsRequestPath,
  ActionsListOrgSecrets200ResponseBody,
  unknown,
  ActionsListOrgSecretsRequestQuery,
  Record<string, any>
>;

export type ActionsListOrgSecretsResponse = Response<
  ActionsListOrgSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListOrgSecretsHandler {
  actionsListOrgSecrets(
    req: ActionsListOrgSecretsRequest,
    res: ActionsListOrgSecretsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetOrgPublicKeyRequest = Request<
  ActionsGetOrgPublicKeyRequestPath,
  ActionsGetOrgPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetOrgPublicKeyResponse = Response<
  ActionsGetOrgPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetOrgPublicKeyHandler {
  actionsGetOrgPublicKey(
    req: ActionsGetOrgPublicKeyRequest,
    res: ActionsGetOrgPublicKeyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetOrgSecretRequest = Request<
  ActionsGetOrgSecretRequestPath,
  ActionsGetOrgSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetOrgSecretResponse = Response<
  ActionsGetOrgSecret200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetOrgSecretHandler {
  actionsGetOrgSecret(
    req: ActionsGetOrgSecretRequest,
    res: ActionsGetOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsCreateOrUpdateOrgSecretRequest = Request<
  ActionsCreateOrUpdateOrgSecretRequestPath,
  ActionsCreateOrUpdateOrgSecret201ResponseBody,
  ActionsCreateOrUpdateOrgSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateOrUpdateOrgSecretResponse = Response<
  ActionsCreateOrUpdateOrgSecret201ResponseBody,
  Record<string, any>,
  201 | 204
>;

export interface ActionsCreateOrUpdateOrgSecretHandler {
  actionsCreateOrUpdateOrgSecret(
    req: ActionsCreateOrUpdateOrgSecretRequest,
    res: ActionsCreateOrUpdateOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDeleteOrgSecretRequest = Request<
  ActionsDeleteOrgSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsDeleteOrgSecretHandler {
  actionsDeleteOrgSecret(
    req: ActionsDeleteOrgSecretRequest,
    res: ActionsDeleteOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListSelectedReposForOrgSecretRequest = Request<
  ActionsListSelectedReposForOrgSecretRequestPath,
  ActionsListSelectedReposForOrgSecret200ResponseBody,
  unknown,
  ActionsListSelectedReposForOrgSecretRequestQuery,
  Record<string, any>
>;

export type ActionsListSelectedReposForOrgSecretResponse = Response<
  ActionsListSelectedReposForOrgSecret200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListSelectedReposForOrgSecretHandler {
  actionsListSelectedReposForOrgSecret(
    req: ActionsListSelectedReposForOrgSecretRequest,
    res: ActionsListSelectedReposForOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetSelectedReposForOrgSecretRequest = Request<
  ActionsSetSelectedReposForOrgSecretRequestPath,
  unknown,
  ActionsSetSelectedReposForOrgSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetSelectedReposForOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsSetSelectedReposForOrgSecretHandler {
  actionsSetSelectedReposForOrgSecret(
    req: ActionsSetSelectedReposForOrgSecretRequest,
    res: ActionsSetSelectedReposForOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsAddSelectedRepoToOrgSecretRequest = Request<
  ActionsAddSelectedRepoToOrgSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsAddSelectedRepoToOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export interface ActionsAddSelectedRepoToOrgSecretHandler {
  actionsAddSelectedRepoToOrgSecret(
    req: ActionsAddSelectedRepoToOrgSecretRequest,
    res: ActionsAddSelectedRepoToOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsRemoveSelectedRepoFromOrgSecretRequest = Request<
  ActionsRemoveSelectedRepoFromOrgSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveSelectedRepoFromOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export interface ActionsRemoveSelectedRepoFromOrgSecretHandler {
  actionsRemoveSelectedRepoFromOrgSecret(
    req: ActionsRemoveSelectedRepoFromOrgSecretRequest,
    res: ActionsRemoveSelectedRepoFromOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListBlockedUsersRequest = Request<
  OrgsListBlockedUsersRequestPath,
  OrgsListBlockedUsers200ResponseBody,
  unknown,
  OrgsListBlockedUsersRequestQuery,
  Record<string, any>
>;

export type OrgsListBlockedUsersResponse = Response<
  OrgsListBlockedUsers200ResponseBody,
  Record<string, any>,
  200
>;

export interface OrgsListBlockedUsersHandler {
  orgsListBlockedUsers(
    req: OrgsListBlockedUsersRequest,
    res: OrgsListBlockedUsersResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsCheckBlockedUserRequest = Request<
  OrgsCheckBlockedUserRequestPath,
  OrgsCheckBlockedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCheckBlockedUserResponse = Response<
  OrgsCheckBlockedUser404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface OrgsCheckBlockedUserHandler {
  orgsCheckBlockedUser(
    req: OrgsCheckBlockedUserRequest,
    res: OrgsCheckBlockedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsBlockUserRequest = Request<
  OrgsBlockUserRequestPath,
  OrgsBlockUser422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsBlockUserResponse = Response<
  OrgsBlockUser422ResponseBody,
  Record<string, any>,
  204 | 422
>;

export interface OrgsBlockUserHandler {
  orgsBlockUser(
    req: OrgsBlockUserRequest,
    res: OrgsBlockUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsUnblockUserRequest = Request<
  OrgsUnblockUserRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsUnblockUserResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface OrgsUnblockUserHandler {
  orgsUnblockUser(
    req: OrgsUnblockUserRequest,
    res: OrgsUnblockUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodeScanningListAlertsForOrgRequest = Request<
  CodeScanningListAlertsForOrgRequestPath,
  | CodeScanningListAlertsForOrg200ResponseBody
  | CodeScanningListAlertsForOrg404ResponseBody
  | CodeScanningListAlertsForOrg503ResponseBody,
  unknown,
  CodeScanningListAlertsForOrgRequestQuery,
  Record<string, any>
>;

export type CodeScanningListAlertsForOrgResponse = Response<
  | CodeScanningListAlertsForOrg200ResponseBody
  | CodeScanningListAlertsForOrg404ResponseBody
  | CodeScanningListAlertsForOrg503ResponseBody,
  Record<string, any>,
  200 | 404 | 503
>;

export interface CodeScanningListAlertsForOrgHandler {
  codeScanningListAlertsForOrg(
    req: CodeScanningListAlertsForOrgRequest,
    res: CodeScanningListAlertsForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesListInOrganizationRequest = Request<
  CodespacesListInOrganizationRequestPath,
  | CodespacesListInOrganization200ResponseBody
  | CodespacesListInOrganization401ResponseBody
  | CodespacesListInOrganization403ResponseBody
  | CodespacesListInOrganization404ResponseBody
  | CodespacesListInOrganization500ResponseBody,
  unknown,
  CodespacesListInOrganizationRequestQuery,
  Record<string, any>
>;

export type CodespacesListInOrganizationResponse = Response<
  | CodespacesListInOrganization200ResponseBody
  | CodespacesListInOrganization401ResponseBody
  | CodespacesListInOrganization403ResponseBody
  | CodespacesListInOrganization404ResponseBody
  | CodespacesListInOrganization500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export interface CodespacesListInOrganizationHandler {
  codespacesListInOrganization(
    req: CodespacesListInOrganizationRequest,
    res: CodespacesListInOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesSetCodespacesBillingRequest = Request<
  CodespacesSetCodespacesBillingRequestPath,
  | CodespacesSetCodespacesBilling404ResponseBody
  | CodespacesSetCodespacesBilling422ResponseBody
  | CodespacesSetCodespacesBilling500ResponseBody,
  CodespacesSetCodespacesBillingRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesSetCodespacesBillingResponse = Response<
  | CodespacesSetCodespacesBilling404ResponseBody
  | CodespacesSetCodespacesBilling422ResponseBody
  | CodespacesSetCodespacesBilling500ResponseBody,
  Record<string, any>,
  204 | 304 | 400 | 404 | 422 | 500
>;

export interface CodespacesSetCodespacesBillingHandler {
  codespacesSetCodespacesBilling(
    req: CodespacesSetCodespacesBillingRequest,
    res: CodespacesSetCodespacesBillingResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesListOrgSecretsRequest = Request<
  CodespacesListOrgSecretsRequestPath,
  CodespacesListOrgSecrets200ResponseBody,
  unknown,
  CodespacesListOrgSecretsRequestQuery,
  Record<string, any>
>;

export type CodespacesListOrgSecretsResponse = Response<
  CodespacesListOrgSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export interface CodespacesListOrgSecretsHandler {
  codespacesListOrgSecrets(
    req: CodespacesListOrgSecretsRequest,
    res: CodespacesListOrgSecretsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesGetOrgPublicKeyRequest = Request<
  CodespacesGetOrgPublicKeyRequestPath,
  CodespacesGetOrgPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetOrgPublicKeyResponse = Response<
  CodespacesGetOrgPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export interface CodespacesGetOrgPublicKeyHandler {
  codespacesGetOrgPublicKey(
    req: CodespacesGetOrgPublicKeyRequest,
    res: CodespacesGetOrgPublicKeyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesGetOrgSecretRequest = Request<
  CodespacesGetOrgSecretRequestPath,
  CodespacesGetOrgSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetOrgSecretResponse = Response<
  CodespacesGetOrgSecret200ResponseBody,
  Record<string, any>,
  200
>;

export interface CodespacesGetOrgSecretHandler {
  codespacesGetOrgSecret(
    req: CodespacesGetOrgSecretRequest,
    res: CodespacesGetOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesCreateOrUpdateOrgSecretRequest = Request<
  CodespacesCreateOrUpdateOrgSecretRequestPath,
  | CodespacesCreateOrUpdateOrgSecret201ResponseBody
  | CodespacesCreateOrUpdateOrgSecret404ResponseBody
  | CodespacesCreateOrUpdateOrgSecret422ResponseBody,
  CodespacesCreateOrUpdateOrgSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCreateOrUpdateOrgSecretResponse = Response<
  | CodespacesCreateOrUpdateOrgSecret201ResponseBody
  | CodespacesCreateOrUpdateOrgSecret404ResponseBody
  | CodespacesCreateOrUpdateOrgSecret422ResponseBody,
  Record<string, any>,
  201 | 204 | 404 | 422
>;

export interface CodespacesCreateOrUpdateOrgSecretHandler {
  codespacesCreateOrUpdateOrgSecret(
    req: CodespacesCreateOrUpdateOrgSecretRequest,
    res: CodespacesCreateOrUpdateOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesDeleteOrgSecretRequest = Request<
  CodespacesDeleteOrgSecretRequestPath,
  CodespacesDeleteOrgSecret404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesDeleteOrgSecretResponse = Response<
  CodespacesDeleteOrgSecret404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface CodespacesDeleteOrgSecretHandler {
  codespacesDeleteOrgSecret(
    req: CodespacesDeleteOrgSecretRequest,
    res: CodespacesDeleteOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesListSelectedReposForOrgSecretRequest = Request<
  CodespacesListSelectedReposForOrgSecretRequestPath,
  | CodespacesListSelectedReposForOrgSecret200ResponseBody
  | CodespacesListSelectedReposForOrgSecret404ResponseBody,
  unknown,
  CodespacesListSelectedReposForOrgSecretRequestQuery,
  Record<string, any>
>;

export type CodespacesListSelectedReposForOrgSecretResponse = Response<
  | CodespacesListSelectedReposForOrgSecret200ResponseBody
  | CodespacesListSelectedReposForOrgSecret404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface CodespacesListSelectedReposForOrgSecretHandler {
  codespacesListSelectedReposForOrgSecret(
    req: CodespacesListSelectedReposForOrgSecretRequest,
    res: CodespacesListSelectedReposForOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesSetSelectedReposForOrgSecretRequest = Request<
  CodespacesSetSelectedReposForOrgSecretRequestPath,
  CodespacesSetSelectedReposForOrgSecret404ResponseBody,
  CodespacesSetSelectedReposForOrgSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesSetSelectedReposForOrgSecretResponse = Response<
  CodespacesSetSelectedReposForOrgSecret404ResponseBody,
  Record<string, any>,
  204 | 404 | 409
>;

export interface CodespacesSetSelectedReposForOrgSecretHandler {
  codespacesSetSelectedReposForOrgSecret(
    req: CodespacesSetSelectedReposForOrgSecretRequest,
    res: CodespacesSetSelectedReposForOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesAddSelectedRepoToOrgSecretRequest = Request<
  CodespacesAddSelectedRepoToOrgSecretRequestPath,
  | CodespacesAddSelectedRepoToOrgSecret404ResponseBody
  | CodespacesAddSelectedRepoToOrgSecret422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesAddSelectedRepoToOrgSecretResponse = Response<
  | CodespacesAddSelectedRepoToOrgSecret404ResponseBody
  | CodespacesAddSelectedRepoToOrgSecret422ResponseBody,
  Record<string, any>,
  204 | 404 | 409 | 422
>;

export interface CodespacesAddSelectedRepoToOrgSecretHandler {
  codespacesAddSelectedRepoToOrgSecret(
    req: CodespacesAddSelectedRepoToOrgSecretRequest,
    res: CodespacesAddSelectedRepoToOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesRemoveSelectedRepoFromOrgSecretRequest = Request<
  CodespacesRemoveSelectedRepoFromOrgSecretRequestPath,
  | CodespacesRemoveSelectedRepoFromOrgSecret404ResponseBody
  | CodespacesRemoveSelectedRepoFromOrgSecret422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesRemoveSelectedRepoFromOrgSecretResponse = Response<
  | CodespacesRemoveSelectedRepoFromOrgSecret404ResponseBody
  | CodespacesRemoveSelectedRepoFromOrgSecret422ResponseBody,
  Record<string, any>,
  204 | 404 | 409 | 422
>;

export interface CodespacesRemoveSelectedRepoFromOrgSecretHandler {
  codespacesRemoveSelectedRepoFromOrgSecret(
    req: CodespacesRemoveSelectedRepoFromOrgSecretRequest,
    res: CodespacesRemoveSelectedRepoFromOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsCreateCustomRoleRequest = Request<
  OrgsCreateCustomRoleRequestPath,
  | OrgsCreateCustomRole201ResponseBody
  | OrgsCreateCustomRole404ResponseBody
  | OrgsCreateCustomRole422ResponseBody,
  OrgsCreateCustomRoleRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCreateCustomRoleResponse = Response<
  | OrgsCreateCustomRole201ResponseBody
  | OrgsCreateCustomRole404ResponseBody
  | OrgsCreateCustomRole422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export interface OrgsCreateCustomRoleHandler {
  orgsCreateCustomRole(
    req: OrgsCreateCustomRoleRequest,
    res: OrgsCreateCustomRoleResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsGetCustomRoleRequest = Request<
  OrgsGetCustomRoleRequestPath,
  OrgsGetCustomRole200ResponseBody | OrgsGetCustomRole404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetCustomRoleResponse = Response<
  OrgsGetCustomRole200ResponseBody | OrgsGetCustomRole404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface OrgsGetCustomRoleHandler {
  orgsGetCustomRole(
    req: OrgsGetCustomRoleRequest,
    res: OrgsGetCustomRoleResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsUpdateCustomRoleRequest = Request<
  OrgsUpdateCustomRoleRequestPath,
  | OrgsUpdateCustomRole200ResponseBody
  | OrgsUpdateCustomRole404ResponseBody
  | OrgsUpdateCustomRole422ResponseBody,
  OrgsUpdateCustomRoleRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsUpdateCustomRoleResponse = Response<
  | OrgsUpdateCustomRole200ResponseBody
  | OrgsUpdateCustomRole404ResponseBody
  | OrgsUpdateCustomRole422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface OrgsUpdateCustomRoleHandler {
  orgsUpdateCustomRole(
    req: OrgsUpdateCustomRoleRequest,
    res: OrgsUpdateCustomRoleResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsDeleteCustomRoleRequest = Request<
  OrgsDeleteCustomRoleRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsDeleteCustomRoleResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface OrgsDeleteCustomRoleHandler {
  orgsDeleteCustomRole(
    req: OrgsDeleteCustomRoleRequest,
    res: OrgsDeleteCustomRoleResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotListAlertsForOrgRequest = Request<
  DependabotListAlertsForOrgRequestPath,
  | DependabotListAlertsForOrg200ResponseBody
  | DependabotListAlertsForOrg400ResponseBody
  | DependabotListAlertsForOrg403ResponseBody
  | DependabotListAlertsForOrg404ResponseBody
  | DependabotListAlertsForOrg422ResponseBody,
  unknown,
  DependabotListAlertsForOrgRequestQuery,
  Record<string, any>
>;

export type DependabotListAlertsForOrgResponse = Response<
  | DependabotListAlertsForOrg200ResponseBody
  | DependabotListAlertsForOrg400ResponseBody
  | DependabotListAlertsForOrg403ResponseBody
  | DependabotListAlertsForOrg404ResponseBody
  | DependabotListAlertsForOrg422ResponseBody,
  Record<string, any>,
  200 | 304 | 400 | 403 | 404 | 422
>;

export interface DependabotListAlertsForOrgHandler {
  dependabotListAlertsForOrg(
    req: DependabotListAlertsForOrgRequest,
    res: DependabotListAlertsForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotListOrgSecretsRequest = Request<
  DependabotListOrgSecretsRequestPath,
  DependabotListOrgSecrets200ResponseBody,
  unknown,
  DependabotListOrgSecretsRequestQuery,
  Record<string, any>
>;

export type DependabotListOrgSecretsResponse = Response<
  DependabotListOrgSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export interface DependabotListOrgSecretsHandler {
  dependabotListOrgSecrets(
    req: DependabotListOrgSecretsRequest,
    res: DependabotListOrgSecretsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotGetOrgPublicKeyRequest = Request<
  DependabotGetOrgPublicKeyRequestPath,
  DependabotGetOrgPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotGetOrgPublicKeyResponse = Response<
  DependabotGetOrgPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export interface DependabotGetOrgPublicKeyHandler {
  dependabotGetOrgPublicKey(
    req: DependabotGetOrgPublicKeyRequest,
    res: DependabotGetOrgPublicKeyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotGetOrgSecretRequest = Request<
  DependabotGetOrgSecretRequestPath,
  DependabotGetOrgSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotGetOrgSecretResponse = Response<
  DependabotGetOrgSecret200ResponseBody,
  Record<string, any>,
  200
>;

export interface DependabotGetOrgSecretHandler {
  dependabotGetOrgSecret(
    req: DependabotGetOrgSecretRequest,
    res: DependabotGetOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotCreateOrUpdateOrgSecretRequest = Request<
  DependabotCreateOrUpdateOrgSecretRequestPath,
  DependabotCreateOrUpdateOrgSecret201ResponseBody,
  DependabotCreateOrUpdateOrgSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type DependabotCreateOrUpdateOrgSecretResponse = Response<
  DependabotCreateOrUpdateOrgSecret201ResponseBody,
  Record<string, any>,
  201 | 204
>;

export interface DependabotCreateOrUpdateOrgSecretHandler {
  dependabotCreateOrUpdateOrgSecret(
    req: DependabotCreateOrUpdateOrgSecretRequest,
    res: DependabotCreateOrUpdateOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotDeleteOrgSecretRequest = Request<
  DependabotDeleteOrgSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotDeleteOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface DependabotDeleteOrgSecretHandler {
  dependabotDeleteOrgSecret(
    req: DependabotDeleteOrgSecretRequest,
    res: DependabotDeleteOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotListSelectedReposForOrgSecretRequest = Request<
  DependabotListSelectedReposForOrgSecretRequestPath,
  DependabotListSelectedReposForOrgSecret200ResponseBody,
  unknown,
  DependabotListSelectedReposForOrgSecretRequestQuery,
  Record<string, any>
>;

export type DependabotListSelectedReposForOrgSecretResponse = Response<
  DependabotListSelectedReposForOrgSecret200ResponseBody,
  Record<string, any>,
  200
>;

export interface DependabotListSelectedReposForOrgSecretHandler {
  dependabotListSelectedReposForOrgSecret(
    req: DependabotListSelectedReposForOrgSecretRequest,
    res: DependabotListSelectedReposForOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotSetSelectedReposForOrgSecretRequest = Request<
  DependabotSetSelectedReposForOrgSecretRequestPath,
  unknown,
  DependabotSetSelectedReposForOrgSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type DependabotSetSelectedReposForOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface DependabotSetSelectedReposForOrgSecretHandler {
  dependabotSetSelectedReposForOrgSecret(
    req: DependabotSetSelectedReposForOrgSecretRequest,
    res: DependabotSetSelectedReposForOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotAddSelectedRepoToOrgSecretRequest = Request<
  DependabotAddSelectedRepoToOrgSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotAddSelectedRepoToOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export interface DependabotAddSelectedRepoToOrgSecretHandler {
  dependabotAddSelectedRepoToOrgSecret(
    req: DependabotAddSelectedRepoToOrgSecretRequest,
    res: DependabotAddSelectedRepoToOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotRemoveSelectedRepoFromOrgSecretRequest = Request<
  DependabotRemoveSelectedRepoFromOrgSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotRemoveSelectedRepoFromOrgSecretResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export interface DependabotRemoveSelectedRepoFromOrgSecretHandler {
  dependabotRemoveSelectedRepoFromOrgSecret(
    req: DependabotRemoveSelectedRepoFromOrgSecretRequest,
    res: DependabotRemoveSelectedRepoFromOrgSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListPublicOrgEventsRequest = Request<
  ActivityListPublicOrgEventsRequestPath,
  ActivityListPublicOrgEvents200ResponseBody,
  unknown,
  ActivityListPublicOrgEventsRequestQuery,
  Record<string, any>
>;

export type ActivityListPublicOrgEventsResponse = Response<
  ActivityListPublicOrgEvents200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActivityListPublicOrgEventsHandler {
  activityListPublicOrgEvents(
    req: ActivityListPublicOrgEventsRequest,
    res: ActivityListPublicOrgEventsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListFailedInvitationsRequest = Request<
  OrgsListFailedInvitationsRequestPath,
  | OrgsListFailedInvitations200ResponseBody
  | OrgsListFailedInvitations404ResponseBody,
  unknown,
  OrgsListFailedInvitationsRequestQuery,
  Record<string, any>
>;

export type OrgsListFailedInvitationsResponse = Response<
  | OrgsListFailedInvitations200ResponseBody
  | OrgsListFailedInvitations404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface OrgsListFailedInvitationsHandler {
  orgsListFailedInvitations(
    req: OrgsListFailedInvitationsRequest,
    res: OrgsListFailedInvitationsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListFineGrainedPermissionsRequest = Request<
  OrgsListFineGrainedPermissionsRequestPath,
  OrgsListFineGrainedPermissions200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsListFineGrainedPermissionsResponse = Response<
  OrgsListFineGrainedPermissions200ResponseBody,
  Record<string, any>,
  200
>;

export interface OrgsListFineGrainedPermissionsHandler {
  orgsListFineGrainedPermissions(
    req: OrgsListFineGrainedPermissionsRequest,
    res: OrgsListFineGrainedPermissionsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListWebhooksRequest = Request<
  OrgsListWebhooksRequestPath,
  OrgsListWebhooks200ResponseBody | OrgsListWebhooks404ResponseBody,
  unknown,
  OrgsListWebhooksRequestQuery,
  Record<string, any>
>;

export type OrgsListWebhooksResponse = Response<
  OrgsListWebhooks200ResponseBody | OrgsListWebhooks404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface OrgsListWebhooksHandler {
  orgsListWebhooks(
    req: OrgsListWebhooksRequest,
    res: OrgsListWebhooksResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsCreateWebhookRequest = Request<
  OrgsCreateWebhookRequestPath,
  | OrgsCreateWebhook201ResponseBody
  | OrgsCreateWebhook404ResponseBody
  | OrgsCreateWebhook422ResponseBody,
  OrgsCreateWebhookRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCreateWebhookResponse = Response<
  | OrgsCreateWebhook201ResponseBody
  | OrgsCreateWebhook404ResponseBody
  | OrgsCreateWebhook422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export interface OrgsCreateWebhookHandler {
  orgsCreateWebhook(
    req: OrgsCreateWebhookRequest,
    res: OrgsCreateWebhookResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsGetWebhookRequest = Request<
  OrgsGetWebhookRequestPath,
  OrgsGetWebhook200ResponseBody | OrgsGetWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetWebhookResponse = Response<
  OrgsGetWebhook200ResponseBody | OrgsGetWebhook404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface OrgsGetWebhookHandler {
  orgsGetWebhook(
    req: OrgsGetWebhookRequest,
    res: OrgsGetWebhookResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsUpdateWebhookRequest = Request<
  OrgsUpdateWebhookRequestPath,
  | OrgsUpdateWebhook200ResponseBody
  | OrgsUpdateWebhook404ResponseBody
  | OrgsUpdateWebhook422ResponseBody,
  OrgsUpdateWebhookRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsUpdateWebhookResponse = Response<
  | OrgsUpdateWebhook200ResponseBody
  | OrgsUpdateWebhook404ResponseBody
  | OrgsUpdateWebhook422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface OrgsUpdateWebhookHandler {
  orgsUpdateWebhook(
    req: OrgsUpdateWebhookRequest,
    res: OrgsUpdateWebhookResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsDeleteWebhookRequest = Request<
  OrgsDeleteWebhookRequestPath,
  OrgsDeleteWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsDeleteWebhookResponse = Response<
  OrgsDeleteWebhook404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface OrgsDeleteWebhookHandler {
  orgsDeleteWebhook(
    req: OrgsDeleteWebhookRequest,
    res: OrgsDeleteWebhookResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsGetWebhookConfigForOrgRequest = Request<
  OrgsGetWebhookConfigForOrgRequestPath,
  OrgsGetWebhookConfigForOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetWebhookConfigForOrgResponse = Response<
  OrgsGetWebhookConfigForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface OrgsGetWebhookConfigForOrgHandler {
  orgsGetWebhookConfigForOrg(
    req: OrgsGetWebhookConfigForOrgRequest,
    res: OrgsGetWebhookConfigForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsUpdateWebhookConfigForOrgRequest = Request<
  OrgsUpdateWebhookConfigForOrgRequestPath,
  OrgsUpdateWebhookConfigForOrg200ResponseBody,
  OrgsUpdateWebhookConfigForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsUpdateWebhookConfigForOrgResponse = Response<
  OrgsUpdateWebhookConfigForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface OrgsUpdateWebhookConfigForOrgHandler {
  orgsUpdateWebhookConfigForOrg(
    req: OrgsUpdateWebhookConfigForOrgRequest,
    res: OrgsUpdateWebhookConfigForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListWebhookDeliveriesRequest = Request<
  OrgsListWebhookDeliveriesRequestPath,
  | OrgsListWebhookDeliveries200ResponseBody
  | OrgsListWebhookDeliveries400ResponseBody
  | OrgsListWebhookDeliveries422ResponseBody,
  unknown,
  OrgsListWebhookDeliveriesRequestQuery,
  Record<string, any>
>;

export type OrgsListWebhookDeliveriesResponse = Response<
  | OrgsListWebhookDeliveries200ResponseBody
  | OrgsListWebhookDeliveries400ResponseBody
  | OrgsListWebhookDeliveries422ResponseBody,
  Record<string, any>,
  200 | 400 | 422
>;

export interface OrgsListWebhookDeliveriesHandler {
  orgsListWebhookDeliveries(
    req: OrgsListWebhookDeliveriesRequest,
    res: OrgsListWebhookDeliveriesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsGetWebhookDeliveryRequest = Request<
  OrgsGetWebhookDeliveryRequestPath,
  | OrgsGetWebhookDelivery200ResponseBody
  | OrgsGetWebhookDelivery400ResponseBody
  | OrgsGetWebhookDelivery422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetWebhookDeliveryResponse = Response<
  | OrgsGetWebhookDelivery200ResponseBody
  | OrgsGetWebhookDelivery400ResponseBody
  | OrgsGetWebhookDelivery422ResponseBody,
  Record<string, any>,
  200 | 400 | 422
>;

export interface OrgsGetWebhookDeliveryHandler {
  orgsGetWebhookDelivery(
    req: OrgsGetWebhookDeliveryRequest,
    res: OrgsGetWebhookDeliveryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsRedeliverWebhookDeliveryRequest = Request<
  OrgsRedeliverWebhookDeliveryRequestPath,
  | OrgsRedeliverWebhookDelivery202ResponseBody
  | OrgsRedeliverWebhookDelivery400ResponseBody
  | OrgsRedeliverWebhookDelivery422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsRedeliverWebhookDeliveryResponse = Response<
  | OrgsRedeliverWebhookDelivery202ResponseBody
  | OrgsRedeliverWebhookDelivery400ResponseBody
  | OrgsRedeliverWebhookDelivery422ResponseBody,
  Record<string, any>,
  202 | 400 | 422
>;

export interface OrgsRedeliverWebhookDeliveryHandler {
  orgsRedeliverWebhookDelivery(
    req: OrgsRedeliverWebhookDeliveryRequest,
    res: OrgsRedeliverWebhookDeliveryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsPingWebhookRequest = Request<
  OrgsPingWebhookRequestPath,
  OrgsPingWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsPingWebhookResponse = Response<
  OrgsPingWebhook404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface OrgsPingWebhookHandler {
  orgsPingWebhook(
    req: OrgsPingWebhookRequest,
    res: OrgsPingWebhookResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsGetOrgInstallationRequest = Request<
  AppsGetOrgInstallationRequestPath,
  AppsGetOrgInstallation200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetOrgInstallationResponse = Response<
  AppsGetOrgInstallation200ResponseBody,
  Record<string, any>,
  200
>;

export interface AppsGetOrgInstallationHandler {
  appsGetOrgInstallation(
    req: AppsGetOrgInstallationRequest,
    res: AppsGetOrgInstallationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListAppInstallationsRequest = Request<
  OrgsListAppInstallationsRequestPath,
  OrgsListAppInstallations200ResponseBody,
  unknown,
  OrgsListAppInstallationsRequestQuery,
  Record<string, any>
>;

export type OrgsListAppInstallationsResponse = Response<
  OrgsListAppInstallations200ResponseBody,
  Record<string, any>,
  200
>;

export interface OrgsListAppInstallationsHandler {
  orgsListAppInstallations(
    req: OrgsListAppInstallationsRequest,
    res: OrgsListAppInstallationsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type InteractionsGetRestrictionsForOrgRequest = Request<
  InteractionsGetRestrictionsForOrgRequestPath,
  InteractionsGetRestrictionsForOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsGetRestrictionsForOrgResponse = Response<
  InteractionsGetRestrictionsForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface InteractionsGetRestrictionsForOrgHandler {
  interactionsGetRestrictionsForOrg(
    req: InteractionsGetRestrictionsForOrgRequest,
    res: InteractionsGetRestrictionsForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type InteractionsSetRestrictionsForOrgRequest = Request<
  InteractionsSetRestrictionsForOrgRequestPath,
  | InteractionsSetRestrictionsForOrg200ResponseBody
  | InteractionsSetRestrictionsForOrg422ResponseBody,
  InteractionsSetRestrictionsForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsSetRestrictionsForOrgResponse = Response<
  | InteractionsSetRestrictionsForOrg200ResponseBody
  | InteractionsSetRestrictionsForOrg422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface InteractionsSetRestrictionsForOrgHandler {
  interactionsSetRestrictionsForOrg(
    req: InteractionsSetRestrictionsForOrgRequest,
    res: InteractionsSetRestrictionsForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type InteractionsRemoveRestrictionsForOrgRequest = Request<
  InteractionsRemoveRestrictionsForOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsRemoveRestrictionsForOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface InteractionsRemoveRestrictionsForOrgHandler {
  interactionsRemoveRestrictionsForOrg(
    req: InteractionsRemoveRestrictionsForOrgRequest,
    res: InteractionsRemoveRestrictionsForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListPendingInvitationsRequest = Request<
  OrgsListPendingInvitationsRequestPath,
  | OrgsListPendingInvitations200ResponseBody
  | OrgsListPendingInvitations404ResponseBody,
  unknown,
  OrgsListPendingInvitationsRequestQuery,
  Record<string, any>
>;

export type OrgsListPendingInvitationsResponse = Response<
  | OrgsListPendingInvitations200ResponseBody
  | OrgsListPendingInvitations404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface OrgsListPendingInvitationsHandler {
  orgsListPendingInvitations(
    req: OrgsListPendingInvitationsRequest,
    res: OrgsListPendingInvitationsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsCreateInvitationRequest = Request<
  OrgsCreateInvitationRequestPath,
  | OrgsCreateInvitation201ResponseBody
  | OrgsCreateInvitation404ResponseBody
  | OrgsCreateInvitation422ResponseBody,
  OrgsCreateInvitationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCreateInvitationResponse = Response<
  | OrgsCreateInvitation201ResponseBody
  | OrgsCreateInvitation404ResponseBody
  | OrgsCreateInvitation422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export interface OrgsCreateInvitationHandler {
  orgsCreateInvitation(
    req: OrgsCreateInvitationRequest,
    res: OrgsCreateInvitationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsCancelInvitationRequest = Request<
  OrgsCancelInvitationRequestPath,
  OrgsCancelInvitation404ResponseBody | OrgsCancelInvitation422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCancelInvitationResponse = Response<
  OrgsCancelInvitation404ResponseBody | OrgsCancelInvitation422ResponseBody,
  Record<string, any>,
  204 | 404 | 422
>;

export interface OrgsCancelInvitationHandler {
  orgsCancelInvitation(
    req: OrgsCancelInvitationRequest,
    res: OrgsCancelInvitationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListInvitationTeamsRequest = Request<
  OrgsListInvitationTeamsRequestPath,
  | OrgsListInvitationTeams200ResponseBody
  | OrgsListInvitationTeams404ResponseBody,
  unknown,
  OrgsListInvitationTeamsRequestQuery,
  Record<string, any>
>;

export type OrgsListInvitationTeamsResponse = Response<
  | OrgsListInvitationTeams200ResponseBody
  | OrgsListInvitationTeams404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface OrgsListInvitationTeamsHandler {
  orgsListInvitationTeams(
    req: OrgsListInvitationTeamsRequest,
    res: OrgsListInvitationTeamsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListForOrgRequest = Request<
  IssuesListForOrgRequestPath,
  IssuesListForOrg200ResponseBody | IssuesListForOrg404ResponseBody,
  unknown,
  IssuesListForOrgRequestQuery,
  Record<string, any>
>;

export type IssuesListForOrgResponse = Response<
  IssuesListForOrg200ResponseBody | IssuesListForOrg404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface IssuesListForOrgHandler {
  issuesListForOrg(
    req: IssuesListForOrgRequest,
    res: IssuesListForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListMembersRequest = Request<
  OrgsListMembersRequestPath,
  OrgsListMembers200ResponseBody | OrgsListMembers422ResponseBody,
  unknown,
  OrgsListMembersRequestQuery,
  Record<string, any>
>;

export type OrgsListMembersResponse = Response<
  OrgsListMembers200ResponseBody | OrgsListMembers422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface OrgsListMembersHandler {
  orgsListMembers(
    req: OrgsListMembersRequest,
    res: OrgsListMembersResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsCheckMembershipForUserRequest = Request<
  OrgsCheckMembershipForUserRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCheckMembershipForUserResponse = Response<
  unknown,
  Record<string, any>,
  204 | 302 | 404
>;

export interface OrgsCheckMembershipForUserHandler {
  orgsCheckMembershipForUser(
    req: OrgsCheckMembershipForUserRequest,
    res: OrgsCheckMembershipForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsRemoveMemberRequest = Request<
  OrgsRemoveMemberRequestPath,
  OrgsRemoveMember403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsRemoveMemberResponse = Response<
  OrgsRemoveMember403ResponseBody,
  Record<string, any>,
  204 | 403
>;

export interface OrgsRemoveMemberHandler {
  orgsRemoveMember(
    req: OrgsRemoveMemberRequest,
    res: OrgsRemoveMemberResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesGetCodespacesForUserInOrgRequest = Request<
  CodespacesGetCodespacesForUserInOrgRequestPath,
  | CodespacesGetCodespacesForUserInOrg200ResponseBody
  | CodespacesGetCodespacesForUserInOrg401ResponseBody
  | CodespacesGetCodespacesForUserInOrg403ResponseBody
  | CodespacesGetCodespacesForUserInOrg404ResponseBody
  | CodespacesGetCodespacesForUserInOrg500ResponseBody,
  unknown,
  CodespacesGetCodespacesForUserInOrgRequestQuery,
  Record<string, any>
>;

export type CodespacesGetCodespacesForUserInOrgResponse = Response<
  | CodespacesGetCodespacesForUserInOrg200ResponseBody
  | CodespacesGetCodespacesForUserInOrg401ResponseBody
  | CodespacesGetCodespacesForUserInOrg403ResponseBody
  | CodespacesGetCodespacesForUserInOrg404ResponseBody
  | CodespacesGetCodespacesForUserInOrg500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export interface CodespacesGetCodespacesForUserInOrgHandler {
  codespacesGetCodespacesForUserInOrg(
    req: CodespacesGetCodespacesForUserInOrgRequest,
    res: CodespacesGetCodespacesForUserInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesDeleteFromOrganizationRequest = Request<
  CodespacesDeleteFromOrganizationRequestPath,
  | CodespacesDeleteFromOrganization202ResponseBody
  | CodespacesDeleteFromOrganization401ResponseBody
  | CodespacesDeleteFromOrganization403ResponseBody
  | CodespacesDeleteFromOrganization404ResponseBody
  | CodespacesDeleteFromOrganization500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesDeleteFromOrganizationResponse = Response<
  | CodespacesDeleteFromOrganization202ResponseBody
  | CodespacesDeleteFromOrganization401ResponseBody
  | CodespacesDeleteFromOrganization403ResponseBody
  | CodespacesDeleteFromOrganization404ResponseBody
  | CodespacesDeleteFromOrganization500ResponseBody,
  Record<string, any>,
  202 | 304 | 401 | 403 | 404 | 500
>;

export interface CodespacesDeleteFromOrganizationHandler {
  codespacesDeleteFromOrganization(
    req: CodespacesDeleteFromOrganizationRequest,
    res: CodespacesDeleteFromOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesStopInOrganizationRequest = Request<
  CodespacesStopInOrganizationRequestPath,
  | CodespacesStopInOrganization200ResponseBody
  | CodespacesStopInOrganization401ResponseBody
  | CodespacesStopInOrganization403ResponseBody
  | CodespacesStopInOrganization404ResponseBody
  | CodespacesStopInOrganization500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesStopInOrganizationResponse = Response<
  | CodespacesStopInOrganization200ResponseBody
  | CodespacesStopInOrganization401ResponseBody
  | CodespacesStopInOrganization403ResponseBody
  | CodespacesStopInOrganization404ResponseBody
  | CodespacesStopInOrganization500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export interface CodespacesStopInOrganizationHandler {
  codespacesStopInOrganization(
    req: CodespacesStopInOrganizationRequest,
    res: CodespacesStopInOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsGetMembershipForUserRequest = Request<
  OrgsGetMembershipForUserRequestPath,
  | OrgsGetMembershipForUser200ResponseBody
  | OrgsGetMembershipForUser403ResponseBody
  | OrgsGetMembershipForUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetMembershipForUserResponse = Response<
  | OrgsGetMembershipForUser200ResponseBody
  | OrgsGetMembershipForUser403ResponseBody
  | OrgsGetMembershipForUser404ResponseBody,
  Record<string, any>,
  200 | 403 | 404
>;

export interface OrgsGetMembershipForUserHandler {
  orgsGetMembershipForUser(
    req: OrgsGetMembershipForUserRequest,
    res: OrgsGetMembershipForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsSetMembershipForUserRequest = Request<
  OrgsSetMembershipForUserRequestPath,
  | OrgsSetMembershipForUser200ResponseBody
  | OrgsSetMembershipForUser403ResponseBody
  | OrgsSetMembershipForUser422ResponseBody,
  OrgsSetMembershipForUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsSetMembershipForUserResponse = Response<
  | OrgsSetMembershipForUser200ResponseBody
  | OrgsSetMembershipForUser403ResponseBody
  | OrgsSetMembershipForUser422ResponseBody,
  Record<string, any>,
  200 | 403 | 422
>;

export interface OrgsSetMembershipForUserHandler {
  orgsSetMembershipForUser(
    req: OrgsSetMembershipForUserRequest,
    res: OrgsSetMembershipForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsRemoveMembershipForUserRequest = Request<
  OrgsRemoveMembershipForUserRequestPath,
  | OrgsRemoveMembershipForUser403ResponseBody
  | OrgsRemoveMembershipForUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsRemoveMembershipForUserResponse = Response<
  | OrgsRemoveMembershipForUser403ResponseBody
  | OrgsRemoveMembershipForUser404ResponseBody,
  Record<string, any>,
  204 | 403 | 404
>;

export interface OrgsRemoveMembershipForUserHandler {
  orgsRemoveMembershipForUser(
    req: OrgsRemoveMembershipForUserRequest,
    res: OrgsRemoveMembershipForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsListForOrgRequest = Request<
  MigrationsListForOrgRequestPath,
  MigrationsListForOrg200ResponseBody,
  unknown,
  MigrationsListForOrgRequestQuery,
  Record<string, any>
>;

export type MigrationsListForOrgResponse = Response<
  MigrationsListForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface MigrationsListForOrgHandler {
  migrationsListForOrg(
    req: MigrationsListForOrgRequest,
    res: MigrationsListForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsStartForOrgRequest = Request<
  MigrationsStartForOrgRequestPath,
  | MigrationsStartForOrg201ResponseBody
  | MigrationsStartForOrg404ResponseBody
  | MigrationsStartForOrg422ResponseBody,
  MigrationsStartForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsStartForOrgResponse = Response<
  | MigrationsStartForOrg201ResponseBody
  | MigrationsStartForOrg404ResponseBody
  | MigrationsStartForOrg422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export interface MigrationsStartForOrgHandler {
  migrationsStartForOrg(
    req: MigrationsStartForOrgRequest,
    res: MigrationsStartForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsGetStatusForOrgRequest = Request<
  MigrationsGetStatusForOrgRequestPath,
  | MigrationsGetStatusForOrg200ResponseBody
  | MigrationsGetStatusForOrg404ResponseBody,
  unknown,
  MigrationsGetStatusForOrgRequestQuery,
  Record<string, any>
>;

export type MigrationsGetStatusForOrgResponse = Response<
  | MigrationsGetStatusForOrg200ResponseBody
  | MigrationsGetStatusForOrg404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface MigrationsGetStatusForOrgHandler {
  migrationsGetStatusForOrg(
    req: MigrationsGetStatusForOrgRequest,
    res: MigrationsGetStatusForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsDownloadArchiveForOrgRequest = Request<
  MigrationsDownloadArchiveForOrgRequestPath,
  MigrationsDownloadArchiveForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsDownloadArchiveForOrgResponse = Response<
  MigrationsDownloadArchiveForOrg404ResponseBody,
  Record<string, any>,
  302 | 404
>;

export interface MigrationsDownloadArchiveForOrgHandler {
  migrationsDownloadArchiveForOrg(
    req: MigrationsDownloadArchiveForOrgRequest,
    res: MigrationsDownloadArchiveForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsDeleteArchiveForOrgRequest = Request<
  MigrationsDeleteArchiveForOrgRequestPath,
  MigrationsDeleteArchiveForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsDeleteArchiveForOrgResponse = Response<
  MigrationsDeleteArchiveForOrg404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface MigrationsDeleteArchiveForOrgHandler {
  migrationsDeleteArchiveForOrg(
    req: MigrationsDeleteArchiveForOrgRequest,
    res: MigrationsDeleteArchiveForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsUnlockRepoForOrgRequest = Request<
  MigrationsUnlockRepoForOrgRequestPath,
  MigrationsUnlockRepoForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsUnlockRepoForOrgResponse = Response<
  MigrationsUnlockRepoForOrg404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface MigrationsUnlockRepoForOrgHandler {
  migrationsUnlockRepoForOrg(
    req: MigrationsUnlockRepoForOrgRequest,
    res: MigrationsUnlockRepoForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsListReposForOrgRequest = Request<
  MigrationsListReposForOrgRequestPath,
  | MigrationsListReposForOrg200ResponseBody
  | MigrationsListReposForOrg404ResponseBody,
  unknown,
  MigrationsListReposForOrgRequestQuery,
  Record<string, any>
>;

export type MigrationsListReposForOrgResponse = Response<
  | MigrationsListReposForOrg200ResponseBody
  | MigrationsListReposForOrg404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface MigrationsListReposForOrgHandler {
  migrationsListReposForOrg(
    req: MigrationsListReposForOrgRequest,
    res: MigrationsListReposForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListOutsideCollaboratorsRequest = Request<
  OrgsListOutsideCollaboratorsRequestPath,
  OrgsListOutsideCollaborators200ResponseBody,
  unknown,
  OrgsListOutsideCollaboratorsRequestQuery,
  Record<string, any>
>;

export type OrgsListOutsideCollaboratorsResponse = Response<
  OrgsListOutsideCollaborators200ResponseBody,
  Record<string, any>,
  200
>;

export interface OrgsListOutsideCollaboratorsHandler {
  orgsListOutsideCollaborators(
    req: OrgsListOutsideCollaboratorsRequest,
    res: OrgsListOutsideCollaboratorsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsConvertMemberToOutsideCollaboratorRequest = Request<
  OrgsConvertMemberToOutsideCollaboratorRequestPath,
  | OrgsConvertMemberToOutsideCollaborator202ResponseBody
  | OrgsConvertMemberToOutsideCollaborator404ResponseBody,
  OrgsConvertMemberToOutsideCollaboratorRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsConvertMemberToOutsideCollaboratorResponse = Response<
  | OrgsConvertMemberToOutsideCollaborator202ResponseBody
  | OrgsConvertMemberToOutsideCollaborator404ResponseBody,
  Record<string, any>,
  202 | 204 | 403 | 404
>;

export interface OrgsConvertMemberToOutsideCollaboratorHandler {
  orgsConvertMemberToOutsideCollaborator(
    req: OrgsConvertMemberToOutsideCollaboratorRequest,
    res: OrgsConvertMemberToOutsideCollaboratorResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsRemoveOutsideCollaboratorRequest = Request<
  OrgsRemoveOutsideCollaboratorRequestPath,
  OrgsRemoveOutsideCollaborator422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsRemoveOutsideCollaboratorResponse = Response<
  OrgsRemoveOutsideCollaborator422ResponseBody,
  Record<string, any>,
  204 | 422
>;

export interface OrgsRemoveOutsideCollaboratorHandler {
  orgsRemoveOutsideCollaborator(
    req: OrgsRemoveOutsideCollaboratorRequest,
    res: OrgsRemoveOutsideCollaboratorResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesListPackagesForOrganizationRequest = Request<
  PackagesListPackagesForOrganizationRequestPath,
  | PackagesListPackagesForOrganization200ResponseBody
  | PackagesListPackagesForOrganization401ResponseBody
  | PackagesListPackagesForOrganization403ResponseBody,
  unknown,
  PackagesListPackagesForOrganizationRequestQuery,
  Record<string, any>
>;

export type PackagesListPackagesForOrganizationResponse = Response<
  | PackagesListPackagesForOrganization200ResponseBody
  | PackagesListPackagesForOrganization401ResponseBody
  | PackagesListPackagesForOrganization403ResponseBody,
  Record<string, any>,
  200 | 401 | 403
>;

export interface PackagesListPackagesForOrganizationHandler {
  packagesListPackagesForOrganization(
    req: PackagesListPackagesForOrganizationRequest,
    res: PackagesListPackagesForOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesGetPackageForOrganizationRequest = Request<
  PackagesGetPackageForOrganizationRequestPath,
  PackagesGetPackageForOrganization200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetPackageForOrganizationResponse = Response<
  PackagesGetPackageForOrganization200ResponseBody,
  Record<string, any>,
  200
>;

export interface PackagesGetPackageForOrganizationHandler {
  packagesGetPackageForOrganization(
    req: PackagesGetPackageForOrganizationRequest,
    res: PackagesGetPackageForOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesDeletePackageForOrgRequest = Request<
  PackagesDeletePackageForOrgRequestPath,
  | PackagesDeletePackageForOrg401ResponseBody
  | PackagesDeletePackageForOrg403ResponseBody
  | PackagesDeletePackageForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesDeletePackageForOrgResponse = Response<
  | PackagesDeletePackageForOrg401ResponseBody
  | PackagesDeletePackageForOrg403ResponseBody
  | PackagesDeletePackageForOrg404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export interface PackagesDeletePackageForOrgHandler {
  packagesDeletePackageForOrg(
    req: PackagesDeletePackageForOrgRequest,
    res: PackagesDeletePackageForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesRestorePackageForOrgRequest = Request<
  PackagesRestorePackageForOrgRequestPath,
  | PackagesRestorePackageForOrg401ResponseBody
  | PackagesRestorePackageForOrg403ResponseBody
  | PackagesRestorePackageForOrg404ResponseBody,
  unknown,
  PackagesRestorePackageForOrgRequestQuery,
  Record<string, any>
>;

export type PackagesRestorePackageForOrgResponse = Response<
  | PackagesRestorePackageForOrg401ResponseBody
  | PackagesRestorePackageForOrg403ResponseBody
  | PackagesRestorePackageForOrg404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export interface PackagesRestorePackageForOrgHandler {
  packagesRestorePackageForOrg(
    req: PackagesRestorePackageForOrgRequest,
    res: PackagesRestorePackageForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesGetAllPackageVersionsForPackageOwnedByOrgRequest = Request<
  PackagesGetAllPackageVersionsForPackageOwnedByOrgRequestPath,
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg200ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg401ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg403ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg404ResponseBody,
  unknown,
  PackagesGetAllPackageVersionsForPackageOwnedByOrgRequestQuery,
  Record<string, any>
>;

export type PackagesGetAllPackageVersionsForPackageOwnedByOrgResponse = Response<
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg200ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg401ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg403ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByOrg404ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404
>;

export interface PackagesGetAllPackageVersionsForPackageOwnedByOrgHandler {
  packagesGetAllPackageVersionsForPackageOwnedByOrg(
    req: PackagesGetAllPackageVersionsForPackageOwnedByOrgRequest,
    res: PackagesGetAllPackageVersionsForPackageOwnedByOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesGetPackageVersionForOrganizationRequest = Request<
  PackagesGetPackageVersionForOrganizationRequestPath,
  PackagesGetPackageVersionForOrganization200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetPackageVersionForOrganizationResponse = Response<
  PackagesGetPackageVersionForOrganization200ResponseBody,
  Record<string, any>,
  200
>;

export interface PackagesGetPackageVersionForOrganizationHandler {
  packagesGetPackageVersionForOrganization(
    req: PackagesGetPackageVersionForOrganizationRequest,
    res: PackagesGetPackageVersionForOrganizationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesDeletePackageVersionForOrgRequest = Request<
  PackagesDeletePackageVersionForOrgRequestPath,
  | PackagesDeletePackageVersionForOrg401ResponseBody
  | PackagesDeletePackageVersionForOrg403ResponseBody
  | PackagesDeletePackageVersionForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesDeletePackageVersionForOrgResponse = Response<
  | PackagesDeletePackageVersionForOrg401ResponseBody
  | PackagesDeletePackageVersionForOrg403ResponseBody
  | PackagesDeletePackageVersionForOrg404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export interface PackagesDeletePackageVersionForOrgHandler {
  packagesDeletePackageVersionForOrg(
    req: PackagesDeletePackageVersionForOrgRequest,
    res: PackagesDeletePackageVersionForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesRestorePackageVersionForOrgRequest = Request<
  PackagesRestorePackageVersionForOrgRequestPath,
  | PackagesRestorePackageVersionForOrg401ResponseBody
  | PackagesRestorePackageVersionForOrg403ResponseBody
  | PackagesRestorePackageVersionForOrg404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesRestorePackageVersionForOrgResponse = Response<
  | PackagesRestorePackageVersionForOrg401ResponseBody
  | PackagesRestorePackageVersionForOrg403ResponseBody
  | PackagesRestorePackageVersionForOrg404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export interface PackagesRestorePackageVersionForOrgHandler {
  packagesRestorePackageVersionForOrg(
    req: PackagesRestorePackageVersionForOrgRequest,
    res: PackagesRestorePackageVersionForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsListForOrgRequest = Request<
  ProjectsListForOrgRequestPath,
  ProjectsListForOrg200ResponseBody | ProjectsListForOrg422ResponseBody,
  unknown,
  ProjectsListForOrgRequestQuery,
  Record<string, any>
>;

export type ProjectsListForOrgResponse = Response<
  ProjectsListForOrg200ResponseBody | ProjectsListForOrg422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ProjectsListForOrgHandler {
  projectsListForOrg(
    req: ProjectsListForOrgRequest,
    res: ProjectsListForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsCreateForOrgRequest = Request<
  ProjectsCreateForOrgRequestPath,
  | ProjectsCreateForOrg201ResponseBody
  | ProjectsCreateForOrg401ResponseBody
  | ProjectsCreateForOrg403ResponseBody
  | ProjectsCreateForOrg404ResponseBody
  | ProjectsCreateForOrg410ResponseBody
  | ProjectsCreateForOrg422ResponseBody,
  ProjectsCreateForOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsCreateForOrgResponse = Response<
  | ProjectsCreateForOrg201ResponseBody
  | ProjectsCreateForOrg401ResponseBody
  | ProjectsCreateForOrg403ResponseBody
  | ProjectsCreateForOrg404ResponseBody
  | ProjectsCreateForOrg410ResponseBody
  | ProjectsCreateForOrg422ResponseBody,
  Record<string, any>,
  201 | 401 | 403 | 404 | 410 | 422
>;

export interface ProjectsCreateForOrgHandler {
  projectsCreateForOrg(
    req: ProjectsCreateForOrgRequest,
    res: ProjectsCreateForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListPublicMembersRequest = Request<
  OrgsListPublicMembersRequestPath,
  OrgsListPublicMembers200ResponseBody,
  unknown,
  OrgsListPublicMembersRequestQuery,
  Record<string, any>
>;

export type OrgsListPublicMembersResponse = Response<
  OrgsListPublicMembers200ResponseBody,
  Record<string, any>,
  200
>;

export interface OrgsListPublicMembersHandler {
  orgsListPublicMembers(
    req: OrgsListPublicMembersRequest,
    res: OrgsListPublicMembersResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsCheckPublicMembershipForUserRequest = Request<
  OrgsCheckPublicMembershipForUserRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsCheckPublicMembershipForUserResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export interface OrgsCheckPublicMembershipForUserHandler {
  orgsCheckPublicMembershipForUser(
    req: OrgsCheckPublicMembershipForUserRequest,
    res: OrgsCheckPublicMembershipForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsSetPublicMembershipForAuthenticatedUserRequest = Request<
  OrgsSetPublicMembershipForAuthenticatedUserRequestPath,
  OrgsSetPublicMembershipForAuthenticatedUser403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsSetPublicMembershipForAuthenticatedUserResponse = Response<
  OrgsSetPublicMembershipForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  204 | 403
>;

export interface OrgsSetPublicMembershipForAuthenticatedUserHandler {
  orgsSetPublicMembershipForAuthenticatedUser(
    req: OrgsSetPublicMembershipForAuthenticatedUserRequest,
    res: OrgsSetPublicMembershipForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsRemovePublicMembershipForAuthenticatedUserRequest = Request<
  OrgsRemovePublicMembershipForAuthenticatedUserRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsRemovePublicMembershipForAuthenticatedUserResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface OrgsRemovePublicMembershipForAuthenticatedUserHandler {
  orgsRemovePublicMembershipForAuthenticatedUser(
    req: OrgsRemovePublicMembershipForAuthenticatedUserRequest,
    res: OrgsRemovePublicMembershipForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListForOrgRequest = Request<
  ReposListForOrgRequestPath,
  ReposListForOrg200ResponseBody,
  unknown,
  ReposListForOrgRequestQuery,
  Record<string, any>
>;

export type ReposListForOrgResponse = Response<
  ReposListForOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListForOrgHandler {
  reposListForOrg(
    req: ReposListForOrgRequest,
    res: ReposListForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateInOrgRequest = Request<
  ReposCreateInOrgRequestPath,
  | ReposCreateInOrg201ResponseBody
  | ReposCreateInOrg403ResponseBody
  | ReposCreateInOrg422ResponseBody,
  ReposCreateInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateInOrgResponse = Response<
  | ReposCreateInOrg201ResponseBody
  | ReposCreateInOrg403ResponseBody
  | ReposCreateInOrg422ResponseBody,
  Record<string, any>,
  201 | 403 | 422
>;

export interface ReposCreateInOrgHandler {
  reposCreateInOrg(
    req: ReposCreateInOrgRequest,
    res: ReposCreateInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type SecretScanningListAlertsForOrgRequest = Request<
  SecretScanningListAlertsForOrgRequestPath,
  | SecretScanningListAlertsForOrg200ResponseBody
  | SecretScanningListAlertsForOrg404ResponseBody
  | SecretScanningListAlertsForOrg503ResponseBody,
  unknown,
  SecretScanningListAlertsForOrgRequestQuery,
  Record<string, any>
>;

export type SecretScanningListAlertsForOrgResponse = Response<
  | SecretScanningListAlertsForOrg200ResponseBody
  | SecretScanningListAlertsForOrg404ResponseBody
  | SecretScanningListAlertsForOrg503ResponseBody,
  Record<string, any>,
  200 | 404 | 503
>;

export interface SecretScanningListAlertsForOrgHandler {
  secretScanningListAlertsForOrg(
    req: SecretScanningListAlertsForOrgRequest,
    res: SecretScanningListAlertsForOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListSecurityManagerTeamsRequest = Request<
  OrgsListSecurityManagerTeamsRequestPath,
  OrgsListSecurityManagerTeams200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsListSecurityManagerTeamsResponse = Response<
  OrgsListSecurityManagerTeams200ResponseBody,
  Record<string, any>,
  200
>;

export interface OrgsListSecurityManagerTeamsHandler {
  orgsListSecurityManagerTeams(
    req: OrgsListSecurityManagerTeamsRequest,
    res: OrgsListSecurityManagerTeamsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsAddSecurityManagerTeamRequest = Request<
  OrgsAddSecurityManagerTeamRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsAddSecurityManagerTeamResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export interface OrgsAddSecurityManagerTeamHandler {
  orgsAddSecurityManagerTeam(
    req: OrgsAddSecurityManagerTeamRequest,
    res: OrgsAddSecurityManagerTeamResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsRemoveSecurityManagerTeamRequest = Request<
  OrgsRemoveSecurityManagerTeamRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsRemoveSecurityManagerTeamResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface OrgsRemoveSecurityManagerTeamHandler {
  orgsRemoveSecurityManagerTeam(
    req: OrgsRemoveSecurityManagerTeamRequest,
    res: OrgsRemoveSecurityManagerTeamResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type BillingGetGithubActionsBillingOrgRequest = Request<
  BillingGetGithubActionsBillingOrgRequestPath,
  BillingGetGithubActionsBillingOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type BillingGetGithubActionsBillingOrgResponse = Response<
  BillingGetGithubActionsBillingOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface BillingGetGithubActionsBillingOrgHandler {
  billingGetGithubActionsBillingOrg(
    req: BillingGetGithubActionsBillingOrgRequest,
    res: BillingGetGithubActionsBillingOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type BillingGetGithubAdvancedSecurityBillingOrgRequest = Request<
  BillingGetGithubAdvancedSecurityBillingOrgRequestPath,
  | BillingGetGithubAdvancedSecurityBillingOrg200ResponseBody
  | BillingGetGithubAdvancedSecurityBillingOrg403ResponseBody,
  unknown,
  BillingGetGithubAdvancedSecurityBillingOrgRequestQuery,
  Record<string, any>
>;

export type BillingGetGithubAdvancedSecurityBillingOrgResponse = Response<
  | BillingGetGithubAdvancedSecurityBillingOrg200ResponseBody
  | BillingGetGithubAdvancedSecurityBillingOrg403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export interface BillingGetGithubAdvancedSecurityBillingOrgHandler {
  billingGetGithubAdvancedSecurityBillingOrg(
    req: BillingGetGithubAdvancedSecurityBillingOrgRequest,
    res: BillingGetGithubAdvancedSecurityBillingOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type BillingGetGithubPackagesBillingOrgRequest = Request<
  BillingGetGithubPackagesBillingOrgRequestPath,
  BillingGetGithubPackagesBillingOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type BillingGetGithubPackagesBillingOrgResponse = Response<
  BillingGetGithubPackagesBillingOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface BillingGetGithubPackagesBillingOrgHandler {
  billingGetGithubPackagesBillingOrg(
    req: BillingGetGithubPackagesBillingOrgRequest,
    res: BillingGetGithubPackagesBillingOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type BillingGetSharedStorageBillingOrgRequest = Request<
  BillingGetSharedStorageBillingOrgRequestPath,
  BillingGetSharedStorageBillingOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type BillingGetSharedStorageBillingOrgResponse = Response<
  BillingGetSharedStorageBillingOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface BillingGetSharedStorageBillingOrgHandler {
  billingGetSharedStorageBillingOrg(
    req: BillingGetSharedStorageBillingOrgRequest,
    res: BillingGetSharedStorageBillingOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListRequest = Request<
  TeamsListRequestPath,
  TeamsList200ResponseBody | TeamsList403ResponseBody,
  unknown,
  TeamsListRequestQuery,
  Record<string, any>
>;

export type TeamsListResponse = Response<
  TeamsList200ResponseBody | TeamsList403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export interface TeamsListHandler {
  teamsList(
    req: TeamsListRequest,
    res: TeamsListResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsCreateRequest = Request<
  TeamsCreateRequestPath,
  | TeamsCreate201ResponseBody
  | TeamsCreate403ResponseBody
  | TeamsCreate422ResponseBody,
  TeamsCreateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCreateResponse = Response<
  | TeamsCreate201ResponseBody
  | TeamsCreate403ResponseBody
  | TeamsCreate422ResponseBody,
  Record<string, any>,
  201 | 403 | 422
>;

export interface TeamsCreateHandler {
  teamsCreate(
    req: TeamsCreateRequest,
    res: TeamsCreateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsGetByNameRequest = Request<
  TeamsGetByNameRequestPath,
  TeamsGetByName200ResponseBody | TeamsGetByName404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetByNameResponse = Response<
  TeamsGetByName200ResponseBody | TeamsGetByName404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface TeamsGetByNameHandler {
  teamsGetByName(
    req: TeamsGetByNameRequest,
    res: TeamsGetByNameResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsUpdateInOrgRequest = Request<
  TeamsUpdateInOrgRequestPath,
  | TeamsUpdateInOrg200ResponseBody
  | TeamsUpdateInOrg201ResponseBody
  | TeamsUpdateInOrg403ResponseBody
  | TeamsUpdateInOrg404ResponseBody
  | TeamsUpdateInOrg422ResponseBody,
  TeamsUpdateInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsUpdateInOrgResponse = Response<
  | TeamsUpdateInOrg200ResponseBody
  | TeamsUpdateInOrg201ResponseBody
  | TeamsUpdateInOrg403ResponseBody
  | TeamsUpdateInOrg404ResponseBody
  | TeamsUpdateInOrg422ResponseBody,
  Record<string, any>,
  200 | 201 | 403 | 404 | 422
>;

export interface TeamsUpdateInOrgHandler {
  teamsUpdateInOrg(
    req: TeamsUpdateInOrgRequest,
    res: TeamsUpdateInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsDeleteInOrgRequest = Request<
  TeamsDeleteInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsDeleteInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface TeamsDeleteInOrgHandler {
  teamsDeleteInOrg(
    req: TeamsDeleteInOrgRequest,
    res: TeamsDeleteInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListDiscussionsInOrgRequest = Request<
  TeamsListDiscussionsInOrgRequestPath,
  TeamsListDiscussionsInOrg200ResponseBody,
  unknown,
  TeamsListDiscussionsInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListDiscussionsInOrgResponse = Response<
  TeamsListDiscussionsInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsListDiscussionsInOrgHandler {
  teamsListDiscussionsInOrg(
    req: TeamsListDiscussionsInOrgRequest,
    res: TeamsListDiscussionsInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsCreateDiscussionInOrgRequest = Request<
  TeamsCreateDiscussionInOrgRequestPath,
  TeamsCreateDiscussionInOrg201ResponseBody,
  TeamsCreateDiscussionInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCreateDiscussionInOrgResponse = Response<
  TeamsCreateDiscussionInOrg201ResponseBody,
  Record<string, any>,
  201
>;

export interface TeamsCreateDiscussionInOrgHandler {
  teamsCreateDiscussionInOrg(
    req: TeamsCreateDiscussionInOrgRequest,
    res: TeamsCreateDiscussionInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsGetDiscussionInOrgRequest = Request<
  TeamsGetDiscussionInOrgRequestPath,
  TeamsGetDiscussionInOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetDiscussionInOrgResponse = Response<
  TeamsGetDiscussionInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsGetDiscussionInOrgHandler {
  teamsGetDiscussionInOrg(
    req: TeamsGetDiscussionInOrgRequest,
    res: TeamsGetDiscussionInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsUpdateDiscussionInOrgRequest = Request<
  TeamsUpdateDiscussionInOrgRequestPath,
  TeamsUpdateDiscussionInOrg200ResponseBody,
  TeamsUpdateDiscussionInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsUpdateDiscussionInOrgResponse = Response<
  TeamsUpdateDiscussionInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsUpdateDiscussionInOrgHandler {
  teamsUpdateDiscussionInOrg(
    req: TeamsUpdateDiscussionInOrgRequest,
    res: TeamsUpdateDiscussionInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsDeleteDiscussionInOrgRequest = Request<
  TeamsDeleteDiscussionInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsDeleteDiscussionInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface TeamsDeleteDiscussionInOrgHandler {
  teamsDeleteDiscussionInOrg(
    req: TeamsDeleteDiscussionInOrgRequest,
    res: TeamsDeleteDiscussionInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListDiscussionCommentsInOrgRequest = Request<
  TeamsListDiscussionCommentsInOrgRequestPath,
  TeamsListDiscussionCommentsInOrg200ResponseBody,
  unknown,
  TeamsListDiscussionCommentsInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListDiscussionCommentsInOrgResponse = Response<
  TeamsListDiscussionCommentsInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsListDiscussionCommentsInOrgHandler {
  teamsListDiscussionCommentsInOrg(
    req: TeamsListDiscussionCommentsInOrgRequest,
    res: TeamsListDiscussionCommentsInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsCreateDiscussionCommentInOrgRequest = Request<
  TeamsCreateDiscussionCommentInOrgRequestPath,
  TeamsCreateDiscussionCommentInOrg201ResponseBody,
  TeamsCreateDiscussionCommentInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCreateDiscussionCommentInOrgResponse = Response<
  TeamsCreateDiscussionCommentInOrg201ResponseBody,
  Record<string, any>,
  201
>;

export interface TeamsCreateDiscussionCommentInOrgHandler {
  teamsCreateDiscussionCommentInOrg(
    req: TeamsCreateDiscussionCommentInOrgRequest,
    res: TeamsCreateDiscussionCommentInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsGetDiscussionCommentInOrgRequest = Request<
  TeamsGetDiscussionCommentInOrgRequestPath,
  TeamsGetDiscussionCommentInOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetDiscussionCommentInOrgResponse = Response<
  TeamsGetDiscussionCommentInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsGetDiscussionCommentInOrgHandler {
  teamsGetDiscussionCommentInOrg(
    req: TeamsGetDiscussionCommentInOrgRequest,
    res: TeamsGetDiscussionCommentInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsUpdateDiscussionCommentInOrgRequest = Request<
  TeamsUpdateDiscussionCommentInOrgRequestPath,
  TeamsUpdateDiscussionCommentInOrg200ResponseBody,
  TeamsUpdateDiscussionCommentInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsUpdateDiscussionCommentInOrgResponse = Response<
  TeamsUpdateDiscussionCommentInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsUpdateDiscussionCommentInOrgHandler {
  teamsUpdateDiscussionCommentInOrg(
    req: TeamsUpdateDiscussionCommentInOrgRequest,
    res: TeamsUpdateDiscussionCommentInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsDeleteDiscussionCommentInOrgRequest = Request<
  TeamsDeleteDiscussionCommentInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsDeleteDiscussionCommentInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface TeamsDeleteDiscussionCommentInOrgHandler {
  teamsDeleteDiscussionCommentInOrg(
    req: TeamsDeleteDiscussionCommentInOrgRequest,
    res: TeamsDeleteDiscussionCommentInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsListForTeamDiscussionCommentInOrgRequest = Request<
  ReactionsListForTeamDiscussionCommentInOrgRequestPath,
  ReactionsListForTeamDiscussionCommentInOrg200ResponseBody,
  unknown,
  ReactionsListForTeamDiscussionCommentInOrgRequestQuery,
  Record<string, any>
>;

export type ReactionsListForTeamDiscussionCommentInOrgResponse = Response<
  ReactionsListForTeamDiscussionCommentInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReactionsListForTeamDiscussionCommentInOrgHandler {
  reactionsListForTeamDiscussionCommentInOrg(
    req: ReactionsListForTeamDiscussionCommentInOrgRequest,
    res: ReactionsListForTeamDiscussionCommentInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsCreateForTeamDiscussionCommentInOrgRequest = Request<
  ReactionsCreateForTeamDiscussionCommentInOrgRequestPath,
  | ReactionsCreateForTeamDiscussionCommentInOrg200ResponseBody
  | ReactionsCreateForTeamDiscussionCommentInOrg201ResponseBody,
  ReactionsCreateForTeamDiscussionCommentInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForTeamDiscussionCommentInOrgResponse = Response<
  | ReactionsCreateForTeamDiscussionCommentInOrg200ResponseBody
  | ReactionsCreateForTeamDiscussionCommentInOrg201ResponseBody,
  Record<string, any>,
  200 | 201
>;

export interface ReactionsCreateForTeamDiscussionCommentInOrgHandler {
  reactionsCreateForTeamDiscussionCommentInOrg(
    req: ReactionsCreateForTeamDiscussionCommentInOrgRequest,
    res: ReactionsCreateForTeamDiscussionCommentInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsDeleteForTeamDiscussionCommentRequest = Request<
  ReactionsDeleteForTeamDiscussionCommentRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForTeamDiscussionCommentResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReactionsDeleteForTeamDiscussionCommentHandler {
  reactionsDeleteForTeamDiscussionComment(
    req: ReactionsDeleteForTeamDiscussionCommentRequest,
    res: ReactionsDeleteForTeamDiscussionCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsListForTeamDiscussionInOrgRequest = Request<
  ReactionsListForTeamDiscussionInOrgRequestPath,
  ReactionsListForTeamDiscussionInOrg200ResponseBody,
  unknown,
  ReactionsListForTeamDiscussionInOrgRequestQuery,
  Record<string, any>
>;

export type ReactionsListForTeamDiscussionInOrgResponse = Response<
  ReactionsListForTeamDiscussionInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReactionsListForTeamDiscussionInOrgHandler {
  reactionsListForTeamDiscussionInOrg(
    req: ReactionsListForTeamDiscussionInOrgRequest,
    res: ReactionsListForTeamDiscussionInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsCreateForTeamDiscussionInOrgRequest = Request<
  ReactionsCreateForTeamDiscussionInOrgRequestPath,
  | ReactionsCreateForTeamDiscussionInOrg200ResponseBody
  | ReactionsCreateForTeamDiscussionInOrg201ResponseBody,
  ReactionsCreateForTeamDiscussionInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForTeamDiscussionInOrgResponse = Response<
  | ReactionsCreateForTeamDiscussionInOrg200ResponseBody
  | ReactionsCreateForTeamDiscussionInOrg201ResponseBody,
  Record<string, any>,
  200 | 201
>;

export interface ReactionsCreateForTeamDiscussionInOrgHandler {
  reactionsCreateForTeamDiscussionInOrg(
    req: ReactionsCreateForTeamDiscussionInOrgRequest,
    res: ReactionsCreateForTeamDiscussionInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsDeleteForTeamDiscussionRequest = Request<
  ReactionsDeleteForTeamDiscussionRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForTeamDiscussionResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReactionsDeleteForTeamDiscussionHandler {
  reactionsDeleteForTeamDiscussion(
    req: ReactionsDeleteForTeamDiscussionRequest,
    res: ReactionsDeleteForTeamDiscussionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListPendingInvitationsInOrgRequest = Request<
  TeamsListPendingInvitationsInOrgRequestPath,
  TeamsListPendingInvitationsInOrg200ResponseBody,
  unknown,
  TeamsListPendingInvitationsInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListPendingInvitationsInOrgResponse = Response<
  TeamsListPendingInvitationsInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsListPendingInvitationsInOrgHandler {
  teamsListPendingInvitationsInOrg(
    req: TeamsListPendingInvitationsInOrgRequest,
    res: TeamsListPendingInvitationsInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListMembersInOrgRequest = Request<
  TeamsListMembersInOrgRequestPath,
  TeamsListMembersInOrg200ResponseBody,
  unknown,
  TeamsListMembersInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListMembersInOrgResponse = Response<
  TeamsListMembersInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsListMembersInOrgHandler {
  teamsListMembersInOrg(
    req: TeamsListMembersInOrgRequest,
    res: TeamsListMembersInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsGetMembershipForUserInOrgRequest = Request<
  TeamsGetMembershipForUserInOrgRequestPath,
  TeamsGetMembershipForUserInOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetMembershipForUserInOrgResponse = Response<
  TeamsGetMembershipForUserInOrg200ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface TeamsGetMembershipForUserInOrgHandler {
  teamsGetMembershipForUserInOrg(
    req: TeamsGetMembershipForUserInOrgRequest,
    res: TeamsGetMembershipForUserInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsAddOrUpdateMembershipForUserInOrgRequest = Request<
  TeamsAddOrUpdateMembershipForUserInOrgRequestPath,
  TeamsAddOrUpdateMembershipForUserInOrg200ResponseBody,
  TeamsAddOrUpdateMembershipForUserInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddOrUpdateMembershipForUserInOrgResponse = Response<
  TeamsAddOrUpdateMembershipForUserInOrg200ResponseBody,
  Record<string, any>,
  200 | 403 | 422
>;

export interface TeamsAddOrUpdateMembershipForUserInOrgHandler {
  teamsAddOrUpdateMembershipForUserInOrg(
    req: TeamsAddOrUpdateMembershipForUserInOrgRequest,
    res: TeamsAddOrUpdateMembershipForUserInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsRemoveMembershipForUserInOrgRequest = Request<
  TeamsRemoveMembershipForUserInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveMembershipForUserInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204 | 403
>;

export interface TeamsRemoveMembershipForUserInOrgHandler {
  teamsRemoveMembershipForUserInOrg(
    req: TeamsRemoveMembershipForUserInOrgRequest,
    res: TeamsRemoveMembershipForUserInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListProjectsInOrgRequest = Request<
  TeamsListProjectsInOrgRequestPath,
  TeamsListProjectsInOrg200ResponseBody,
  unknown,
  TeamsListProjectsInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListProjectsInOrgResponse = Response<
  TeamsListProjectsInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsListProjectsInOrgHandler {
  teamsListProjectsInOrg(
    req: TeamsListProjectsInOrgRequest,
    res: TeamsListProjectsInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsCheckPermissionsForProjectInOrgRequest = Request<
  TeamsCheckPermissionsForProjectInOrgRequestPath,
  TeamsCheckPermissionsForProjectInOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCheckPermissionsForProjectInOrgResponse = Response<
  TeamsCheckPermissionsForProjectInOrg200ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface TeamsCheckPermissionsForProjectInOrgHandler {
  teamsCheckPermissionsForProjectInOrg(
    req: TeamsCheckPermissionsForProjectInOrgRequest,
    res: TeamsCheckPermissionsForProjectInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsAddOrUpdateProjectPermissionsInOrgRequest = Request<
  TeamsAddOrUpdateProjectPermissionsInOrgRequestPath,
  TeamsAddOrUpdateProjectPermissionsInOrg403ResponseBody,
  TeamsAddOrUpdateProjectPermissionsInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddOrUpdateProjectPermissionsInOrgResponse = Response<
  TeamsAddOrUpdateProjectPermissionsInOrg403ResponseBody,
  Record<string, any>,
  204 | 403
>;

export interface TeamsAddOrUpdateProjectPermissionsInOrgHandler {
  teamsAddOrUpdateProjectPermissionsInOrg(
    req: TeamsAddOrUpdateProjectPermissionsInOrgRequest,
    res: TeamsAddOrUpdateProjectPermissionsInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsRemoveProjectInOrgRequest = Request<
  TeamsRemoveProjectInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveProjectInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface TeamsRemoveProjectInOrgHandler {
  teamsRemoveProjectInOrg(
    req: TeamsRemoveProjectInOrgRequest,
    res: TeamsRemoveProjectInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListReposInOrgRequest = Request<
  TeamsListReposInOrgRequestPath,
  TeamsListReposInOrg200ResponseBody,
  unknown,
  TeamsListReposInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListReposInOrgResponse = Response<
  TeamsListReposInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsListReposInOrgHandler {
  teamsListReposInOrg(
    req: TeamsListReposInOrgRequest,
    res: TeamsListReposInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsCheckPermissionsForRepoInOrgRequest = Request<
  TeamsCheckPermissionsForRepoInOrgRequestPath,
  TeamsCheckPermissionsForRepoInOrg200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCheckPermissionsForRepoInOrgResponse = Response<
  TeamsCheckPermissionsForRepoInOrg200ResponseBody,
  Record<string, any>,
  200 | 204 | 404
>;

export interface TeamsCheckPermissionsForRepoInOrgHandler {
  teamsCheckPermissionsForRepoInOrg(
    req: TeamsCheckPermissionsForRepoInOrgRequest,
    res: TeamsCheckPermissionsForRepoInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsAddOrUpdateRepoPermissionsInOrgRequest = Request<
  TeamsAddOrUpdateRepoPermissionsInOrgRequestPath,
  unknown,
  TeamsAddOrUpdateRepoPermissionsInOrgRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddOrUpdateRepoPermissionsInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface TeamsAddOrUpdateRepoPermissionsInOrgHandler {
  teamsAddOrUpdateRepoPermissionsInOrg(
    req: TeamsAddOrUpdateRepoPermissionsInOrgRequest,
    res: TeamsAddOrUpdateRepoPermissionsInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsRemoveRepoInOrgRequest = Request<
  TeamsRemoveRepoInOrgRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveRepoInOrgResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface TeamsRemoveRepoInOrgHandler {
  teamsRemoveRepoInOrg(
    req: TeamsRemoveRepoInOrgRequest,
    res: TeamsRemoveRepoInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListChildInOrgRequest = Request<
  TeamsListChildInOrgRequestPath,
  TeamsListChildInOrg200ResponseBody,
  unknown,
  TeamsListChildInOrgRequestQuery,
  Record<string, any>
>;

export type TeamsListChildInOrgResponse = Response<
  TeamsListChildInOrg200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsListChildInOrgHandler {
  teamsListChildInOrg(
    req: TeamsListChildInOrgRequest,
    res: TeamsListChildInOrgResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsEnableOrDisableSecurityProductOnAllOrgReposRequest = Request<
  OrgsEnableOrDisableSecurityProductOnAllOrgReposRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsEnableOrDisableSecurityProductOnAllOrgReposResponse = Response<
  unknown,
  Record<string, any>,
  204 | 422
>;

export interface OrgsEnableOrDisableSecurityProductOnAllOrgReposHandler {
  orgsEnableOrDisableSecurityProductOnAllOrgRepos(
    req: OrgsEnableOrDisableSecurityProductOnAllOrgReposRequest,
    res: OrgsEnableOrDisableSecurityProductOnAllOrgReposResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsGetCardRequest = Request<
  ProjectsGetCardRequestPath,
  | ProjectsGetCard200ResponseBody
  | ProjectsGetCard401ResponseBody
  | ProjectsGetCard403ResponseBody
  | ProjectsGetCard404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsGetCardResponse = Response<
  | ProjectsGetCard200ResponseBody
  | ProjectsGetCard401ResponseBody
  | ProjectsGetCard403ResponseBody
  | ProjectsGetCard404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export interface ProjectsGetCardHandler {
  projectsGetCard(
    req: ProjectsGetCardRequest,
    res: ProjectsGetCardResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsUpdateCardRequest = Request<
  ProjectsUpdateCardRequestPath,
  | ProjectsUpdateCard200ResponseBody
  | ProjectsUpdateCard401ResponseBody
  | ProjectsUpdateCard403ResponseBody
  | ProjectsUpdateCard404ResponseBody
  | ProjectsUpdateCard422ResponseBody,
  ProjectsUpdateCardRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsUpdateCardResponse = Response<
  | ProjectsUpdateCard200ResponseBody
  | ProjectsUpdateCard401ResponseBody
  | ProjectsUpdateCard403ResponseBody
  | ProjectsUpdateCard404ResponseBody
  | ProjectsUpdateCard422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 422
>;

export interface ProjectsUpdateCardHandler {
  projectsUpdateCard(
    req: ProjectsUpdateCardRequest,
    res: ProjectsUpdateCardResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsDeleteCardRequest = Request<
  ProjectsDeleteCardRequestPath,
  | ProjectsDeleteCard401ResponseBody
  | ProjectsDeleteCard403ResponseBody
  | ProjectsDeleteCard404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsDeleteCardResponse = Response<
  | ProjectsDeleteCard401ResponseBody
  | ProjectsDeleteCard403ResponseBody
  | ProjectsDeleteCard404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export interface ProjectsDeleteCardHandler {
  projectsDeleteCard(
    req: ProjectsDeleteCardRequest,
    res: ProjectsDeleteCardResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsMoveCardRequest = Request<
  ProjectsMoveCardRequestPath,
  | ProjectsMoveCard201ResponseBody
  | ProjectsMoveCard401ResponseBody
  | ProjectsMoveCard403ResponseBody
  | ProjectsMoveCard422ResponseBody
  | ProjectsMoveCard503ResponseBody,
  ProjectsMoveCardRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsMoveCardResponse = Response<
  | ProjectsMoveCard201ResponseBody
  | ProjectsMoveCard401ResponseBody
  | ProjectsMoveCard403ResponseBody
  | ProjectsMoveCard422ResponseBody
  | ProjectsMoveCard503ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 422 | 503
>;

export interface ProjectsMoveCardHandler {
  projectsMoveCard(
    req: ProjectsMoveCardRequest,
    res: ProjectsMoveCardResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsGetColumnRequest = Request<
  ProjectsGetColumnRequestPath,
  | ProjectsGetColumn200ResponseBody
  | ProjectsGetColumn401ResponseBody
  | ProjectsGetColumn403ResponseBody
  | ProjectsGetColumn404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsGetColumnResponse = Response<
  | ProjectsGetColumn200ResponseBody
  | ProjectsGetColumn401ResponseBody
  | ProjectsGetColumn403ResponseBody
  | ProjectsGetColumn404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export interface ProjectsGetColumnHandler {
  projectsGetColumn(
    req: ProjectsGetColumnRequest,
    res: ProjectsGetColumnResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsUpdateColumnRequest = Request<
  ProjectsUpdateColumnRequestPath,
  | ProjectsUpdateColumn200ResponseBody
  | ProjectsUpdateColumn401ResponseBody
  | ProjectsUpdateColumn403ResponseBody,
  ProjectsUpdateColumnRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsUpdateColumnResponse = Response<
  | ProjectsUpdateColumn200ResponseBody
  | ProjectsUpdateColumn401ResponseBody
  | ProjectsUpdateColumn403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface ProjectsUpdateColumnHandler {
  projectsUpdateColumn(
    req: ProjectsUpdateColumnRequest,
    res: ProjectsUpdateColumnResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsDeleteColumnRequest = Request<
  ProjectsDeleteColumnRequestPath,
  ProjectsDeleteColumn401ResponseBody | ProjectsDeleteColumn403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsDeleteColumnResponse = Response<
  ProjectsDeleteColumn401ResponseBody | ProjectsDeleteColumn403ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403
>;

export interface ProjectsDeleteColumnHandler {
  projectsDeleteColumn(
    req: ProjectsDeleteColumnRequest,
    res: ProjectsDeleteColumnResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsListCardsRequest = Request<
  ProjectsListCardsRequestPath,
  | ProjectsListCards200ResponseBody
  | ProjectsListCards401ResponseBody
  | ProjectsListCards403ResponseBody,
  unknown,
  ProjectsListCardsRequestQuery,
  Record<string, any>
>;

export type ProjectsListCardsResponse = Response<
  | ProjectsListCards200ResponseBody
  | ProjectsListCards401ResponseBody
  | ProjectsListCards403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface ProjectsListCardsHandler {
  projectsListCards(
    req: ProjectsListCardsRequest,
    res: ProjectsListCardsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsCreateCardRequest = Request<
  ProjectsCreateCardRequestPath,
  | ProjectsCreateCard201ResponseBody
  | ProjectsCreateCard401ResponseBody
  | ProjectsCreateCard403ResponseBody
  | ProjectsCreateCard422ResponseBody
  | ProjectsCreateCard503ResponseBody,
  ProjectsCreateCardRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsCreateCardResponse = Response<
  | ProjectsCreateCard201ResponseBody
  | ProjectsCreateCard401ResponseBody
  | ProjectsCreateCard403ResponseBody
  | ProjectsCreateCard422ResponseBody
  | ProjectsCreateCard503ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 422 | 503
>;

export interface ProjectsCreateCardHandler {
  projectsCreateCard(
    req: ProjectsCreateCardRequest,
    res: ProjectsCreateCardResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsMoveColumnRequest = Request<
  ProjectsMoveColumnRequestPath,
  | ProjectsMoveColumn201ResponseBody
  | ProjectsMoveColumn401ResponseBody
  | ProjectsMoveColumn403ResponseBody
  | ProjectsMoveColumn422ResponseBody,
  ProjectsMoveColumnRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsMoveColumnResponse = Response<
  | ProjectsMoveColumn201ResponseBody
  | ProjectsMoveColumn401ResponseBody
  | ProjectsMoveColumn403ResponseBody
  | ProjectsMoveColumn422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 422
>;

export interface ProjectsMoveColumnHandler {
  projectsMoveColumn(
    req: ProjectsMoveColumnRequest,
    res: ProjectsMoveColumnResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsGetRequest = Request<
  ProjectsGetRequestPath,
  | ProjectsGet200ResponseBody
  | ProjectsGet401ResponseBody
  | ProjectsGet403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsGetResponse = Response<
  | ProjectsGet200ResponseBody
  | ProjectsGet401ResponseBody
  | ProjectsGet403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface ProjectsGetHandler {
  projectsGet(
    req: ProjectsGetRequest,
    res: ProjectsGetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsUpdateRequest = Request<
  ProjectsUpdateRequestPath,
  | ProjectsUpdate200ResponseBody
  | ProjectsUpdate401ResponseBody
  | ProjectsUpdate403ResponseBody
  | ProjectsUpdate410ResponseBody
  | ProjectsUpdate422ResponseBody,
  ProjectsUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsUpdateResponse = Response<
  | ProjectsUpdate200ResponseBody
  | ProjectsUpdate401ResponseBody
  | ProjectsUpdate403ResponseBody
  | ProjectsUpdate410ResponseBody
  | ProjectsUpdate422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 410 | 422
>;

export interface ProjectsUpdateHandler {
  projectsUpdate(
    req: ProjectsUpdateRequest,
    res: ProjectsUpdateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsDeleteRequest = Request<
  ProjectsDeleteRequestPath,
  | ProjectsDelete401ResponseBody
  | ProjectsDelete403ResponseBody
  | ProjectsDelete404ResponseBody
  | ProjectsDelete410ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsDeleteResponse = Response<
  | ProjectsDelete401ResponseBody
  | ProjectsDelete403ResponseBody
  | ProjectsDelete404ResponseBody
  | ProjectsDelete410ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404 | 410
>;

export interface ProjectsDeleteHandler {
  projectsDelete(
    req: ProjectsDeleteRequest,
    res: ProjectsDeleteResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsListCollaboratorsRequest = Request<
  ProjectsListCollaboratorsRequestPath,
  | ProjectsListCollaborators200ResponseBody
  | ProjectsListCollaborators401ResponseBody
  | ProjectsListCollaborators403ResponseBody
  | ProjectsListCollaborators404ResponseBody
  | ProjectsListCollaborators422ResponseBody,
  unknown,
  ProjectsListCollaboratorsRequestQuery,
  Record<string, any>
>;

export type ProjectsListCollaboratorsResponse = Response<
  | ProjectsListCollaborators200ResponseBody
  | ProjectsListCollaborators401ResponseBody
  | ProjectsListCollaborators403ResponseBody
  | ProjectsListCollaborators404ResponseBody
  | ProjectsListCollaborators422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 422
>;

export interface ProjectsListCollaboratorsHandler {
  projectsListCollaborators(
    req: ProjectsListCollaboratorsRequest,
    res: ProjectsListCollaboratorsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsAddCollaboratorRequest = Request<
  ProjectsAddCollaboratorRequestPath,
  | ProjectsAddCollaborator401ResponseBody
  | ProjectsAddCollaborator403ResponseBody
  | ProjectsAddCollaborator404ResponseBody
  | ProjectsAddCollaborator422ResponseBody,
  ProjectsAddCollaboratorRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsAddCollaboratorResponse = Response<
  | ProjectsAddCollaborator401ResponseBody
  | ProjectsAddCollaborator403ResponseBody
  | ProjectsAddCollaborator404ResponseBody
  | ProjectsAddCollaborator422ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404 | 422
>;

export interface ProjectsAddCollaboratorHandler {
  projectsAddCollaborator(
    req: ProjectsAddCollaboratorRequest,
    res: ProjectsAddCollaboratorResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsRemoveCollaboratorRequest = Request<
  ProjectsRemoveCollaboratorRequestPath,
  | ProjectsRemoveCollaborator401ResponseBody
  | ProjectsRemoveCollaborator403ResponseBody
  | ProjectsRemoveCollaborator404ResponseBody
  | ProjectsRemoveCollaborator422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsRemoveCollaboratorResponse = Response<
  | ProjectsRemoveCollaborator401ResponseBody
  | ProjectsRemoveCollaborator403ResponseBody
  | ProjectsRemoveCollaborator404ResponseBody
  | ProjectsRemoveCollaborator422ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404 | 422
>;

export interface ProjectsRemoveCollaboratorHandler {
  projectsRemoveCollaborator(
    req: ProjectsRemoveCollaboratorRequest,
    res: ProjectsRemoveCollaboratorResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsGetPermissionForUserRequest = Request<
  ProjectsGetPermissionForUserRequestPath,
  | ProjectsGetPermissionForUser200ResponseBody
  | ProjectsGetPermissionForUser401ResponseBody
  | ProjectsGetPermissionForUser403ResponseBody
  | ProjectsGetPermissionForUser404ResponseBody
  | ProjectsGetPermissionForUser422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsGetPermissionForUserResponse = Response<
  | ProjectsGetPermissionForUser200ResponseBody
  | ProjectsGetPermissionForUser401ResponseBody
  | ProjectsGetPermissionForUser403ResponseBody
  | ProjectsGetPermissionForUser404ResponseBody
  | ProjectsGetPermissionForUser422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 422
>;

export interface ProjectsGetPermissionForUserHandler {
  projectsGetPermissionForUser(
    req: ProjectsGetPermissionForUserRequest,
    res: ProjectsGetPermissionForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsListColumnsRequest = Request<
  ProjectsListColumnsRequestPath,
  | ProjectsListColumns200ResponseBody
  | ProjectsListColumns401ResponseBody
  | ProjectsListColumns403ResponseBody,
  unknown,
  ProjectsListColumnsRequestQuery,
  Record<string, any>
>;

export type ProjectsListColumnsResponse = Response<
  | ProjectsListColumns200ResponseBody
  | ProjectsListColumns401ResponseBody
  | ProjectsListColumns403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface ProjectsListColumnsHandler {
  projectsListColumns(
    req: ProjectsListColumnsRequest,
    res: ProjectsListColumnsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsCreateColumnRequest = Request<
  ProjectsCreateColumnRequestPath,
  | ProjectsCreateColumn201ResponseBody
  | ProjectsCreateColumn401ResponseBody
  | ProjectsCreateColumn403ResponseBody
  | ProjectsCreateColumn422ResponseBody,
  ProjectsCreateColumnRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsCreateColumnResponse = Response<
  | ProjectsCreateColumn201ResponseBody
  | ProjectsCreateColumn401ResponseBody
  | ProjectsCreateColumn403ResponseBody
  | ProjectsCreateColumn422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 422
>;

export interface ProjectsCreateColumnHandler {
  projectsCreateColumn(
    req: ProjectsCreateColumnRequest,
    res: ProjectsCreateColumnResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type RateLimitGetRequest = Request<
  ParamsDictionary,
  RateLimitGet200ResponseBody | RateLimitGet404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type RateLimitGetResponse = Response<
  RateLimitGet200ResponseBody | RateLimitGet404ResponseBody,
  Record<string, any>,
  200 | 304 | 404
>;

export interface RateLimitGetHandler {
  rateLimitGet(
    req: RateLimitGetRequest,
    res: RateLimitGetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetRequest = Request<
  ReposGetRequestPath,
  | ReposGet200ResponseBody
  | ReposGet301ResponseBody
  | ReposGet403ResponseBody
  | ReposGet404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetResponse = Response<
  | ReposGet200ResponseBody
  | ReposGet301ResponseBody
  | ReposGet403ResponseBody
  | ReposGet404ResponseBody,
  Record<string, any>,
  200 | 301 | 403 | 404
>;

export interface ReposGetHandler {
  reposGet(
    req: ReposGetRequest,
    res: ReposGetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposUpdateRequest = Request<
  ReposUpdateRequestPath,
  | ReposUpdate200ResponseBody
  | ReposUpdate307ResponseBody
  | ReposUpdate403ResponseBody
  | ReposUpdate404ResponseBody
  | ReposUpdate422ResponseBody,
  ReposUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateResponse = Response<
  | ReposUpdate200ResponseBody
  | ReposUpdate307ResponseBody
  | ReposUpdate403ResponseBody
  | ReposUpdate404ResponseBody
  | ReposUpdate422ResponseBody,
  Record<string, any>,
  200 | 307 | 403 | 404 | 422
>;

export interface ReposUpdateHandler {
  reposUpdate(
    req: ReposUpdateRequest,
    res: ReposUpdateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteRequest = Request<
  ReposDeleteRequestPath,
  | ReposDelete307ResponseBody
  | ReposDelete403ResponseBody
  | ReposDelete404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteResponse = Response<
  | ReposDelete307ResponseBody
  | ReposDelete403ResponseBody
  | ReposDelete404ResponseBody,
  Record<string, any>,
  204 | 307 | 403 | 404
>;

export interface ReposDeleteHandler {
  reposDelete(
    req: ReposDeleteRequest,
    res: ReposDeleteResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListArtifactsForRepoRequest = Request<
  ActionsListArtifactsForRepoRequestPath,
  ActionsListArtifactsForRepo200ResponseBody,
  unknown,
  ActionsListArtifactsForRepoRequestQuery,
  Record<string, any>
>;

export type ActionsListArtifactsForRepoResponse = Response<
  ActionsListArtifactsForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListArtifactsForRepoHandler {
  actionsListArtifactsForRepo(
    req: ActionsListArtifactsForRepoRequest,
    res: ActionsListArtifactsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetArtifactRequest = Request<
  ActionsGetArtifactRequestPath,
  ActionsGetArtifact200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetArtifactResponse = Response<
  ActionsGetArtifact200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetArtifactHandler {
  actionsGetArtifact(
    req: ActionsGetArtifactRequest,
    res: ActionsGetArtifactResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDeleteArtifactRequest = Request<
  ActionsDeleteArtifactRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteArtifactResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsDeleteArtifactHandler {
  actionsDeleteArtifact(
    req: ActionsDeleteArtifactRequest,
    res: ActionsDeleteArtifactResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDownloadArtifactRequest = Request<
  ActionsDownloadArtifactRequestPath,
  ActionsDownloadArtifact410ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDownloadArtifactResponse = Response<
  ActionsDownloadArtifact410ResponseBody,
  Record<string, any>,
  302 | 410
>;

export interface ActionsDownloadArtifactHandler {
  actionsDownloadArtifact(
    req: ActionsDownloadArtifactRequest,
    res: ActionsDownloadArtifactResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetActionsCacheUsageRequest = Request<
  ActionsGetActionsCacheUsageRequestPath,
  ActionsGetActionsCacheUsage200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetActionsCacheUsageResponse = Response<
  ActionsGetActionsCacheUsage200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetActionsCacheUsageHandler {
  actionsGetActionsCacheUsage(
    req: ActionsGetActionsCacheUsageRequest,
    res: ActionsGetActionsCacheUsageResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetActionsCacheListRequest = Request<
  ActionsGetActionsCacheListRequestPath,
  ActionsGetActionsCacheList200ResponseBody,
  unknown,
  ActionsGetActionsCacheListRequestQuery,
  Record<string, any>
>;

export type ActionsGetActionsCacheListResponse = Response<
  ActionsGetActionsCacheList200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetActionsCacheListHandler {
  actionsGetActionsCacheList(
    req: ActionsGetActionsCacheListRequest,
    res: ActionsGetActionsCacheListResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDeleteActionsCacheByKeyRequest = Request<
  ActionsDeleteActionsCacheByKeyRequestPath,
  ActionsDeleteActionsCacheByKey200ResponseBody,
  unknown,
  ActionsDeleteActionsCacheByKeyRequestQuery,
  Record<string, any>
>;

export type ActionsDeleteActionsCacheByKeyResponse = Response<
  ActionsDeleteActionsCacheByKey200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsDeleteActionsCacheByKeyHandler {
  actionsDeleteActionsCacheByKey(
    req: ActionsDeleteActionsCacheByKeyRequest,
    res: ActionsDeleteActionsCacheByKeyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDeleteActionsCacheByIdRequest = Request<
  ActionsDeleteActionsCacheByIdRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteActionsCacheByIdResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsDeleteActionsCacheByIdHandler {
  actionsDeleteActionsCacheById(
    req: ActionsDeleteActionsCacheByIdRequest,
    res: ActionsDeleteActionsCacheByIdResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetJobForWorkflowRunRequest = Request<
  ActionsGetJobForWorkflowRunRequestPath,
  ActionsGetJobForWorkflowRun200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetJobForWorkflowRunResponse = Response<
  ActionsGetJobForWorkflowRun200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetJobForWorkflowRunHandler {
  actionsGetJobForWorkflowRun(
    req: ActionsGetJobForWorkflowRunRequest,
    res: ActionsGetJobForWorkflowRunResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDownloadJobLogsForWorkflowRunRequest = Request<
  ActionsDownloadJobLogsForWorkflowRunRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDownloadJobLogsForWorkflowRunResponse = Response<
  unknown,
  Record<string, any>,
  302
>;

export interface ActionsDownloadJobLogsForWorkflowRunHandler {
  actionsDownloadJobLogsForWorkflowRun(
    req: ActionsDownloadJobLogsForWorkflowRunRequest,
    res: ActionsDownloadJobLogsForWorkflowRunResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsReRunJobForWorkflowRunRequest = Request<
  ActionsReRunJobForWorkflowRunRequestPath,
  | ActionsReRunJobForWorkflowRun201ResponseBody
  | ActionsReRunJobForWorkflowRun403ResponseBody,
  ActionsReRunJobForWorkflowRunRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsReRunJobForWorkflowRunResponse = Response<
  | ActionsReRunJobForWorkflowRun201ResponseBody
  | ActionsReRunJobForWorkflowRun403ResponseBody,
  Record<string, any>,
  201 | 403
>;

export interface ActionsReRunJobForWorkflowRunHandler {
  actionsReRunJobForWorkflowRun(
    req: ActionsReRunJobForWorkflowRunRequest,
    res: ActionsReRunJobForWorkflowRunResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetGithubActionsPermissionsRepositoryRequest = Request<
  ActionsGetGithubActionsPermissionsRepositoryRequestPath,
  ActionsGetGithubActionsPermissionsRepository200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetGithubActionsPermissionsRepositoryResponse = Response<
  ActionsGetGithubActionsPermissionsRepository200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetGithubActionsPermissionsRepositoryHandler {
  actionsGetGithubActionsPermissionsRepository(
    req: ActionsGetGithubActionsPermissionsRepositoryRequest,
    res: ActionsGetGithubActionsPermissionsRepositoryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetGithubActionsPermissionsRepositoryRequest = Request<
  ActionsSetGithubActionsPermissionsRepositoryRequestPath,
  unknown,
  ActionsSetGithubActionsPermissionsRepositoryRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetGithubActionsPermissionsRepositoryResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsSetGithubActionsPermissionsRepositoryHandler {
  actionsSetGithubActionsPermissionsRepository(
    req: ActionsSetGithubActionsPermissionsRepositoryRequest,
    res: ActionsSetGithubActionsPermissionsRepositoryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetWorkflowAccessToRepositoryRequest = Request<
  ActionsGetWorkflowAccessToRepositoryRequestPath,
  ActionsGetWorkflowAccessToRepository200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetWorkflowAccessToRepositoryResponse = Response<
  ActionsGetWorkflowAccessToRepository200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetWorkflowAccessToRepositoryHandler {
  actionsGetWorkflowAccessToRepository(
    req: ActionsGetWorkflowAccessToRepositoryRequest,
    res: ActionsGetWorkflowAccessToRepositoryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetWorkflowAccessToRepositoryRequest = Request<
  ActionsSetWorkflowAccessToRepositoryRequestPath,
  unknown,
  ActionsSetWorkflowAccessToRepositoryRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetWorkflowAccessToRepositoryResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsSetWorkflowAccessToRepositoryHandler {
  actionsSetWorkflowAccessToRepository(
    req: ActionsSetWorkflowAccessToRepositoryRequest,
    res: ActionsSetWorkflowAccessToRepositoryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetAllowedActionsRepositoryRequest = Request<
  ActionsGetAllowedActionsRepositoryRequestPath,
  ActionsGetAllowedActionsRepository200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetAllowedActionsRepositoryResponse = Response<
  ActionsGetAllowedActionsRepository200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetAllowedActionsRepositoryHandler {
  actionsGetAllowedActionsRepository(
    req: ActionsGetAllowedActionsRepositoryRequest,
    res: ActionsGetAllowedActionsRepositoryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetAllowedActionsRepositoryRequest = Request<
  ActionsSetAllowedActionsRepositoryRequestPath,
  unknown,
  ActionsSetAllowedActionsRepositoryRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetAllowedActionsRepositoryResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsSetAllowedActionsRepositoryHandler {
  actionsSetAllowedActionsRepository(
    req: ActionsSetAllowedActionsRepositoryRequest,
    res: ActionsSetAllowedActionsRepositoryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest = Request<
  ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequestPath,
  ActionsGetGithubActionsDefaultWorkflowPermissionsRepository200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse = Response<
  ActionsGetGithubActionsDefaultWorkflowPermissionsRepository200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryHandler {
  actionsGetGithubActionsDefaultWorkflowPermissionsRepository(
    req: ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest,
    res: ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest = Request<
  ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequestPath,
  unknown,
  ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export interface ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryHandler {
  actionsSetGithubActionsDefaultWorkflowPermissionsRepository(
    req: ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest,
    res: ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListSelfHostedRunnersForRepoRequest = Request<
  ActionsListSelfHostedRunnersForRepoRequestPath,
  ActionsListSelfHostedRunnersForRepo200ResponseBody,
  unknown,
  ActionsListSelfHostedRunnersForRepoRequestQuery,
  Record<string, any>
>;

export type ActionsListSelfHostedRunnersForRepoResponse = Response<
  ActionsListSelfHostedRunnersForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListSelfHostedRunnersForRepoHandler {
  actionsListSelfHostedRunnersForRepo(
    req: ActionsListSelfHostedRunnersForRepoRequest,
    res: ActionsListSelfHostedRunnersForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListRunnerApplicationsForRepoRequest = Request<
  ActionsListRunnerApplicationsForRepoRequestPath,
  ActionsListRunnerApplicationsForRepo200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsListRunnerApplicationsForRepoResponse = Response<
  ActionsListRunnerApplicationsForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListRunnerApplicationsForRepoHandler {
  actionsListRunnerApplicationsForRepo(
    req: ActionsListRunnerApplicationsForRepoRequest,
    res: ActionsListRunnerApplicationsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsCreateRegistrationTokenForRepoRequest = Request<
  ActionsCreateRegistrationTokenForRepoRequestPath,
  ActionsCreateRegistrationTokenForRepo201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateRegistrationTokenForRepoResponse = Response<
  ActionsCreateRegistrationTokenForRepo201ResponseBody,
  Record<string, any>,
  201
>;

export interface ActionsCreateRegistrationTokenForRepoHandler {
  actionsCreateRegistrationTokenForRepo(
    req: ActionsCreateRegistrationTokenForRepoRequest,
    res: ActionsCreateRegistrationTokenForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsCreateRemoveTokenForRepoRequest = Request<
  ActionsCreateRemoveTokenForRepoRequestPath,
  ActionsCreateRemoveTokenForRepo201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateRemoveTokenForRepoResponse = Response<
  ActionsCreateRemoveTokenForRepo201ResponseBody,
  Record<string, any>,
  201
>;

export interface ActionsCreateRemoveTokenForRepoHandler {
  actionsCreateRemoveTokenForRepo(
    req: ActionsCreateRemoveTokenForRepoRequest,
    res: ActionsCreateRemoveTokenForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetSelfHostedRunnerForRepoRequest = Request<
  ActionsGetSelfHostedRunnerForRepoRequestPath,
  ActionsGetSelfHostedRunnerForRepo200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetSelfHostedRunnerForRepoResponse = Response<
  ActionsGetSelfHostedRunnerForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetSelfHostedRunnerForRepoHandler {
  actionsGetSelfHostedRunnerForRepo(
    req: ActionsGetSelfHostedRunnerForRepoRequest,
    res: ActionsGetSelfHostedRunnerForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDeleteSelfHostedRunnerFromRepoRequest = Request<
  ActionsDeleteSelfHostedRunnerFromRepoRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteSelfHostedRunnerFromRepoResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsDeleteSelfHostedRunnerFromRepoHandler {
  actionsDeleteSelfHostedRunnerFromRepo(
    req: ActionsDeleteSelfHostedRunnerFromRepoRequest,
    res: ActionsDeleteSelfHostedRunnerFromRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListLabelsForSelfHostedRunnerForRepoRequest = Request<
  ActionsListLabelsForSelfHostedRunnerForRepoRequestPath,
  | ActionsListLabelsForSelfHostedRunnerForRepo200ResponseBody
  | ActionsListLabelsForSelfHostedRunnerForRepo404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsListLabelsForSelfHostedRunnerForRepoResponse = Response<
  | ActionsListLabelsForSelfHostedRunnerForRepo200ResponseBody
  | ActionsListLabelsForSelfHostedRunnerForRepo404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ActionsListLabelsForSelfHostedRunnerForRepoHandler {
  actionsListLabelsForSelfHostedRunnerForRepo(
    req: ActionsListLabelsForSelfHostedRunnerForRepoRequest,
    res: ActionsListLabelsForSelfHostedRunnerForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest = Request<
  ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestPath,
  | ActionsAddCustomLabelsToSelfHostedRunnerForRepo200ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForRepo404ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForRepo422ResponseBody,
  ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse = Response<
  | ActionsAddCustomLabelsToSelfHostedRunnerForRepo200ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForRepo404ResponseBody
  | ActionsAddCustomLabelsToSelfHostedRunnerForRepo422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface ActionsAddCustomLabelsToSelfHostedRunnerForRepoHandler {
  actionsAddCustomLabelsToSelfHostedRunnerForRepo(
    req: ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest,
    res: ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest = Request<
  ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestPath,
  | ActionsSetCustomLabelsForSelfHostedRunnerForRepo200ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForRepo404ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForRepo422ResponseBody,
  ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse = Response<
  | ActionsSetCustomLabelsForSelfHostedRunnerForRepo200ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForRepo404ResponseBody
  | ActionsSetCustomLabelsForSelfHostedRunnerForRepo422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface ActionsSetCustomLabelsForSelfHostedRunnerForRepoHandler {
  actionsSetCustomLabelsForSelfHostedRunnerForRepo(
    req: ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest,
    res: ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest = Request<
  ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequestPath,
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo200ResponseBody
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse = Response<
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo200ResponseBody
  | ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoHandler {
  actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo(
    req: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest,
    res: ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest = Request<
  ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequestPath,
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo200ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo404ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse = Response<
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo200ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo404ResponseBody
  | ActionsRemoveCustomLabelFromSelfHostedRunnerForRepo422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoHandler {
  actionsRemoveCustomLabelFromSelfHostedRunnerForRepo(
    req: ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest,
    res: ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListWorkflowRunsForRepoRequest = Request<
  ActionsListWorkflowRunsForRepoRequestPath,
  ActionsListWorkflowRunsForRepo200ResponseBody,
  unknown,
  ActionsListWorkflowRunsForRepoRequestQuery,
  Record<string, any>
>;

export type ActionsListWorkflowRunsForRepoResponse = Response<
  ActionsListWorkflowRunsForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListWorkflowRunsForRepoHandler {
  actionsListWorkflowRunsForRepo(
    req: ActionsListWorkflowRunsForRepoRequest,
    res: ActionsListWorkflowRunsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetWorkflowRunRequest = Request<
  ActionsGetWorkflowRunRequestPath,
  ActionsGetWorkflowRun200ResponseBody,
  unknown,
  ActionsGetWorkflowRunRequestQuery,
  Record<string, any>
>;

export type ActionsGetWorkflowRunResponse = Response<
  ActionsGetWorkflowRun200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetWorkflowRunHandler {
  actionsGetWorkflowRun(
    req: ActionsGetWorkflowRunRequest,
    res: ActionsGetWorkflowRunResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDeleteWorkflowRunRequest = Request<
  ActionsDeleteWorkflowRunRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteWorkflowRunResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsDeleteWorkflowRunHandler {
  actionsDeleteWorkflowRun(
    req: ActionsDeleteWorkflowRunRequest,
    res: ActionsDeleteWorkflowRunResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetReviewsForRunRequest = Request<
  ActionsGetReviewsForRunRequestPath,
  ActionsGetReviewsForRun200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetReviewsForRunResponse = Response<
  ActionsGetReviewsForRun200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetReviewsForRunHandler {
  actionsGetReviewsForRun(
    req: ActionsGetReviewsForRunRequest,
    res: ActionsGetReviewsForRunResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsApproveWorkflowRunRequest = Request<
  ActionsApproveWorkflowRunRequestPath,
  | ActionsApproveWorkflowRun201ResponseBody
  | ActionsApproveWorkflowRun403ResponseBody
  | ActionsApproveWorkflowRun404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsApproveWorkflowRunResponse = Response<
  | ActionsApproveWorkflowRun201ResponseBody
  | ActionsApproveWorkflowRun403ResponseBody
  | ActionsApproveWorkflowRun404ResponseBody,
  Record<string, any>,
  201 | 403 | 404
>;

export interface ActionsApproveWorkflowRunHandler {
  actionsApproveWorkflowRun(
    req: ActionsApproveWorkflowRunRequest,
    res: ActionsApproveWorkflowRunResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListWorkflowRunArtifactsRequest = Request<
  ActionsListWorkflowRunArtifactsRequestPath,
  ActionsListWorkflowRunArtifacts200ResponseBody,
  unknown,
  ActionsListWorkflowRunArtifactsRequestQuery,
  Record<string, any>
>;

export type ActionsListWorkflowRunArtifactsResponse = Response<
  ActionsListWorkflowRunArtifacts200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListWorkflowRunArtifactsHandler {
  actionsListWorkflowRunArtifacts(
    req: ActionsListWorkflowRunArtifactsRequest,
    res: ActionsListWorkflowRunArtifactsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetWorkflowRunAttemptRequest = Request<
  ActionsGetWorkflowRunAttemptRequestPath,
  ActionsGetWorkflowRunAttempt200ResponseBody,
  unknown,
  ActionsGetWorkflowRunAttemptRequestQuery,
  Record<string, any>
>;

export type ActionsGetWorkflowRunAttemptResponse = Response<
  ActionsGetWorkflowRunAttempt200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetWorkflowRunAttemptHandler {
  actionsGetWorkflowRunAttempt(
    req: ActionsGetWorkflowRunAttemptRequest,
    res: ActionsGetWorkflowRunAttemptResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListJobsForWorkflowRunAttemptRequest = Request<
  ActionsListJobsForWorkflowRunAttemptRequestPath,
  | ActionsListJobsForWorkflowRunAttempt200ResponseBody
  | ActionsListJobsForWorkflowRunAttempt404ResponseBody,
  unknown,
  ActionsListJobsForWorkflowRunAttemptRequestQuery,
  Record<string, any>
>;

export type ActionsListJobsForWorkflowRunAttemptResponse = Response<
  | ActionsListJobsForWorkflowRunAttempt200ResponseBody
  | ActionsListJobsForWorkflowRunAttempt404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ActionsListJobsForWorkflowRunAttemptHandler {
  actionsListJobsForWorkflowRunAttempt(
    req: ActionsListJobsForWorkflowRunAttemptRequest,
    res: ActionsListJobsForWorkflowRunAttemptResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDownloadWorkflowRunAttemptLogsRequest = Request<
  ActionsDownloadWorkflowRunAttemptLogsRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDownloadWorkflowRunAttemptLogsResponse = Response<
  unknown,
  Record<string, any>,
  302
>;

export interface ActionsDownloadWorkflowRunAttemptLogsHandler {
  actionsDownloadWorkflowRunAttemptLogs(
    req: ActionsDownloadWorkflowRunAttemptLogsRequest,
    res: ActionsDownloadWorkflowRunAttemptLogsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsCancelWorkflowRunRequest = Request<
  ActionsCancelWorkflowRunRequestPath,
  | ActionsCancelWorkflowRun202ResponseBody
  | ActionsCancelWorkflowRun409ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCancelWorkflowRunResponse = Response<
  | ActionsCancelWorkflowRun202ResponseBody
  | ActionsCancelWorkflowRun409ResponseBody,
  Record<string, any>,
  202 | 409
>;

export interface ActionsCancelWorkflowRunHandler {
  actionsCancelWorkflowRun(
    req: ActionsCancelWorkflowRunRequest,
    res: ActionsCancelWorkflowRunResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListJobsForWorkflowRunRequest = Request<
  ActionsListJobsForWorkflowRunRequestPath,
  ActionsListJobsForWorkflowRun200ResponseBody,
  unknown,
  ActionsListJobsForWorkflowRunRequestQuery,
  Record<string, any>
>;

export type ActionsListJobsForWorkflowRunResponse = Response<
  ActionsListJobsForWorkflowRun200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListJobsForWorkflowRunHandler {
  actionsListJobsForWorkflowRun(
    req: ActionsListJobsForWorkflowRunRequest,
    res: ActionsListJobsForWorkflowRunResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDownloadWorkflowRunLogsRequest = Request<
  ActionsDownloadWorkflowRunLogsRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDownloadWorkflowRunLogsResponse = Response<
  unknown,
  Record<string, any>,
  302
>;

export interface ActionsDownloadWorkflowRunLogsHandler {
  actionsDownloadWorkflowRunLogs(
    req: ActionsDownloadWorkflowRunLogsRequest,
    res: ActionsDownloadWorkflowRunLogsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDeleteWorkflowRunLogsRequest = Request<
  ActionsDeleteWorkflowRunLogsRequestPath,
  | ActionsDeleteWorkflowRunLogs403ResponseBody
  | ActionsDeleteWorkflowRunLogs500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteWorkflowRunLogsResponse = Response<
  | ActionsDeleteWorkflowRunLogs403ResponseBody
  | ActionsDeleteWorkflowRunLogs500ResponseBody,
  Record<string, any>,
  204 | 403 | 500
>;

export interface ActionsDeleteWorkflowRunLogsHandler {
  actionsDeleteWorkflowRunLogs(
    req: ActionsDeleteWorkflowRunLogsRequest,
    res: ActionsDeleteWorkflowRunLogsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetPendingDeploymentsForRunRequest = Request<
  ActionsGetPendingDeploymentsForRunRequestPath,
  ActionsGetPendingDeploymentsForRun200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetPendingDeploymentsForRunResponse = Response<
  ActionsGetPendingDeploymentsForRun200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetPendingDeploymentsForRunHandler {
  actionsGetPendingDeploymentsForRun(
    req: ActionsGetPendingDeploymentsForRunRequest,
    res: ActionsGetPendingDeploymentsForRunResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsReviewPendingDeploymentsForRunRequest = Request<
  ActionsReviewPendingDeploymentsForRunRequestPath,
  ActionsReviewPendingDeploymentsForRun200ResponseBody,
  ActionsReviewPendingDeploymentsForRunRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsReviewPendingDeploymentsForRunResponse = Response<
  ActionsReviewPendingDeploymentsForRun200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsReviewPendingDeploymentsForRunHandler {
  actionsReviewPendingDeploymentsForRun(
    req: ActionsReviewPendingDeploymentsForRunRequest,
    res: ActionsReviewPendingDeploymentsForRunResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsReRunWorkflowRequest = Request<
  ActionsReRunWorkflowRequestPath,
  ActionsReRunWorkflow201ResponseBody,
  ActionsReRunWorkflowRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsReRunWorkflowResponse = Response<
  ActionsReRunWorkflow201ResponseBody,
  Record<string, any>,
  201
>;

export interface ActionsReRunWorkflowHandler {
  actionsReRunWorkflow(
    req: ActionsReRunWorkflowRequest,
    res: ActionsReRunWorkflowResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsReRunWorkflowFailedJobsRequest = Request<
  ActionsReRunWorkflowFailedJobsRequestPath,
  ActionsReRunWorkflowFailedJobs201ResponseBody,
  ActionsReRunWorkflowFailedJobsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsReRunWorkflowFailedJobsResponse = Response<
  ActionsReRunWorkflowFailedJobs201ResponseBody,
  Record<string, any>,
  201
>;

export interface ActionsReRunWorkflowFailedJobsHandler {
  actionsReRunWorkflowFailedJobs(
    req: ActionsReRunWorkflowFailedJobsRequest,
    res: ActionsReRunWorkflowFailedJobsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetWorkflowRunUsageRequest = Request<
  ActionsGetWorkflowRunUsageRequestPath,
  ActionsGetWorkflowRunUsage200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetWorkflowRunUsageResponse = Response<
  ActionsGetWorkflowRunUsage200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetWorkflowRunUsageHandler {
  actionsGetWorkflowRunUsage(
    req: ActionsGetWorkflowRunUsageRequest,
    res: ActionsGetWorkflowRunUsageResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListRepoSecretsRequest = Request<
  ActionsListRepoSecretsRequestPath,
  ActionsListRepoSecrets200ResponseBody,
  unknown,
  ActionsListRepoSecretsRequestQuery,
  Record<string, any>
>;

export type ActionsListRepoSecretsResponse = Response<
  ActionsListRepoSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListRepoSecretsHandler {
  actionsListRepoSecrets(
    req: ActionsListRepoSecretsRequest,
    res: ActionsListRepoSecretsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetRepoPublicKeyRequest = Request<
  ActionsGetRepoPublicKeyRequestPath,
  ActionsGetRepoPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetRepoPublicKeyResponse = Response<
  ActionsGetRepoPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetRepoPublicKeyHandler {
  actionsGetRepoPublicKey(
    req: ActionsGetRepoPublicKeyRequest,
    res: ActionsGetRepoPublicKeyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetRepoSecretRequest = Request<
  ActionsGetRepoSecretRequestPath,
  ActionsGetRepoSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetRepoSecretResponse = Response<
  ActionsGetRepoSecret200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetRepoSecretHandler {
  actionsGetRepoSecret(
    req: ActionsGetRepoSecretRequest,
    res: ActionsGetRepoSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsCreateOrUpdateRepoSecretRequest = Request<
  ActionsCreateOrUpdateRepoSecretRequestPath,
  ActionsCreateOrUpdateRepoSecret201ResponseBody,
  ActionsCreateOrUpdateRepoSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateOrUpdateRepoSecretResponse = Response<
  ActionsCreateOrUpdateRepoSecret201ResponseBody,
  Record<string, any>,
  201 | 204
>;

export interface ActionsCreateOrUpdateRepoSecretHandler {
  actionsCreateOrUpdateRepoSecret(
    req: ActionsCreateOrUpdateRepoSecretRequest,
    res: ActionsCreateOrUpdateRepoSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDeleteRepoSecretRequest = Request<
  ActionsDeleteRepoSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteRepoSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsDeleteRepoSecretHandler {
  actionsDeleteRepoSecret(
    req: ActionsDeleteRepoSecretRequest,
    res: ActionsDeleteRepoSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListRepoWorkflowsRequest = Request<
  ActionsListRepoWorkflowsRequestPath,
  ActionsListRepoWorkflows200ResponseBody,
  unknown,
  ActionsListRepoWorkflowsRequestQuery,
  Record<string, any>
>;

export type ActionsListRepoWorkflowsResponse = Response<
  ActionsListRepoWorkflows200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListRepoWorkflowsHandler {
  actionsListRepoWorkflows(
    req: ActionsListRepoWorkflowsRequest,
    res: ActionsListRepoWorkflowsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetWorkflowRequest = Request<
  ActionsGetWorkflowRequestPath,
  ActionsGetWorkflow200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetWorkflowResponse = Response<
  ActionsGetWorkflow200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetWorkflowHandler {
  actionsGetWorkflow(
    req: ActionsGetWorkflowRequest,
    res: ActionsGetWorkflowResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDisableWorkflowRequest = Request<
  ActionsDisableWorkflowRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDisableWorkflowResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsDisableWorkflowHandler {
  actionsDisableWorkflow(
    req: ActionsDisableWorkflowRequest,
    res: ActionsDisableWorkflowResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsCreateWorkflowDispatchRequest = Request<
  ActionsCreateWorkflowDispatchRequestPath,
  unknown,
  ActionsCreateWorkflowDispatchRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateWorkflowDispatchResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsCreateWorkflowDispatchHandler {
  actionsCreateWorkflowDispatch(
    req: ActionsCreateWorkflowDispatchRequest,
    res: ActionsCreateWorkflowDispatchResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsEnableWorkflowRequest = Request<
  ActionsEnableWorkflowRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsEnableWorkflowResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsEnableWorkflowHandler {
  actionsEnableWorkflow(
    req: ActionsEnableWorkflowRequest,
    res: ActionsEnableWorkflowResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListWorkflowRunsRequest = Request<
  ActionsListWorkflowRunsRequestPath,
  ActionsListWorkflowRuns200ResponseBody,
  unknown,
  ActionsListWorkflowRunsRequestQuery,
  Record<string, any>
>;

export type ActionsListWorkflowRunsResponse = Response<
  ActionsListWorkflowRuns200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListWorkflowRunsHandler {
  actionsListWorkflowRuns(
    req: ActionsListWorkflowRunsRequest,
    res: ActionsListWorkflowRunsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetWorkflowUsageRequest = Request<
  ActionsGetWorkflowUsageRequestPath,
  ActionsGetWorkflowUsage200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetWorkflowUsageResponse = Response<
  ActionsGetWorkflowUsage200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetWorkflowUsageHandler {
  actionsGetWorkflowUsage(
    req: ActionsGetWorkflowUsageRequest,
    res: ActionsGetWorkflowUsageResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListAssigneesRequest = Request<
  IssuesListAssigneesRequestPath,
  IssuesListAssignees200ResponseBody | IssuesListAssignees404ResponseBody,
  unknown,
  IssuesListAssigneesRequestQuery,
  Record<string, any>
>;

export type IssuesListAssigneesResponse = Response<
  IssuesListAssignees200ResponseBody | IssuesListAssignees404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface IssuesListAssigneesHandler {
  issuesListAssignees(
    req: IssuesListAssigneesRequest,
    res: IssuesListAssigneesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesCheckUserCanBeAssignedRequest = Request<
  IssuesCheckUserCanBeAssignedRequestPath,
  IssuesCheckUserCanBeAssigned404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesCheckUserCanBeAssignedResponse = Response<
  IssuesCheckUserCanBeAssigned404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface IssuesCheckUserCanBeAssignedHandler {
  issuesCheckUserCanBeAssigned(
    req: IssuesCheckUserCanBeAssignedRequest,
    res: IssuesCheckUserCanBeAssignedResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListAutolinksRequest = Request<
  ReposListAutolinksRequestPath,
  ReposListAutolinks200ResponseBody,
  unknown,
  ReposListAutolinksRequestQuery,
  Record<string, any>
>;

export type ReposListAutolinksResponse = Response<
  ReposListAutolinks200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListAutolinksHandler {
  reposListAutolinks(
    req: ReposListAutolinksRequest,
    res: ReposListAutolinksResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateAutolinkRequest = Request<
  ReposCreateAutolinkRequestPath,
  ReposCreateAutolink201ResponseBody | ReposCreateAutolink422ResponseBody,
  ReposCreateAutolinkRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateAutolinkResponse = Response<
  ReposCreateAutolink201ResponseBody | ReposCreateAutolink422ResponseBody,
  Record<string, any>,
  201 | 422
>;

export interface ReposCreateAutolinkHandler {
  reposCreateAutolink(
    req: ReposCreateAutolinkRequest,
    res: ReposCreateAutolinkResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetAutolinkRequest = Request<
  ReposGetAutolinkRequestPath,
  ReposGetAutolink200ResponseBody | ReposGetAutolink404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetAutolinkResponse = Response<
  ReposGetAutolink200ResponseBody | ReposGetAutolink404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetAutolinkHandler {
  reposGetAutolink(
    req: ReposGetAutolinkRequest,
    res: ReposGetAutolinkResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteAutolinkRequest = Request<
  ReposDeleteAutolinkRequestPath,
  ReposDeleteAutolink404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteAutolinkResponse = Response<
  ReposDeleteAutolink404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface ReposDeleteAutolinkHandler {
  reposDeleteAutolink(
    req: ReposDeleteAutolinkRequest,
    res: ReposDeleteAutolinkResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposEnableAutomatedSecurityFixesRequest = Request<
  ReposEnableAutomatedSecurityFixesRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposEnableAutomatedSecurityFixesResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposEnableAutomatedSecurityFixesHandler {
  reposEnableAutomatedSecurityFixes(
    req: ReposEnableAutomatedSecurityFixesRequest,
    res: ReposEnableAutomatedSecurityFixesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDisableAutomatedSecurityFixesRequest = Request<
  ReposDisableAutomatedSecurityFixesRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDisableAutomatedSecurityFixesResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposDisableAutomatedSecurityFixesHandler {
  reposDisableAutomatedSecurityFixes(
    req: ReposDisableAutomatedSecurityFixesRequest,
    res: ReposDisableAutomatedSecurityFixesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListBranchesRequest = Request<
  ReposListBranchesRequestPath,
  ReposListBranches200ResponseBody | ReposListBranches404ResponseBody,
  unknown,
  ReposListBranchesRequestQuery,
  Record<string, any>
>;

export type ReposListBranchesResponse = Response<
  ReposListBranches200ResponseBody | ReposListBranches404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposListBranchesHandler {
  reposListBranches(
    req: ReposListBranchesRequest,
    res: ReposListBranchesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetBranchRequest = Request<
  ReposGetBranchRequestPath,
  | ReposGetBranch200ResponseBody
  | ReposGetBranch301ResponseBody
  | ReposGetBranch404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetBranchResponse = Response<
  | ReposGetBranch200ResponseBody
  | ReposGetBranch301ResponseBody
  | ReposGetBranch404ResponseBody,
  Record<string, any>,
  200 | 301 | 404
>;

export interface ReposGetBranchHandler {
  reposGetBranch(
    req: ReposGetBranchRequest,
    res: ReposGetBranchResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetBranchProtectionRequest = Request<
  ReposGetBranchProtectionRequestPath,
  | ReposGetBranchProtection200ResponseBody
  | ReposGetBranchProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetBranchProtectionResponse = Response<
  | ReposGetBranchProtection200ResponseBody
  | ReposGetBranchProtection404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetBranchProtectionHandler {
  reposGetBranchProtection(
    req: ReposGetBranchProtectionRequest,
    res: ReposGetBranchProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposUpdateBranchProtectionRequest = Request<
  ReposUpdateBranchProtectionRequestPath,
  | ReposUpdateBranchProtection200ResponseBody
  | ReposUpdateBranchProtection403ResponseBody
  | ReposUpdateBranchProtection404ResponseBody
  | ReposUpdateBranchProtection422ResponseBody,
  ReposUpdateBranchProtectionRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateBranchProtectionResponse = Response<
  | ReposUpdateBranchProtection200ResponseBody
  | ReposUpdateBranchProtection403ResponseBody
  | ReposUpdateBranchProtection404ResponseBody
  | ReposUpdateBranchProtection422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export interface ReposUpdateBranchProtectionHandler {
  reposUpdateBranchProtection(
    req: ReposUpdateBranchProtectionRequest,
    res: ReposUpdateBranchProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteBranchProtectionRequest = Request<
  ReposDeleteBranchProtectionRequestPath,
  ReposDeleteBranchProtection403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteBranchProtectionResponse = Response<
  ReposDeleteBranchProtection403ResponseBody,
  Record<string, any>,
  204 | 403
>;

export interface ReposDeleteBranchProtectionHandler {
  reposDeleteBranchProtection(
    req: ReposDeleteBranchProtectionRequest,
    res: ReposDeleteBranchProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetAdminBranchProtectionRequest = Request<
  ReposGetAdminBranchProtectionRequestPath,
  ReposGetAdminBranchProtection200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetAdminBranchProtectionResponse = Response<
  ReposGetAdminBranchProtection200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposGetAdminBranchProtectionHandler {
  reposGetAdminBranchProtection(
    req: ReposGetAdminBranchProtectionRequest,
    res: ReposGetAdminBranchProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposSetAdminBranchProtectionRequest = Request<
  ReposSetAdminBranchProtectionRequestPath,
  ReposSetAdminBranchProtection200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposSetAdminBranchProtectionResponse = Response<
  ReposSetAdminBranchProtection200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposSetAdminBranchProtectionHandler {
  reposSetAdminBranchProtection(
    req: ReposSetAdminBranchProtectionRequest,
    res: ReposSetAdminBranchProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteAdminBranchProtectionRequest = Request<
  ReposDeleteAdminBranchProtectionRequestPath,
  ReposDeleteAdminBranchProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteAdminBranchProtectionResponse = Response<
  ReposDeleteAdminBranchProtection404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface ReposDeleteAdminBranchProtectionHandler {
  reposDeleteAdminBranchProtection(
    req: ReposDeleteAdminBranchProtectionRequest,
    res: ReposDeleteAdminBranchProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetPullRequestReviewProtectionRequest = Request<
  ReposGetPullRequestReviewProtectionRequestPath,
  ReposGetPullRequestReviewProtection200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetPullRequestReviewProtectionResponse = Response<
  ReposGetPullRequestReviewProtection200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposGetPullRequestReviewProtectionHandler {
  reposGetPullRequestReviewProtection(
    req: ReposGetPullRequestReviewProtectionRequest,
    res: ReposGetPullRequestReviewProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposUpdatePullRequestReviewProtectionRequest = Request<
  ReposUpdatePullRequestReviewProtectionRequestPath,
  | ReposUpdatePullRequestReviewProtection200ResponseBody
  | ReposUpdatePullRequestReviewProtection422ResponseBody,
  ReposUpdatePullRequestReviewProtectionRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdatePullRequestReviewProtectionResponse = Response<
  | ReposUpdatePullRequestReviewProtection200ResponseBody
  | ReposUpdatePullRequestReviewProtection422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ReposUpdatePullRequestReviewProtectionHandler {
  reposUpdatePullRequestReviewProtection(
    req: ReposUpdatePullRequestReviewProtectionRequest,
    res: ReposUpdatePullRequestReviewProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeletePullRequestReviewProtectionRequest = Request<
  ReposDeletePullRequestReviewProtectionRequestPath,
  ReposDeletePullRequestReviewProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeletePullRequestReviewProtectionResponse = Response<
  ReposDeletePullRequestReviewProtection404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface ReposDeletePullRequestReviewProtectionHandler {
  reposDeletePullRequestReviewProtection(
    req: ReposDeletePullRequestReviewProtectionRequest,
    res: ReposDeletePullRequestReviewProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetCommitSignatureProtectionRequest = Request<
  ReposGetCommitSignatureProtectionRequestPath,
  | ReposGetCommitSignatureProtection200ResponseBody
  | ReposGetCommitSignatureProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetCommitSignatureProtectionResponse = Response<
  | ReposGetCommitSignatureProtection200ResponseBody
  | ReposGetCommitSignatureProtection404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetCommitSignatureProtectionHandler {
  reposGetCommitSignatureProtection(
    req: ReposGetCommitSignatureProtectionRequest,
    res: ReposGetCommitSignatureProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateCommitSignatureProtectionRequest = Request<
  ReposCreateCommitSignatureProtectionRequestPath,
  | ReposCreateCommitSignatureProtection200ResponseBody
  | ReposCreateCommitSignatureProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateCommitSignatureProtectionResponse = Response<
  | ReposCreateCommitSignatureProtection200ResponseBody
  | ReposCreateCommitSignatureProtection404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposCreateCommitSignatureProtectionHandler {
  reposCreateCommitSignatureProtection(
    req: ReposCreateCommitSignatureProtectionRequest,
    res: ReposCreateCommitSignatureProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteCommitSignatureProtectionRequest = Request<
  ReposDeleteCommitSignatureProtectionRequestPath,
  ReposDeleteCommitSignatureProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteCommitSignatureProtectionResponse = Response<
  ReposDeleteCommitSignatureProtection404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface ReposDeleteCommitSignatureProtectionHandler {
  reposDeleteCommitSignatureProtection(
    req: ReposDeleteCommitSignatureProtectionRequest,
    res: ReposDeleteCommitSignatureProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetStatusChecksProtectionRequest = Request<
  ReposGetStatusChecksProtectionRequestPath,
  | ReposGetStatusChecksProtection200ResponseBody
  | ReposGetStatusChecksProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetStatusChecksProtectionResponse = Response<
  | ReposGetStatusChecksProtection200ResponseBody
  | ReposGetStatusChecksProtection404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetStatusChecksProtectionHandler {
  reposGetStatusChecksProtection(
    req: ReposGetStatusChecksProtectionRequest,
    res: ReposGetStatusChecksProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposUpdateStatusCheckProtectionRequest = Request<
  ReposUpdateStatusCheckProtectionRequestPath,
  | ReposUpdateStatusCheckProtection200ResponseBody
  | ReposUpdateStatusCheckProtection404ResponseBody
  | ReposUpdateStatusCheckProtection422ResponseBody,
  ReposUpdateStatusCheckProtectionRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateStatusCheckProtectionResponse = Response<
  | ReposUpdateStatusCheckProtection200ResponseBody
  | ReposUpdateStatusCheckProtection404ResponseBody
  | ReposUpdateStatusCheckProtection422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface ReposUpdateStatusCheckProtectionHandler {
  reposUpdateStatusCheckProtection(
    req: ReposUpdateStatusCheckProtectionRequest,
    res: ReposUpdateStatusCheckProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposRemoveStatusCheckProtectionRequest = Request<
  ReposRemoveStatusCheckProtectionRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposRemoveStatusCheckProtectionResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposRemoveStatusCheckProtectionHandler {
  reposRemoveStatusCheckProtection(
    req: ReposRemoveStatusCheckProtectionRequest,
    res: ReposRemoveStatusCheckProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetAllStatusCheckContextsRequest = Request<
  ReposGetAllStatusCheckContextsRequestPath,
  | ReposGetAllStatusCheckContexts200ResponseBody
  | ReposGetAllStatusCheckContexts404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetAllStatusCheckContextsResponse = Response<
  | ReposGetAllStatusCheckContexts200ResponseBody
  | ReposGetAllStatusCheckContexts404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetAllStatusCheckContextsHandler {
  reposGetAllStatusCheckContexts(
    req: ReposGetAllStatusCheckContextsRequest,
    res: ReposGetAllStatusCheckContextsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposAddStatusCheckContextsRequest = Request<
  ReposAddStatusCheckContextsRequestPath,
  | ReposAddStatusCheckContexts200ResponseBody
  | ReposAddStatusCheckContexts403ResponseBody
  | ReposAddStatusCheckContexts404ResponseBody
  | ReposAddStatusCheckContexts422ResponseBody,
  ReposAddStatusCheckContextsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposAddStatusCheckContextsResponse = Response<
  | ReposAddStatusCheckContexts200ResponseBody
  | ReposAddStatusCheckContexts403ResponseBody
  | ReposAddStatusCheckContexts404ResponseBody
  | ReposAddStatusCheckContexts422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export interface ReposAddStatusCheckContextsHandler {
  reposAddStatusCheckContexts(
    req: ReposAddStatusCheckContextsRequest,
    res: ReposAddStatusCheckContextsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposSetStatusCheckContextsRequest = Request<
  ReposSetStatusCheckContextsRequestPath,
  | ReposSetStatusCheckContexts200ResponseBody
  | ReposSetStatusCheckContexts404ResponseBody
  | ReposSetStatusCheckContexts422ResponseBody,
  ReposSetStatusCheckContextsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposSetStatusCheckContextsResponse = Response<
  | ReposSetStatusCheckContexts200ResponseBody
  | ReposSetStatusCheckContexts404ResponseBody
  | ReposSetStatusCheckContexts422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface ReposSetStatusCheckContextsHandler {
  reposSetStatusCheckContexts(
    req: ReposSetStatusCheckContextsRequest,
    res: ReposSetStatusCheckContextsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposRemoveStatusCheckContextsRequest = Request<
  ReposRemoveStatusCheckContextsRequestPath,
  | ReposRemoveStatusCheckContexts200ResponseBody
  | ReposRemoveStatusCheckContexts404ResponseBody
  | ReposRemoveStatusCheckContexts422ResponseBody,
  ReposRemoveStatusCheckContextsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposRemoveStatusCheckContextsResponse = Response<
  | ReposRemoveStatusCheckContexts200ResponseBody
  | ReposRemoveStatusCheckContexts404ResponseBody
  | ReposRemoveStatusCheckContexts422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface ReposRemoveStatusCheckContextsHandler {
  reposRemoveStatusCheckContexts(
    req: ReposRemoveStatusCheckContextsRequest,
    res: ReposRemoveStatusCheckContextsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetAccessRestrictionsRequest = Request<
  ReposGetAccessRestrictionsRequestPath,
  | ReposGetAccessRestrictions200ResponseBody
  | ReposGetAccessRestrictions404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetAccessRestrictionsResponse = Response<
  | ReposGetAccessRestrictions200ResponseBody
  | ReposGetAccessRestrictions404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetAccessRestrictionsHandler {
  reposGetAccessRestrictions(
    req: ReposGetAccessRestrictionsRequest,
    res: ReposGetAccessRestrictionsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteAccessRestrictionsRequest = Request<
  ReposDeleteAccessRestrictionsRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteAccessRestrictionsResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposDeleteAccessRestrictionsHandler {
  reposDeleteAccessRestrictions(
    req: ReposDeleteAccessRestrictionsRequest,
    res: ReposDeleteAccessRestrictionsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetAppsWithAccessToProtectedBranchRequest = Request<
  ReposGetAppsWithAccessToProtectedBranchRequestPath,
  | ReposGetAppsWithAccessToProtectedBranch200ResponseBody
  | ReposGetAppsWithAccessToProtectedBranch404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetAppsWithAccessToProtectedBranchResponse = Response<
  | ReposGetAppsWithAccessToProtectedBranch200ResponseBody
  | ReposGetAppsWithAccessToProtectedBranch404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetAppsWithAccessToProtectedBranchHandler {
  reposGetAppsWithAccessToProtectedBranch(
    req: ReposGetAppsWithAccessToProtectedBranchRequest,
    res: ReposGetAppsWithAccessToProtectedBranchResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposAddAppAccessRestrictionsRequest = Request<
  ReposAddAppAccessRestrictionsRequestPath,
  | ReposAddAppAccessRestrictions200ResponseBody
  | ReposAddAppAccessRestrictions422ResponseBody,
  ReposAddAppAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposAddAppAccessRestrictionsResponse = Response<
  | ReposAddAppAccessRestrictions200ResponseBody
  | ReposAddAppAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ReposAddAppAccessRestrictionsHandler {
  reposAddAppAccessRestrictions(
    req: ReposAddAppAccessRestrictionsRequest,
    res: ReposAddAppAccessRestrictionsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposSetAppAccessRestrictionsRequest = Request<
  ReposSetAppAccessRestrictionsRequestPath,
  | ReposSetAppAccessRestrictions200ResponseBody
  | ReposSetAppAccessRestrictions422ResponseBody,
  ReposSetAppAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposSetAppAccessRestrictionsResponse = Response<
  | ReposSetAppAccessRestrictions200ResponseBody
  | ReposSetAppAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ReposSetAppAccessRestrictionsHandler {
  reposSetAppAccessRestrictions(
    req: ReposSetAppAccessRestrictionsRequest,
    res: ReposSetAppAccessRestrictionsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposRemoveAppAccessRestrictionsRequest = Request<
  ReposRemoveAppAccessRestrictionsRequestPath,
  | ReposRemoveAppAccessRestrictions200ResponseBody
  | ReposRemoveAppAccessRestrictions422ResponseBody,
  ReposRemoveAppAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposRemoveAppAccessRestrictionsResponse = Response<
  | ReposRemoveAppAccessRestrictions200ResponseBody
  | ReposRemoveAppAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ReposRemoveAppAccessRestrictionsHandler {
  reposRemoveAppAccessRestrictions(
    req: ReposRemoveAppAccessRestrictionsRequest,
    res: ReposRemoveAppAccessRestrictionsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetTeamsWithAccessToProtectedBranchRequest = Request<
  ReposGetTeamsWithAccessToProtectedBranchRequestPath,
  | ReposGetTeamsWithAccessToProtectedBranch200ResponseBody
  | ReposGetTeamsWithAccessToProtectedBranch404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetTeamsWithAccessToProtectedBranchResponse = Response<
  | ReposGetTeamsWithAccessToProtectedBranch200ResponseBody
  | ReposGetTeamsWithAccessToProtectedBranch404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetTeamsWithAccessToProtectedBranchHandler {
  reposGetTeamsWithAccessToProtectedBranch(
    req: ReposGetTeamsWithAccessToProtectedBranchRequest,
    res: ReposGetTeamsWithAccessToProtectedBranchResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposAddTeamAccessRestrictionsRequest = Request<
  ReposAddTeamAccessRestrictionsRequestPath,
  | ReposAddTeamAccessRestrictions200ResponseBody
  | ReposAddTeamAccessRestrictions422ResponseBody,
  ReposAddTeamAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposAddTeamAccessRestrictionsResponse = Response<
  | ReposAddTeamAccessRestrictions200ResponseBody
  | ReposAddTeamAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ReposAddTeamAccessRestrictionsHandler {
  reposAddTeamAccessRestrictions(
    req: ReposAddTeamAccessRestrictionsRequest,
    res: ReposAddTeamAccessRestrictionsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposSetTeamAccessRestrictionsRequest = Request<
  ReposSetTeamAccessRestrictionsRequestPath,
  | ReposSetTeamAccessRestrictions200ResponseBody
  | ReposSetTeamAccessRestrictions422ResponseBody,
  ReposSetTeamAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposSetTeamAccessRestrictionsResponse = Response<
  | ReposSetTeamAccessRestrictions200ResponseBody
  | ReposSetTeamAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ReposSetTeamAccessRestrictionsHandler {
  reposSetTeamAccessRestrictions(
    req: ReposSetTeamAccessRestrictionsRequest,
    res: ReposSetTeamAccessRestrictionsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposRemoveTeamAccessRestrictionsRequest = Request<
  ReposRemoveTeamAccessRestrictionsRequestPath,
  | ReposRemoveTeamAccessRestrictions200ResponseBody
  | ReposRemoveTeamAccessRestrictions422ResponseBody,
  ReposRemoveTeamAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposRemoveTeamAccessRestrictionsResponse = Response<
  | ReposRemoveTeamAccessRestrictions200ResponseBody
  | ReposRemoveTeamAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ReposRemoveTeamAccessRestrictionsHandler {
  reposRemoveTeamAccessRestrictions(
    req: ReposRemoveTeamAccessRestrictionsRequest,
    res: ReposRemoveTeamAccessRestrictionsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetUsersWithAccessToProtectedBranchRequest = Request<
  ReposGetUsersWithAccessToProtectedBranchRequestPath,
  | ReposGetUsersWithAccessToProtectedBranch200ResponseBody
  | ReposGetUsersWithAccessToProtectedBranch404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetUsersWithAccessToProtectedBranchResponse = Response<
  | ReposGetUsersWithAccessToProtectedBranch200ResponseBody
  | ReposGetUsersWithAccessToProtectedBranch404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetUsersWithAccessToProtectedBranchHandler {
  reposGetUsersWithAccessToProtectedBranch(
    req: ReposGetUsersWithAccessToProtectedBranchRequest,
    res: ReposGetUsersWithAccessToProtectedBranchResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposAddUserAccessRestrictionsRequest = Request<
  ReposAddUserAccessRestrictionsRequestPath,
  | ReposAddUserAccessRestrictions200ResponseBody
  | ReposAddUserAccessRestrictions422ResponseBody,
  ReposAddUserAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposAddUserAccessRestrictionsResponse = Response<
  | ReposAddUserAccessRestrictions200ResponseBody
  | ReposAddUserAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ReposAddUserAccessRestrictionsHandler {
  reposAddUserAccessRestrictions(
    req: ReposAddUserAccessRestrictionsRequest,
    res: ReposAddUserAccessRestrictionsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposSetUserAccessRestrictionsRequest = Request<
  ReposSetUserAccessRestrictionsRequestPath,
  | ReposSetUserAccessRestrictions200ResponseBody
  | ReposSetUserAccessRestrictions422ResponseBody,
  ReposSetUserAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposSetUserAccessRestrictionsResponse = Response<
  | ReposSetUserAccessRestrictions200ResponseBody
  | ReposSetUserAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ReposSetUserAccessRestrictionsHandler {
  reposSetUserAccessRestrictions(
    req: ReposSetUserAccessRestrictionsRequest,
    res: ReposSetUserAccessRestrictionsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposRemoveUserAccessRestrictionsRequest = Request<
  ReposRemoveUserAccessRestrictionsRequestPath,
  | ReposRemoveUserAccessRestrictions200ResponseBody
  | ReposRemoveUserAccessRestrictions422ResponseBody,
  ReposRemoveUserAccessRestrictionsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposRemoveUserAccessRestrictionsResponse = Response<
  | ReposRemoveUserAccessRestrictions200ResponseBody
  | ReposRemoveUserAccessRestrictions422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ReposRemoveUserAccessRestrictionsHandler {
  reposRemoveUserAccessRestrictions(
    req: ReposRemoveUserAccessRestrictionsRequest,
    res: ReposRemoveUserAccessRestrictionsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposRenameBranchRequest = Request<
  ReposRenameBranchRequestPath,
  | ReposRenameBranch201ResponseBody
  | ReposRenameBranch403ResponseBody
  | ReposRenameBranch404ResponseBody
  | ReposRenameBranch422ResponseBody,
  ReposRenameBranchRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposRenameBranchResponse = Response<
  | ReposRenameBranch201ResponseBody
  | ReposRenameBranch403ResponseBody
  | ReposRenameBranch404ResponseBody
  | ReposRenameBranch422ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 422
>;

export interface ReposRenameBranchHandler {
  reposRenameBranch(
    req: ReposRenameBranchRequest,
    res: ReposRenameBranchResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ChecksCreateRequest = Request<
  ChecksCreateRequestPath,
  ChecksCreate201ResponseBody,
  ChecksCreateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ChecksCreateResponse = Response<
  ChecksCreate201ResponseBody,
  Record<string, any>,
  201
>;

export interface ChecksCreateHandler {
  checksCreate(
    req: ChecksCreateRequest,
    res: ChecksCreateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ChecksGetRequest = Request<
  ChecksGetRequestPath,
  ChecksGet200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ChecksGetResponse = Response<
  ChecksGet200ResponseBody,
  Record<string, any>,
  200
>;

export interface ChecksGetHandler {
  checksGet(
    req: ChecksGetRequest,
    res: ChecksGetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ChecksUpdateRequest = Request<
  ChecksUpdateRequestPath,
  ChecksUpdate200ResponseBody,
  ChecksUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ChecksUpdateResponse = Response<
  ChecksUpdate200ResponseBody,
  Record<string, any>,
  200
>;

export interface ChecksUpdateHandler {
  checksUpdate(
    req: ChecksUpdateRequest,
    res: ChecksUpdateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ChecksListAnnotationsRequest = Request<
  ChecksListAnnotationsRequestPath,
  ChecksListAnnotations200ResponseBody,
  unknown,
  ChecksListAnnotationsRequestQuery,
  Record<string, any>
>;

export type ChecksListAnnotationsResponse = Response<
  ChecksListAnnotations200ResponseBody,
  Record<string, any>,
  200
>;

export interface ChecksListAnnotationsHandler {
  checksListAnnotations(
    req: ChecksListAnnotationsRequest,
    res: ChecksListAnnotationsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ChecksRerequestRunRequest = Request<
  ChecksRerequestRunRequestPath,
  | ChecksRerequestRun201ResponseBody
  | ChecksRerequestRun403ResponseBody
  | ChecksRerequestRun404ResponseBody
  | ChecksRerequestRun422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ChecksRerequestRunResponse = Response<
  | ChecksRerequestRun201ResponseBody
  | ChecksRerequestRun403ResponseBody
  | ChecksRerequestRun404ResponseBody
  | ChecksRerequestRun422ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 422
>;

export interface ChecksRerequestRunHandler {
  checksRerequestRun(
    req: ChecksRerequestRunRequest,
    res: ChecksRerequestRunResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ChecksCreateSuiteRequest = Request<
  ChecksCreateSuiteRequestPath,
  ChecksCreateSuite200ResponseBody | ChecksCreateSuite201ResponseBody,
  ChecksCreateSuiteRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ChecksCreateSuiteResponse = Response<
  ChecksCreateSuite200ResponseBody | ChecksCreateSuite201ResponseBody,
  Record<string, any>,
  200 | 201
>;

export interface ChecksCreateSuiteHandler {
  checksCreateSuite(
    req: ChecksCreateSuiteRequest,
    res: ChecksCreateSuiteResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ChecksSetSuitesPreferencesRequest = Request<
  ChecksSetSuitesPreferencesRequestPath,
  ChecksSetSuitesPreferences200ResponseBody,
  ChecksSetSuitesPreferencesRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ChecksSetSuitesPreferencesResponse = Response<
  ChecksSetSuitesPreferences200ResponseBody,
  Record<string, any>,
  200
>;

export interface ChecksSetSuitesPreferencesHandler {
  checksSetSuitesPreferences(
    req: ChecksSetSuitesPreferencesRequest,
    res: ChecksSetSuitesPreferencesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ChecksGetSuiteRequest = Request<
  ChecksGetSuiteRequestPath,
  ChecksGetSuite200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ChecksGetSuiteResponse = Response<
  ChecksGetSuite200ResponseBody,
  Record<string, any>,
  200
>;

export interface ChecksGetSuiteHandler {
  checksGetSuite(
    req: ChecksGetSuiteRequest,
    res: ChecksGetSuiteResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ChecksListForSuiteRequest = Request<
  ChecksListForSuiteRequestPath,
  ChecksListForSuite200ResponseBody,
  unknown,
  ChecksListForSuiteRequestQuery,
  Record<string, any>
>;

export type ChecksListForSuiteResponse = Response<
  ChecksListForSuite200ResponseBody,
  Record<string, any>,
  200
>;

export interface ChecksListForSuiteHandler {
  checksListForSuite(
    req: ChecksListForSuiteRequest,
    res: ChecksListForSuiteResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ChecksRerequestSuiteRequest = Request<
  ChecksRerequestSuiteRequestPath,
  ChecksRerequestSuite201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ChecksRerequestSuiteResponse = Response<
  ChecksRerequestSuite201ResponseBody,
  Record<string, any>,
  201
>;

export interface ChecksRerequestSuiteHandler {
  checksRerequestSuite(
    req: ChecksRerequestSuiteRequest,
    res: ChecksRerequestSuiteResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodeScanningListAlertsForRepoRequest = Request<
  CodeScanningListAlertsForRepoRequestPath,
  | CodeScanningListAlertsForRepo200ResponseBody
  | CodeScanningListAlertsForRepo403ResponseBody
  | CodeScanningListAlertsForRepo404ResponseBody
  | CodeScanningListAlertsForRepo503ResponseBody,
  unknown,
  CodeScanningListAlertsForRepoRequestQuery,
  Record<string, any>
>;

export type CodeScanningListAlertsForRepoResponse = Response<
  | CodeScanningListAlertsForRepo200ResponseBody
  | CodeScanningListAlertsForRepo403ResponseBody
  | CodeScanningListAlertsForRepo404ResponseBody
  | CodeScanningListAlertsForRepo503ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404 | 503
>;

export interface CodeScanningListAlertsForRepoHandler {
  codeScanningListAlertsForRepo(
    req: CodeScanningListAlertsForRepoRequest,
    res: CodeScanningListAlertsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodeScanningGetAlertRequest = Request<
  CodeScanningGetAlertRequestPath,
  | CodeScanningGetAlert200ResponseBody
  | CodeScanningGetAlert403ResponseBody
  | CodeScanningGetAlert404ResponseBody
  | CodeScanningGetAlert503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningGetAlertResponse = Response<
  | CodeScanningGetAlert200ResponseBody
  | CodeScanningGetAlert403ResponseBody
  | CodeScanningGetAlert404ResponseBody
  | CodeScanningGetAlert503ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404 | 503
>;

export interface CodeScanningGetAlertHandler {
  codeScanningGetAlert(
    req: CodeScanningGetAlertRequest,
    res: CodeScanningGetAlertResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodeScanningUpdateAlertRequest = Request<
  CodeScanningUpdateAlertRequestPath,
  | CodeScanningUpdateAlert200ResponseBody
  | CodeScanningUpdateAlert403ResponseBody
  | CodeScanningUpdateAlert404ResponseBody
  | CodeScanningUpdateAlert503ResponseBody,
  CodeScanningUpdateAlertRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningUpdateAlertResponse = Response<
  | CodeScanningUpdateAlert200ResponseBody
  | CodeScanningUpdateAlert403ResponseBody
  | CodeScanningUpdateAlert404ResponseBody
  | CodeScanningUpdateAlert503ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 503
>;

export interface CodeScanningUpdateAlertHandler {
  codeScanningUpdateAlert(
    req: CodeScanningUpdateAlertRequest,
    res: CodeScanningUpdateAlertResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodeScanningListAlertInstancesRequest = Request<
  CodeScanningListAlertInstancesRequestPath,
  | CodeScanningListAlertInstances200ResponseBody
  | CodeScanningListAlertInstances403ResponseBody
  | CodeScanningListAlertInstances404ResponseBody
  | CodeScanningListAlertInstances503ResponseBody,
  unknown,
  CodeScanningListAlertInstancesRequestQuery,
  Record<string, any>
>;

export type CodeScanningListAlertInstancesResponse = Response<
  | CodeScanningListAlertInstances200ResponseBody
  | CodeScanningListAlertInstances403ResponseBody
  | CodeScanningListAlertInstances404ResponseBody
  | CodeScanningListAlertInstances503ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 503
>;

export interface CodeScanningListAlertInstancesHandler {
  codeScanningListAlertInstances(
    req: CodeScanningListAlertInstancesRequest,
    res: CodeScanningListAlertInstancesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodeScanningListRecentAnalysesRequest = Request<
  CodeScanningListRecentAnalysesRequestPath,
  | CodeScanningListRecentAnalyses200ResponseBody
  | CodeScanningListRecentAnalyses403ResponseBody
  | CodeScanningListRecentAnalyses404ResponseBody
  | CodeScanningListRecentAnalyses503ResponseBody,
  unknown,
  CodeScanningListRecentAnalysesRequestQuery,
  Record<string, any>
>;

export type CodeScanningListRecentAnalysesResponse = Response<
  | CodeScanningListRecentAnalyses200ResponseBody
  | CodeScanningListRecentAnalyses403ResponseBody
  | CodeScanningListRecentAnalyses404ResponseBody
  | CodeScanningListRecentAnalyses503ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 503
>;

export interface CodeScanningListRecentAnalysesHandler {
  codeScanningListRecentAnalyses(
    req: CodeScanningListRecentAnalysesRequest,
    res: CodeScanningListRecentAnalysesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodeScanningGetAnalysisRequest = Request<
  CodeScanningGetAnalysisRequestPath,
  | CodeScanningGetAnalysis200ResponseBody
  | CodeScanningGetAnalysis403ResponseBody
  | CodeScanningGetAnalysis404ResponseBody
  | CodeScanningGetAnalysis503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningGetAnalysisResponse = Response<
  | CodeScanningGetAnalysis200ResponseBody
  | CodeScanningGetAnalysis403ResponseBody
  | CodeScanningGetAnalysis404ResponseBody
  | CodeScanningGetAnalysis503ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 503
>;

export interface CodeScanningGetAnalysisHandler {
  codeScanningGetAnalysis(
    req: CodeScanningGetAnalysisRequest,
    res: CodeScanningGetAnalysisResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodeScanningDeleteAnalysisRequest = Request<
  CodeScanningDeleteAnalysisRequestPath,
  | CodeScanningDeleteAnalysis200ResponseBody
  | CodeScanningDeleteAnalysis400ResponseBody
  | CodeScanningDeleteAnalysis403ResponseBody
  | CodeScanningDeleteAnalysis404ResponseBody
  | CodeScanningDeleteAnalysis503ResponseBody,
  unknown,
  CodeScanningDeleteAnalysisRequestQuery,
  Record<string, any>
>;

export type CodeScanningDeleteAnalysisResponse = Response<
  | CodeScanningDeleteAnalysis200ResponseBody
  | CodeScanningDeleteAnalysis400ResponseBody
  | CodeScanningDeleteAnalysis403ResponseBody
  | CodeScanningDeleteAnalysis404ResponseBody
  | CodeScanningDeleteAnalysis503ResponseBody,
  Record<string, any>,
  200 | 400 | 403 | 404 | 503
>;

export interface CodeScanningDeleteAnalysisHandler {
  codeScanningDeleteAnalysis(
    req: CodeScanningDeleteAnalysisRequest,
    res: CodeScanningDeleteAnalysisResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodeScanningListCodeqlDatabasesRequest = Request<
  CodeScanningListCodeqlDatabasesRequestPath,
  | CodeScanningListCodeqlDatabases200ResponseBody
  | CodeScanningListCodeqlDatabases403ResponseBody
  | CodeScanningListCodeqlDatabases404ResponseBody
  | CodeScanningListCodeqlDatabases503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningListCodeqlDatabasesResponse = Response<
  | CodeScanningListCodeqlDatabases200ResponseBody
  | CodeScanningListCodeqlDatabases403ResponseBody
  | CodeScanningListCodeqlDatabases404ResponseBody
  | CodeScanningListCodeqlDatabases503ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 503
>;

export interface CodeScanningListCodeqlDatabasesHandler {
  codeScanningListCodeqlDatabases(
    req: CodeScanningListCodeqlDatabasesRequest,
    res: CodeScanningListCodeqlDatabasesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodeScanningGetCodeqlDatabaseRequest = Request<
  CodeScanningGetCodeqlDatabaseRequestPath,
  | CodeScanningGetCodeqlDatabase200ResponseBody
  | CodeScanningGetCodeqlDatabase403ResponseBody
  | CodeScanningGetCodeqlDatabase404ResponseBody
  | CodeScanningGetCodeqlDatabase503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningGetCodeqlDatabaseResponse = Response<
  | CodeScanningGetCodeqlDatabase200ResponseBody
  | CodeScanningGetCodeqlDatabase403ResponseBody
  | CodeScanningGetCodeqlDatabase404ResponseBody
  | CodeScanningGetCodeqlDatabase503ResponseBody,
  Record<string, any>,
  200 | 302 | 403 | 404 | 503
>;

export interface CodeScanningGetCodeqlDatabaseHandler {
  codeScanningGetCodeqlDatabase(
    req: CodeScanningGetCodeqlDatabaseRequest,
    res: CodeScanningGetCodeqlDatabaseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodeScanningUploadSarifRequest = Request<
  CodeScanningUploadSarifRequestPath,
  | CodeScanningUploadSarif202ResponseBody
  | CodeScanningUploadSarif403ResponseBody
  | CodeScanningUploadSarif404ResponseBody
  | CodeScanningUploadSarif503ResponseBody,
  CodeScanningUploadSarifRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningUploadSarifResponse = Response<
  | CodeScanningUploadSarif202ResponseBody
  | CodeScanningUploadSarif403ResponseBody
  | CodeScanningUploadSarif404ResponseBody
  | CodeScanningUploadSarif503ResponseBody,
  Record<string, any>,
  202 | 400 | 403 | 404 | 413 | 503
>;

export interface CodeScanningUploadSarifHandler {
  codeScanningUploadSarif(
    req: CodeScanningUploadSarifRequest,
    res: CodeScanningUploadSarifResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodeScanningGetSarifRequest = Request<
  CodeScanningGetSarifRequestPath,
  | CodeScanningGetSarif200ResponseBody
  | CodeScanningGetSarif403ResponseBody
  | CodeScanningGetSarif503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodeScanningGetSarifResponse = Response<
  | CodeScanningGetSarif200ResponseBody
  | CodeScanningGetSarif403ResponseBody
  | CodeScanningGetSarif503ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 503
>;

export interface CodeScanningGetSarifHandler {
  codeScanningGetSarif(
    req: CodeScanningGetSarifRequest,
    res: CodeScanningGetSarifResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCodeownersErrorsRequest = Request<
  ReposCodeownersErrorsRequestPath,
  ReposCodeownersErrors200ResponseBody,
  unknown,
  ReposCodeownersErrorsRequestQuery,
  Record<string, any>
>;

export type ReposCodeownersErrorsResponse = Response<
  ReposCodeownersErrors200ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposCodeownersErrorsHandler {
  reposCodeownersErrors(
    req: ReposCodeownersErrorsRequest,
    res: ReposCodeownersErrorsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesListInRepositoryForAuthenticatedUserRequest = Request<
  CodespacesListInRepositoryForAuthenticatedUserRequestPath,
  | CodespacesListInRepositoryForAuthenticatedUser200ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser401ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser403ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser404ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser500ResponseBody,
  unknown,
  CodespacesListInRepositoryForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type CodespacesListInRepositoryForAuthenticatedUserResponse = Response<
  | CodespacesListInRepositoryForAuthenticatedUser200ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser401ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser403ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser404ResponseBody
  | CodespacesListInRepositoryForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404 | 500
>;

export interface CodespacesListInRepositoryForAuthenticatedUserHandler {
  codespacesListInRepositoryForAuthenticatedUser(
    req: CodespacesListInRepositoryForAuthenticatedUserRequest,
    res: CodespacesListInRepositoryForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesCreateWithRepoForAuthenticatedUserRequest = Request<
  CodespacesCreateWithRepoForAuthenticatedUserRequestPath,
  | CodespacesCreateWithRepoForAuthenticatedUser201ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser202ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser400ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser401ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser403ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser404ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser503ResponseBody,
  CodespacesCreateWithRepoForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCreateWithRepoForAuthenticatedUserResponse = Response<
  | CodespacesCreateWithRepoForAuthenticatedUser201ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser202ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser400ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser401ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser403ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser404ResponseBody
  | CodespacesCreateWithRepoForAuthenticatedUser503ResponseBody,
  Record<string, any>,
  201 | 202 | 400 | 401 | 403 | 404 | 503
>;

export interface CodespacesCreateWithRepoForAuthenticatedUserHandler {
  codespacesCreateWithRepoForAuthenticatedUser(
    req: CodespacesCreateWithRepoForAuthenticatedUserRequest,
    res: CodespacesCreateWithRepoForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequest = Request<
  CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequestPath,
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser200ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser400ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser401ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser403ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser404ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser500ResponseBody,
  unknown,
  CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse = Response<
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser200ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser400ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser401ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser403ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser404ResponseBody
  | CodespacesListDevcontainersInRepositoryForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 400 | 401 | 403 | 404 | 500
>;

export interface CodespacesListDevcontainersInRepositoryForAuthenticatedUserHandler {
  codespacesListDevcontainersInRepositoryForAuthenticatedUser(
    req: CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequest,
    res: CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesRepoMachinesForAuthenticatedUserRequest = Request<
  CodespacesRepoMachinesForAuthenticatedUserRequestPath,
  | CodespacesRepoMachinesForAuthenticatedUser200ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser401ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser403ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser404ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser500ResponseBody,
  unknown,
  CodespacesRepoMachinesForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type CodespacesRepoMachinesForAuthenticatedUserResponse = Response<
  | CodespacesRepoMachinesForAuthenticatedUser200ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser401ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser403ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser404ResponseBody
  | CodespacesRepoMachinesForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export interface CodespacesRepoMachinesForAuthenticatedUserHandler {
  codespacesRepoMachinesForAuthenticatedUser(
    req: CodespacesRepoMachinesForAuthenticatedUserRequest,
    res: CodespacesRepoMachinesForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesPreFlightWithRepoForAuthenticatedUserRequest = Request<
  CodespacesPreFlightWithRepoForAuthenticatedUserRequestPath,
  | CodespacesPreFlightWithRepoForAuthenticatedUser200ResponseBody
  | CodespacesPreFlightWithRepoForAuthenticatedUser401ResponseBody
  | CodespacesPreFlightWithRepoForAuthenticatedUser403ResponseBody
  | CodespacesPreFlightWithRepoForAuthenticatedUser404ResponseBody,
  unknown,
  CodespacesPreFlightWithRepoForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type CodespacesPreFlightWithRepoForAuthenticatedUserResponse = Response<
  | CodespacesPreFlightWithRepoForAuthenticatedUser200ResponseBody
  | CodespacesPreFlightWithRepoForAuthenticatedUser401ResponseBody
  | CodespacesPreFlightWithRepoForAuthenticatedUser403ResponseBody
  | CodespacesPreFlightWithRepoForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404
>;

export interface CodespacesPreFlightWithRepoForAuthenticatedUserHandler {
  codespacesPreFlightWithRepoForAuthenticatedUser(
    req: CodespacesPreFlightWithRepoForAuthenticatedUserRequest,
    res: CodespacesPreFlightWithRepoForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesListRepoSecretsRequest = Request<
  CodespacesListRepoSecretsRequestPath,
  CodespacesListRepoSecrets200ResponseBody,
  unknown,
  CodespacesListRepoSecretsRequestQuery,
  Record<string, any>
>;

export type CodespacesListRepoSecretsResponse = Response<
  CodespacesListRepoSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export interface CodespacesListRepoSecretsHandler {
  codespacesListRepoSecrets(
    req: CodespacesListRepoSecretsRequest,
    res: CodespacesListRepoSecretsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesGetRepoPublicKeyRequest = Request<
  CodespacesGetRepoPublicKeyRequestPath,
  CodespacesGetRepoPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetRepoPublicKeyResponse = Response<
  CodespacesGetRepoPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export interface CodespacesGetRepoPublicKeyHandler {
  codespacesGetRepoPublicKey(
    req: CodespacesGetRepoPublicKeyRequest,
    res: CodespacesGetRepoPublicKeyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesGetRepoSecretRequest = Request<
  CodespacesGetRepoSecretRequestPath,
  CodespacesGetRepoSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetRepoSecretResponse = Response<
  CodespacesGetRepoSecret200ResponseBody,
  Record<string, any>,
  200
>;

export interface CodespacesGetRepoSecretHandler {
  codespacesGetRepoSecret(
    req: CodespacesGetRepoSecretRequest,
    res: CodespacesGetRepoSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesCreateOrUpdateRepoSecretRequest = Request<
  CodespacesCreateOrUpdateRepoSecretRequestPath,
  CodespacesCreateOrUpdateRepoSecret201ResponseBody,
  CodespacesCreateOrUpdateRepoSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCreateOrUpdateRepoSecretResponse = Response<
  CodespacesCreateOrUpdateRepoSecret201ResponseBody,
  Record<string, any>,
  201 | 204
>;

export interface CodespacesCreateOrUpdateRepoSecretHandler {
  codespacesCreateOrUpdateRepoSecret(
    req: CodespacesCreateOrUpdateRepoSecretRequest,
    res: CodespacesCreateOrUpdateRepoSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesDeleteRepoSecretRequest = Request<
  CodespacesDeleteRepoSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesDeleteRepoSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface CodespacesDeleteRepoSecretHandler {
  codespacesDeleteRepoSecret(
    req: CodespacesDeleteRepoSecretRequest,
    res: CodespacesDeleteRepoSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListCollaboratorsRequest = Request<
  ReposListCollaboratorsRequestPath,
  ReposListCollaborators200ResponseBody | ReposListCollaborators404ResponseBody,
  unknown,
  ReposListCollaboratorsRequestQuery,
  Record<string, any>
>;

export type ReposListCollaboratorsResponse = Response<
  ReposListCollaborators200ResponseBody | ReposListCollaborators404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposListCollaboratorsHandler {
  reposListCollaborators(
    req: ReposListCollaboratorsRequest,
    res: ReposListCollaboratorsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCheckCollaboratorRequest = Request<
  ReposCheckCollaboratorRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposCheckCollaboratorResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export interface ReposCheckCollaboratorHandler {
  reposCheckCollaborator(
    req: ReposCheckCollaboratorRequest,
    res: ReposCheckCollaboratorResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposAddCollaboratorRequest = Request<
  ReposAddCollaboratorRequestPath,
  | ReposAddCollaborator201ResponseBody
  | ReposAddCollaborator403ResponseBody
  | ReposAddCollaborator422ResponseBody,
  ReposAddCollaboratorRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposAddCollaboratorResponse = Response<
  | ReposAddCollaborator201ResponseBody
  | ReposAddCollaborator403ResponseBody
  | ReposAddCollaborator422ResponseBody,
  Record<string, any>,
  201 | 204 | 403 | 422
>;

export interface ReposAddCollaboratorHandler {
  reposAddCollaborator(
    req: ReposAddCollaboratorRequest,
    res: ReposAddCollaboratorResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposRemoveCollaboratorRequest = Request<
  ReposRemoveCollaboratorRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposRemoveCollaboratorResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposRemoveCollaboratorHandler {
  reposRemoveCollaborator(
    req: ReposRemoveCollaboratorRequest,
    res: ReposRemoveCollaboratorResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetCollaboratorPermissionLevelRequest = Request<
  ReposGetCollaboratorPermissionLevelRequestPath,
  | ReposGetCollaboratorPermissionLevel200ResponseBody
  | ReposGetCollaboratorPermissionLevel404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetCollaboratorPermissionLevelResponse = Response<
  | ReposGetCollaboratorPermissionLevel200ResponseBody
  | ReposGetCollaboratorPermissionLevel404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetCollaboratorPermissionLevelHandler {
  reposGetCollaboratorPermissionLevel(
    req: ReposGetCollaboratorPermissionLevelRequest,
    res: ReposGetCollaboratorPermissionLevelResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListCommitCommentsForRepoRequest = Request<
  ReposListCommitCommentsForRepoRequestPath,
  ReposListCommitCommentsForRepo200ResponseBody,
  unknown,
  ReposListCommitCommentsForRepoRequestQuery,
  Record<string, any>
>;

export type ReposListCommitCommentsForRepoResponse = Response<
  ReposListCommitCommentsForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListCommitCommentsForRepoHandler {
  reposListCommitCommentsForRepo(
    req: ReposListCommitCommentsForRepoRequest,
    res: ReposListCommitCommentsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetCommitCommentRequest = Request<
  ReposGetCommitCommentRequestPath,
  ReposGetCommitComment200ResponseBody | ReposGetCommitComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetCommitCommentResponse = Response<
  ReposGetCommitComment200ResponseBody | ReposGetCommitComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetCommitCommentHandler {
  reposGetCommitComment(
    req: ReposGetCommitCommentRequest,
    res: ReposGetCommitCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposUpdateCommitCommentRequest = Request<
  ReposUpdateCommitCommentRequestPath,
  | ReposUpdateCommitComment200ResponseBody
  | ReposUpdateCommitComment404ResponseBody,
  ReposUpdateCommitCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateCommitCommentResponse = Response<
  | ReposUpdateCommitComment200ResponseBody
  | ReposUpdateCommitComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposUpdateCommitCommentHandler {
  reposUpdateCommitComment(
    req: ReposUpdateCommitCommentRequest,
    res: ReposUpdateCommitCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteCommitCommentRequest = Request<
  ReposDeleteCommitCommentRequestPath,
  ReposDeleteCommitComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteCommitCommentResponse = Response<
  ReposDeleteCommitComment404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface ReposDeleteCommitCommentHandler {
  reposDeleteCommitComment(
    req: ReposDeleteCommitCommentRequest,
    res: ReposDeleteCommitCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsListForCommitCommentRequest = Request<
  ReactionsListForCommitCommentRequestPath,
  | ReactionsListForCommitComment200ResponseBody
  | ReactionsListForCommitComment404ResponseBody,
  unknown,
  ReactionsListForCommitCommentRequestQuery,
  Record<string, any>
>;

export type ReactionsListForCommitCommentResponse = Response<
  | ReactionsListForCommitComment200ResponseBody
  | ReactionsListForCommitComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReactionsListForCommitCommentHandler {
  reactionsListForCommitComment(
    req: ReactionsListForCommitCommentRequest,
    res: ReactionsListForCommitCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsCreateForCommitCommentRequest = Request<
  ReactionsCreateForCommitCommentRequestPath,
  | ReactionsCreateForCommitComment200ResponseBody
  | ReactionsCreateForCommitComment201ResponseBody
  | ReactionsCreateForCommitComment422ResponseBody,
  ReactionsCreateForCommitCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForCommitCommentResponse = Response<
  | ReactionsCreateForCommitComment200ResponseBody
  | ReactionsCreateForCommitComment201ResponseBody
  | ReactionsCreateForCommitComment422ResponseBody,
  Record<string, any>,
  200 | 201 | 422
>;

export interface ReactionsCreateForCommitCommentHandler {
  reactionsCreateForCommitComment(
    req: ReactionsCreateForCommitCommentRequest,
    res: ReactionsCreateForCommitCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsDeleteForCommitCommentRequest = Request<
  ReactionsDeleteForCommitCommentRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForCommitCommentResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReactionsDeleteForCommitCommentHandler {
  reactionsDeleteForCommitComment(
    req: ReactionsDeleteForCommitCommentRequest,
    res: ReactionsDeleteForCommitCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListCommitsRequest = Request<
  ReposListCommitsRequestPath,
  | ReposListCommits200ResponseBody
  | ReposListCommits400ResponseBody
  | ReposListCommits404ResponseBody
  | ReposListCommits409ResponseBody
  | ReposListCommits500ResponseBody,
  unknown,
  ReposListCommitsRequestQuery,
  Record<string, any>
>;

export type ReposListCommitsResponse = Response<
  | ReposListCommits200ResponseBody
  | ReposListCommits400ResponseBody
  | ReposListCommits404ResponseBody
  | ReposListCommits409ResponseBody
  | ReposListCommits500ResponseBody,
  Record<string, any>,
  200 | 400 | 404 | 409 | 500
>;

export interface ReposListCommitsHandler {
  reposListCommits(
    req: ReposListCommitsRequest,
    res: ReposListCommitsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListBranchesForHeadCommitRequest = Request<
  ReposListBranchesForHeadCommitRequestPath,
  | ReposListBranchesForHeadCommit200ResponseBody
  | ReposListBranchesForHeadCommit422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposListBranchesForHeadCommitResponse = Response<
  | ReposListBranchesForHeadCommit200ResponseBody
  | ReposListBranchesForHeadCommit422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ReposListBranchesForHeadCommitHandler {
  reposListBranchesForHeadCommit(
    req: ReposListBranchesForHeadCommitRequest,
    res: ReposListBranchesForHeadCommitResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListCommentsForCommitRequest = Request<
  ReposListCommentsForCommitRequestPath,
  ReposListCommentsForCommit200ResponseBody,
  unknown,
  ReposListCommentsForCommitRequestQuery,
  Record<string, any>
>;

export type ReposListCommentsForCommitResponse = Response<
  ReposListCommentsForCommit200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListCommentsForCommitHandler {
  reposListCommentsForCommit(
    req: ReposListCommentsForCommitRequest,
    res: ReposListCommentsForCommitResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateCommitCommentRequest = Request<
  ReposCreateCommitCommentRequestPath,
  | ReposCreateCommitComment201ResponseBody
  | ReposCreateCommitComment403ResponseBody
  | ReposCreateCommitComment422ResponseBody,
  ReposCreateCommitCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateCommitCommentResponse = Response<
  | ReposCreateCommitComment201ResponseBody
  | ReposCreateCommitComment403ResponseBody
  | ReposCreateCommitComment422ResponseBody,
  Record<string, any>,
  201 | 403 | 422
>;

export interface ReposCreateCommitCommentHandler {
  reposCreateCommitComment(
    req: ReposCreateCommitCommentRequest,
    res: ReposCreateCommitCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListPullRequestsAssociatedWithCommitRequest = Request<
  ReposListPullRequestsAssociatedWithCommitRequestPath,
  ReposListPullRequestsAssociatedWithCommit200ResponseBody,
  unknown,
  ReposListPullRequestsAssociatedWithCommitRequestQuery,
  Record<string, any>
>;

export type ReposListPullRequestsAssociatedWithCommitResponse = Response<
  ReposListPullRequestsAssociatedWithCommit200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListPullRequestsAssociatedWithCommitHandler {
  reposListPullRequestsAssociatedWithCommit(
    req: ReposListPullRequestsAssociatedWithCommitRequest,
    res: ReposListPullRequestsAssociatedWithCommitResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetCommitRequest = Request<
  ReposGetCommitRequestPath,
  | ReposGetCommit200ResponseBody
  | ReposGetCommit404ResponseBody
  | ReposGetCommit422ResponseBody
  | ReposGetCommit500ResponseBody
  | ReposGetCommit503ResponseBody,
  unknown,
  ReposGetCommitRequestQuery,
  Record<string, any>
>;

export type ReposGetCommitResponse = Response<
  | ReposGetCommit200ResponseBody
  | ReposGetCommit404ResponseBody
  | ReposGetCommit422ResponseBody
  | ReposGetCommit500ResponseBody
  | ReposGetCommit503ResponseBody,
  Record<string, any>,
  200 | 404 | 422 | 500 | 503
>;

export interface ReposGetCommitHandler {
  reposGetCommit(
    req: ReposGetCommitRequest,
    res: ReposGetCommitResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ChecksListForRefRequest = Request<
  ChecksListForRefRequestPath,
  ChecksListForRef200ResponseBody,
  unknown,
  ChecksListForRefRequestQuery,
  Record<string, any>
>;

export type ChecksListForRefResponse = Response<
  ChecksListForRef200ResponseBody,
  Record<string, any>,
  200
>;

export interface ChecksListForRefHandler {
  checksListForRef(
    req: ChecksListForRefRequest,
    res: ChecksListForRefResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ChecksListSuitesForRefRequest = Request<
  ChecksListSuitesForRefRequestPath,
  ChecksListSuitesForRef200ResponseBody,
  unknown,
  ChecksListSuitesForRefRequestQuery,
  Record<string, any>
>;

export type ChecksListSuitesForRefResponse = Response<
  ChecksListSuitesForRef200ResponseBody,
  Record<string, any>,
  200
>;

export interface ChecksListSuitesForRefHandler {
  checksListSuitesForRef(
    req: ChecksListSuitesForRefRequest,
    res: ChecksListSuitesForRefResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetCombinedStatusForRefRequest = Request<
  ReposGetCombinedStatusForRefRequestPath,
  | ReposGetCombinedStatusForRef200ResponseBody
  | ReposGetCombinedStatusForRef404ResponseBody,
  unknown,
  ReposGetCombinedStatusForRefRequestQuery,
  Record<string, any>
>;

export type ReposGetCombinedStatusForRefResponse = Response<
  | ReposGetCombinedStatusForRef200ResponseBody
  | ReposGetCombinedStatusForRef404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetCombinedStatusForRefHandler {
  reposGetCombinedStatusForRef(
    req: ReposGetCombinedStatusForRefRequest,
    res: ReposGetCombinedStatusForRefResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListCommitStatusesForRefRequest = Request<
  ReposListCommitStatusesForRefRequestPath,
  | ReposListCommitStatusesForRef200ResponseBody
  | ReposListCommitStatusesForRef301ResponseBody,
  unknown,
  ReposListCommitStatusesForRefRequestQuery,
  Record<string, any>
>;

export type ReposListCommitStatusesForRefResponse = Response<
  | ReposListCommitStatusesForRef200ResponseBody
  | ReposListCommitStatusesForRef301ResponseBody,
  Record<string, any>,
  200 | 301
>;

export interface ReposListCommitStatusesForRefHandler {
  reposListCommitStatusesForRef(
    req: ReposListCommitStatusesForRefRequest,
    res: ReposListCommitStatusesForRefResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetCommunityProfileMetricsRequest = Request<
  ReposGetCommunityProfileMetricsRequestPath,
  ReposGetCommunityProfileMetrics200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetCommunityProfileMetricsResponse = Response<
  ReposGetCommunityProfileMetrics200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposGetCommunityProfileMetricsHandler {
  reposGetCommunityProfileMetrics(
    req: ReposGetCommunityProfileMetricsRequest,
    res: ReposGetCommunityProfileMetricsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCompareCommitsRequest = Request<
  ReposCompareCommitsRequestPath,
  | ReposCompareCommits200ResponseBody
  | ReposCompareCommits404ResponseBody
  | ReposCompareCommits500ResponseBody
  | ReposCompareCommits503ResponseBody,
  unknown,
  ReposCompareCommitsRequestQuery,
  Record<string, any>
>;

export type ReposCompareCommitsResponse = Response<
  | ReposCompareCommits200ResponseBody
  | ReposCompareCommits404ResponseBody
  | ReposCompareCommits500ResponseBody
  | ReposCompareCommits503ResponseBody,
  Record<string, any>,
  200 | 404 | 500 | 503
>;

export interface ReposCompareCommitsHandler {
  reposCompareCommits(
    req: ReposCompareCommitsRequest,
    res: ReposCompareCommitsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetContentRequest = Request<
  ReposGetContentRequestPath,
  | ReposGetContent200ResponseBody
  | ReposGetContent403ResponseBody
  | ReposGetContent404ResponseBody,
  unknown,
  ReposGetContentRequestQuery,
  Record<string, any>
>;

export type ReposGetContentResponse = Response<
  | ReposGetContent200ResponseBody
  | ReposGetContent403ResponseBody
  | ReposGetContent404ResponseBody,
  Record<string, any>,
  200 | 302 | 403 | 404
>;

export interface ReposGetContentHandler {
  reposGetContent(
    req: ReposGetContentRequest,
    res: ReposGetContentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateOrUpdateFileContentsRequest = Request<
  ReposCreateOrUpdateFileContentsRequestPath,
  | ReposCreateOrUpdateFileContents200ResponseBody
  | ReposCreateOrUpdateFileContents201ResponseBody
  | ReposCreateOrUpdateFileContents404ResponseBody
  | ReposCreateOrUpdateFileContents409ResponseBody
  | ReposCreateOrUpdateFileContents422ResponseBody,
  ReposCreateOrUpdateFileContentsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateOrUpdateFileContentsResponse = Response<
  | ReposCreateOrUpdateFileContents200ResponseBody
  | ReposCreateOrUpdateFileContents201ResponseBody
  | ReposCreateOrUpdateFileContents404ResponseBody
  | ReposCreateOrUpdateFileContents409ResponseBody
  | ReposCreateOrUpdateFileContents422ResponseBody,
  Record<string, any>,
  200 | 201 | 404 | 409 | 422
>;

export interface ReposCreateOrUpdateFileContentsHandler {
  reposCreateOrUpdateFileContents(
    req: ReposCreateOrUpdateFileContentsRequest,
    res: ReposCreateOrUpdateFileContentsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteFileRequest = Request<
  ReposDeleteFileRequestPath,
  | ReposDeleteFile200ResponseBody
  | ReposDeleteFile404ResponseBody
  | ReposDeleteFile409ResponseBody
  | ReposDeleteFile422ResponseBody
  | ReposDeleteFile503ResponseBody,
  ReposDeleteFileRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteFileResponse = Response<
  | ReposDeleteFile200ResponseBody
  | ReposDeleteFile404ResponseBody
  | ReposDeleteFile409ResponseBody
  | ReposDeleteFile422ResponseBody
  | ReposDeleteFile503ResponseBody,
  Record<string, any>,
  200 | 404 | 409 | 422 | 503
>;

export interface ReposDeleteFileHandler {
  reposDeleteFile(
    req: ReposDeleteFileRequest,
    res: ReposDeleteFileResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListContributorsRequest = Request<
  ReposListContributorsRequestPath,
  | ReposListContributors200ResponseBody
  | ReposListContributors403ResponseBody
  | ReposListContributors404ResponseBody,
  unknown,
  ReposListContributorsRequestQuery,
  Record<string, any>
>;

export type ReposListContributorsResponse = Response<
  | ReposListContributors200ResponseBody
  | ReposListContributors403ResponseBody
  | ReposListContributors404ResponseBody,
  Record<string, any>,
  200 | 204 | 403 | 404
>;

export interface ReposListContributorsHandler {
  reposListContributors(
    req: ReposListContributorsRequest,
    res: ReposListContributorsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotListAlertsForRepoRequest = Request<
  DependabotListAlertsForRepoRequestPath,
  | DependabotListAlertsForRepo200ResponseBody
  | DependabotListAlertsForRepo400ResponseBody
  | DependabotListAlertsForRepo403ResponseBody
  | DependabotListAlertsForRepo404ResponseBody
  | DependabotListAlertsForRepo422ResponseBody,
  unknown,
  DependabotListAlertsForRepoRequestQuery,
  Record<string, any>
>;

export type DependabotListAlertsForRepoResponse = Response<
  | DependabotListAlertsForRepo200ResponseBody
  | DependabotListAlertsForRepo400ResponseBody
  | DependabotListAlertsForRepo403ResponseBody
  | DependabotListAlertsForRepo404ResponseBody
  | DependabotListAlertsForRepo422ResponseBody,
  Record<string, any>,
  200 | 304 | 400 | 403 | 404 | 422
>;

export interface DependabotListAlertsForRepoHandler {
  dependabotListAlertsForRepo(
    req: DependabotListAlertsForRepoRequest,
    res: DependabotListAlertsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotGetAlertRequest = Request<
  DependabotGetAlertRequestPath,
  | DependabotGetAlert200ResponseBody
  | DependabotGetAlert403ResponseBody
  | DependabotGetAlert404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotGetAlertResponse = Response<
  | DependabotGetAlert200ResponseBody
  | DependabotGetAlert403ResponseBody
  | DependabotGetAlert404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export interface DependabotGetAlertHandler {
  dependabotGetAlert(
    req: DependabotGetAlertRequest,
    res: DependabotGetAlertResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotUpdateAlertRequest = Request<
  DependabotUpdateAlertRequestPath,
  | DependabotUpdateAlert200ResponseBody
  | DependabotUpdateAlert400ResponseBody
  | DependabotUpdateAlert403ResponseBody
  | DependabotUpdateAlert404ResponseBody
  | DependabotUpdateAlert409ResponseBody
  | DependabotUpdateAlert422ResponseBody,
  DependabotUpdateAlertRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type DependabotUpdateAlertResponse = Response<
  | DependabotUpdateAlert200ResponseBody
  | DependabotUpdateAlert400ResponseBody
  | DependabotUpdateAlert403ResponseBody
  | DependabotUpdateAlert404ResponseBody
  | DependabotUpdateAlert409ResponseBody
  | DependabotUpdateAlert422ResponseBody,
  Record<string, any>,
  200 | 400 | 403 | 404 | 409 | 422
>;

export interface DependabotUpdateAlertHandler {
  dependabotUpdateAlert(
    req: DependabotUpdateAlertRequest,
    res: DependabotUpdateAlertResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotListRepoSecretsRequest = Request<
  DependabotListRepoSecretsRequestPath,
  DependabotListRepoSecrets200ResponseBody,
  unknown,
  DependabotListRepoSecretsRequestQuery,
  Record<string, any>
>;

export type DependabotListRepoSecretsResponse = Response<
  DependabotListRepoSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export interface DependabotListRepoSecretsHandler {
  dependabotListRepoSecrets(
    req: DependabotListRepoSecretsRequest,
    res: DependabotListRepoSecretsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotGetRepoPublicKeyRequest = Request<
  DependabotGetRepoPublicKeyRequestPath,
  DependabotGetRepoPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotGetRepoPublicKeyResponse = Response<
  DependabotGetRepoPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export interface DependabotGetRepoPublicKeyHandler {
  dependabotGetRepoPublicKey(
    req: DependabotGetRepoPublicKeyRequest,
    res: DependabotGetRepoPublicKeyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotGetRepoSecretRequest = Request<
  DependabotGetRepoSecretRequestPath,
  DependabotGetRepoSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotGetRepoSecretResponse = Response<
  DependabotGetRepoSecret200ResponseBody,
  Record<string, any>,
  200
>;

export interface DependabotGetRepoSecretHandler {
  dependabotGetRepoSecret(
    req: DependabotGetRepoSecretRequest,
    res: DependabotGetRepoSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotCreateOrUpdateRepoSecretRequest = Request<
  DependabotCreateOrUpdateRepoSecretRequestPath,
  DependabotCreateOrUpdateRepoSecret201ResponseBody,
  DependabotCreateOrUpdateRepoSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type DependabotCreateOrUpdateRepoSecretResponse = Response<
  DependabotCreateOrUpdateRepoSecret201ResponseBody,
  Record<string, any>,
  201 | 204
>;

export interface DependabotCreateOrUpdateRepoSecretHandler {
  dependabotCreateOrUpdateRepoSecret(
    req: DependabotCreateOrUpdateRepoSecretRequest,
    res: DependabotCreateOrUpdateRepoSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependabotDeleteRepoSecretRequest = Request<
  DependabotDeleteRepoSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type DependabotDeleteRepoSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface DependabotDeleteRepoSecretHandler {
  dependabotDeleteRepoSecret(
    req: DependabotDeleteRepoSecretRequest,
    res: DependabotDeleteRepoSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependencyGraphDiffRangeRequest = Request<
  DependencyGraphDiffRangeRequestPath,
  | DependencyGraphDiffRange200ResponseBody
  | DependencyGraphDiffRange403ResponseBody
  | DependencyGraphDiffRange404ResponseBody,
  unknown,
  DependencyGraphDiffRangeRequestQuery,
  Record<string, any>
>;

export type DependencyGraphDiffRangeResponse = Response<
  | DependencyGraphDiffRange200ResponseBody
  | DependencyGraphDiffRange403ResponseBody
  | DependencyGraphDiffRange404ResponseBody,
  Record<string, any>,
  200 | 403 | 404
>;

export interface DependencyGraphDiffRangeHandler {
  dependencyGraphDiffRange(
    req: DependencyGraphDiffRangeRequest,
    res: DependencyGraphDiffRangeResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type DependencyGraphCreateRepositorySnapshotRequest = Request<
  DependencyGraphCreateRepositorySnapshotRequestPath,
  DependencyGraphCreateRepositorySnapshot201ResponseBody,
  DependencyGraphCreateRepositorySnapshotRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type DependencyGraphCreateRepositorySnapshotResponse = Response<
  DependencyGraphCreateRepositorySnapshot201ResponseBody,
  Record<string, any>,
  201
>;

export interface DependencyGraphCreateRepositorySnapshotHandler {
  dependencyGraphCreateRepositorySnapshot(
    req: DependencyGraphCreateRepositorySnapshotRequest,
    res: DependencyGraphCreateRepositorySnapshotResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListDeploymentsRequest = Request<
  ReposListDeploymentsRequestPath,
  ReposListDeployments200ResponseBody,
  unknown,
  ReposListDeploymentsRequestQuery,
  Record<string, any>
>;

export type ReposListDeploymentsResponse = Response<
  ReposListDeployments200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListDeploymentsHandler {
  reposListDeployments(
    req: ReposListDeploymentsRequest,
    res: ReposListDeploymentsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateDeploymentRequest = Request<
  ReposCreateDeploymentRequestPath,
  | ReposCreateDeployment201ResponseBody
  | ReposCreateDeployment202ResponseBody
  | ReposCreateDeployment422ResponseBody,
  ReposCreateDeploymentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateDeploymentResponse = Response<
  | ReposCreateDeployment201ResponseBody
  | ReposCreateDeployment202ResponseBody
  | ReposCreateDeployment422ResponseBody,
  Record<string, any>,
  201 | 202 | 409 | 422
>;

export interface ReposCreateDeploymentHandler {
  reposCreateDeployment(
    req: ReposCreateDeploymentRequest,
    res: ReposCreateDeploymentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetDeploymentRequest = Request<
  ReposGetDeploymentRequestPath,
  ReposGetDeployment200ResponseBody | ReposGetDeployment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetDeploymentResponse = Response<
  ReposGetDeployment200ResponseBody | ReposGetDeployment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetDeploymentHandler {
  reposGetDeployment(
    req: ReposGetDeploymentRequest,
    res: ReposGetDeploymentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteDeploymentRequest = Request<
  ReposDeleteDeploymentRequestPath,
  ReposDeleteDeployment404ResponseBody | ReposDeleteDeployment422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteDeploymentResponse = Response<
  ReposDeleteDeployment404ResponseBody | ReposDeleteDeployment422ResponseBody,
  Record<string, any>,
  204 | 404 | 422
>;

export interface ReposDeleteDeploymentHandler {
  reposDeleteDeployment(
    req: ReposDeleteDeploymentRequest,
    res: ReposDeleteDeploymentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListDeploymentStatusesRequest = Request<
  ReposListDeploymentStatusesRequestPath,
  | ReposListDeploymentStatuses200ResponseBody
  | ReposListDeploymentStatuses404ResponseBody,
  unknown,
  ReposListDeploymentStatusesRequestQuery,
  Record<string, any>
>;

export type ReposListDeploymentStatusesResponse = Response<
  | ReposListDeploymentStatuses200ResponseBody
  | ReposListDeploymentStatuses404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposListDeploymentStatusesHandler {
  reposListDeploymentStatuses(
    req: ReposListDeploymentStatusesRequest,
    res: ReposListDeploymentStatusesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateDeploymentStatusRequest = Request<
  ReposCreateDeploymentStatusRequestPath,
  | ReposCreateDeploymentStatus201ResponseBody
  | ReposCreateDeploymentStatus422ResponseBody,
  ReposCreateDeploymentStatusRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateDeploymentStatusResponse = Response<
  | ReposCreateDeploymentStatus201ResponseBody
  | ReposCreateDeploymentStatus422ResponseBody,
  Record<string, any>,
  201 | 422
>;

export interface ReposCreateDeploymentStatusHandler {
  reposCreateDeploymentStatus(
    req: ReposCreateDeploymentStatusRequest,
    res: ReposCreateDeploymentStatusResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetDeploymentStatusRequest = Request<
  ReposGetDeploymentStatusRequestPath,
  | ReposGetDeploymentStatus200ResponseBody
  | ReposGetDeploymentStatus404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetDeploymentStatusResponse = Response<
  | ReposGetDeploymentStatus200ResponseBody
  | ReposGetDeploymentStatus404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetDeploymentStatusHandler {
  reposGetDeploymentStatus(
    req: ReposGetDeploymentStatusRequest,
    res: ReposGetDeploymentStatusResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateDispatchEventRequest = Request<
  ReposCreateDispatchEventRequestPath,
  ReposCreateDispatchEvent422ResponseBody,
  ReposCreateDispatchEventRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateDispatchEventResponse = Response<
  ReposCreateDispatchEvent422ResponseBody,
  Record<string, any>,
  204 | 422
>;

export interface ReposCreateDispatchEventHandler {
  reposCreateDispatchEvent(
    req: ReposCreateDispatchEventRequest,
    res: ReposCreateDispatchEventResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetAllEnvironmentsRequest = Request<
  ReposGetAllEnvironmentsRequestPath,
  ReposGetAllEnvironments200ResponseBody,
  unknown,
  ReposGetAllEnvironmentsRequestQuery,
  Record<string, any>
>;

export type ReposGetAllEnvironmentsResponse = Response<
  ReposGetAllEnvironments200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposGetAllEnvironmentsHandler {
  reposGetAllEnvironments(
    req: ReposGetAllEnvironmentsRequest,
    res: ReposGetAllEnvironmentsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetEnvironmentRequest = Request<
  ReposGetEnvironmentRequestPath,
  ReposGetEnvironment200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetEnvironmentResponse = Response<
  ReposGetEnvironment200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposGetEnvironmentHandler {
  reposGetEnvironment(
    req: ReposGetEnvironmentRequest,
    res: ReposGetEnvironmentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateOrUpdateEnvironmentRequest = Request<
  ReposCreateOrUpdateEnvironmentRequestPath,
  | ReposCreateOrUpdateEnvironment200ResponseBody
  | ReposCreateOrUpdateEnvironment422ResponseBody,
  ReposCreateOrUpdateEnvironmentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateOrUpdateEnvironmentResponse = Response<
  | ReposCreateOrUpdateEnvironment200ResponseBody
  | ReposCreateOrUpdateEnvironment422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ReposCreateOrUpdateEnvironmentHandler {
  reposCreateOrUpdateEnvironment(
    req: ReposCreateOrUpdateEnvironmentRequest,
    res: ReposCreateOrUpdateEnvironmentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteAnEnvironmentRequest = Request<
  ReposDeleteAnEnvironmentRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteAnEnvironmentResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposDeleteAnEnvironmentHandler {
  reposDeleteAnEnvironment(
    req: ReposDeleteAnEnvironmentRequest,
    res: ReposDeleteAnEnvironmentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListDeploymentBranchPoliciesRequest = Request<
  ReposListDeploymentBranchPoliciesRequestPath,
  ReposListDeploymentBranchPolicies200ResponseBody,
  unknown,
  ReposListDeploymentBranchPoliciesRequestQuery,
  Record<string, any>
>;

export type ReposListDeploymentBranchPoliciesResponse = Response<
  ReposListDeploymentBranchPolicies200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListDeploymentBranchPoliciesHandler {
  reposListDeploymentBranchPolicies(
    req: ReposListDeploymentBranchPoliciesRequest,
    res: ReposListDeploymentBranchPoliciesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateDeploymentBranchPolicyRequest = Request<
  ReposCreateDeploymentBranchPolicyRequestPath,
  ReposCreateDeploymentBranchPolicy200ResponseBody,
  ReposCreateDeploymentBranchPolicyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateDeploymentBranchPolicyResponse = Response<
  ReposCreateDeploymentBranchPolicy200ResponseBody,
  Record<string, any>,
  200 | 303 | 404
>;

export interface ReposCreateDeploymentBranchPolicyHandler {
  reposCreateDeploymentBranchPolicy(
    req: ReposCreateDeploymentBranchPolicyRequest,
    res: ReposCreateDeploymentBranchPolicyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetDeploymentBranchPolicyRequest = Request<
  ReposGetDeploymentBranchPolicyRequestPath,
  ReposGetDeploymentBranchPolicy200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetDeploymentBranchPolicyResponse = Response<
  ReposGetDeploymentBranchPolicy200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposGetDeploymentBranchPolicyHandler {
  reposGetDeploymentBranchPolicy(
    req: ReposGetDeploymentBranchPolicyRequest,
    res: ReposGetDeploymentBranchPolicyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposUpdateDeploymentBranchPolicyRequest = Request<
  ReposUpdateDeploymentBranchPolicyRequestPath,
  ReposUpdateDeploymentBranchPolicy200ResponseBody,
  ReposUpdateDeploymentBranchPolicyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateDeploymentBranchPolicyResponse = Response<
  ReposUpdateDeploymentBranchPolicy200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposUpdateDeploymentBranchPolicyHandler {
  reposUpdateDeploymentBranchPolicy(
    req: ReposUpdateDeploymentBranchPolicyRequest,
    res: ReposUpdateDeploymentBranchPolicyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteDeploymentBranchPolicyRequest = Request<
  ReposDeleteDeploymentBranchPolicyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteDeploymentBranchPolicyResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposDeleteDeploymentBranchPolicyHandler {
  reposDeleteDeploymentBranchPolicy(
    req: ReposDeleteDeploymentBranchPolicyRequest,
    res: ReposDeleteDeploymentBranchPolicyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListRepoEventsRequest = Request<
  ActivityListRepoEventsRequestPath,
  ActivityListRepoEvents200ResponseBody,
  unknown,
  ActivityListRepoEventsRequestQuery,
  Record<string, any>
>;

export type ActivityListRepoEventsResponse = Response<
  ActivityListRepoEvents200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActivityListRepoEventsHandler {
  activityListRepoEvents(
    req: ActivityListRepoEventsRequest,
    res: ActivityListRepoEventsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListForksRequest = Request<
  ReposListForksRequestPath,
  ReposListForks200ResponseBody | ReposListForks400ResponseBody,
  unknown,
  ReposListForksRequestQuery,
  Record<string, any>
>;

export type ReposListForksResponse = Response<
  ReposListForks200ResponseBody | ReposListForks400ResponseBody,
  Record<string, any>,
  200 | 400
>;

export interface ReposListForksHandler {
  reposListForks(
    req: ReposListForksRequest,
    res: ReposListForksResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateForkRequest = Request<
  ReposCreateForkRequestPath,
  | ReposCreateFork202ResponseBody
  | ReposCreateFork400ResponseBody
  | ReposCreateFork403ResponseBody
  | ReposCreateFork404ResponseBody
  | ReposCreateFork422ResponseBody,
  ReposCreateForkRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateForkResponse = Response<
  | ReposCreateFork202ResponseBody
  | ReposCreateFork400ResponseBody
  | ReposCreateFork403ResponseBody
  | ReposCreateFork404ResponseBody
  | ReposCreateFork422ResponseBody,
  Record<string, any>,
  202 | 400 | 403 | 404 | 422
>;

export interface ReposCreateForkHandler {
  reposCreateFork(
    req: ReposCreateForkRequest,
    res: ReposCreateForkResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitCreateBlobRequest = Request<
  GitCreateBlobRequestPath,
  | GitCreateBlob201ResponseBody
  | GitCreateBlob403ResponseBody
  | GitCreateBlob404ResponseBody
  | GitCreateBlob409ResponseBody
  | GitCreateBlob422ResponseBody,
  GitCreateBlobRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GitCreateBlobResponse = Response<
  | GitCreateBlob201ResponseBody
  | GitCreateBlob403ResponseBody
  | GitCreateBlob404ResponseBody
  | GitCreateBlob409ResponseBody
  | GitCreateBlob422ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 409 | 422
>;

export interface GitCreateBlobHandler {
  gitCreateBlob(
    req: GitCreateBlobRequest,
    res: GitCreateBlobResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitGetBlobRequest = Request<
  GitGetBlobRequestPath,
  | GitGetBlob200ResponseBody
  | GitGetBlob403ResponseBody
  | GitGetBlob404ResponseBody
  | GitGetBlob422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitGetBlobResponse = Response<
  | GitGetBlob200ResponseBody
  | GitGetBlob403ResponseBody
  | GitGetBlob404ResponseBody
  | GitGetBlob422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export interface GitGetBlobHandler {
  gitGetBlob(
    req: GitGetBlobRequest,
    res: GitGetBlobResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitCreateCommitRequest = Request<
  GitCreateCommitRequestPath,
  | GitCreateCommit201ResponseBody
  | GitCreateCommit404ResponseBody
  | GitCreateCommit422ResponseBody,
  GitCreateCommitRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GitCreateCommitResponse = Response<
  | GitCreateCommit201ResponseBody
  | GitCreateCommit404ResponseBody
  | GitCreateCommit422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export interface GitCreateCommitHandler {
  gitCreateCommit(
    req: GitCreateCommitRequest,
    res: GitCreateCommitResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitGetCommitRequest = Request<
  GitGetCommitRequestPath,
  GitGetCommit200ResponseBody | GitGetCommit404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitGetCommitResponse = Response<
  GitGetCommit200ResponseBody | GitGetCommit404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface GitGetCommitHandler {
  gitGetCommit(
    req: GitGetCommitRequest,
    res: GitGetCommitResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitListMatchingRefsRequest = Request<
  GitListMatchingRefsRequestPath,
  GitListMatchingRefs200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitListMatchingRefsResponse = Response<
  GitListMatchingRefs200ResponseBody,
  Record<string, any>,
  200
>;

export interface GitListMatchingRefsHandler {
  gitListMatchingRefs(
    req: GitListMatchingRefsRequest,
    res: GitListMatchingRefsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitGetRefRequest = Request<
  GitGetRefRequestPath,
  GitGetRef200ResponseBody | GitGetRef404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitGetRefResponse = Response<
  GitGetRef200ResponseBody | GitGetRef404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface GitGetRefHandler {
  gitGetRef(
    req: GitGetRefRequest,
    res: GitGetRefResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitCreateRefRequest = Request<
  GitCreateRefRequestPath,
  GitCreateRef201ResponseBody | GitCreateRef422ResponseBody,
  GitCreateRefRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GitCreateRefResponse = Response<
  GitCreateRef201ResponseBody | GitCreateRef422ResponseBody,
  Record<string, any>,
  201 | 422
>;

export interface GitCreateRefHandler {
  gitCreateRef(
    req: GitCreateRefRequest,
    res: GitCreateRefResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitUpdateRefRequest = Request<
  GitUpdateRefRequestPath,
  GitUpdateRef200ResponseBody | GitUpdateRef422ResponseBody,
  GitUpdateRefRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GitUpdateRefResponse = Response<
  GitUpdateRef200ResponseBody | GitUpdateRef422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface GitUpdateRefHandler {
  gitUpdateRef(
    req: GitUpdateRefRequest,
    res: GitUpdateRefResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitDeleteRefRequest = Request<
  GitDeleteRefRequestPath,
  GitDeleteRef422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitDeleteRefResponse = Response<
  GitDeleteRef422ResponseBody,
  Record<string, any>,
  204 | 422
>;

export interface GitDeleteRefHandler {
  gitDeleteRef(
    req: GitDeleteRefRequest,
    res: GitDeleteRefResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitCreateTagRequest = Request<
  GitCreateTagRequestPath,
  GitCreateTag201ResponseBody | GitCreateTag422ResponseBody,
  GitCreateTagRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GitCreateTagResponse = Response<
  GitCreateTag201ResponseBody | GitCreateTag422ResponseBody,
  Record<string, any>,
  201 | 422
>;

export interface GitCreateTagHandler {
  gitCreateTag(
    req: GitCreateTagRequest,
    res: GitCreateTagResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitGetTagRequest = Request<
  GitGetTagRequestPath,
  GitGetTag200ResponseBody | GitGetTag404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type GitGetTagResponse = Response<
  GitGetTag200ResponseBody | GitGetTag404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface GitGetTagHandler {
  gitGetTag(
    req: GitGetTagRequest,
    res: GitGetTagResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitCreateTreeRequest = Request<
  GitCreateTreeRequestPath,
  | GitCreateTree201ResponseBody
  | GitCreateTree403ResponseBody
  | GitCreateTree404ResponseBody
  | GitCreateTree422ResponseBody,
  GitCreateTreeRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type GitCreateTreeResponse = Response<
  | GitCreateTree201ResponseBody
  | GitCreateTree403ResponseBody
  | GitCreateTree404ResponseBody
  | GitCreateTree422ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 422
>;

export interface GitCreateTreeHandler {
  gitCreateTree(
    req: GitCreateTreeRequest,
    res: GitCreateTreeResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GitGetTreeRequest = Request<
  GitGetTreeRequestPath,
  | GitGetTree200ResponseBody
  | GitGetTree404ResponseBody
  | GitGetTree422ResponseBody,
  unknown,
  GitGetTreeRequestQuery,
  Record<string, any>
>;

export type GitGetTreeResponse = Response<
  | GitGetTree200ResponseBody
  | GitGetTree404ResponseBody
  | GitGetTree422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface GitGetTreeHandler {
  gitGetTree(
    req: GitGetTreeRequest,
    res: GitGetTreeResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListWebhooksRequest = Request<
  ReposListWebhooksRequestPath,
  ReposListWebhooks200ResponseBody | ReposListWebhooks404ResponseBody,
  unknown,
  ReposListWebhooksRequestQuery,
  Record<string, any>
>;

export type ReposListWebhooksResponse = Response<
  ReposListWebhooks200ResponseBody | ReposListWebhooks404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposListWebhooksHandler {
  reposListWebhooks(
    req: ReposListWebhooksRequest,
    res: ReposListWebhooksResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateWebhookRequest = Request<
  ReposCreateWebhookRequestPath,
  | ReposCreateWebhook201ResponseBody
  | ReposCreateWebhook403ResponseBody
  | ReposCreateWebhook404ResponseBody
  | ReposCreateWebhook422ResponseBody,
  ReposCreateWebhookRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateWebhookResponse = Response<
  | ReposCreateWebhook201ResponseBody
  | ReposCreateWebhook403ResponseBody
  | ReposCreateWebhook404ResponseBody
  | ReposCreateWebhook422ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 422
>;

export interface ReposCreateWebhookHandler {
  reposCreateWebhook(
    req: ReposCreateWebhookRequest,
    res: ReposCreateWebhookResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetWebhookRequest = Request<
  ReposGetWebhookRequestPath,
  ReposGetWebhook200ResponseBody | ReposGetWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetWebhookResponse = Response<
  ReposGetWebhook200ResponseBody | ReposGetWebhook404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetWebhookHandler {
  reposGetWebhook(
    req: ReposGetWebhookRequest,
    res: ReposGetWebhookResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposUpdateWebhookRequest = Request<
  ReposUpdateWebhookRequestPath,
  | ReposUpdateWebhook200ResponseBody
  | ReposUpdateWebhook404ResponseBody
  | ReposUpdateWebhook422ResponseBody,
  ReposUpdateWebhookRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateWebhookResponse = Response<
  | ReposUpdateWebhook200ResponseBody
  | ReposUpdateWebhook404ResponseBody
  | ReposUpdateWebhook422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface ReposUpdateWebhookHandler {
  reposUpdateWebhook(
    req: ReposUpdateWebhookRequest,
    res: ReposUpdateWebhookResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteWebhookRequest = Request<
  ReposDeleteWebhookRequestPath,
  ReposDeleteWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteWebhookResponse = Response<
  ReposDeleteWebhook404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface ReposDeleteWebhookHandler {
  reposDeleteWebhook(
    req: ReposDeleteWebhookRequest,
    res: ReposDeleteWebhookResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetWebhookConfigForRepoRequest = Request<
  ReposGetWebhookConfigForRepoRequestPath,
  ReposGetWebhookConfigForRepo200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetWebhookConfigForRepoResponse = Response<
  ReposGetWebhookConfigForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposGetWebhookConfigForRepoHandler {
  reposGetWebhookConfigForRepo(
    req: ReposGetWebhookConfigForRepoRequest,
    res: ReposGetWebhookConfigForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposUpdateWebhookConfigForRepoRequest = Request<
  ReposUpdateWebhookConfigForRepoRequestPath,
  ReposUpdateWebhookConfigForRepo200ResponseBody,
  ReposUpdateWebhookConfigForRepoRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateWebhookConfigForRepoResponse = Response<
  ReposUpdateWebhookConfigForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposUpdateWebhookConfigForRepoHandler {
  reposUpdateWebhookConfigForRepo(
    req: ReposUpdateWebhookConfigForRepoRequest,
    res: ReposUpdateWebhookConfigForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListWebhookDeliveriesRequest = Request<
  ReposListWebhookDeliveriesRequestPath,
  | ReposListWebhookDeliveries200ResponseBody
  | ReposListWebhookDeliveries400ResponseBody
  | ReposListWebhookDeliveries422ResponseBody,
  unknown,
  ReposListWebhookDeliveriesRequestQuery,
  Record<string, any>
>;

export type ReposListWebhookDeliveriesResponse = Response<
  | ReposListWebhookDeliveries200ResponseBody
  | ReposListWebhookDeliveries400ResponseBody
  | ReposListWebhookDeliveries422ResponseBody,
  Record<string, any>,
  200 | 400 | 422
>;

export interface ReposListWebhookDeliveriesHandler {
  reposListWebhookDeliveries(
    req: ReposListWebhookDeliveriesRequest,
    res: ReposListWebhookDeliveriesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetWebhookDeliveryRequest = Request<
  ReposGetWebhookDeliveryRequestPath,
  | ReposGetWebhookDelivery200ResponseBody
  | ReposGetWebhookDelivery400ResponseBody
  | ReposGetWebhookDelivery422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetWebhookDeliveryResponse = Response<
  | ReposGetWebhookDelivery200ResponseBody
  | ReposGetWebhookDelivery400ResponseBody
  | ReposGetWebhookDelivery422ResponseBody,
  Record<string, any>,
  200 | 400 | 422
>;

export interface ReposGetWebhookDeliveryHandler {
  reposGetWebhookDelivery(
    req: ReposGetWebhookDeliveryRequest,
    res: ReposGetWebhookDeliveryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposRedeliverWebhookDeliveryRequest = Request<
  ReposRedeliverWebhookDeliveryRequestPath,
  | ReposRedeliverWebhookDelivery202ResponseBody
  | ReposRedeliverWebhookDelivery400ResponseBody
  | ReposRedeliverWebhookDelivery422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposRedeliverWebhookDeliveryResponse = Response<
  | ReposRedeliverWebhookDelivery202ResponseBody
  | ReposRedeliverWebhookDelivery400ResponseBody
  | ReposRedeliverWebhookDelivery422ResponseBody,
  Record<string, any>,
  202 | 400 | 422
>;

export interface ReposRedeliverWebhookDeliveryHandler {
  reposRedeliverWebhookDelivery(
    req: ReposRedeliverWebhookDeliveryRequest,
    res: ReposRedeliverWebhookDeliveryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposPingWebhookRequest = Request<
  ReposPingWebhookRequestPath,
  ReposPingWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposPingWebhookResponse = Response<
  ReposPingWebhook404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface ReposPingWebhookHandler {
  reposPingWebhook(
    req: ReposPingWebhookRequest,
    res: ReposPingWebhookResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposTestPushWebhookRequest = Request<
  ReposTestPushWebhookRequestPath,
  ReposTestPushWebhook404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposTestPushWebhookResponse = Response<
  ReposTestPushWebhook404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface ReposTestPushWebhookHandler {
  reposTestPushWebhook(
    req: ReposTestPushWebhookRequest,
    res: ReposTestPushWebhookResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsGetImportStatusRequest = Request<
  MigrationsGetImportStatusRequestPath,
  | MigrationsGetImportStatus200ResponseBody
  | MigrationsGetImportStatus404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsGetImportStatusResponse = Response<
  | MigrationsGetImportStatus200ResponseBody
  | MigrationsGetImportStatus404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface MigrationsGetImportStatusHandler {
  migrationsGetImportStatus(
    req: MigrationsGetImportStatusRequest,
    res: MigrationsGetImportStatusResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsStartImportRequest = Request<
  MigrationsStartImportRequestPath,
  | MigrationsStartImport201ResponseBody
  | MigrationsStartImport404ResponseBody
  | MigrationsStartImport422ResponseBody,
  MigrationsStartImportRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsStartImportResponse = Response<
  | MigrationsStartImport201ResponseBody
  | MigrationsStartImport404ResponseBody
  | MigrationsStartImport422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export interface MigrationsStartImportHandler {
  migrationsStartImport(
    req: MigrationsStartImportRequest,
    res: MigrationsStartImportResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsUpdateImportRequest = Request<
  MigrationsUpdateImportRequestPath,
  MigrationsUpdateImport200ResponseBody,
  MigrationsUpdateImportRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsUpdateImportResponse = Response<
  MigrationsUpdateImport200ResponseBody,
  Record<string, any>,
  200
>;

export interface MigrationsUpdateImportHandler {
  migrationsUpdateImport(
    req: MigrationsUpdateImportRequest,
    res: MigrationsUpdateImportResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsCancelImportRequest = Request<
  MigrationsCancelImportRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsCancelImportResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface MigrationsCancelImportHandler {
  migrationsCancelImport(
    req: MigrationsCancelImportRequest,
    res: MigrationsCancelImportResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsGetCommitAuthorsRequest = Request<
  MigrationsGetCommitAuthorsRequestPath,
  | MigrationsGetCommitAuthors200ResponseBody
  | MigrationsGetCommitAuthors404ResponseBody,
  unknown,
  MigrationsGetCommitAuthorsRequestQuery,
  Record<string, any>
>;

export type MigrationsGetCommitAuthorsResponse = Response<
  | MigrationsGetCommitAuthors200ResponseBody
  | MigrationsGetCommitAuthors404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface MigrationsGetCommitAuthorsHandler {
  migrationsGetCommitAuthors(
    req: MigrationsGetCommitAuthorsRequest,
    res: MigrationsGetCommitAuthorsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsMapCommitAuthorRequest = Request<
  MigrationsMapCommitAuthorRequestPath,
  | MigrationsMapCommitAuthor200ResponseBody
  | MigrationsMapCommitAuthor404ResponseBody
  | MigrationsMapCommitAuthor422ResponseBody,
  MigrationsMapCommitAuthorRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsMapCommitAuthorResponse = Response<
  | MigrationsMapCommitAuthor200ResponseBody
  | MigrationsMapCommitAuthor404ResponseBody
  | MigrationsMapCommitAuthor422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface MigrationsMapCommitAuthorHandler {
  migrationsMapCommitAuthor(
    req: MigrationsMapCommitAuthorRequest,
    res: MigrationsMapCommitAuthorResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsGetLargeFilesRequest = Request<
  MigrationsGetLargeFilesRequestPath,
  MigrationsGetLargeFiles200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsGetLargeFilesResponse = Response<
  MigrationsGetLargeFiles200ResponseBody,
  Record<string, any>,
  200
>;

export interface MigrationsGetLargeFilesHandler {
  migrationsGetLargeFiles(
    req: MigrationsGetLargeFilesRequest,
    res: MigrationsGetLargeFilesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsSetLfsPreferenceRequest = Request<
  MigrationsSetLfsPreferenceRequestPath,
  | MigrationsSetLfsPreference200ResponseBody
  | MigrationsSetLfsPreference422ResponseBody,
  MigrationsSetLfsPreferenceRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsSetLfsPreferenceResponse = Response<
  | MigrationsSetLfsPreference200ResponseBody
  | MigrationsSetLfsPreference422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface MigrationsSetLfsPreferenceHandler {
  migrationsSetLfsPreference(
    req: MigrationsSetLfsPreferenceRequest,
    res: MigrationsSetLfsPreferenceResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsGetRepoInstallationRequest = Request<
  AppsGetRepoInstallationRequestPath,
  | AppsGetRepoInstallation200ResponseBody
  | AppsGetRepoInstallation301ResponseBody
  | AppsGetRepoInstallation404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetRepoInstallationResponse = Response<
  | AppsGetRepoInstallation200ResponseBody
  | AppsGetRepoInstallation301ResponseBody
  | AppsGetRepoInstallation404ResponseBody,
  Record<string, any>,
  200 | 301 | 404
>;

export interface AppsGetRepoInstallationHandler {
  appsGetRepoInstallation(
    req: AppsGetRepoInstallationRequest,
    res: AppsGetRepoInstallationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type InteractionsGetRestrictionsForRepoRequest = Request<
  InteractionsGetRestrictionsForRepoRequestPath,
  InteractionsGetRestrictionsForRepo200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsGetRestrictionsForRepoResponse = Response<
  InteractionsGetRestrictionsForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export interface InteractionsGetRestrictionsForRepoHandler {
  interactionsGetRestrictionsForRepo(
    req: InteractionsGetRestrictionsForRepoRequest,
    res: InteractionsGetRestrictionsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type InteractionsSetRestrictionsForRepoRequest = Request<
  InteractionsSetRestrictionsForRepoRequestPath,
  InteractionsSetRestrictionsForRepo200ResponseBody,
  InteractionsSetRestrictionsForRepoRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsSetRestrictionsForRepoResponse = Response<
  InteractionsSetRestrictionsForRepo200ResponseBody,
  Record<string, any>,
  200 | 409
>;

export interface InteractionsSetRestrictionsForRepoHandler {
  interactionsSetRestrictionsForRepo(
    req: InteractionsSetRestrictionsForRepoRequest,
    res: InteractionsSetRestrictionsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type InteractionsRemoveRestrictionsForRepoRequest = Request<
  InteractionsRemoveRestrictionsForRepoRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsRemoveRestrictionsForRepoResponse = Response<
  unknown,
  Record<string, any>,
  204 | 409
>;

export interface InteractionsRemoveRestrictionsForRepoHandler {
  interactionsRemoveRestrictionsForRepo(
    req: InteractionsRemoveRestrictionsForRepoRequest,
    res: InteractionsRemoveRestrictionsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListInvitationsRequest = Request<
  ReposListInvitationsRequestPath,
  ReposListInvitations200ResponseBody,
  unknown,
  ReposListInvitationsRequestQuery,
  Record<string, any>
>;

export type ReposListInvitationsResponse = Response<
  ReposListInvitations200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListInvitationsHandler {
  reposListInvitations(
    req: ReposListInvitationsRequest,
    res: ReposListInvitationsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposUpdateInvitationRequest = Request<
  ReposUpdateInvitationRequestPath,
  ReposUpdateInvitation200ResponseBody,
  ReposUpdateInvitationRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateInvitationResponse = Response<
  ReposUpdateInvitation200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposUpdateInvitationHandler {
  reposUpdateInvitation(
    req: ReposUpdateInvitationRequest,
    res: ReposUpdateInvitationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteInvitationRequest = Request<
  ReposDeleteInvitationRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteInvitationResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposDeleteInvitationHandler {
  reposDeleteInvitation(
    req: ReposDeleteInvitationRequest,
    res: ReposDeleteInvitationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListForRepoRequest = Request<
  IssuesListForRepoRequestPath,
  | IssuesListForRepo200ResponseBody
  | IssuesListForRepo301ResponseBody
  | IssuesListForRepo404ResponseBody
  | IssuesListForRepo422ResponseBody,
  unknown,
  IssuesListForRepoRequestQuery,
  Record<string, any>
>;

export type IssuesListForRepoResponse = Response<
  | IssuesListForRepo200ResponseBody
  | IssuesListForRepo301ResponseBody
  | IssuesListForRepo404ResponseBody
  | IssuesListForRepo422ResponseBody,
  Record<string, any>,
  200 | 301 | 404 | 422
>;

export interface IssuesListForRepoHandler {
  issuesListForRepo(
    req: IssuesListForRepoRequest,
    res: IssuesListForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesCreateRequest = Request<
  IssuesCreateRequestPath,
  | IssuesCreate201ResponseBody
  | IssuesCreate403ResponseBody
  | IssuesCreate404ResponseBody
  | IssuesCreate410ResponseBody
  | IssuesCreate422ResponseBody
  | IssuesCreate503ResponseBody,
  IssuesCreateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesCreateResponse = Response<
  | IssuesCreate201ResponseBody
  | IssuesCreate403ResponseBody
  | IssuesCreate404ResponseBody
  | IssuesCreate410ResponseBody
  | IssuesCreate422ResponseBody
  | IssuesCreate503ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 410 | 422 | 503
>;

export interface IssuesCreateHandler {
  issuesCreate(
    req: IssuesCreateRequest,
    res: IssuesCreateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListCommentsForRepoRequest = Request<
  IssuesListCommentsForRepoRequestPath,
  | IssuesListCommentsForRepo200ResponseBody
  | IssuesListCommentsForRepo404ResponseBody
  | IssuesListCommentsForRepo422ResponseBody,
  unknown,
  IssuesListCommentsForRepoRequestQuery,
  Record<string, any>
>;

export type IssuesListCommentsForRepoResponse = Response<
  | IssuesListCommentsForRepo200ResponseBody
  | IssuesListCommentsForRepo404ResponseBody
  | IssuesListCommentsForRepo422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface IssuesListCommentsForRepoHandler {
  issuesListCommentsForRepo(
    req: IssuesListCommentsForRepoRequest,
    res: IssuesListCommentsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesGetCommentRequest = Request<
  IssuesGetCommentRequestPath,
  IssuesGetComment200ResponseBody | IssuesGetComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesGetCommentResponse = Response<
  IssuesGetComment200ResponseBody | IssuesGetComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface IssuesGetCommentHandler {
  issuesGetComment(
    req: IssuesGetCommentRequest,
    res: IssuesGetCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesUpdateCommentRequest = Request<
  IssuesUpdateCommentRequestPath,
  IssuesUpdateComment200ResponseBody | IssuesUpdateComment422ResponseBody,
  IssuesUpdateCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesUpdateCommentResponse = Response<
  IssuesUpdateComment200ResponseBody | IssuesUpdateComment422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface IssuesUpdateCommentHandler {
  issuesUpdateComment(
    req: IssuesUpdateCommentRequest,
    res: IssuesUpdateCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesDeleteCommentRequest = Request<
  IssuesDeleteCommentRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesDeleteCommentResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface IssuesDeleteCommentHandler {
  issuesDeleteComment(
    req: IssuesDeleteCommentRequest,
    res: IssuesDeleteCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsListForIssueCommentRequest = Request<
  ReactionsListForIssueCommentRequestPath,
  | ReactionsListForIssueComment200ResponseBody
  | ReactionsListForIssueComment404ResponseBody,
  unknown,
  ReactionsListForIssueCommentRequestQuery,
  Record<string, any>
>;

export type ReactionsListForIssueCommentResponse = Response<
  | ReactionsListForIssueComment200ResponseBody
  | ReactionsListForIssueComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReactionsListForIssueCommentHandler {
  reactionsListForIssueComment(
    req: ReactionsListForIssueCommentRequest,
    res: ReactionsListForIssueCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsCreateForIssueCommentRequest = Request<
  ReactionsCreateForIssueCommentRequestPath,
  | ReactionsCreateForIssueComment200ResponseBody
  | ReactionsCreateForIssueComment201ResponseBody
  | ReactionsCreateForIssueComment422ResponseBody,
  ReactionsCreateForIssueCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForIssueCommentResponse = Response<
  | ReactionsCreateForIssueComment200ResponseBody
  | ReactionsCreateForIssueComment201ResponseBody
  | ReactionsCreateForIssueComment422ResponseBody,
  Record<string, any>,
  200 | 201 | 422
>;

export interface ReactionsCreateForIssueCommentHandler {
  reactionsCreateForIssueComment(
    req: ReactionsCreateForIssueCommentRequest,
    res: ReactionsCreateForIssueCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsDeleteForIssueCommentRequest = Request<
  ReactionsDeleteForIssueCommentRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForIssueCommentResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReactionsDeleteForIssueCommentHandler {
  reactionsDeleteForIssueComment(
    req: ReactionsDeleteForIssueCommentRequest,
    res: ReactionsDeleteForIssueCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListEventsForRepoRequest = Request<
  IssuesListEventsForRepoRequestPath,
  | IssuesListEventsForRepo200ResponseBody
  | IssuesListEventsForRepo422ResponseBody,
  unknown,
  IssuesListEventsForRepoRequestQuery,
  Record<string, any>
>;

export type IssuesListEventsForRepoResponse = Response<
  | IssuesListEventsForRepo200ResponseBody
  | IssuesListEventsForRepo422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface IssuesListEventsForRepoHandler {
  issuesListEventsForRepo(
    req: IssuesListEventsForRepoRequest,
    res: IssuesListEventsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesGetEventRequest = Request<
  IssuesGetEventRequestPath,
  | IssuesGetEvent200ResponseBody
  | IssuesGetEvent403ResponseBody
  | IssuesGetEvent404ResponseBody
  | IssuesGetEvent410ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesGetEventResponse = Response<
  | IssuesGetEvent200ResponseBody
  | IssuesGetEvent403ResponseBody
  | IssuesGetEvent404ResponseBody
  | IssuesGetEvent410ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 410
>;

export interface IssuesGetEventHandler {
  issuesGetEvent(
    req: IssuesGetEventRequest,
    res: IssuesGetEventResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesGetRequest = Request<
  IssuesGetRequestPath,
  | IssuesGet200ResponseBody
  | IssuesGet301ResponseBody
  | IssuesGet404ResponseBody
  | IssuesGet410ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesGetResponse = Response<
  | IssuesGet200ResponseBody
  | IssuesGet301ResponseBody
  | IssuesGet404ResponseBody
  | IssuesGet410ResponseBody,
  Record<string, any>,
  200 | 301 | 304 | 404 | 410
>;

export interface IssuesGetHandler {
  issuesGet(
    req: IssuesGetRequest,
    res: IssuesGetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesUpdateRequest = Request<
  IssuesUpdateRequestPath,
  | IssuesUpdate200ResponseBody
  | IssuesUpdate301ResponseBody
  | IssuesUpdate403ResponseBody
  | IssuesUpdate404ResponseBody
  | IssuesUpdate410ResponseBody
  | IssuesUpdate422ResponseBody
  | IssuesUpdate503ResponseBody,
  IssuesUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesUpdateResponse = Response<
  | IssuesUpdate200ResponseBody
  | IssuesUpdate301ResponseBody
  | IssuesUpdate403ResponseBody
  | IssuesUpdate404ResponseBody
  | IssuesUpdate410ResponseBody
  | IssuesUpdate422ResponseBody
  | IssuesUpdate503ResponseBody,
  Record<string, any>,
  200 | 301 | 403 | 404 | 410 | 422 | 503
>;

export interface IssuesUpdateHandler {
  issuesUpdate(
    req: IssuesUpdateRequest,
    res: IssuesUpdateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesAddAssigneesRequest = Request<
  IssuesAddAssigneesRequestPath,
  IssuesAddAssignees201ResponseBody,
  IssuesAddAssigneesRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesAddAssigneesResponse = Response<
  IssuesAddAssignees201ResponseBody,
  Record<string, any>,
  201
>;

export interface IssuesAddAssigneesHandler {
  issuesAddAssignees(
    req: IssuesAddAssigneesRequest,
    res: IssuesAddAssigneesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesRemoveAssigneesRequest = Request<
  IssuesRemoveAssigneesRequestPath,
  IssuesRemoveAssignees200ResponseBody,
  IssuesRemoveAssigneesRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesRemoveAssigneesResponse = Response<
  IssuesRemoveAssignees200ResponseBody,
  Record<string, any>,
  200
>;

export interface IssuesRemoveAssigneesHandler {
  issuesRemoveAssignees(
    req: IssuesRemoveAssigneesRequest,
    res: IssuesRemoveAssigneesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListCommentsRequest = Request<
  IssuesListCommentsRequestPath,
  | IssuesListComments200ResponseBody
  | IssuesListComments404ResponseBody
  | IssuesListComments410ResponseBody,
  unknown,
  IssuesListCommentsRequestQuery,
  Record<string, any>
>;

export type IssuesListCommentsResponse = Response<
  | IssuesListComments200ResponseBody
  | IssuesListComments404ResponseBody
  | IssuesListComments410ResponseBody,
  Record<string, any>,
  200 | 404 | 410
>;

export interface IssuesListCommentsHandler {
  issuesListComments(
    req: IssuesListCommentsRequest,
    res: IssuesListCommentsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesCreateCommentRequest = Request<
  IssuesCreateCommentRequestPath,
  | IssuesCreateComment201ResponseBody
  | IssuesCreateComment403ResponseBody
  | IssuesCreateComment404ResponseBody
  | IssuesCreateComment410ResponseBody
  | IssuesCreateComment422ResponseBody,
  IssuesCreateCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesCreateCommentResponse = Response<
  | IssuesCreateComment201ResponseBody
  | IssuesCreateComment403ResponseBody
  | IssuesCreateComment404ResponseBody
  | IssuesCreateComment410ResponseBody
  | IssuesCreateComment422ResponseBody,
  Record<string, any>,
  201 | 403 | 404 | 410 | 422
>;

export interface IssuesCreateCommentHandler {
  issuesCreateComment(
    req: IssuesCreateCommentRequest,
    res: IssuesCreateCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListEventsRequest = Request<
  IssuesListEventsRequestPath,
  IssuesListEvents200ResponseBody | IssuesListEvents410ResponseBody,
  unknown,
  IssuesListEventsRequestQuery,
  Record<string, any>
>;

export type IssuesListEventsResponse = Response<
  IssuesListEvents200ResponseBody | IssuesListEvents410ResponseBody,
  Record<string, any>,
  200 | 410
>;

export interface IssuesListEventsHandler {
  issuesListEvents(
    req: IssuesListEventsRequest,
    res: IssuesListEventsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListLabelsOnIssueRequest = Request<
  IssuesListLabelsOnIssueRequestPath,
  | IssuesListLabelsOnIssue200ResponseBody
  | IssuesListLabelsOnIssue301ResponseBody
  | IssuesListLabelsOnIssue404ResponseBody
  | IssuesListLabelsOnIssue410ResponseBody,
  unknown,
  IssuesListLabelsOnIssueRequestQuery,
  Record<string, any>
>;

export type IssuesListLabelsOnIssueResponse = Response<
  | IssuesListLabelsOnIssue200ResponseBody
  | IssuesListLabelsOnIssue301ResponseBody
  | IssuesListLabelsOnIssue404ResponseBody
  | IssuesListLabelsOnIssue410ResponseBody,
  Record<string, any>,
  200 | 301 | 404 | 410
>;

export interface IssuesListLabelsOnIssueHandler {
  issuesListLabelsOnIssue(
    req: IssuesListLabelsOnIssueRequest,
    res: IssuesListLabelsOnIssueResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesAddLabelsRequest = Request<
  IssuesAddLabelsRequestPath,
  | IssuesAddLabels200ResponseBody
  | IssuesAddLabels301ResponseBody
  | IssuesAddLabels404ResponseBody
  | IssuesAddLabels410ResponseBody
  | IssuesAddLabels422ResponseBody,
  IssuesAddLabelsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesAddLabelsResponse = Response<
  | IssuesAddLabels200ResponseBody
  | IssuesAddLabels301ResponseBody
  | IssuesAddLabels404ResponseBody
  | IssuesAddLabels410ResponseBody
  | IssuesAddLabels422ResponseBody,
  Record<string, any>,
  200 | 301 | 404 | 410 | 422
>;

export interface IssuesAddLabelsHandler {
  issuesAddLabels(
    req: IssuesAddLabelsRequest,
    res: IssuesAddLabelsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesSetLabelsRequest = Request<
  IssuesSetLabelsRequestPath,
  | IssuesSetLabels200ResponseBody
  | IssuesSetLabels301ResponseBody
  | IssuesSetLabels404ResponseBody
  | IssuesSetLabels410ResponseBody
  | IssuesSetLabels422ResponseBody,
  IssuesSetLabelsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesSetLabelsResponse = Response<
  | IssuesSetLabels200ResponseBody
  | IssuesSetLabels301ResponseBody
  | IssuesSetLabels404ResponseBody
  | IssuesSetLabels410ResponseBody
  | IssuesSetLabels422ResponseBody,
  Record<string, any>,
  200 | 301 | 404 | 410 | 422
>;

export interface IssuesSetLabelsHandler {
  issuesSetLabels(
    req: IssuesSetLabelsRequest,
    res: IssuesSetLabelsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesRemoveAllLabelsRequest = Request<
  IssuesRemoveAllLabelsRequestPath,
  | IssuesRemoveAllLabels301ResponseBody
  | IssuesRemoveAllLabels404ResponseBody
  | IssuesRemoveAllLabels410ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesRemoveAllLabelsResponse = Response<
  | IssuesRemoveAllLabels301ResponseBody
  | IssuesRemoveAllLabels404ResponseBody
  | IssuesRemoveAllLabels410ResponseBody,
  Record<string, any>,
  204 | 301 | 404 | 410
>;

export interface IssuesRemoveAllLabelsHandler {
  issuesRemoveAllLabels(
    req: IssuesRemoveAllLabelsRequest,
    res: IssuesRemoveAllLabelsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesRemoveLabelRequest = Request<
  IssuesRemoveLabelRequestPath,
  | IssuesRemoveLabel200ResponseBody
  | IssuesRemoveLabel301ResponseBody
  | IssuesRemoveLabel404ResponseBody
  | IssuesRemoveLabel410ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesRemoveLabelResponse = Response<
  | IssuesRemoveLabel200ResponseBody
  | IssuesRemoveLabel301ResponseBody
  | IssuesRemoveLabel404ResponseBody
  | IssuesRemoveLabel410ResponseBody,
  Record<string, any>,
  200 | 301 | 404 | 410
>;

export interface IssuesRemoveLabelHandler {
  issuesRemoveLabel(
    req: IssuesRemoveLabelRequest,
    res: IssuesRemoveLabelResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesLockRequest = Request<
  IssuesLockRequestPath,
  | IssuesLock403ResponseBody
  | IssuesLock404ResponseBody
  | IssuesLock410ResponseBody
  | IssuesLock422ResponseBody,
  IssuesLockRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesLockResponse = Response<
  | IssuesLock403ResponseBody
  | IssuesLock404ResponseBody
  | IssuesLock410ResponseBody
  | IssuesLock422ResponseBody,
  Record<string, any>,
  204 | 403 | 404 | 410 | 422
>;

export interface IssuesLockHandler {
  issuesLock(
    req: IssuesLockRequest,
    res: IssuesLockResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesUnlockRequest = Request<
  IssuesUnlockRequestPath,
  IssuesUnlock403ResponseBody | IssuesUnlock404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesUnlockResponse = Response<
  IssuesUnlock403ResponseBody | IssuesUnlock404ResponseBody,
  Record<string, any>,
  204 | 403 | 404
>;

export interface IssuesUnlockHandler {
  issuesUnlock(
    req: IssuesUnlockRequest,
    res: IssuesUnlockResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsListForIssueRequest = Request<
  ReactionsListForIssueRequestPath,
  | ReactionsListForIssue200ResponseBody
  | ReactionsListForIssue404ResponseBody
  | ReactionsListForIssue410ResponseBody,
  unknown,
  ReactionsListForIssueRequestQuery,
  Record<string, any>
>;

export type ReactionsListForIssueResponse = Response<
  | ReactionsListForIssue200ResponseBody
  | ReactionsListForIssue404ResponseBody
  | ReactionsListForIssue410ResponseBody,
  Record<string, any>,
  200 | 404 | 410
>;

export interface ReactionsListForIssueHandler {
  reactionsListForIssue(
    req: ReactionsListForIssueRequest,
    res: ReactionsListForIssueResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsCreateForIssueRequest = Request<
  ReactionsCreateForIssueRequestPath,
  | ReactionsCreateForIssue200ResponseBody
  | ReactionsCreateForIssue201ResponseBody
  | ReactionsCreateForIssue422ResponseBody,
  ReactionsCreateForIssueRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForIssueResponse = Response<
  | ReactionsCreateForIssue200ResponseBody
  | ReactionsCreateForIssue201ResponseBody
  | ReactionsCreateForIssue422ResponseBody,
  Record<string, any>,
  200 | 201 | 422
>;

export interface ReactionsCreateForIssueHandler {
  reactionsCreateForIssue(
    req: ReactionsCreateForIssueRequest,
    res: ReactionsCreateForIssueResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsDeleteForIssueRequest = Request<
  ReactionsDeleteForIssueRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForIssueResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReactionsDeleteForIssueHandler {
  reactionsDeleteForIssue(
    req: ReactionsDeleteForIssueRequest,
    res: ReactionsDeleteForIssueResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListEventsForTimelineRequest = Request<
  IssuesListEventsForTimelineRequestPath,
  | IssuesListEventsForTimeline200ResponseBody
  | IssuesListEventsForTimeline404ResponseBody
  | IssuesListEventsForTimeline410ResponseBody,
  unknown,
  IssuesListEventsForTimelineRequestQuery,
  Record<string, any>
>;

export type IssuesListEventsForTimelineResponse = Response<
  | IssuesListEventsForTimeline200ResponseBody
  | IssuesListEventsForTimeline404ResponseBody
  | IssuesListEventsForTimeline410ResponseBody,
  Record<string, any>,
  200 | 404 | 410
>;

export interface IssuesListEventsForTimelineHandler {
  issuesListEventsForTimeline(
    req: IssuesListEventsForTimelineRequest,
    res: IssuesListEventsForTimelineResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListDeployKeysRequest = Request<
  ReposListDeployKeysRequestPath,
  ReposListDeployKeys200ResponseBody,
  unknown,
  ReposListDeployKeysRequestQuery,
  Record<string, any>
>;

export type ReposListDeployKeysResponse = Response<
  ReposListDeployKeys200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListDeployKeysHandler {
  reposListDeployKeys(
    req: ReposListDeployKeysRequest,
    res: ReposListDeployKeysResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateDeployKeyRequest = Request<
  ReposCreateDeployKeyRequestPath,
  ReposCreateDeployKey201ResponseBody | ReposCreateDeployKey422ResponseBody,
  ReposCreateDeployKeyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateDeployKeyResponse = Response<
  ReposCreateDeployKey201ResponseBody | ReposCreateDeployKey422ResponseBody,
  Record<string, any>,
  201 | 422
>;

export interface ReposCreateDeployKeyHandler {
  reposCreateDeployKey(
    req: ReposCreateDeployKeyRequest,
    res: ReposCreateDeployKeyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetDeployKeyRequest = Request<
  ReposGetDeployKeyRequestPath,
  ReposGetDeployKey200ResponseBody | ReposGetDeployKey404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetDeployKeyResponse = Response<
  ReposGetDeployKey200ResponseBody | ReposGetDeployKey404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetDeployKeyHandler {
  reposGetDeployKey(
    req: ReposGetDeployKeyRequest,
    res: ReposGetDeployKeyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteDeployKeyRequest = Request<
  ReposDeleteDeployKeyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteDeployKeyResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposDeleteDeployKeyHandler {
  reposDeleteDeployKey(
    req: ReposDeleteDeployKeyRequest,
    res: ReposDeleteDeployKeyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListLabelsForRepoRequest = Request<
  IssuesListLabelsForRepoRequestPath,
  | IssuesListLabelsForRepo200ResponseBody
  | IssuesListLabelsForRepo404ResponseBody,
  unknown,
  IssuesListLabelsForRepoRequestQuery,
  Record<string, any>
>;

export type IssuesListLabelsForRepoResponse = Response<
  | IssuesListLabelsForRepo200ResponseBody
  | IssuesListLabelsForRepo404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface IssuesListLabelsForRepoHandler {
  issuesListLabelsForRepo(
    req: IssuesListLabelsForRepoRequest,
    res: IssuesListLabelsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesCreateLabelRequest = Request<
  IssuesCreateLabelRequestPath,
  | IssuesCreateLabel201ResponseBody
  | IssuesCreateLabel404ResponseBody
  | IssuesCreateLabel422ResponseBody,
  IssuesCreateLabelRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesCreateLabelResponse = Response<
  | IssuesCreateLabel201ResponseBody
  | IssuesCreateLabel404ResponseBody
  | IssuesCreateLabel422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export interface IssuesCreateLabelHandler {
  issuesCreateLabel(
    req: IssuesCreateLabelRequest,
    res: IssuesCreateLabelResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesGetLabelRequest = Request<
  IssuesGetLabelRequestPath,
  IssuesGetLabel200ResponseBody | IssuesGetLabel404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesGetLabelResponse = Response<
  IssuesGetLabel200ResponseBody | IssuesGetLabel404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface IssuesGetLabelHandler {
  issuesGetLabel(
    req: IssuesGetLabelRequest,
    res: IssuesGetLabelResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesUpdateLabelRequest = Request<
  IssuesUpdateLabelRequestPath,
  IssuesUpdateLabel200ResponseBody,
  IssuesUpdateLabelRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesUpdateLabelResponse = Response<
  IssuesUpdateLabel200ResponseBody,
  Record<string, any>,
  200
>;

export interface IssuesUpdateLabelHandler {
  issuesUpdateLabel(
    req: IssuesUpdateLabelRequest,
    res: IssuesUpdateLabelResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesDeleteLabelRequest = Request<
  IssuesDeleteLabelRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesDeleteLabelResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface IssuesDeleteLabelHandler {
  issuesDeleteLabel(
    req: IssuesDeleteLabelRequest,
    res: IssuesDeleteLabelResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListLanguagesRequest = Request<
  ReposListLanguagesRequestPath,
  ReposListLanguages200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposListLanguagesResponse = Response<
  ReposListLanguages200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListLanguagesHandler {
  reposListLanguages(
    req: ReposListLanguagesRequest,
    res: ReposListLanguagesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposEnableLfsForRepoRequest = Request<
  ReposEnableLfsForRepoRequestPath,
  ReposEnableLfsForRepo202ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposEnableLfsForRepoResponse = Response<
  ReposEnableLfsForRepo202ResponseBody,
  Record<string, any>,
  202 | 403
>;

export interface ReposEnableLfsForRepoHandler {
  reposEnableLfsForRepo(
    req: ReposEnableLfsForRepoRequest,
    res: ReposEnableLfsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDisableLfsForRepoRequest = Request<
  ReposDisableLfsForRepoRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDisableLfsForRepoResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposDisableLfsForRepoHandler {
  reposDisableLfsForRepo(
    req: ReposDisableLfsForRepoRequest,
    res: ReposDisableLfsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type LicensesGetForRepoRequest = Request<
  LicensesGetForRepoRequestPath,
  LicensesGetForRepo200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type LicensesGetForRepoResponse = Response<
  LicensesGetForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export interface LicensesGetForRepoHandler {
  licensesGetForRepo(
    req: LicensesGetForRepoRequest,
    res: LicensesGetForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposMergeUpstreamRequest = Request<
  ReposMergeUpstreamRequestPath,
  ReposMergeUpstream200ResponseBody,
  ReposMergeUpstreamRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposMergeUpstreamResponse = Response<
  ReposMergeUpstream200ResponseBody,
  Record<string, any>,
  200 | 409 | 422
>;

export interface ReposMergeUpstreamHandler {
  reposMergeUpstream(
    req: ReposMergeUpstreamRequest,
    res: ReposMergeUpstreamResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposMergeRequest = Request<
  ReposMergeRequestPath,
  | ReposMerge201ResponseBody
  | ReposMerge403ResponseBody
  | ReposMerge422ResponseBody,
  ReposMergeRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposMergeResponse = Response<
  | ReposMerge201ResponseBody
  | ReposMerge403ResponseBody
  | ReposMerge422ResponseBody,
  Record<string, any>,
  201 | 204 | 403 | 404 | 409 | 422
>;

export interface ReposMergeHandler {
  reposMerge(
    req: ReposMergeRequest,
    res: ReposMergeResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListMilestonesRequest = Request<
  IssuesListMilestonesRequestPath,
  IssuesListMilestones200ResponseBody | IssuesListMilestones404ResponseBody,
  unknown,
  IssuesListMilestonesRequestQuery,
  Record<string, any>
>;

export type IssuesListMilestonesResponse = Response<
  IssuesListMilestones200ResponseBody | IssuesListMilestones404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface IssuesListMilestonesHandler {
  issuesListMilestones(
    req: IssuesListMilestonesRequest,
    res: IssuesListMilestonesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesCreateMilestoneRequest = Request<
  IssuesCreateMilestoneRequestPath,
  | IssuesCreateMilestone201ResponseBody
  | IssuesCreateMilestone404ResponseBody
  | IssuesCreateMilestone422ResponseBody,
  IssuesCreateMilestoneRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesCreateMilestoneResponse = Response<
  | IssuesCreateMilestone201ResponseBody
  | IssuesCreateMilestone404ResponseBody
  | IssuesCreateMilestone422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export interface IssuesCreateMilestoneHandler {
  issuesCreateMilestone(
    req: IssuesCreateMilestoneRequest,
    res: IssuesCreateMilestoneResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesGetMilestoneRequest = Request<
  IssuesGetMilestoneRequestPath,
  IssuesGetMilestone200ResponseBody | IssuesGetMilestone404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesGetMilestoneResponse = Response<
  IssuesGetMilestone200ResponseBody | IssuesGetMilestone404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface IssuesGetMilestoneHandler {
  issuesGetMilestone(
    req: IssuesGetMilestoneRequest,
    res: IssuesGetMilestoneResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesUpdateMilestoneRequest = Request<
  IssuesUpdateMilestoneRequestPath,
  IssuesUpdateMilestone200ResponseBody,
  IssuesUpdateMilestoneRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type IssuesUpdateMilestoneResponse = Response<
  IssuesUpdateMilestone200ResponseBody,
  Record<string, any>,
  200
>;

export interface IssuesUpdateMilestoneHandler {
  issuesUpdateMilestone(
    req: IssuesUpdateMilestoneRequest,
    res: IssuesUpdateMilestoneResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesDeleteMilestoneRequest = Request<
  IssuesDeleteMilestoneRequestPath,
  IssuesDeleteMilestone404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type IssuesDeleteMilestoneResponse = Response<
  IssuesDeleteMilestone404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface IssuesDeleteMilestoneHandler {
  issuesDeleteMilestone(
    req: IssuesDeleteMilestoneRequest,
    res: IssuesDeleteMilestoneResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListLabelsForMilestoneRequest = Request<
  IssuesListLabelsForMilestoneRequestPath,
  IssuesListLabelsForMilestone200ResponseBody,
  unknown,
  IssuesListLabelsForMilestoneRequestQuery,
  Record<string, any>
>;

export type IssuesListLabelsForMilestoneResponse = Response<
  IssuesListLabelsForMilestone200ResponseBody,
  Record<string, any>,
  200
>;

export interface IssuesListLabelsForMilestoneHandler {
  issuesListLabelsForMilestone(
    req: IssuesListLabelsForMilestoneRequest,
    res: IssuesListLabelsForMilestoneResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListRepoNotificationsForAuthenticatedUserRequest = Request<
  ActivityListRepoNotificationsForAuthenticatedUserRequestPath,
  ActivityListRepoNotificationsForAuthenticatedUser200ResponseBody,
  unknown,
  ActivityListRepoNotificationsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ActivityListRepoNotificationsForAuthenticatedUserResponse = Response<
  ActivityListRepoNotificationsForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActivityListRepoNotificationsForAuthenticatedUserHandler {
  activityListRepoNotificationsForAuthenticatedUser(
    req: ActivityListRepoNotificationsForAuthenticatedUserRequest,
    res: ActivityListRepoNotificationsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityMarkRepoNotificationsAsReadRequest = Request<
  ActivityMarkRepoNotificationsAsReadRequestPath,
  ActivityMarkRepoNotificationsAsRead202ResponseBody,
  ActivityMarkRepoNotificationsAsReadRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActivityMarkRepoNotificationsAsReadResponse = Response<
  ActivityMarkRepoNotificationsAsRead202ResponseBody,
  Record<string, any>,
  202 | 205
>;

export interface ActivityMarkRepoNotificationsAsReadHandler {
  activityMarkRepoNotificationsAsRead(
    req: ActivityMarkRepoNotificationsAsReadRequest,
    res: ActivityMarkRepoNotificationsAsReadResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetPagesRequest = Request<
  ReposGetPagesRequestPath,
  ReposGetPages200ResponseBody | ReposGetPages404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetPagesResponse = Response<
  ReposGetPages200ResponseBody | ReposGetPages404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetPagesHandler {
  reposGetPages(
    req: ReposGetPagesRequest,
    res: ReposGetPagesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreatePagesSiteRequest = Request<
  ReposCreatePagesSiteRequestPath,
  | ReposCreatePagesSite201ResponseBody
  | ReposCreatePagesSite409ResponseBody
  | ReposCreatePagesSite422ResponseBody,
  ReposCreatePagesSiteRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreatePagesSiteResponse = Response<
  | ReposCreatePagesSite201ResponseBody
  | ReposCreatePagesSite409ResponseBody
  | ReposCreatePagesSite422ResponseBody,
  Record<string, any>,
  201 | 409 | 422
>;

export interface ReposCreatePagesSiteHandler {
  reposCreatePagesSite(
    req: ReposCreatePagesSiteRequest,
    res: ReposCreatePagesSiteResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposUpdateInformationAboutPagesSiteRequest = Request<
  ReposUpdateInformationAboutPagesSiteRequestPath,
  | ReposUpdateInformationAboutPagesSite400ResponseBody
  | ReposUpdateInformationAboutPagesSite409ResponseBody
  | ReposUpdateInformationAboutPagesSite422ResponseBody,
  ReposUpdateInformationAboutPagesSiteRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateInformationAboutPagesSiteResponse = Response<
  | ReposUpdateInformationAboutPagesSite400ResponseBody
  | ReposUpdateInformationAboutPagesSite409ResponseBody
  | ReposUpdateInformationAboutPagesSite422ResponseBody,
  Record<string, any>,
  204 | 400 | 409 | 422
>;

export interface ReposUpdateInformationAboutPagesSiteHandler {
  reposUpdateInformationAboutPagesSite(
    req: ReposUpdateInformationAboutPagesSiteRequest,
    res: ReposUpdateInformationAboutPagesSiteResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeletePagesSiteRequest = Request<
  ReposDeletePagesSiteRequestPath,
  | ReposDeletePagesSite404ResponseBody
  | ReposDeletePagesSite409ResponseBody
  | ReposDeletePagesSite422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeletePagesSiteResponse = Response<
  | ReposDeletePagesSite404ResponseBody
  | ReposDeletePagesSite409ResponseBody
  | ReposDeletePagesSite422ResponseBody,
  Record<string, any>,
  204 | 404 | 409 | 422
>;

export interface ReposDeletePagesSiteHandler {
  reposDeletePagesSite(
    req: ReposDeletePagesSiteRequest,
    res: ReposDeletePagesSiteResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListPagesBuildsRequest = Request<
  ReposListPagesBuildsRequestPath,
  ReposListPagesBuilds200ResponseBody,
  unknown,
  ReposListPagesBuildsRequestQuery,
  Record<string, any>
>;

export type ReposListPagesBuildsResponse = Response<
  ReposListPagesBuilds200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListPagesBuildsHandler {
  reposListPagesBuilds(
    req: ReposListPagesBuildsRequest,
    res: ReposListPagesBuildsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposRequestPagesBuildRequest = Request<
  ReposRequestPagesBuildRequestPath,
  ReposRequestPagesBuild201ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposRequestPagesBuildResponse = Response<
  ReposRequestPagesBuild201ResponseBody,
  Record<string, any>,
  201
>;

export interface ReposRequestPagesBuildHandler {
  reposRequestPagesBuild(
    req: ReposRequestPagesBuildRequest,
    res: ReposRequestPagesBuildResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetLatestPagesBuildRequest = Request<
  ReposGetLatestPagesBuildRequestPath,
  ReposGetLatestPagesBuild200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetLatestPagesBuildResponse = Response<
  ReposGetLatestPagesBuild200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposGetLatestPagesBuildHandler {
  reposGetLatestPagesBuild(
    req: ReposGetLatestPagesBuildRequest,
    res: ReposGetLatestPagesBuildResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetPagesBuildRequest = Request<
  ReposGetPagesBuildRequestPath,
  ReposGetPagesBuild200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetPagesBuildResponse = Response<
  ReposGetPagesBuild200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposGetPagesBuildHandler {
  reposGetPagesBuild(
    req: ReposGetPagesBuildRequest,
    res: ReposGetPagesBuildResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreatePagesDeploymentRequest = Request<
  ReposCreatePagesDeploymentRequestPath,
  | ReposCreatePagesDeployment200ResponseBody
  | ReposCreatePagesDeployment400ResponseBody
  | ReposCreatePagesDeployment404ResponseBody
  | ReposCreatePagesDeployment422ResponseBody,
  ReposCreatePagesDeploymentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreatePagesDeploymentResponse = Response<
  | ReposCreatePagesDeployment200ResponseBody
  | ReposCreatePagesDeployment400ResponseBody
  | ReposCreatePagesDeployment404ResponseBody
  | ReposCreatePagesDeployment422ResponseBody,
  Record<string, any>,
  200 | 400 | 404 | 422
>;

export interface ReposCreatePagesDeploymentHandler {
  reposCreatePagesDeployment(
    req: ReposCreatePagesDeploymentRequest,
    res: ReposCreatePagesDeploymentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetPagesHealthCheckRequest = Request<
  ReposGetPagesHealthCheckRequestPath,
  | ReposGetPagesHealthCheck200ResponseBody
  | ReposGetPagesHealthCheck202ResponseBody
  | ReposGetPagesHealthCheck404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetPagesHealthCheckResponse = Response<
  | ReposGetPagesHealthCheck200ResponseBody
  | ReposGetPagesHealthCheck202ResponseBody
  | ReposGetPagesHealthCheck404ResponseBody,
  Record<string, any>,
  200 | 202 | 400 | 404 | 422
>;

export interface ReposGetPagesHealthCheckHandler {
  reposGetPagesHealthCheck(
    req: ReposGetPagesHealthCheckRequest,
    res: ReposGetPagesHealthCheckResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsListForRepoRequest = Request<
  ProjectsListForRepoRequestPath,
  | ProjectsListForRepo200ResponseBody
  | ProjectsListForRepo401ResponseBody
  | ProjectsListForRepo403ResponseBody
  | ProjectsListForRepo404ResponseBody
  | ProjectsListForRepo410ResponseBody
  | ProjectsListForRepo422ResponseBody,
  unknown,
  ProjectsListForRepoRequestQuery,
  Record<string, any>
>;

export type ProjectsListForRepoResponse = Response<
  | ProjectsListForRepo200ResponseBody
  | ProjectsListForRepo401ResponseBody
  | ProjectsListForRepo403ResponseBody
  | ProjectsListForRepo404ResponseBody
  | ProjectsListForRepo410ResponseBody
  | ProjectsListForRepo422ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404 | 410 | 422
>;

export interface ProjectsListForRepoHandler {
  projectsListForRepo(
    req: ProjectsListForRepoRequest,
    res: ProjectsListForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsCreateForRepoRequest = Request<
  ProjectsCreateForRepoRequestPath,
  | ProjectsCreateForRepo201ResponseBody
  | ProjectsCreateForRepo401ResponseBody
  | ProjectsCreateForRepo403ResponseBody
  | ProjectsCreateForRepo404ResponseBody
  | ProjectsCreateForRepo410ResponseBody
  | ProjectsCreateForRepo422ResponseBody,
  ProjectsCreateForRepoRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsCreateForRepoResponse = Response<
  | ProjectsCreateForRepo201ResponseBody
  | ProjectsCreateForRepo401ResponseBody
  | ProjectsCreateForRepo403ResponseBody
  | ProjectsCreateForRepo404ResponseBody
  | ProjectsCreateForRepo410ResponseBody
  | ProjectsCreateForRepo422ResponseBody,
  Record<string, any>,
  201 | 401 | 403 | 404 | 410 | 422
>;

export interface ProjectsCreateForRepoHandler {
  projectsCreateForRepo(
    req: ProjectsCreateForRepoRequest,
    res: ProjectsCreateForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsListRequest = Request<
  PullsListRequestPath,
  PullsList200ResponseBody | PullsList422ResponseBody,
  unknown,
  PullsListRequestQuery,
  Record<string, any>
>;

export type PullsListResponse = Response<
  PullsList200ResponseBody | PullsList422ResponseBody,
  Record<string, any>,
  200 | 304 | 422
>;

export interface PullsListHandler {
  pullsList(
    req: PullsListRequest,
    res: PullsListResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsCreateRequest = Request<
  PullsCreateRequestPath,
  | PullsCreate201ResponseBody
  | PullsCreate403ResponseBody
  | PullsCreate422ResponseBody,
  PullsCreateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsCreateResponse = Response<
  | PullsCreate201ResponseBody
  | PullsCreate403ResponseBody
  | PullsCreate422ResponseBody,
  Record<string, any>,
  201 | 403 | 422
>;

export interface PullsCreateHandler {
  pullsCreate(
    req: PullsCreateRequest,
    res: PullsCreateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsListReviewCommentsForRepoRequest = Request<
  PullsListReviewCommentsForRepoRequestPath,
  PullsListReviewCommentsForRepo200ResponseBody,
  unknown,
  PullsListReviewCommentsForRepoRequestQuery,
  Record<string, any>
>;

export type PullsListReviewCommentsForRepoResponse = Response<
  PullsListReviewCommentsForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export interface PullsListReviewCommentsForRepoHandler {
  pullsListReviewCommentsForRepo(
    req: PullsListReviewCommentsForRepoRequest,
    res: PullsListReviewCommentsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsGetReviewCommentRequest = Request<
  PullsGetReviewCommentRequestPath,
  PullsGetReviewComment200ResponseBody | PullsGetReviewComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsGetReviewCommentResponse = Response<
  PullsGetReviewComment200ResponseBody | PullsGetReviewComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface PullsGetReviewCommentHandler {
  pullsGetReviewComment(
    req: PullsGetReviewCommentRequest,
    res: PullsGetReviewCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsUpdateReviewCommentRequest = Request<
  PullsUpdateReviewCommentRequestPath,
  PullsUpdateReviewComment200ResponseBody,
  PullsUpdateReviewCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsUpdateReviewCommentResponse = Response<
  PullsUpdateReviewComment200ResponseBody,
  Record<string, any>,
  200
>;

export interface PullsUpdateReviewCommentHandler {
  pullsUpdateReviewComment(
    req: PullsUpdateReviewCommentRequest,
    res: PullsUpdateReviewCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsDeleteReviewCommentRequest = Request<
  PullsDeleteReviewCommentRequestPath,
  PullsDeleteReviewComment404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsDeleteReviewCommentResponse = Response<
  PullsDeleteReviewComment404ResponseBody,
  Record<string, any>,
  204 | 404
>;

export interface PullsDeleteReviewCommentHandler {
  pullsDeleteReviewComment(
    req: PullsDeleteReviewCommentRequest,
    res: PullsDeleteReviewCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsListForPullRequestReviewCommentRequest = Request<
  ReactionsListForPullRequestReviewCommentRequestPath,
  | ReactionsListForPullRequestReviewComment200ResponseBody
  | ReactionsListForPullRequestReviewComment404ResponseBody,
  unknown,
  ReactionsListForPullRequestReviewCommentRequestQuery,
  Record<string, any>
>;

export type ReactionsListForPullRequestReviewCommentResponse = Response<
  | ReactionsListForPullRequestReviewComment200ResponseBody
  | ReactionsListForPullRequestReviewComment404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReactionsListForPullRequestReviewCommentHandler {
  reactionsListForPullRequestReviewComment(
    req: ReactionsListForPullRequestReviewCommentRequest,
    res: ReactionsListForPullRequestReviewCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsCreateForPullRequestReviewCommentRequest = Request<
  ReactionsCreateForPullRequestReviewCommentRequestPath,
  | ReactionsCreateForPullRequestReviewComment200ResponseBody
  | ReactionsCreateForPullRequestReviewComment201ResponseBody
  | ReactionsCreateForPullRequestReviewComment422ResponseBody,
  ReactionsCreateForPullRequestReviewCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForPullRequestReviewCommentResponse = Response<
  | ReactionsCreateForPullRequestReviewComment200ResponseBody
  | ReactionsCreateForPullRequestReviewComment201ResponseBody
  | ReactionsCreateForPullRequestReviewComment422ResponseBody,
  Record<string, any>,
  200 | 201 | 422
>;

export interface ReactionsCreateForPullRequestReviewCommentHandler {
  reactionsCreateForPullRequestReviewComment(
    req: ReactionsCreateForPullRequestReviewCommentRequest,
    res: ReactionsCreateForPullRequestReviewCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsDeleteForPullRequestCommentRequest = Request<
  ReactionsDeleteForPullRequestCommentRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForPullRequestCommentResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReactionsDeleteForPullRequestCommentHandler {
  reactionsDeleteForPullRequestComment(
    req: ReactionsDeleteForPullRequestCommentRequest,
    res: ReactionsDeleteForPullRequestCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsGetRequest = Request<
  PullsGetRequestPath,
  | PullsGet200ResponseBody
  | PullsGet404ResponseBody
  | PullsGet500ResponseBody
  | PullsGet503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsGetResponse = Response<
  | PullsGet200ResponseBody
  | PullsGet404ResponseBody
  | PullsGet500ResponseBody
  | PullsGet503ResponseBody,
  Record<string, any>,
  200 | 304 | 404 | 500 | 503
>;

export interface PullsGetHandler {
  pullsGet(
    req: PullsGetRequest,
    res: PullsGetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsUpdateRequest = Request<
  PullsUpdateRequestPath,
  | PullsUpdate200ResponseBody
  | PullsUpdate403ResponseBody
  | PullsUpdate422ResponseBody,
  PullsUpdateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsUpdateResponse = Response<
  | PullsUpdate200ResponseBody
  | PullsUpdate403ResponseBody
  | PullsUpdate422ResponseBody,
  Record<string, any>,
  200 | 403 | 422
>;

export interface PullsUpdateHandler {
  pullsUpdate(
    req: PullsUpdateRequest,
    res: PullsUpdateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesCreateWithPrForAuthenticatedUserRequest = Request<
  CodespacesCreateWithPrForAuthenticatedUserRequestPath,
  | CodespacesCreateWithPrForAuthenticatedUser201ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser202ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser401ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser403ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser404ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser503ResponseBody,
  CodespacesCreateWithPrForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCreateWithPrForAuthenticatedUserResponse = Response<
  | CodespacesCreateWithPrForAuthenticatedUser201ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser202ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser401ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser403ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser404ResponseBody
  | CodespacesCreateWithPrForAuthenticatedUser503ResponseBody,
  Record<string, any>,
  201 | 202 | 401 | 403 | 404 | 503
>;

export interface CodespacesCreateWithPrForAuthenticatedUserHandler {
  codespacesCreateWithPrForAuthenticatedUser(
    req: CodespacesCreateWithPrForAuthenticatedUserRequest,
    res: CodespacesCreateWithPrForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsListReviewCommentsRequest = Request<
  PullsListReviewCommentsRequestPath,
  PullsListReviewComments200ResponseBody,
  unknown,
  PullsListReviewCommentsRequestQuery,
  Record<string, any>
>;

export type PullsListReviewCommentsResponse = Response<
  PullsListReviewComments200ResponseBody,
  Record<string, any>,
  200
>;

export interface PullsListReviewCommentsHandler {
  pullsListReviewComments(
    req: PullsListReviewCommentsRequest,
    res: PullsListReviewCommentsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsCreateReviewCommentRequest = Request<
  PullsCreateReviewCommentRequestPath,
  | PullsCreateReviewComment201ResponseBody
  | PullsCreateReviewComment403ResponseBody
  | PullsCreateReviewComment422ResponseBody,
  PullsCreateReviewCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsCreateReviewCommentResponse = Response<
  | PullsCreateReviewComment201ResponseBody
  | PullsCreateReviewComment403ResponseBody
  | PullsCreateReviewComment422ResponseBody,
  Record<string, any>,
  201 | 403 | 422
>;

export interface PullsCreateReviewCommentHandler {
  pullsCreateReviewComment(
    req: PullsCreateReviewCommentRequest,
    res: PullsCreateReviewCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsCreateReplyForReviewCommentRequest = Request<
  PullsCreateReplyForReviewCommentRequestPath,
  | PullsCreateReplyForReviewComment201ResponseBody
  | PullsCreateReplyForReviewComment404ResponseBody,
  PullsCreateReplyForReviewCommentRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsCreateReplyForReviewCommentResponse = Response<
  | PullsCreateReplyForReviewComment201ResponseBody
  | PullsCreateReplyForReviewComment404ResponseBody,
  Record<string, any>,
  201 | 404
>;

export interface PullsCreateReplyForReviewCommentHandler {
  pullsCreateReplyForReviewComment(
    req: PullsCreateReplyForReviewCommentRequest,
    res: PullsCreateReplyForReviewCommentResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsListCommitsRequest = Request<
  PullsListCommitsRequestPath,
  PullsListCommits200ResponseBody,
  unknown,
  PullsListCommitsRequestQuery,
  Record<string, any>
>;

export type PullsListCommitsResponse = Response<
  PullsListCommits200ResponseBody,
  Record<string, any>,
  200
>;

export interface PullsListCommitsHandler {
  pullsListCommits(
    req: PullsListCommitsRequest,
    res: PullsListCommitsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsListFilesRequest = Request<
  PullsListFilesRequestPath,
  | PullsListFiles200ResponseBody
  | PullsListFiles422ResponseBody
  | PullsListFiles500ResponseBody
  | PullsListFiles503ResponseBody,
  unknown,
  PullsListFilesRequestQuery,
  Record<string, any>
>;

export type PullsListFilesResponse = Response<
  | PullsListFiles200ResponseBody
  | PullsListFiles422ResponseBody
  | PullsListFiles500ResponseBody
  | PullsListFiles503ResponseBody,
  Record<string, any>,
  200 | 422 | 500 | 503
>;

export interface PullsListFilesHandler {
  pullsListFiles(
    req: PullsListFilesRequest,
    res: PullsListFilesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsCheckIfMergedRequest = Request<
  PullsCheckIfMergedRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsCheckIfMergedResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export interface PullsCheckIfMergedHandler {
  pullsCheckIfMerged(
    req: PullsCheckIfMergedRequest,
    res: PullsCheckIfMergedResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsMergeRequest = Request<
  PullsMergeRequestPath,
  | PullsMerge200ResponseBody
  | PullsMerge403ResponseBody
  | PullsMerge404ResponseBody
  | PullsMerge405ResponseBody
  | PullsMerge409ResponseBody
  | PullsMerge422ResponseBody,
  PullsMergeRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsMergeResponse = Response<
  | PullsMerge200ResponseBody
  | PullsMerge403ResponseBody
  | PullsMerge404ResponseBody
  | PullsMerge405ResponseBody
  | PullsMerge409ResponseBody
  | PullsMerge422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 405 | 409 | 422
>;

export interface PullsMergeHandler {
  pullsMerge(
    req: PullsMergeRequest,
    res: PullsMergeResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsListRequestedReviewersRequest = Request<
  PullsListRequestedReviewersRequestPath,
  PullsListRequestedReviewers200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsListRequestedReviewersResponse = Response<
  PullsListRequestedReviewers200ResponseBody,
  Record<string, any>,
  200
>;

export interface PullsListRequestedReviewersHandler {
  pullsListRequestedReviewers(
    req: PullsListRequestedReviewersRequest,
    res: PullsListRequestedReviewersResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsRequestReviewersRequest = Request<
  PullsRequestReviewersRequestPath,
  PullsRequestReviewers201ResponseBody | PullsRequestReviewers403ResponseBody,
  PullsRequestReviewersRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsRequestReviewersResponse = Response<
  PullsRequestReviewers201ResponseBody | PullsRequestReviewers403ResponseBody,
  Record<string, any>,
  201 | 403 | 422
>;

export interface PullsRequestReviewersHandler {
  pullsRequestReviewers(
    req: PullsRequestReviewersRequest,
    res: PullsRequestReviewersResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsRemoveRequestedReviewersRequest = Request<
  PullsRemoveRequestedReviewersRequestPath,
  | PullsRemoveRequestedReviewers200ResponseBody
  | PullsRemoveRequestedReviewers422ResponseBody,
  PullsRemoveRequestedReviewersRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsRemoveRequestedReviewersResponse = Response<
  | PullsRemoveRequestedReviewers200ResponseBody
  | PullsRemoveRequestedReviewers422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface PullsRemoveRequestedReviewersHandler {
  pullsRemoveRequestedReviewers(
    req: PullsRemoveRequestedReviewersRequest,
    res: PullsRemoveRequestedReviewersResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsListReviewsRequest = Request<
  PullsListReviewsRequestPath,
  PullsListReviews200ResponseBody,
  unknown,
  PullsListReviewsRequestQuery,
  Record<string, any>
>;

export type PullsListReviewsResponse = Response<
  PullsListReviews200ResponseBody,
  Record<string, any>,
  200
>;

export interface PullsListReviewsHandler {
  pullsListReviews(
    req: PullsListReviewsRequest,
    res: PullsListReviewsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsCreateReviewRequest = Request<
  PullsCreateReviewRequestPath,
  | PullsCreateReview200ResponseBody
  | PullsCreateReview403ResponseBody
  | PullsCreateReview422ResponseBody,
  PullsCreateReviewRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsCreateReviewResponse = Response<
  | PullsCreateReview200ResponseBody
  | PullsCreateReview403ResponseBody
  | PullsCreateReview422ResponseBody,
  Record<string, any>,
  200 | 403 | 422
>;

export interface PullsCreateReviewHandler {
  pullsCreateReview(
    req: PullsCreateReviewRequest,
    res: PullsCreateReviewResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsGetReviewRequest = Request<
  PullsGetReviewRequestPath,
  PullsGetReview200ResponseBody | PullsGetReview404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsGetReviewResponse = Response<
  PullsGetReview200ResponseBody | PullsGetReview404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface PullsGetReviewHandler {
  pullsGetReview(
    req: PullsGetReviewRequest,
    res: PullsGetReviewResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsUpdateReviewRequest = Request<
  PullsUpdateReviewRequestPath,
  PullsUpdateReview200ResponseBody | PullsUpdateReview422ResponseBody,
  PullsUpdateReviewRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsUpdateReviewResponse = Response<
  PullsUpdateReview200ResponseBody | PullsUpdateReview422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface PullsUpdateReviewHandler {
  pullsUpdateReview(
    req: PullsUpdateReviewRequest,
    res: PullsUpdateReviewResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsDeletePendingReviewRequest = Request<
  PullsDeletePendingReviewRequestPath,
  | PullsDeletePendingReview200ResponseBody
  | PullsDeletePendingReview404ResponseBody
  | PullsDeletePendingReview422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PullsDeletePendingReviewResponse = Response<
  | PullsDeletePendingReview200ResponseBody
  | PullsDeletePendingReview404ResponseBody
  | PullsDeletePendingReview422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface PullsDeletePendingReviewHandler {
  pullsDeletePendingReview(
    req: PullsDeletePendingReviewRequest,
    res: PullsDeletePendingReviewResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsListCommentsForReviewRequest = Request<
  PullsListCommentsForReviewRequestPath,
  | PullsListCommentsForReview200ResponseBody
  | PullsListCommentsForReview404ResponseBody,
  unknown,
  PullsListCommentsForReviewRequestQuery,
  Record<string, any>
>;

export type PullsListCommentsForReviewResponse = Response<
  | PullsListCommentsForReview200ResponseBody
  | PullsListCommentsForReview404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface PullsListCommentsForReviewHandler {
  pullsListCommentsForReview(
    req: PullsListCommentsForReviewRequest,
    res: PullsListCommentsForReviewResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsDismissReviewRequest = Request<
  PullsDismissReviewRequestPath,
  | PullsDismissReview200ResponseBody
  | PullsDismissReview404ResponseBody
  | PullsDismissReview422ResponseBody,
  PullsDismissReviewRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsDismissReviewResponse = Response<
  | PullsDismissReview200ResponseBody
  | PullsDismissReview404ResponseBody
  | PullsDismissReview422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface PullsDismissReviewHandler {
  pullsDismissReview(
    req: PullsDismissReviewRequest,
    res: PullsDismissReviewResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsSubmitReviewRequest = Request<
  PullsSubmitReviewRequestPath,
  | PullsSubmitReview200ResponseBody
  | PullsSubmitReview403ResponseBody
  | PullsSubmitReview404ResponseBody
  | PullsSubmitReview422ResponseBody,
  PullsSubmitReviewRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsSubmitReviewResponse = Response<
  | PullsSubmitReview200ResponseBody
  | PullsSubmitReview403ResponseBody
  | PullsSubmitReview404ResponseBody
  | PullsSubmitReview422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export interface PullsSubmitReviewHandler {
  pullsSubmitReview(
    req: PullsSubmitReviewRequest,
    res: PullsSubmitReviewResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PullsUpdateBranchRequest = Request<
  PullsUpdateBranchRequestPath,
  | PullsUpdateBranch202ResponseBody
  | PullsUpdateBranch403ResponseBody
  | PullsUpdateBranch422ResponseBody,
  PullsUpdateBranchRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type PullsUpdateBranchResponse = Response<
  | PullsUpdateBranch202ResponseBody
  | PullsUpdateBranch403ResponseBody
  | PullsUpdateBranch422ResponseBody,
  Record<string, any>,
  202 | 403 | 422
>;

export interface PullsUpdateBranchHandler {
  pullsUpdateBranch(
    req: PullsUpdateBranchRequest,
    res: PullsUpdateBranchResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetReadmeRequest = Request<
  ReposGetReadmeRequestPath,
  | ReposGetReadme200ResponseBody
  | ReposGetReadme404ResponseBody
  | ReposGetReadme422ResponseBody,
  unknown,
  ReposGetReadmeRequestQuery,
  Record<string, any>
>;

export type ReposGetReadmeResponse = Response<
  | ReposGetReadme200ResponseBody
  | ReposGetReadme404ResponseBody
  | ReposGetReadme422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface ReposGetReadmeHandler {
  reposGetReadme(
    req: ReposGetReadmeRequest,
    res: ReposGetReadmeResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetReadmeInDirectoryRequest = Request<
  ReposGetReadmeInDirectoryRequestPath,
  | ReposGetReadmeInDirectory200ResponseBody
  | ReposGetReadmeInDirectory404ResponseBody
  | ReposGetReadmeInDirectory422ResponseBody,
  unknown,
  ReposGetReadmeInDirectoryRequestQuery,
  Record<string, any>
>;

export type ReposGetReadmeInDirectoryResponse = Response<
  | ReposGetReadmeInDirectory200ResponseBody
  | ReposGetReadmeInDirectory404ResponseBody
  | ReposGetReadmeInDirectory422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface ReposGetReadmeInDirectoryHandler {
  reposGetReadmeInDirectory(
    req: ReposGetReadmeInDirectoryRequest,
    res: ReposGetReadmeInDirectoryResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListReleasesRequest = Request<
  ReposListReleasesRequestPath,
  ReposListReleases200ResponseBody | ReposListReleases404ResponseBody,
  unknown,
  ReposListReleasesRequestQuery,
  Record<string, any>
>;

export type ReposListReleasesResponse = Response<
  ReposListReleases200ResponseBody | ReposListReleases404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposListReleasesHandler {
  reposListReleases(
    req: ReposListReleasesRequest,
    res: ReposListReleasesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateReleaseRequest = Request<
  ReposCreateReleaseRequestPath,
  | ReposCreateRelease201ResponseBody
  | ReposCreateRelease404ResponseBody
  | ReposCreateRelease422ResponseBody,
  ReposCreateReleaseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateReleaseResponse = Response<
  | ReposCreateRelease201ResponseBody
  | ReposCreateRelease404ResponseBody
  | ReposCreateRelease422ResponseBody,
  Record<string, any>,
  201 | 404 | 422
>;

export interface ReposCreateReleaseHandler {
  reposCreateRelease(
    req: ReposCreateReleaseRequest,
    res: ReposCreateReleaseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetReleaseAssetRequest = Request<
  ReposGetReleaseAssetRequestPath,
  ReposGetReleaseAsset200ResponseBody | ReposGetReleaseAsset404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetReleaseAssetResponse = Response<
  ReposGetReleaseAsset200ResponseBody | ReposGetReleaseAsset404ResponseBody,
  Record<string, any>,
  200 | 302 | 404
>;

export interface ReposGetReleaseAssetHandler {
  reposGetReleaseAsset(
    req: ReposGetReleaseAssetRequest,
    res: ReposGetReleaseAssetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposUpdateReleaseAssetRequest = Request<
  ReposUpdateReleaseAssetRequestPath,
  ReposUpdateReleaseAsset200ResponseBody,
  ReposUpdateReleaseAssetRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateReleaseAssetResponse = Response<
  ReposUpdateReleaseAsset200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposUpdateReleaseAssetHandler {
  reposUpdateReleaseAsset(
    req: ReposUpdateReleaseAssetRequest,
    res: ReposUpdateReleaseAssetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteReleaseAssetRequest = Request<
  ReposDeleteReleaseAssetRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteReleaseAssetResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposDeleteReleaseAssetHandler {
  reposDeleteReleaseAsset(
    req: ReposDeleteReleaseAssetRequest,
    res: ReposDeleteReleaseAssetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGenerateReleaseNotesRequest = Request<
  ReposGenerateReleaseNotesRequestPath,
  | ReposGenerateReleaseNotes200ResponseBody
  | ReposGenerateReleaseNotes404ResponseBody,
  ReposGenerateReleaseNotesRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposGenerateReleaseNotesResponse = Response<
  | ReposGenerateReleaseNotes200ResponseBody
  | ReposGenerateReleaseNotes404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGenerateReleaseNotesHandler {
  reposGenerateReleaseNotes(
    req: ReposGenerateReleaseNotesRequest,
    res: ReposGenerateReleaseNotesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetLatestReleaseRequest = Request<
  ReposGetLatestReleaseRequestPath,
  ReposGetLatestRelease200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetLatestReleaseResponse = Response<
  ReposGetLatestRelease200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposGetLatestReleaseHandler {
  reposGetLatestRelease(
    req: ReposGetLatestReleaseRequest,
    res: ReposGetLatestReleaseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetReleaseByTagRequest = Request<
  ReposGetReleaseByTagRequestPath,
  ReposGetReleaseByTag200ResponseBody | ReposGetReleaseByTag404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetReleaseByTagResponse = Response<
  ReposGetReleaseByTag200ResponseBody | ReposGetReleaseByTag404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetReleaseByTagHandler {
  reposGetReleaseByTag(
    req: ReposGetReleaseByTagRequest,
    res: ReposGetReleaseByTagResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetReleaseRequest = Request<
  ReposGetReleaseRequestPath,
  ReposGetRelease200ResponseBody | ReposGetRelease404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetReleaseResponse = Response<
  ReposGetRelease200ResponseBody | ReposGetRelease404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetReleaseHandler {
  reposGetRelease(
    req: ReposGetReleaseRequest,
    res: ReposGetReleaseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposUpdateReleaseRequest = Request<
  ReposUpdateReleaseRequestPath,
  ReposUpdateRelease200ResponseBody | ReposUpdateRelease404ResponseBody,
  ReposUpdateReleaseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposUpdateReleaseResponse = Response<
  ReposUpdateRelease200ResponseBody | ReposUpdateRelease404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposUpdateReleaseHandler {
  reposUpdateRelease(
    req: ReposUpdateReleaseRequest,
    res: ReposUpdateReleaseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteReleaseRequest = Request<
  ReposDeleteReleaseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteReleaseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposDeleteReleaseHandler {
  reposDeleteRelease(
    req: ReposDeleteReleaseRequest,
    res: ReposDeleteReleaseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListReleaseAssetsRequest = Request<
  ReposListReleaseAssetsRequestPath,
  ReposListReleaseAssets200ResponseBody,
  unknown,
  ReposListReleaseAssetsRequestQuery,
  Record<string, any>
>;

export type ReposListReleaseAssetsResponse = Response<
  ReposListReleaseAssets200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListReleaseAssetsHandler {
  reposListReleaseAssets(
    req: ReposListReleaseAssetsRequest,
    res: ReposListReleaseAssetsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposUploadReleaseAssetRequest = Request<
  ReposUploadReleaseAssetRequestPath,
  ReposUploadReleaseAsset201ResponseBody,
  unknown,
  ReposUploadReleaseAssetRequestQuery,
  Record<string, any>
>;

export type ReposUploadReleaseAssetResponse = Response<
  ReposUploadReleaseAsset201ResponseBody,
  Record<string, any>,
  201 | 422
>;

export interface ReposUploadReleaseAssetHandler {
  reposUploadReleaseAsset(
    req: ReposUploadReleaseAssetRequest,
    res: ReposUploadReleaseAssetResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsListForReleaseRequest = Request<
  ReactionsListForReleaseRequestPath,
  | ReactionsListForRelease200ResponseBody
  | ReactionsListForRelease404ResponseBody,
  unknown,
  ReactionsListForReleaseRequestQuery,
  Record<string, any>
>;

export type ReactionsListForReleaseResponse = Response<
  | ReactionsListForRelease200ResponseBody
  | ReactionsListForRelease404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReactionsListForReleaseHandler {
  reactionsListForRelease(
    req: ReactionsListForReleaseRequest,
    res: ReactionsListForReleaseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsCreateForReleaseRequest = Request<
  ReactionsCreateForReleaseRequestPath,
  | ReactionsCreateForRelease200ResponseBody
  | ReactionsCreateForRelease201ResponseBody
  | ReactionsCreateForRelease422ResponseBody,
  ReactionsCreateForReleaseRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForReleaseResponse = Response<
  | ReactionsCreateForRelease200ResponseBody
  | ReactionsCreateForRelease201ResponseBody
  | ReactionsCreateForRelease422ResponseBody,
  Record<string, any>,
  200 | 201 | 422
>;

export interface ReactionsCreateForReleaseHandler {
  reactionsCreateForRelease(
    req: ReactionsCreateForReleaseRequest,
    res: ReactionsCreateForReleaseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsDeleteForReleaseRequest = Request<
  ReactionsDeleteForReleaseRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsDeleteForReleaseResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReactionsDeleteForReleaseHandler {
  reactionsDeleteForRelease(
    req: ReactionsDeleteForReleaseRequest,
    res: ReactionsDeleteForReleaseResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type SecretScanningListAlertsForRepoRequest = Request<
  SecretScanningListAlertsForRepoRequestPath,
  | SecretScanningListAlertsForRepo200ResponseBody
  | SecretScanningListAlertsForRepo503ResponseBody,
  unknown,
  SecretScanningListAlertsForRepoRequestQuery,
  Record<string, any>
>;

export type SecretScanningListAlertsForRepoResponse = Response<
  | SecretScanningListAlertsForRepo200ResponseBody
  | SecretScanningListAlertsForRepo503ResponseBody,
  Record<string, any>,
  200 | 404 | 503
>;

export interface SecretScanningListAlertsForRepoHandler {
  secretScanningListAlertsForRepo(
    req: SecretScanningListAlertsForRepoRequest,
    res: SecretScanningListAlertsForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type SecretScanningGetAlertRequest = Request<
  SecretScanningGetAlertRequestPath,
  SecretScanningGetAlert200ResponseBody | SecretScanningGetAlert503ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type SecretScanningGetAlertResponse = Response<
  SecretScanningGetAlert200ResponseBody | SecretScanningGetAlert503ResponseBody,
  Record<string, any>,
  200 | 304 | 404 | 503
>;

export interface SecretScanningGetAlertHandler {
  secretScanningGetAlert(
    req: SecretScanningGetAlertRequest,
    res: SecretScanningGetAlertResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type SecretScanningUpdateAlertRequest = Request<
  SecretScanningUpdateAlertRequestPath,
  | SecretScanningUpdateAlert200ResponseBody
  | SecretScanningUpdateAlert503ResponseBody,
  SecretScanningUpdateAlertRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type SecretScanningUpdateAlertResponse = Response<
  | SecretScanningUpdateAlert200ResponseBody
  | SecretScanningUpdateAlert503ResponseBody,
  Record<string, any>,
  200 | 400 | 404 | 422 | 503
>;

export interface SecretScanningUpdateAlertHandler {
  secretScanningUpdateAlert(
    req: SecretScanningUpdateAlertRequest,
    res: SecretScanningUpdateAlertResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type SecretScanningListLocationsForAlertRequest = Request<
  SecretScanningListLocationsForAlertRequestPath,
  | SecretScanningListLocationsForAlert200ResponseBody
  | SecretScanningListLocationsForAlert503ResponseBody,
  unknown,
  SecretScanningListLocationsForAlertRequestQuery,
  Record<string, any>
>;

export type SecretScanningListLocationsForAlertResponse = Response<
  | SecretScanningListLocationsForAlert200ResponseBody
  | SecretScanningListLocationsForAlert503ResponseBody,
  Record<string, any>,
  200 | 404 | 503
>;

export interface SecretScanningListLocationsForAlertHandler {
  secretScanningListLocationsForAlert(
    req: SecretScanningListLocationsForAlertRequest,
    res: SecretScanningListLocationsForAlertResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListStargazersForRepoRequest = Request<
  ActivityListStargazersForRepoRequestPath,
  | ActivityListStargazersForRepo200ResponseBody
  | ActivityListStargazersForRepo422ResponseBody,
  unknown,
  ActivityListStargazersForRepoRequestQuery,
  Record<string, any>
>;

export type ActivityListStargazersForRepoResponse = Response<
  | ActivityListStargazersForRepo200ResponseBody
  | ActivityListStargazersForRepo422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ActivityListStargazersForRepoHandler {
  activityListStargazersForRepo(
    req: ActivityListStargazersForRepoRequest,
    res: ActivityListStargazersForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetCodeFrequencyStatsRequest = Request<
  ReposGetCodeFrequencyStatsRequestPath,
  | ReposGetCodeFrequencyStats200ResponseBody
  | ReposGetCodeFrequencyStats202ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetCodeFrequencyStatsResponse = Response<
  | ReposGetCodeFrequencyStats200ResponseBody
  | ReposGetCodeFrequencyStats202ResponseBody,
  Record<string, any>,
  200 | 202 | 204
>;

export interface ReposGetCodeFrequencyStatsHandler {
  reposGetCodeFrequencyStats(
    req: ReposGetCodeFrequencyStatsRequest,
    res: ReposGetCodeFrequencyStatsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetCommitActivityStatsRequest = Request<
  ReposGetCommitActivityStatsRequestPath,
  | ReposGetCommitActivityStats200ResponseBody
  | ReposGetCommitActivityStats202ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetCommitActivityStatsResponse = Response<
  | ReposGetCommitActivityStats200ResponseBody
  | ReposGetCommitActivityStats202ResponseBody,
  Record<string, any>,
  200 | 202 | 204
>;

export interface ReposGetCommitActivityStatsHandler {
  reposGetCommitActivityStats(
    req: ReposGetCommitActivityStatsRequest,
    res: ReposGetCommitActivityStatsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetContributorsStatsRequest = Request<
  ReposGetContributorsStatsRequestPath,
  | ReposGetContributorsStats200ResponseBody
  | ReposGetContributorsStats202ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetContributorsStatsResponse = Response<
  | ReposGetContributorsStats200ResponseBody
  | ReposGetContributorsStats202ResponseBody,
  Record<string, any>,
  200 | 202 | 204
>;

export interface ReposGetContributorsStatsHandler {
  reposGetContributorsStats(
    req: ReposGetContributorsStatsRequest,
    res: ReposGetContributorsStatsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetParticipationStatsRequest = Request<
  ReposGetParticipationStatsRequestPath,
  | ReposGetParticipationStats200ResponseBody
  | ReposGetParticipationStats404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetParticipationStatsResponse = Response<
  | ReposGetParticipationStats200ResponseBody
  | ReposGetParticipationStats404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetParticipationStatsHandler {
  reposGetParticipationStats(
    req: ReposGetParticipationStatsRequest,
    res: ReposGetParticipationStatsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetPunchCardStatsRequest = Request<
  ReposGetPunchCardStatsRequestPath,
  ReposGetPunchCardStats200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetPunchCardStatsResponse = Response<
  ReposGetPunchCardStats200ResponseBody,
  Record<string, any>,
  200 | 204
>;

export interface ReposGetPunchCardStatsHandler {
  reposGetPunchCardStats(
    req: ReposGetPunchCardStatsRequest,
    res: ReposGetPunchCardStatsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateCommitStatusRequest = Request<
  ReposCreateCommitStatusRequestPath,
  ReposCreateCommitStatus201ResponseBody,
  ReposCreateCommitStatusRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateCommitStatusResponse = Response<
  ReposCreateCommitStatus201ResponseBody,
  Record<string, any>,
  201
>;

export interface ReposCreateCommitStatusHandler {
  reposCreateCommitStatus(
    req: ReposCreateCommitStatusRequest,
    res: ReposCreateCommitStatusResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListWatchersForRepoRequest = Request<
  ActivityListWatchersForRepoRequestPath,
  ActivityListWatchersForRepo200ResponseBody,
  unknown,
  ActivityListWatchersForRepoRequestQuery,
  Record<string, any>
>;

export type ActivityListWatchersForRepoResponse = Response<
  ActivityListWatchersForRepo200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActivityListWatchersForRepoHandler {
  activityListWatchersForRepo(
    req: ActivityListWatchersForRepoRequest,
    res: ActivityListWatchersForRepoResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityGetRepoSubscriptionRequest = Request<
  ActivityGetRepoSubscriptionRequestPath,
  | ActivityGetRepoSubscription200ResponseBody
  | ActivityGetRepoSubscription403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityGetRepoSubscriptionResponse = Response<
  | ActivityGetRepoSubscription200ResponseBody
  | ActivityGetRepoSubscription403ResponseBody,
  Record<string, any>,
  200 | 403 | 404
>;

export interface ActivityGetRepoSubscriptionHandler {
  activityGetRepoSubscription(
    req: ActivityGetRepoSubscriptionRequest,
    res: ActivityGetRepoSubscriptionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivitySetRepoSubscriptionRequest = Request<
  ActivitySetRepoSubscriptionRequestPath,
  ActivitySetRepoSubscription200ResponseBody,
  ActivitySetRepoSubscriptionRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActivitySetRepoSubscriptionResponse = Response<
  ActivitySetRepoSubscription200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActivitySetRepoSubscriptionHandler {
  activitySetRepoSubscription(
    req: ActivitySetRepoSubscriptionRequest,
    res: ActivitySetRepoSubscriptionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityDeleteRepoSubscriptionRequest = Request<
  ActivityDeleteRepoSubscriptionRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityDeleteRepoSubscriptionResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActivityDeleteRepoSubscriptionHandler {
  activityDeleteRepoSubscription(
    req: ActivityDeleteRepoSubscriptionRequest,
    res: ActivityDeleteRepoSubscriptionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListTagsRequest = Request<
  ReposListTagsRequestPath,
  ReposListTags200ResponseBody,
  unknown,
  ReposListTagsRequestQuery,
  Record<string, any>
>;

export type ReposListTagsResponse = Response<
  ReposListTags200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListTagsHandler {
  reposListTags(
    req: ReposListTagsRequest,
    res: ReposListTagsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListTagProtectionRequest = Request<
  ReposListTagProtectionRequestPath,
  | ReposListTagProtection200ResponseBody
  | ReposListTagProtection403ResponseBody
  | ReposListTagProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposListTagProtectionResponse = Response<
  | ReposListTagProtection200ResponseBody
  | ReposListTagProtection403ResponseBody
  | ReposListTagProtection404ResponseBody,
  Record<string, any>,
  200 | 403 | 404
>;

export interface ReposListTagProtectionHandler {
  reposListTagProtection(
    req: ReposListTagProtectionRequest,
    res: ReposListTagProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateTagProtectionRequest = Request<
  ReposCreateTagProtectionRequestPath,
  | ReposCreateTagProtection201ResponseBody
  | ReposCreateTagProtection403ResponseBody
  | ReposCreateTagProtection404ResponseBody,
  ReposCreateTagProtectionRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateTagProtectionResponse = Response<
  | ReposCreateTagProtection201ResponseBody
  | ReposCreateTagProtection403ResponseBody
  | ReposCreateTagProtection404ResponseBody,
  Record<string, any>,
  201 | 403 | 404
>;

export interface ReposCreateTagProtectionHandler {
  reposCreateTagProtection(
    req: ReposCreateTagProtectionRequest,
    res: ReposCreateTagProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeleteTagProtectionRequest = Request<
  ReposDeleteTagProtectionRequestPath,
  | ReposDeleteTagProtection403ResponseBody
  | ReposDeleteTagProtection404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeleteTagProtectionResponse = Response<
  | ReposDeleteTagProtection403ResponseBody
  | ReposDeleteTagProtection404ResponseBody,
  Record<string, any>,
  204 | 403 | 404
>;

export interface ReposDeleteTagProtectionHandler {
  reposDeleteTagProtection(
    req: ReposDeleteTagProtectionRequest,
    res: ReposDeleteTagProtectionResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDownloadTarballArchiveRequest = Request<
  ReposDownloadTarballArchiveRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDownloadTarballArchiveResponse = Response<
  unknown,
  Record<string, any>,
  302
>;

export interface ReposDownloadTarballArchiveHandler {
  reposDownloadTarballArchive(
    req: ReposDownloadTarballArchiveRequest,
    res: ReposDownloadTarballArchiveResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListTeamsRequest = Request<
  ReposListTeamsRequestPath,
  ReposListTeams200ResponseBody,
  unknown,
  ReposListTeamsRequestQuery,
  Record<string, any>
>;

export type ReposListTeamsResponse = Response<
  ReposListTeams200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListTeamsHandler {
  reposListTeams(
    req: ReposListTeamsRequest,
    res: ReposListTeamsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetAllTopicsRequest = Request<
  ReposGetAllTopicsRequestPath,
  ReposGetAllTopics200ResponseBody | ReposGetAllTopics404ResponseBody,
  unknown,
  ReposGetAllTopicsRequestQuery,
  Record<string, any>
>;

export type ReposGetAllTopicsResponse = Response<
  ReposGetAllTopics200ResponseBody | ReposGetAllTopics404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface ReposGetAllTopicsHandler {
  reposGetAllTopics(
    req: ReposGetAllTopicsRequest,
    res: ReposGetAllTopicsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposReplaceAllTopicsRequest = Request<
  ReposReplaceAllTopicsRequestPath,
  | ReposReplaceAllTopics200ResponseBody
  | ReposReplaceAllTopics404ResponseBody
  | ReposReplaceAllTopics422ResponseBody,
  ReposReplaceAllTopicsRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposReplaceAllTopicsResponse = Response<
  | ReposReplaceAllTopics200ResponseBody
  | ReposReplaceAllTopics404ResponseBody
  | ReposReplaceAllTopics422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface ReposReplaceAllTopicsHandler {
  reposReplaceAllTopics(
    req: ReposReplaceAllTopicsRequest,
    res: ReposReplaceAllTopicsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetClonesRequest = Request<
  ReposGetClonesRequestPath,
  ReposGetClones200ResponseBody | ReposGetClones403ResponseBody,
  unknown,
  ReposGetClonesRequestQuery,
  Record<string, any>
>;

export type ReposGetClonesResponse = Response<
  ReposGetClones200ResponseBody | ReposGetClones403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export interface ReposGetClonesHandler {
  reposGetClones(
    req: ReposGetClonesRequest,
    res: ReposGetClonesResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetTopPathsRequest = Request<
  ReposGetTopPathsRequestPath,
  ReposGetTopPaths200ResponseBody | ReposGetTopPaths403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetTopPathsResponse = Response<
  ReposGetTopPaths200ResponseBody | ReposGetTopPaths403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export interface ReposGetTopPathsHandler {
  reposGetTopPaths(
    req: ReposGetTopPathsRequest,
    res: ReposGetTopPathsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetTopReferrersRequest = Request<
  ReposGetTopReferrersRequestPath,
  ReposGetTopReferrers200ResponseBody | ReposGetTopReferrers403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposGetTopReferrersResponse = Response<
  ReposGetTopReferrers200ResponseBody | ReposGetTopReferrers403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export interface ReposGetTopReferrersHandler {
  reposGetTopReferrers(
    req: ReposGetTopReferrersRequest,
    res: ReposGetTopReferrersResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposGetViewsRequest = Request<
  ReposGetViewsRequestPath,
  ReposGetViews200ResponseBody | ReposGetViews403ResponseBody,
  unknown,
  ReposGetViewsRequestQuery,
  Record<string, any>
>;

export type ReposGetViewsResponse = Response<
  ReposGetViews200ResponseBody | ReposGetViews403ResponseBody,
  Record<string, any>,
  200 | 403
>;

export interface ReposGetViewsHandler {
  reposGetViews(
    req: ReposGetViewsRequest,
    res: ReposGetViewsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposTransferRequest = Request<
  ReposTransferRequestPath,
  ReposTransfer202ResponseBody,
  ReposTransferRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposTransferResponse = Response<
  ReposTransfer202ResponseBody,
  Record<string, any>,
  202
>;

export interface ReposTransferHandler {
  reposTransfer(
    req: ReposTransferRequest,
    res: ReposTransferResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCheckVulnerabilityAlertsRequest = Request<
  ReposCheckVulnerabilityAlertsRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposCheckVulnerabilityAlertsResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export interface ReposCheckVulnerabilityAlertsHandler {
  reposCheckVulnerabilityAlerts(
    req: ReposCheckVulnerabilityAlertsRequest,
    res: ReposCheckVulnerabilityAlertsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposEnableVulnerabilityAlertsRequest = Request<
  ReposEnableVulnerabilityAlertsRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposEnableVulnerabilityAlertsResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposEnableVulnerabilityAlertsHandler {
  reposEnableVulnerabilityAlerts(
    req: ReposEnableVulnerabilityAlertsRequest,
    res: ReposEnableVulnerabilityAlertsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDisableVulnerabilityAlertsRequest = Request<
  ReposDisableVulnerabilityAlertsRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDisableVulnerabilityAlertsResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ReposDisableVulnerabilityAlertsHandler {
  reposDisableVulnerabilityAlerts(
    req: ReposDisableVulnerabilityAlertsRequest,
    res: ReposDisableVulnerabilityAlertsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDownloadZipballArchiveRequest = Request<
  ReposDownloadZipballArchiveRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDownloadZipballArchiveResponse = Response<
  unknown,
  Record<string, any>,
  302
>;

export interface ReposDownloadZipballArchiveHandler {
  reposDownloadZipballArchive(
    req: ReposDownloadZipballArchiveRequest,
    res: ReposDownloadZipballArchiveResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateUsingTemplateRequest = Request<
  ReposCreateUsingTemplateRequestPath,
  ReposCreateUsingTemplate201ResponseBody,
  ReposCreateUsingTemplateRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateUsingTemplateResponse = Response<
  ReposCreateUsingTemplate201ResponseBody,
  Record<string, any>,
  201
>;

export interface ReposCreateUsingTemplateHandler {
  reposCreateUsingTemplate(
    req: ReposCreateUsingTemplateRequest,
    res: ReposCreateUsingTemplateResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListPublicRequest = Request<
  ParamsDictionary,
  ReposListPublic200ResponseBody | ReposListPublic422ResponseBody,
  unknown,
  ReposListPublicRequestQuery,
  Record<string, any>
>;

export type ReposListPublicResponse = Response<
  ReposListPublic200ResponseBody | ReposListPublic422ResponseBody,
  Record<string, any>,
  200 | 304 | 422
>;

export interface ReposListPublicHandler {
  reposListPublic(
    req: ReposListPublicRequest,
    res: ReposListPublicResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsListEnvironmentSecretsRequest = Request<
  ActionsListEnvironmentSecretsRequestPath,
  ActionsListEnvironmentSecrets200ResponseBody,
  unknown,
  ActionsListEnvironmentSecretsRequestQuery,
  Record<string, any>
>;

export type ActionsListEnvironmentSecretsResponse = Response<
  ActionsListEnvironmentSecrets200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsListEnvironmentSecretsHandler {
  actionsListEnvironmentSecrets(
    req: ActionsListEnvironmentSecretsRequest,
    res: ActionsListEnvironmentSecretsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetEnvironmentPublicKeyRequest = Request<
  ActionsGetEnvironmentPublicKeyRequestPath,
  ActionsGetEnvironmentPublicKey200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetEnvironmentPublicKeyResponse = Response<
  ActionsGetEnvironmentPublicKey200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetEnvironmentPublicKeyHandler {
  actionsGetEnvironmentPublicKey(
    req: ActionsGetEnvironmentPublicKeyRequest,
    res: ActionsGetEnvironmentPublicKeyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsGetEnvironmentSecretRequest = Request<
  ActionsGetEnvironmentSecretRequestPath,
  ActionsGetEnvironmentSecret200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsGetEnvironmentSecretResponse = Response<
  ActionsGetEnvironmentSecret200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActionsGetEnvironmentSecretHandler {
  actionsGetEnvironmentSecret(
    req: ActionsGetEnvironmentSecretRequest,
    res: ActionsGetEnvironmentSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsCreateOrUpdateEnvironmentSecretRequest = Request<
  ActionsCreateOrUpdateEnvironmentSecretRequestPath,
  ActionsCreateOrUpdateEnvironmentSecret201ResponseBody,
  ActionsCreateOrUpdateEnvironmentSecretRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ActionsCreateOrUpdateEnvironmentSecretResponse = Response<
  ActionsCreateOrUpdateEnvironmentSecret201ResponseBody,
  Record<string, any>,
  201 | 204
>;

export interface ActionsCreateOrUpdateEnvironmentSecretHandler {
  actionsCreateOrUpdateEnvironmentSecret(
    req: ActionsCreateOrUpdateEnvironmentSecretRequest,
    res: ActionsCreateOrUpdateEnvironmentSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActionsDeleteEnvironmentSecretRequest = Request<
  ActionsDeleteEnvironmentSecretRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActionsDeleteEnvironmentSecretResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface ActionsDeleteEnvironmentSecretHandler {
  actionsDeleteEnvironmentSecret(
    req: ActionsDeleteEnvironmentSecretRequest,
    res: ActionsDeleteEnvironmentSecretResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type SearchCodeRequest = Request<
  ParamsDictionary,
  | SearchCode200ResponseBody
  | SearchCode403ResponseBody
  | SearchCode422ResponseBody
  | SearchCode503ResponseBody,
  unknown,
  SearchCodeRequestQuery,
  Record<string, any>
>;

export type SearchCodeResponse = Response<
  | SearchCode200ResponseBody
  | SearchCode403ResponseBody
  | SearchCode422ResponseBody
  | SearchCode503ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 422 | 503
>;

export interface SearchCodeHandler {
  searchCode(
    req: SearchCodeRequest,
    res: SearchCodeResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type SearchCommitsRequest = Request<
  ParamsDictionary,
  SearchCommits200ResponseBody,
  unknown,
  SearchCommitsRequestQuery,
  Record<string, any>
>;

export type SearchCommitsResponse = Response<
  SearchCommits200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export interface SearchCommitsHandler {
  searchCommits(
    req: SearchCommitsRequest,
    res: SearchCommitsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type SearchIssuesAndPullRequestsRequest = Request<
  ParamsDictionary,
  | SearchIssuesAndPullRequests200ResponseBody
  | SearchIssuesAndPullRequests403ResponseBody
  | SearchIssuesAndPullRequests422ResponseBody
  | SearchIssuesAndPullRequests503ResponseBody,
  unknown,
  SearchIssuesAndPullRequestsRequestQuery,
  Record<string, any>
>;

export type SearchIssuesAndPullRequestsResponse = Response<
  | SearchIssuesAndPullRequests200ResponseBody
  | SearchIssuesAndPullRequests403ResponseBody
  | SearchIssuesAndPullRequests422ResponseBody
  | SearchIssuesAndPullRequests503ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 422 | 503
>;

export interface SearchIssuesAndPullRequestsHandler {
  searchIssuesAndPullRequests(
    req: SearchIssuesAndPullRequestsRequest,
    res: SearchIssuesAndPullRequestsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type SearchLabelsRequest = Request<
  ParamsDictionary,
  | SearchLabels200ResponseBody
  | SearchLabels403ResponseBody
  | SearchLabels404ResponseBody
  | SearchLabels422ResponseBody,
  unknown,
  SearchLabelsRequestQuery,
  Record<string, any>
>;

export type SearchLabelsResponse = Response<
  | SearchLabels200ResponseBody
  | SearchLabels403ResponseBody
  | SearchLabels404ResponseBody
  | SearchLabels422ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404 | 422
>;

export interface SearchLabelsHandler {
  searchLabels(
    req: SearchLabelsRequest,
    res: SearchLabelsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type SearchReposRequest = Request<
  ParamsDictionary,
  | SearchRepos200ResponseBody
  | SearchRepos422ResponseBody
  | SearchRepos503ResponseBody,
  unknown,
  SearchReposRequestQuery,
  Record<string, any>
>;

export type SearchReposResponse = Response<
  | SearchRepos200ResponseBody
  | SearchRepos422ResponseBody
  | SearchRepos503ResponseBody,
  Record<string, any>,
  200 | 304 | 422 | 503
>;

export interface SearchReposHandler {
  searchRepos(
    req: SearchReposRequest,
    res: SearchReposResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type SearchTopicsRequest = Request<
  ParamsDictionary,
  SearchTopics200ResponseBody,
  unknown,
  SearchTopicsRequestQuery,
  Record<string, any>
>;

export type SearchTopicsResponse = Response<
  SearchTopics200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export interface SearchTopicsHandler {
  searchTopics(
    req: SearchTopicsRequest,
    res: SearchTopicsResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type SearchUsersRequest = Request<
  ParamsDictionary,
  | SearchUsers200ResponseBody
  | SearchUsers422ResponseBody
  | SearchUsers503ResponseBody,
  unknown,
  SearchUsersRequestQuery,
  Record<string, any>
>;

export type SearchUsersResponse = Response<
  | SearchUsers200ResponseBody
  | SearchUsers422ResponseBody
  | SearchUsers503ResponseBody,
  Record<string, any>,
  200 | 304 | 422 | 503
>;

export interface SearchUsersHandler {
  searchUsers(
    req: SearchUsersRequest,
    res: SearchUsersResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsGetLegacyRequest = Request<
  TeamsGetLegacyRequestPath,
  TeamsGetLegacy200ResponseBody | TeamsGetLegacy404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetLegacyResponse = Response<
  TeamsGetLegacy200ResponseBody | TeamsGetLegacy404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface TeamsGetLegacyHandler {
  teamsGetLegacy(
    req: TeamsGetLegacyRequest,
    res: TeamsGetLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsUpdateLegacyRequest = Request<
  TeamsUpdateLegacyRequestPath,
  | TeamsUpdateLegacy200ResponseBody
  | TeamsUpdateLegacy201ResponseBody
  | TeamsUpdateLegacy403ResponseBody
  | TeamsUpdateLegacy404ResponseBody
  | TeamsUpdateLegacy422ResponseBody,
  TeamsUpdateLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsUpdateLegacyResponse = Response<
  | TeamsUpdateLegacy200ResponseBody
  | TeamsUpdateLegacy201ResponseBody
  | TeamsUpdateLegacy403ResponseBody
  | TeamsUpdateLegacy404ResponseBody
  | TeamsUpdateLegacy422ResponseBody,
  Record<string, any>,
  200 | 201 | 403 | 404 | 422
>;

export interface TeamsUpdateLegacyHandler {
  teamsUpdateLegacy(
    req: TeamsUpdateLegacyRequest,
    res: TeamsUpdateLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsDeleteLegacyRequest = Request<
  TeamsDeleteLegacyRequestPath,
  TeamsDeleteLegacy404ResponseBody | TeamsDeleteLegacy422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsDeleteLegacyResponse = Response<
  TeamsDeleteLegacy404ResponseBody | TeamsDeleteLegacy422ResponseBody,
  Record<string, any>,
  204 | 404 | 422
>;

export interface TeamsDeleteLegacyHandler {
  teamsDeleteLegacy(
    req: TeamsDeleteLegacyRequest,
    res: TeamsDeleteLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListDiscussionsLegacyRequest = Request<
  TeamsListDiscussionsLegacyRequestPath,
  TeamsListDiscussionsLegacy200ResponseBody,
  unknown,
  TeamsListDiscussionsLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListDiscussionsLegacyResponse = Response<
  TeamsListDiscussionsLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsListDiscussionsLegacyHandler {
  teamsListDiscussionsLegacy(
    req: TeamsListDiscussionsLegacyRequest,
    res: TeamsListDiscussionsLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsCreateDiscussionLegacyRequest = Request<
  TeamsCreateDiscussionLegacyRequestPath,
  TeamsCreateDiscussionLegacy201ResponseBody,
  TeamsCreateDiscussionLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCreateDiscussionLegacyResponse = Response<
  TeamsCreateDiscussionLegacy201ResponseBody,
  Record<string, any>,
  201
>;

export interface TeamsCreateDiscussionLegacyHandler {
  teamsCreateDiscussionLegacy(
    req: TeamsCreateDiscussionLegacyRequest,
    res: TeamsCreateDiscussionLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsGetDiscussionLegacyRequest = Request<
  TeamsGetDiscussionLegacyRequestPath,
  TeamsGetDiscussionLegacy200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetDiscussionLegacyResponse = Response<
  TeamsGetDiscussionLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsGetDiscussionLegacyHandler {
  teamsGetDiscussionLegacy(
    req: TeamsGetDiscussionLegacyRequest,
    res: TeamsGetDiscussionLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsUpdateDiscussionLegacyRequest = Request<
  TeamsUpdateDiscussionLegacyRequestPath,
  TeamsUpdateDiscussionLegacy200ResponseBody,
  TeamsUpdateDiscussionLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsUpdateDiscussionLegacyResponse = Response<
  TeamsUpdateDiscussionLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsUpdateDiscussionLegacyHandler {
  teamsUpdateDiscussionLegacy(
    req: TeamsUpdateDiscussionLegacyRequest,
    res: TeamsUpdateDiscussionLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsDeleteDiscussionLegacyRequest = Request<
  TeamsDeleteDiscussionLegacyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsDeleteDiscussionLegacyResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface TeamsDeleteDiscussionLegacyHandler {
  teamsDeleteDiscussionLegacy(
    req: TeamsDeleteDiscussionLegacyRequest,
    res: TeamsDeleteDiscussionLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListDiscussionCommentsLegacyRequest = Request<
  TeamsListDiscussionCommentsLegacyRequestPath,
  TeamsListDiscussionCommentsLegacy200ResponseBody,
  unknown,
  TeamsListDiscussionCommentsLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListDiscussionCommentsLegacyResponse = Response<
  TeamsListDiscussionCommentsLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsListDiscussionCommentsLegacyHandler {
  teamsListDiscussionCommentsLegacy(
    req: TeamsListDiscussionCommentsLegacyRequest,
    res: TeamsListDiscussionCommentsLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsCreateDiscussionCommentLegacyRequest = Request<
  TeamsCreateDiscussionCommentLegacyRequestPath,
  TeamsCreateDiscussionCommentLegacy201ResponseBody,
  TeamsCreateDiscussionCommentLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCreateDiscussionCommentLegacyResponse = Response<
  TeamsCreateDiscussionCommentLegacy201ResponseBody,
  Record<string, any>,
  201
>;

export interface TeamsCreateDiscussionCommentLegacyHandler {
  teamsCreateDiscussionCommentLegacy(
    req: TeamsCreateDiscussionCommentLegacyRequest,
    res: TeamsCreateDiscussionCommentLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsGetDiscussionCommentLegacyRequest = Request<
  TeamsGetDiscussionCommentLegacyRequestPath,
  TeamsGetDiscussionCommentLegacy200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetDiscussionCommentLegacyResponse = Response<
  TeamsGetDiscussionCommentLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsGetDiscussionCommentLegacyHandler {
  teamsGetDiscussionCommentLegacy(
    req: TeamsGetDiscussionCommentLegacyRequest,
    res: TeamsGetDiscussionCommentLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsUpdateDiscussionCommentLegacyRequest = Request<
  TeamsUpdateDiscussionCommentLegacyRequestPath,
  TeamsUpdateDiscussionCommentLegacy200ResponseBody,
  TeamsUpdateDiscussionCommentLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsUpdateDiscussionCommentLegacyResponse = Response<
  TeamsUpdateDiscussionCommentLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsUpdateDiscussionCommentLegacyHandler {
  teamsUpdateDiscussionCommentLegacy(
    req: TeamsUpdateDiscussionCommentLegacyRequest,
    res: TeamsUpdateDiscussionCommentLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsDeleteDiscussionCommentLegacyRequest = Request<
  TeamsDeleteDiscussionCommentLegacyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsDeleteDiscussionCommentLegacyResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface TeamsDeleteDiscussionCommentLegacyHandler {
  teamsDeleteDiscussionCommentLegacy(
    req: TeamsDeleteDiscussionCommentLegacyRequest,
    res: TeamsDeleteDiscussionCommentLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsListForTeamDiscussionCommentLegacyRequest = Request<
  ReactionsListForTeamDiscussionCommentLegacyRequestPath,
  ReactionsListForTeamDiscussionCommentLegacy200ResponseBody,
  unknown,
  ReactionsListForTeamDiscussionCommentLegacyRequestQuery,
  Record<string, any>
>;

export type ReactionsListForTeamDiscussionCommentLegacyResponse = Response<
  ReactionsListForTeamDiscussionCommentLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReactionsListForTeamDiscussionCommentLegacyHandler {
  reactionsListForTeamDiscussionCommentLegacy(
    req: ReactionsListForTeamDiscussionCommentLegacyRequest,
    res: ReactionsListForTeamDiscussionCommentLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsCreateForTeamDiscussionCommentLegacyRequest = Request<
  ReactionsCreateForTeamDiscussionCommentLegacyRequestPath,
  ReactionsCreateForTeamDiscussionCommentLegacy201ResponseBody,
  ReactionsCreateForTeamDiscussionCommentLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForTeamDiscussionCommentLegacyResponse = Response<
  ReactionsCreateForTeamDiscussionCommentLegacy201ResponseBody,
  Record<string, any>,
  201
>;

export interface ReactionsCreateForTeamDiscussionCommentLegacyHandler {
  reactionsCreateForTeamDiscussionCommentLegacy(
    req: ReactionsCreateForTeamDiscussionCommentLegacyRequest,
    res: ReactionsCreateForTeamDiscussionCommentLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsListForTeamDiscussionLegacyRequest = Request<
  ReactionsListForTeamDiscussionLegacyRequestPath,
  ReactionsListForTeamDiscussionLegacy200ResponseBody,
  unknown,
  ReactionsListForTeamDiscussionLegacyRequestQuery,
  Record<string, any>
>;

export type ReactionsListForTeamDiscussionLegacyResponse = Response<
  ReactionsListForTeamDiscussionLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReactionsListForTeamDiscussionLegacyHandler {
  reactionsListForTeamDiscussionLegacy(
    req: ReactionsListForTeamDiscussionLegacyRequest,
    res: ReactionsListForTeamDiscussionLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReactionsCreateForTeamDiscussionLegacyRequest = Request<
  ReactionsCreateForTeamDiscussionLegacyRequestPath,
  ReactionsCreateForTeamDiscussionLegacy201ResponseBody,
  ReactionsCreateForTeamDiscussionLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReactionsCreateForTeamDiscussionLegacyResponse = Response<
  ReactionsCreateForTeamDiscussionLegacy201ResponseBody,
  Record<string, any>,
  201
>;

export interface ReactionsCreateForTeamDiscussionLegacyHandler {
  reactionsCreateForTeamDiscussionLegacy(
    req: ReactionsCreateForTeamDiscussionLegacyRequest,
    res: ReactionsCreateForTeamDiscussionLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListPendingInvitationsLegacyRequest = Request<
  TeamsListPendingInvitationsLegacyRequestPath,
  TeamsListPendingInvitationsLegacy200ResponseBody,
  unknown,
  TeamsListPendingInvitationsLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListPendingInvitationsLegacyResponse = Response<
  TeamsListPendingInvitationsLegacy200ResponseBody,
  Record<string, any>,
  200
>;

export interface TeamsListPendingInvitationsLegacyHandler {
  teamsListPendingInvitationsLegacy(
    req: TeamsListPendingInvitationsLegacyRequest,
    res: TeamsListPendingInvitationsLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListMembersLegacyRequest = Request<
  TeamsListMembersLegacyRequestPath,
  TeamsListMembersLegacy200ResponseBody | TeamsListMembersLegacy404ResponseBody,
  unknown,
  TeamsListMembersLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListMembersLegacyResponse = Response<
  TeamsListMembersLegacy200ResponseBody | TeamsListMembersLegacy404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface TeamsListMembersLegacyHandler {
  teamsListMembersLegacy(
    req: TeamsListMembersLegacyRequest,
    res: TeamsListMembersLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsGetMemberLegacyRequest = Request<
  TeamsGetMemberLegacyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetMemberLegacyResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export interface TeamsGetMemberLegacyHandler {
  teamsGetMemberLegacy(
    req: TeamsGetMemberLegacyRequest,
    res: TeamsGetMemberLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsAddMemberLegacyRequest = Request<
  TeamsAddMemberLegacyRequestPath,
  TeamsAddMemberLegacy403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddMemberLegacyResponse = Response<
  TeamsAddMemberLegacy403ResponseBody,
  Record<string, any>,
  204 | 403 | 404 | 422
>;

export interface TeamsAddMemberLegacyHandler {
  teamsAddMemberLegacy(
    req: TeamsAddMemberLegacyRequest,
    res: TeamsAddMemberLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsRemoveMemberLegacyRequest = Request<
  TeamsRemoveMemberLegacyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveMemberLegacyResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export interface TeamsRemoveMemberLegacyHandler {
  teamsRemoveMemberLegacy(
    req: TeamsRemoveMemberLegacyRequest,
    res: TeamsRemoveMemberLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsGetMembershipForUserLegacyRequest = Request<
  TeamsGetMembershipForUserLegacyRequestPath,
  | TeamsGetMembershipForUserLegacy200ResponseBody
  | TeamsGetMembershipForUserLegacy404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsGetMembershipForUserLegacyResponse = Response<
  | TeamsGetMembershipForUserLegacy200ResponseBody
  | TeamsGetMembershipForUserLegacy404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface TeamsGetMembershipForUserLegacyHandler {
  teamsGetMembershipForUserLegacy(
    req: TeamsGetMembershipForUserLegacyRequest,
    res: TeamsGetMembershipForUserLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsAddOrUpdateMembershipForUserLegacyRequest = Request<
  TeamsAddOrUpdateMembershipForUserLegacyRequestPath,
  | TeamsAddOrUpdateMembershipForUserLegacy200ResponseBody
  | TeamsAddOrUpdateMembershipForUserLegacy404ResponseBody,
  TeamsAddOrUpdateMembershipForUserLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddOrUpdateMembershipForUserLegacyResponse = Response<
  | TeamsAddOrUpdateMembershipForUserLegacy200ResponseBody
  | TeamsAddOrUpdateMembershipForUserLegacy404ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export interface TeamsAddOrUpdateMembershipForUserLegacyHandler {
  teamsAddOrUpdateMembershipForUserLegacy(
    req: TeamsAddOrUpdateMembershipForUserLegacyRequest,
    res: TeamsAddOrUpdateMembershipForUserLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsRemoveMembershipForUserLegacyRequest = Request<
  TeamsRemoveMembershipForUserLegacyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveMembershipForUserLegacyResponse = Response<
  unknown,
  Record<string, any>,
  204 | 403
>;

export interface TeamsRemoveMembershipForUserLegacyHandler {
  teamsRemoveMembershipForUserLegacy(
    req: TeamsRemoveMembershipForUserLegacyRequest,
    res: TeamsRemoveMembershipForUserLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListProjectsLegacyRequest = Request<
  TeamsListProjectsLegacyRequestPath,
  | TeamsListProjectsLegacy200ResponseBody
  | TeamsListProjectsLegacy404ResponseBody,
  unknown,
  TeamsListProjectsLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListProjectsLegacyResponse = Response<
  | TeamsListProjectsLegacy200ResponseBody
  | TeamsListProjectsLegacy404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface TeamsListProjectsLegacyHandler {
  teamsListProjectsLegacy(
    req: TeamsListProjectsLegacyRequest,
    res: TeamsListProjectsLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsCheckPermissionsForProjectLegacyRequest = Request<
  TeamsCheckPermissionsForProjectLegacyRequestPath,
  TeamsCheckPermissionsForProjectLegacy200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCheckPermissionsForProjectLegacyResponse = Response<
  TeamsCheckPermissionsForProjectLegacy200ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface TeamsCheckPermissionsForProjectLegacyHandler {
  teamsCheckPermissionsForProjectLegacy(
    req: TeamsCheckPermissionsForProjectLegacyRequest,
    res: TeamsCheckPermissionsForProjectLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsAddOrUpdateProjectPermissionsLegacyRequest = Request<
  TeamsAddOrUpdateProjectPermissionsLegacyRequestPath,
  | TeamsAddOrUpdateProjectPermissionsLegacy403ResponseBody
  | TeamsAddOrUpdateProjectPermissionsLegacy404ResponseBody
  | TeamsAddOrUpdateProjectPermissionsLegacy422ResponseBody,
  TeamsAddOrUpdateProjectPermissionsLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddOrUpdateProjectPermissionsLegacyResponse = Response<
  | TeamsAddOrUpdateProjectPermissionsLegacy403ResponseBody
  | TeamsAddOrUpdateProjectPermissionsLegacy404ResponseBody
  | TeamsAddOrUpdateProjectPermissionsLegacy422ResponseBody,
  Record<string, any>,
  204 | 403 | 404 | 422
>;

export interface TeamsAddOrUpdateProjectPermissionsLegacyHandler {
  teamsAddOrUpdateProjectPermissionsLegacy(
    req: TeamsAddOrUpdateProjectPermissionsLegacyRequest,
    res: TeamsAddOrUpdateProjectPermissionsLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsRemoveProjectLegacyRequest = Request<
  TeamsRemoveProjectLegacyRequestPath,
  | TeamsRemoveProjectLegacy404ResponseBody
  | TeamsRemoveProjectLegacy422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveProjectLegacyResponse = Response<
  | TeamsRemoveProjectLegacy404ResponseBody
  | TeamsRemoveProjectLegacy422ResponseBody,
  Record<string, any>,
  204 | 404 | 422
>;

export interface TeamsRemoveProjectLegacyHandler {
  teamsRemoveProjectLegacy(
    req: TeamsRemoveProjectLegacyRequest,
    res: TeamsRemoveProjectLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListReposLegacyRequest = Request<
  TeamsListReposLegacyRequestPath,
  TeamsListReposLegacy200ResponseBody | TeamsListReposLegacy404ResponseBody,
  unknown,
  TeamsListReposLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListReposLegacyResponse = Response<
  TeamsListReposLegacy200ResponseBody | TeamsListReposLegacy404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface TeamsListReposLegacyHandler {
  teamsListReposLegacy(
    req: TeamsListReposLegacyRequest,
    res: TeamsListReposLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsCheckPermissionsForRepoLegacyRequest = Request<
  TeamsCheckPermissionsForRepoLegacyRequestPath,
  TeamsCheckPermissionsForRepoLegacy200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsCheckPermissionsForRepoLegacyResponse = Response<
  TeamsCheckPermissionsForRepoLegacy200ResponseBody,
  Record<string, any>,
  200 | 204 | 404
>;

export interface TeamsCheckPermissionsForRepoLegacyHandler {
  teamsCheckPermissionsForRepoLegacy(
    req: TeamsCheckPermissionsForRepoLegacyRequest,
    res: TeamsCheckPermissionsForRepoLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsAddOrUpdateRepoPermissionsLegacyRequest = Request<
  TeamsAddOrUpdateRepoPermissionsLegacyRequestPath,
  | TeamsAddOrUpdateRepoPermissionsLegacy403ResponseBody
  | TeamsAddOrUpdateRepoPermissionsLegacy422ResponseBody,
  TeamsAddOrUpdateRepoPermissionsLegacyRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type TeamsAddOrUpdateRepoPermissionsLegacyResponse = Response<
  | TeamsAddOrUpdateRepoPermissionsLegacy403ResponseBody
  | TeamsAddOrUpdateRepoPermissionsLegacy422ResponseBody,
  Record<string, any>,
  204 | 403 | 422
>;

export interface TeamsAddOrUpdateRepoPermissionsLegacyHandler {
  teamsAddOrUpdateRepoPermissionsLegacy(
    req: TeamsAddOrUpdateRepoPermissionsLegacyRequest,
    res: TeamsAddOrUpdateRepoPermissionsLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsRemoveRepoLegacyRequest = Request<
  TeamsRemoveRepoLegacyRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type TeamsRemoveRepoLegacyResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface TeamsRemoveRepoLegacyHandler {
  teamsRemoveRepoLegacy(
    req: TeamsRemoveRepoLegacyRequest,
    res: TeamsRemoveRepoLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListChildLegacyRequest = Request<
  TeamsListChildLegacyRequestPath,
  | TeamsListChildLegacy200ResponseBody
  | TeamsListChildLegacy403ResponseBody
  | TeamsListChildLegacy404ResponseBody
  | TeamsListChildLegacy422ResponseBody,
  unknown,
  TeamsListChildLegacyRequestQuery,
  Record<string, any>
>;

export type TeamsListChildLegacyResponse = Response<
  | TeamsListChildLegacy200ResponseBody
  | TeamsListChildLegacy403ResponseBody
  | TeamsListChildLegacy404ResponseBody
  | TeamsListChildLegacy422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export interface TeamsListChildLegacyHandler {
  teamsListChildLegacy(
    req: TeamsListChildLegacyRequest,
    res: TeamsListChildLegacyResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersGetAuthenticatedRequest = Request<
  ParamsDictionary,
  | UsersGetAuthenticated200ResponseBody
  | UsersGetAuthenticated401ResponseBody
  | UsersGetAuthenticated403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersGetAuthenticatedResponse = Response<
  | UsersGetAuthenticated200ResponseBody
  | UsersGetAuthenticated401ResponseBody
  | UsersGetAuthenticated403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface UsersGetAuthenticatedHandler {
  usersGetAuthenticated(
    req: UsersGetAuthenticatedRequest,
    res: UsersGetAuthenticatedResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersUpdateAuthenticatedRequest = Request<
  ParamsDictionary,
  | UsersUpdateAuthenticated200ResponseBody
  | UsersUpdateAuthenticated401ResponseBody
  | UsersUpdateAuthenticated403ResponseBody
  | UsersUpdateAuthenticated404ResponseBody
  | UsersUpdateAuthenticated422ResponseBody,
  UsersUpdateAuthenticatedRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersUpdateAuthenticatedResponse = Response<
  | UsersUpdateAuthenticated200ResponseBody
  | UsersUpdateAuthenticated401ResponseBody
  | UsersUpdateAuthenticated403ResponseBody
  | UsersUpdateAuthenticated404ResponseBody
  | UsersUpdateAuthenticated422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 422
>;

export interface UsersUpdateAuthenticatedHandler {
  usersUpdateAuthenticated(
    req: UsersUpdateAuthenticatedRequest,
    res: UsersUpdateAuthenticatedResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListBlockedByAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListBlockedByAuthenticatedUser200ResponseBody
  | UsersListBlockedByAuthenticatedUser401ResponseBody
  | UsersListBlockedByAuthenticatedUser403ResponseBody
  | UsersListBlockedByAuthenticatedUser404ResponseBody,
  unknown,
  UsersListBlockedByAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListBlockedByAuthenticatedUserResponse = Response<
  | UsersListBlockedByAuthenticatedUser200ResponseBody
  | UsersListBlockedByAuthenticatedUser401ResponseBody
  | UsersListBlockedByAuthenticatedUser403ResponseBody
  | UsersListBlockedByAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export interface UsersListBlockedByAuthenticatedUserHandler {
  usersListBlockedByAuthenticatedUser(
    req: UsersListBlockedByAuthenticatedUserRequest,
    res: UsersListBlockedByAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersCheckBlockedRequest = Request<
  UsersCheckBlockedRequestPath,
  | UsersCheckBlocked401ResponseBody
  | UsersCheckBlocked403ResponseBody
  | UsersCheckBlocked404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersCheckBlockedResponse = Response<
  | UsersCheckBlocked401ResponseBody
  | UsersCheckBlocked403ResponseBody
  | UsersCheckBlocked404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export interface UsersCheckBlockedHandler {
  usersCheckBlocked(
    req: UsersCheckBlockedRequest,
    res: UsersCheckBlockedResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersBlockRequest = Request<
  UsersBlockRequestPath,
  | UsersBlock401ResponseBody
  | UsersBlock403ResponseBody
  | UsersBlock404ResponseBody
  | UsersBlock422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersBlockResponse = Response<
  | UsersBlock401ResponseBody
  | UsersBlock403ResponseBody
  | UsersBlock404ResponseBody
  | UsersBlock422ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404 | 422
>;

export interface UsersBlockHandler {
  usersBlock(
    req: UsersBlockRequest,
    res: UsersBlockResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersUnblockRequest = Request<
  UsersUnblockRequestPath,
  | UsersUnblock401ResponseBody
  | UsersUnblock403ResponseBody
  | UsersUnblock404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersUnblockResponse = Response<
  | UsersUnblock401ResponseBody
  | UsersUnblock403ResponseBody
  | UsersUnblock404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export interface UsersUnblockHandler {
  usersUnblock(
    req: UsersUnblockRequest,
    res: UsersUnblockResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesListForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | CodespacesListForAuthenticatedUser200ResponseBody
  | CodespacesListForAuthenticatedUser401ResponseBody
  | CodespacesListForAuthenticatedUser403ResponseBody
  | CodespacesListForAuthenticatedUser404ResponseBody
  | CodespacesListForAuthenticatedUser500ResponseBody,
  unknown,
  CodespacesListForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type CodespacesListForAuthenticatedUserResponse = Response<
  | CodespacesListForAuthenticatedUser200ResponseBody
  | CodespacesListForAuthenticatedUser401ResponseBody
  | CodespacesListForAuthenticatedUser403ResponseBody
  | CodespacesListForAuthenticatedUser404ResponseBody
  | CodespacesListForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export interface CodespacesListForAuthenticatedUserHandler {
  codespacesListForAuthenticatedUser(
    req: CodespacesListForAuthenticatedUserRequest,
    res: CodespacesListForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesCreateForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | CodespacesCreateForAuthenticatedUser201ResponseBody
  | CodespacesCreateForAuthenticatedUser202ResponseBody
  | CodespacesCreateForAuthenticatedUser401ResponseBody
  | CodespacesCreateForAuthenticatedUser403ResponseBody
  | CodespacesCreateForAuthenticatedUser404ResponseBody
  | CodespacesCreateForAuthenticatedUser503ResponseBody,
  CodespacesCreateForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCreateForAuthenticatedUserResponse = Response<
  | CodespacesCreateForAuthenticatedUser201ResponseBody
  | CodespacesCreateForAuthenticatedUser202ResponseBody
  | CodespacesCreateForAuthenticatedUser401ResponseBody
  | CodespacesCreateForAuthenticatedUser403ResponseBody
  | CodespacesCreateForAuthenticatedUser404ResponseBody
  | CodespacesCreateForAuthenticatedUser503ResponseBody,
  Record<string, any>,
  201 | 202 | 401 | 403 | 404 | 503
>;

export interface CodespacesCreateForAuthenticatedUserHandler {
  codespacesCreateForAuthenticatedUser(
    req: CodespacesCreateForAuthenticatedUserRequest,
    res: CodespacesCreateForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesListSecretsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  CodespacesListSecretsForAuthenticatedUser200ResponseBody,
  unknown,
  CodespacesListSecretsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type CodespacesListSecretsForAuthenticatedUserResponse = Response<
  CodespacesListSecretsForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface CodespacesListSecretsForAuthenticatedUserHandler {
  codespacesListSecretsForAuthenticatedUser(
    req: CodespacesListSecretsForAuthenticatedUserRequest,
    res: CodespacesListSecretsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesGetPublicKeyForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  CodespacesGetPublicKeyForAuthenticatedUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetPublicKeyForAuthenticatedUserResponse = Response<
  CodespacesGetPublicKeyForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface CodespacesGetPublicKeyForAuthenticatedUserHandler {
  codespacesGetPublicKeyForAuthenticatedUser(
    req: CodespacesGetPublicKeyForAuthenticatedUserRequest,
    res: CodespacesGetPublicKeyForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesGetSecretForAuthenticatedUserRequest = Request<
  CodespacesGetSecretForAuthenticatedUserRequestPath,
  CodespacesGetSecretForAuthenticatedUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetSecretForAuthenticatedUserResponse = Response<
  CodespacesGetSecretForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface CodespacesGetSecretForAuthenticatedUserHandler {
  codespacesGetSecretForAuthenticatedUser(
    req: CodespacesGetSecretForAuthenticatedUserRequest,
    res: CodespacesGetSecretForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesCreateOrUpdateSecretForAuthenticatedUserRequest = Request<
  CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestPath,
  | CodespacesCreateOrUpdateSecretForAuthenticatedUser201ResponseBody
  | CodespacesCreateOrUpdateSecretForAuthenticatedUser404ResponseBody
  | CodespacesCreateOrUpdateSecretForAuthenticatedUser422ResponseBody,
  CodespacesCreateOrUpdateSecretForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCreateOrUpdateSecretForAuthenticatedUserResponse = Response<
  | CodespacesCreateOrUpdateSecretForAuthenticatedUser201ResponseBody
  | CodespacesCreateOrUpdateSecretForAuthenticatedUser404ResponseBody
  | CodespacesCreateOrUpdateSecretForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 204 | 404 | 422
>;

export interface CodespacesCreateOrUpdateSecretForAuthenticatedUserHandler {
  codespacesCreateOrUpdateSecretForAuthenticatedUser(
    req: CodespacesCreateOrUpdateSecretForAuthenticatedUserRequest,
    res: CodespacesCreateOrUpdateSecretForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesDeleteSecretForAuthenticatedUserRequest = Request<
  CodespacesDeleteSecretForAuthenticatedUserRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesDeleteSecretForAuthenticatedUserResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface CodespacesDeleteSecretForAuthenticatedUserHandler {
  codespacesDeleteSecretForAuthenticatedUser(
    req: CodespacesDeleteSecretForAuthenticatedUserRequest,
    res: CodespacesDeleteSecretForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesListRepositoriesForSecretForAuthenticatedUserRequest = Request<
  CodespacesListRepositoriesForSecretForAuthenticatedUserRequestPath,
  | CodespacesListRepositoriesForSecretForAuthenticatedUser200ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser401ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser403ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser404ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesListRepositoriesForSecretForAuthenticatedUserResponse = Response<
  | CodespacesListRepositoriesForSecretForAuthenticatedUser200ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser401ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser403ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser404ResponseBody
  | CodespacesListRepositoriesForSecretForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404 | 500
>;

export interface CodespacesListRepositoriesForSecretForAuthenticatedUserHandler {
  codespacesListRepositoriesForSecretForAuthenticatedUser(
    req: CodespacesListRepositoriesForSecretForAuthenticatedUserRequest,
    res: CodespacesListRepositoriesForSecretForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesSetRepositoriesForSecretForAuthenticatedUserRequest = Request<
  CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestPath,
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser401ResponseBody
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser403ResponseBody
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser404ResponseBody
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser500ResponseBody,
  CodespacesSetRepositoriesForSecretForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesSetRepositoriesForSecretForAuthenticatedUserResponse = Response<
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser401ResponseBody
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser403ResponseBody
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser404ResponseBody
  | CodespacesSetRepositoriesForSecretForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404 | 500
>;

export interface CodespacesSetRepositoriesForSecretForAuthenticatedUserHandler {
  codespacesSetRepositoriesForSecretForAuthenticatedUser(
    req: CodespacesSetRepositoriesForSecretForAuthenticatedUserRequest,
    res: CodespacesSetRepositoriesForSecretForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesAddRepositoryForSecretForAuthenticatedUserRequest = Request<
  CodespacesAddRepositoryForSecretForAuthenticatedUserRequestPath,
  | CodespacesAddRepositoryForSecretForAuthenticatedUser401ResponseBody
  | CodespacesAddRepositoryForSecretForAuthenticatedUser403ResponseBody
  | CodespacesAddRepositoryForSecretForAuthenticatedUser404ResponseBody
  | CodespacesAddRepositoryForSecretForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesAddRepositoryForSecretForAuthenticatedUserResponse = Response<
  | CodespacesAddRepositoryForSecretForAuthenticatedUser401ResponseBody
  | CodespacesAddRepositoryForSecretForAuthenticatedUser403ResponseBody
  | CodespacesAddRepositoryForSecretForAuthenticatedUser404ResponseBody
  | CodespacesAddRepositoryForSecretForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404 | 500
>;

export interface CodespacesAddRepositoryForSecretForAuthenticatedUserHandler {
  codespacesAddRepositoryForSecretForAuthenticatedUser(
    req: CodespacesAddRepositoryForSecretForAuthenticatedUserRequest,
    res: CodespacesAddRepositoryForSecretForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUserRequest = Request<
  CodespacesRemoveRepositoryForSecretForAuthenticatedUserRequestPath,
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser401ResponseBody
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser403ResponseBody
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser404ResponseBody
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse = Response<
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser401ResponseBody
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser403ResponseBody
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser404ResponseBody
  | CodespacesRemoveRepositoryForSecretForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404 | 500
>;

export interface CodespacesRemoveRepositoryForSecretForAuthenticatedUserHandler {
  codespacesRemoveRepositoryForSecretForAuthenticatedUser(
    req: CodespacesRemoveRepositoryForSecretForAuthenticatedUserRequest,
    res: CodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesGetForAuthenticatedUserRequest = Request<
  CodespacesGetForAuthenticatedUserRequestPath,
  | CodespacesGetForAuthenticatedUser200ResponseBody
  | CodespacesGetForAuthenticatedUser401ResponseBody
  | CodespacesGetForAuthenticatedUser403ResponseBody
  | CodespacesGetForAuthenticatedUser404ResponseBody
  | CodespacesGetForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetForAuthenticatedUserResponse = Response<
  | CodespacesGetForAuthenticatedUser200ResponseBody
  | CodespacesGetForAuthenticatedUser401ResponseBody
  | CodespacesGetForAuthenticatedUser403ResponseBody
  | CodespacesGetForAuthenticatedUser404ResponseBody
  | CodespacesGetForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export interface CodespacesGetForAuthenticatedUserHandler {
  codespacesGetForAuthenticatedUser(
    req: CodespacesGetForAuthenticatedUserRequest,
    res: CodespacesGetForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesUpdateForAuthenticatedUserRequest = Request<
  CodespacesUpdateForAuthenticatedUserRequestPath,
  | CodespacesUpdateForAuthenticatedUser200ResponseBody
  | CodespacesUpdateForAuthenticatedUser401ResponseBody
  | CodespacesUpdateForAuthenticatedUser403ResponseBody
  | CodespacesUpdateForAuthenticatedUser404ResponseBody,
  CodespacesUpdateForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesUpdateForAuthenticatedUserResponse = Response<
  | CodespacesUpdateForAuthenticatedUser200ResponseBody
  | CodespacesUpdateForAuthenticatedUser401ResponseBody
  | CodespacesUpdateForAuthenticatedUser403ResponseBody
  | CodespacesUpdateForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404
>;

export interface CodespacesUpdateForAuthenticatedUserHandler {
  codespacesUpdateForAuthenticatedUser(
    req: CodespacesUpdateForAuthenticatedUserRequest,
    res: CodespacesUpdateForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesDeleteForAuthenticatedUserRequest = Request<
  CodespacesDeleteForAuthenticatedUserRequestPath,
  | CodespacesDeleteForAuthenticatedUser202ResponseBody
  | CodespacesDeleteForAuthenticatedUser401ResponseBody
  | CodespacesDeleteForAuthenticatedUser403ResponseBody
  | CodespacesDeleteForAuthenticatedUser404ResponseBody
  | CodespacesDeleteForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesDeleteForAuthenticatedUserResponse = Response<
  | CodespacesDeleteForAuthenticatedUser202ResponseBody
  | CodespacesDeleteForAuthenticatedUser401ResponseBody
  | CodespacesDeleteForAuthenticatedUser403ResponseBody
  | CodespacesDeleteForAuthenticatedUser404ResponseBody
  | CodespacesDeleteForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  202 | 304 | 401 | 403 | 404 | 500
>;

export interface CodespacesDeleteForAuthenticatedUserHandler {
  codespacesDeleteForAuthenticatedUser(
    req: CodespacesDeleteForAuthenticatedUserRequest,
    res: CodespacesDeleteForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesExportForAuthenticatedUserRequest = Request<
  CodespacesExportForAuthenticatedUserRequestPath,
  | CodespacesExportForAuthenticatedUser202ResponseBody
  | CodespacesExportForAuthenticatedUser401ResponseBody
  | CodespacesExportForAuthenticatedUser403ResponseBody
  | CodespacesExportForAuthenticatedUser404ResponseBody
  | CodespacesExportForAuthenticatedUser422ResponseBody
  | CodespacesExportForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesExportForAuthenticatedUserResponse = Response<
  | CodespacesExportForAuthenticatedUser202ResponseBody
  | CodespacesExportForAuthenticatedUser401ResponseBody
  | CodespacesExportForAuthenticatedUser403ResponseBody
  | CodespacesExportForAuthenticatedUser404ResponseBody
  | CodespacesExportForAuthenticatedUser422ResponseBody
  | CodespacesExportForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  202 | 401 | 403 | 404 | 422 | 500
>;

export interface CodespacesExportForAuthenticatedUserHandler {
  codespacesExportForAuthenticatedUser(
    req: CodespacesExportForAuthenticatedUserRequest,
    res: CodespacesExportForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesGetExportDetailsForAuthenticatedUserRequest = Request<
  CodespacesGetExportDetailsForAuthenticatedUserRequestPath,
  | CodespacesGetExportDetailsForAuthenticatedUser200ResponseBody
  | CodespacesGetExportDetailsForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesGetExportDetailsForAuthenticatedUserResponse = Response<
  | CodespacesGetExportDetailsForAuthenticatedUser200ResponseBody
  | CodespacesGetExportDetailsForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface CodespacesGetExportDetailsForAuthenticatedUserHandler {
  codespacesGetExportDetailsForAuthenticatedUser(
    req: CodespacesGetExportDetailsForAuthenticatedUserRequest,
    res: CodespacesGetExportDetailsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesCodespaceMachinesForAuthenticatedUserRequest = Request<
  CodespacesCodespaceMachinesForAuthenticatedUserRequestPath,
  | CodespacesCodespaceMachinesForAuthenticatedUser200ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser401ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser403ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser404ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesCodespaceMachinesForAuthenticatedUserResponse = Response<
  | CodespacesCodespaceMachinesForAuthenticatedUser200ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser401ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser403ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser404ResponseBody
  | CodespacesCodespaceMachinesForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 500
>;

export interface CodespacesCodespaceMachinesForAuthenticatedUserHandler {
  codespacesCodespaceMachinesForAuthenticatedUser(
    req: CodespacesCodespaceMachinesForAuthenticatedUserRequest,
    res: CodespacesCodespaceMachinesForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesStartForAuthenticatedUserRequest = Request<
  CodespacesStartForAuthenticatedUserRequestPath,
  | CodespacesStartForAuthenticatedUser200ResponseBody
  | CodespacesStartForAuthenticatedUser400ResponseBody
  | CodespacesStartForAuthenticatedUser401ResponseBody
  | CodespacesStartForAuthenticatedUser402ResponseBody
  | CodespacesStartForAuthenticatedUser403ResponseBody
  | CodespacesStartForAuthenticatedUser404ResponseBody
  | CodespacesStartForAuthenticatedUser409ResponseBody
  | CodespacesStartForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesStartForAuthenticatedUserResponse = Response<
  | CodespacesStartForAuthenticatedUser200ResponseBody
  | CodespacesStartForAuthenticatedUser400ResponseBody
  | CodespacesStartForAuthenticatedUser401ResponseBody
  | CodespacesStartForAuthenticatedUser402ResponseBody
  | CodespacesStartForAuthenticatedUser403ResponseBody
  | CodespacesStartForAuthenticatedUser404ResponseBody
  | CodespacesStartForAuthenticatedUser409ResponseBody
  | CodespacesStartForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 304 | 400 | 401 | 402 | 403 | 404 | 409 | 500
>;

export interface CodespacesStartForAuthenticatedUserHandler {
  codespacesStartForAuthenticatedUser(
    req: CodespacesStartForAuthenticatedUserRequest,
    res: CodespacesStartForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type CodespacesStopForAuthenticatedUserRequest = Request<
  CodespacesStopForAuthenticatedUserRequestPath,
  | CodespacesStopForAuthenticatedUser200ResponseBody
  | CodespacesStopForAuthenticatedUser401ResponseBody
  | CodespacesStopForAuthenticatedUser403ResponseBody
  | CodespacesStopForAuthenticatedUser404ResponseBody
  | CodespacesStopForAuthenticatedUser500ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type CodespacesStopForAuthenticatedUserResponse = Response<
  | CodespacesStopForAuthenticatedUser200ResponseBody
  | CodespacesStopForAuthenticatedUser401ResponseBody
  | CodespacesStopForAuthenticatedUser403ResponseBody
  | CodespacesStopForAuthenticatedUser404ResponseBody
  | CodespacesStopForAuthenticatedUser500ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404 | 500
>;

export interface CodespacesStopForAuthenticatedUserHandler {
  codespacesStopForAuthenticatedUser(
    req: CodespacesStopForAuthenticatedUserRequest,
    res: CodespacesStopForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser200ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser401ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser403ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser404ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser422ResponseBody,
  UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse = Response<
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser200ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser401ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser403ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser404ResponseBody
  | UsersSetPrimaryEmailVisibilityForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404 | 422
>;

export interface UsersSetPrimaryEmailVisibilityForAuthenticatedUserHandler {
  usersSetPrimaryEmailVisibilityForAuthenticatedUser(
    req: UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequest,
    res: UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListEmailsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListEmailsForAuthenticatedUser200ResponseBody
  | UsersListEmailsForAuthenticatedUser401ResponseBody
  | UsersListEmailsForAuthenticatedUser403ResponseBody
  | UsersListEmailsForAuthenticatedUser404ResponseBody,
  unknown,
  UsersListEmailsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListEmailsForAuthenticatedUserResponse = Response<
  | UsersListEmailsForAuthenticatedUser200ResponseBody
  | UsersListEmailsForAuthenticatedUser401ResponseBody
  | UsersListEmailsForAuthenticatedUser403ResponseBody
  | UsersListEmailsForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export interface UsersListEmailsForAuthenticatedUserHandler {
  usersListEmailsForAuthenticatedUser(
    req: UsersListEmailsForAuthenticatedUserRequest,
    res: UsersListEmailsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersAddEmailForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersAddEmailForAuthenticatedUser201ResponseBody
  | UsersAddEmailForAuthenticatedUser401ResponseBody
  | UsersAddEmailForAuthenticatedUser403ResponseBody
  | UsersAddEmailForAuthenticatedUser404ResponseBody
  | UsersAddEmailForAuthenticatedUser422ResponseBody,
  UsersAddEmailForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersAddEmailForAuthenticatedUserResponse = Response<
  | UsersAddEmailForAuthenticatedUser201ResponseBody
  | UsersAddEmailForAuthenticatedUser401ResponseBody
  | UsersAddEmailForAuthenticatedUser403ResponseBody
  | UsersAddEmailForAuthenticatedUser404ResponseBody
  | UsersAddEmailForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 404 | 422
>;

export interface UsersAddEmailForAuthenticatedUserHandler {
  usersAddEmailForAuthenticatedUser(
    req: UsersAddEmailForAuthenticatedUserRequest,
    res: UsersAddEmailForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersDeleteEmailForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersDeleteEmailForAuthenticatedUser401ResponseBody
  | UsersDeleteEmailForAuthenticatedUser403ResponseBody
  | UsersDeleteEmailForAuthenticatedUser404ResponseBody
  | UsersDeleteEmailForAuthenticatedUser422ResponseBody,
  UsersDeleteEmailForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersDeleteEmailForAuthenticatedUserResponse = Response<
  | UsersDeleteEmailForAuthenticatedUser401ResponseBody
  | UsersDeleteEmailForAuthenticatedUser403ResponseBody
  | UsersDeleteEmailForAuthenticatedUser404ResponseBody
  | UsersDeleteEmailForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404 | 422
>;

export interface UsersDeleteEmailForAuthenticatedUserHandler {
  usersDeleteEmailForAuthenticatedUser(
    req: UsersDeleteEmailForAuthenticatedUserRequest,
    res: UsersDeleteEmailForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListFollowersForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListFollowersForAuthenticatedUser200ResponseBody
  | UsersListFollowersForAuthenticatedUser401ResponseBody
  | UsersListFollowersForAuthenticatedUser403ResponseBody,
  unknown,
  UsersListFollowersForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListFollowersForAuthenticatedUserResponse = Response<
  | UsersListFollowersForAuthenticatedUser200ResponseBody
  | UsersListFollowersForAuthenticatedUser401ResponseBody
  | UsersListFollowersForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface UsersListFollowersForAuthenticatedUserHandler {
  usersListFollowersForAuthenticatedUser(
    req: UsersListFollowersForAuthenticatedUserRequest,
    res: UsersListFollowersForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListFollowedByAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListFollowedByAuthenticatedUser200ResponseBody
  | UsersListFollowedByAuthenticatedUser401ResponseBody
  | UsersListFollowedByAuthenticatedUser403ResponseBody,
  unknown,
  UsersListFollowedByAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListFollowedByAuthenticatedUserResponse = Response<
  | UsersListFollowedByAuthenticatedUser200ResponseBody
  | UsersListFollowedByAuthenticatedUser401ResponseBody
  | UsersListFollowedByAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface UsersListFollowedByAuthenticatedUserHandler {
  usersListFollowedByAuthenticatedUser(
    req: UsersListFollowedByAuthenticatedUserRequest,
    res: UsersListFollowedByAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersCheckPersonIsFollowedByAuthenticatedRequest = Request<
  UsersCheckPersonIsFollowedByAuthenticatedRequestPath,
  | UsersCheckPersonIsFollowedByAuthenticated401ResponseBody
  | UsersCheckPersonIsFollowedByAuthenticated403ResponseBody
  | UsersCheckPersonIsFollowedByAuthenticated404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersCheckPersonIsFollowedByAuthenticatedResponse = Response<
  | UsersCheckPersonIsFollowedByAuthenticated401ResponseBody
  | UsersCheckPersonIsFollowedByAuthenticated403ResponseBody
  | UsersCheckPersonIsFollowedByAuthenticated404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export interface UsersCheckPersonIsFollowedByAuthenticatedHandler {
  usersCheckPersonIsFollowedByAuthenticated(
    req: UsersCheckPersonIsFollowedByAuthenticatedRequest,
    res: UsersCheckPersonIsFollowedByAuthenticatedResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersFollowRequest = Request<
  UsersFollowRequestPath,
  | UsersFollow401ResponseBody
  | UsersFollow403ResponseBody
  | UsersFollow404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersFollowResponse = Response<
  | UsersFollow401ResponseBody
  | UsersFollow403ResponseBody
  | UsersFollow404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export interface UsersFollowHandler {
  usersFollow(
    req: UsersFollowRequest,
    res: UsersFollowResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersUnfollowRequest = Request<
  UsersUnfollowRequestPath,
  | UsersUnfollow401ResponseBody
  | UsersUnfollow403ResponseBody
  | UsersUnfollow404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersUnfollowResponse = Response<
  | UsersUnfollow401ResponseBody
  | UsersUnfollow403ResponseBody
  | UsersUnfollow404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export interface UsersUnfollowHandler {
  usersUnfollow(
    req: UsersUnfollowRequest,
    res: UsersUnfollowResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListGpgKeysForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListGpgKeysForAuthenticatedUser200ResponseBody
  | UsersListGpgKeysForAuthenticatedUser401ResponseBody
  | UsersListGpgKeysForAuthenticatedUser403ResponseBody
  | UsersListGpgKeysForAuthenticatedUser404ResponseBody,
  unknown,
  UsersListGpgKeysForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListGpgKeysForAuthenticatedUserResponse = Response<
  | UsersListGpgKeysForAuthenticatedUser200ResponseBody
  | UsersListGpgKeysForAuthenticatedUser401ResponseBody
  | UsersListGpgKeysForAuthenticatedUser403ResponseBody
  | UsersListGpgKeysForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export interface UsersListGpgKeysForAuthenticatedUserHandler {
  usersListGpgKeysForAuthenticatedUser(
    req: UsersListGpgKeysForAuthenticatedUserRequest,
    res: UsersListGpgKeysForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersCreateGpgKeyForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersCreateGpgKeyForAuthenticatedUser201ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser401ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser403ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser404ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser422ResponseBody,
  UsersCreateGpgKeyForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersCreateGpgKeyForAuthenticatedUserResponse = Response<
  | UsersCreateGpgKeyForAuthenticatedUser201ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser401ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser403ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser404ResponseBody
  | UsersCreateGpgKeyForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 404 | 422
>;

export interface UsersCreateGpgKeyForAuthenticatedUserHandler {
  usersCreateGpgKeyForAuthenticatedUser(
    req: UsersCreateGpgKeyForAuthenticatedUserRequest,
    res: UsersCreateGpgKeyForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersGetGpgKeyForAuthenticatedUserRequest = Request<
  UsersGetGpgKeyForAuthenticatedUserRequestPath,
  | UsersGetGpgKeyForAuthenticatedUser200ResponseBody
  | UsersGetGpgKeyForAuthenticatedUser401ResponseBody
  | UsersGetGpgKeyForAuthenticatedUser403ResponseBody
  | UsersGetGpgKeyForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersGetGpgKeyForAuthenticatedUserResponse = Response<
  | UsersGetGpgKeyForAuthenticatedUser200ResponseBody
  | UsersGetGpgKeyForAuthenticatedUser401ResponseBody
  | UsersGetGpgKeyForAuthenticatedUser403ResponseBody
  | UsersGetGpgKeyForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export interface UsersGetGpgKeyForAuthenticatedUserHandler {
  usersGetGpgKeyForAuthenticatedUser(
    req: UsersGetGpgKeyForAuthenticatedUserRequest,
    res: UsersGetGpgKeyForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersDeleteGpgKeyForAuthenticatedUserRequest = Request<
  UsersDeleteGpgKeyForAuthenticatedUserRequestPath,
  | UsersDeleteGpgKeyForAuthenticatedUser401ResponseBody
  | UsersDeleteGpgKeyForAuthenticatedUser403ResponseBody
  | UsersDeleteGpgKeyForAuthenticatedUser404ResponseBody
  | UsersDeleteGpgKeyForAuthenticatedUser422ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersDeleteGpgKeyForAuthenticatedUserResponse = Response<
  | UsersDeleteGpgKeyForAuthenticatedUser401ResponseBody
  | UsersDeleteGpgKeyForAuthenticatedUser403ResponseBody
  | UsersDeleteGpgKeyForAuthenticatedUser404ResponseBody
  | UsersDeleteGpgKeyForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404 | 422
>;

export interface UsersDeleteGpgKeyForAuthenticatedUserHandler {
  usersDeleteGpgKeyForAuthenticatedUser(
    req: UsersDeleteGpgKeyForAuthenticatedUserRequest,
    res: UsersDeleteGpgKeyForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsListInstallationsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | AppsListInstallationsForAuthenticatedUser200ResponseBody
  | AppsListInstallationsForAuthenticatedUser401ResponseBody
  | AppsListInstallationsForAuthenticatedUser403ResponseBody,
  unknown,
  AppsListInstallationsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type AppsListInstallationsForAuthenticatedUserResponse = Response<
  | AppsListInstallationsForAuthenticatedUser200ResponseBody
  | AppsListInstallationsForAuthenticatedUser401ResponseBody
  | AppsListInstallationsForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface AppsListInstallationsForAuthenticatedUserHandler {
  appsListInstallationsForAuthenticatedUser(
    req: AppsListInstallationsForAuthenticatedUserRequest,
    res: AppsListInstallationsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsListInstallationReposForAuthenticatedUserRequest = Request<
  AppsListInstallationReposForAuthenticatedUserRequestPath,
  | AppsListInstallationReposForAuthenticatedUser200ResponseBody
  | AppsListInstallationReposForAuthenticatedUser403ResponseBody
  | AppsListInstallationReposForAuthenticatedUser404ResponseBody,
  unknown,
  AppsListInstallationReposForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type AppsListInstallationReposForAuthenticatedUserResponse = Response<
  | AppsListInstallationReposForAuthenticatedUser200ResponseBody
  | AppsListInstallationReposForAuthenticatedUser403ResponseBody
  | AppsListInstallationReposForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export interface AppsListInstallationReposForAuthenticatedUserHandler {
  appsListInstallationReposForAuthenticatedUser(
    req: AppsListInstallationReposForAuthenticatedUserRequest,
    res: AppsListInstallationReposForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsAddRepoToInstallationForAuthenticatedUserRequest = Request<
  AppsAddRepoToInstallationForAuthenticatedUserRequestPath,
  | AppsAddRepoToInstallationForAuthenticatedUser403ResponseBody
  | AppsAddRepoToInstallationForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsAddRepoToInstallationForAuthenticatedUserResponse = Response<
  | AppsAddRepoToInstallationForAuthenticatedUser403ResponseBody
  | AppsAddRepoToInstallationForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export interface AppsAddRepoToInstallationForAuthenticatedUserHandler {
  appsAddRepoToInstallationForAuthenticatedUser(
    req: AppsAddRepoToInstallationForAuthenticatedUserRequest,
    res: AppsAddRepoToInstallationForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsRemoveRepoFromInstallationForAuthenticatedUserRequest = Request<
  AppsRemoveRepoFromInstallationForAuthenticatedUserRequestPath,
  | AppsRemoveRepoFromInstallationForAuthenticatedUser403ResponseBody
  | AppsRemoveRepoFromInstallationForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsRemoveRepoFromInstallationForAuthenticatedUserResponse = Response<
  | AppsRemoveRepoFromInstallationForAuthenticatedUser403ResponseBody
  | AppsRemoveRepoFromInstallationForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404
>;

export interface AppsRemoveRepoFromInstallationForAuthenticatedUserHandler {
  appsRemoveRepoFromInstallationForAuthenticatedUser(
    req: AppsRemoveRepoFromInstallationForAuthenticatedUserRequest,
    res: AppsRemoveRepoFromInstallationForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type InteractionsGetRestrictionsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  InteractionsGetRestrictionsForAuthenticatedUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsGetRestrictionsForAuthenticatedUserResponse = Response<
  InteractionsGetRestrictionsForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200 | 204
>;

export interface InteractionsGetRestrictionsForAuthenticatedUserHandler {
  interactionsGetRestrictionsForAuthenticatedUser(
    req: InteractionsGetRestrictionsForAuthenticatedUserRequest,
    res: InteractionsGetRestrictionsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type InteractionsSetRestrictionsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | InteractionsSetRestrictionsForAuthenticatedUser200ResponseBody
  | InteractionsSetRestrictionsForAuthenticatedUser422ResponseBody,
  InteractionsSetRestrictionsForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsSetRestrictionsForAuthenticatedUserResponse = Response<
  | InteractionsSetRestrictionsForAuthenticatedUser200ResponseBody
  | InteractionsSetRestrictionsForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface InteractionsSetRestrictionsForAuthenticatedUserHandler {
  interactionsSetRestrictionsForAuthenticatedUser(
    req: InteractionsSetRestrictionsForAuthenticatedUserRequest,
    res: InteractionsSetRestrictionsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type InteractionsRemoveRestrictionsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type InteractionsRemoveRestrictionsForAuthenticatedUserResponse = Response<
  unknown,
  Record<string, any>,
  204
>;

export interface InteractionsRemoveRestrictionsForAuthenticatedUserHandler {
  interactionsRemoveRestrictionsForAuthenticatedUser(
    req: InteractionsRemoveRestrictionsForAuthenticatedUserRequest,
    res: InteractionsRemoveRestrictionsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type IssuesListForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | IssuesListForAuthenticatedUser200ResponseBody
  | IssuesListForAuthenticatedUser404ResponseBody,
  unknown,
  IssuesListForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type IssuesListForAuthenticatedUserResponse = Response<
  | IssuesListForAuthenticatedUser200ResponseBody
  | IssuesListForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 404
>;

export interface IssuesListForAuthenticatedUserHandler {
  issuesListForAuthenticatedUser(
    req: IssuesListForAuthenticatedUserRequest,
    res: IssuesListForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListPublicSshKeysForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListPublicSshKeysForAuthenticatedUser200ResponseBody
  | UsersListPublicSshKeysForAuthenticatedUser401ResponseBody
  | UsersListPublicSshKeysForAuthenticatedUser403ResponseBody
  | UsersListPublicSshKeysForAuthenticatedUser404ResponseBody,
  unknown,
  UsersListPublicSshKeysForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListPublicSshKeysForAuthenticatedUserResponse = Response<
  | UsersListPublicSshKeysForAuthenticatedUser200ResponseBody
  | UsersListPublicSshKeysForAuthenticatedUser401ResponseBody
  | UsersListPublicSshKeysForAuthenticatedUser403ResponseBody
  | UsersListPublicSshKeysForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export interface UsersListPublicSshKeysForAuthenticatedUserHandler {
  usersListPublicSshKeysForAuthenticatedUser(
    req: UsersListPublicSshKeysForAuthenticatedUserRequest,
    res: UsersListPublicSshKeysForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersCreatePublicSshKeyForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersCreatePublicSshKeyForAuthenticatedUser201ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser401ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser403ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser404ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser422ResponseBody,
  UsersCreatePublicSshKeyForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersCreatePublicSshKeyForAuthenticatedUserResponse = Response<
  | UsersCreatePublicSshKeyForAuthenticatedUser201ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser401ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser403ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser404ResponseBody
  | UsersCreatePublicSshKeyForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 404 | 422
>;

export interface UsersCreatePublicSshKeyForAuthenticatedUserHandler {
  usersCreatePublicSshKeyForAuthenticatedUser(
    req: UsersCreatePublicSshKeyForAuthenticatedUserRequest,
    res: UsersCreatePublicSshKeyForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersGetPublicSshKeyForAuthenticatedUserRequest = Request<
  UsersGetPublicSshKeyForAuthenticatedUserRequestPath,
  | UsersGetPublicSshKeyForAuthenticatedUser200ResponseBody
  | UsersGetPublicSshKeyForAuthenticatedUser401ResponseBody
  | UsersGetPublicSshKeyForAuthenticatedUser403ResponseBody
  | UsersGetPublicSshKeyForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersGetPublicSshKeyForAuthenticatedUserResponse = Response<
  | UsersGetPublicSshKeyForAuthenticatedUser200ResponseBody
  | UsersGetPublicSshKeyForAuthenticatedUser401ResponseBody
  | UsersGetPublicSshKeyForAuthenticatedUser403ResponseBody
  | UsersGetPublicSshKeyForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export interface UsersGetPublicSshKeyForAuthenticatedUserHandler {
  usersGetPublicSshKeyForAuthenticatedUser(
    req: UsersGetPublicSshKeyForAuthenticatedUserRequest,
    res: UsersGetPublicSshKeyForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersDeletePublicSshKeyForAuthenticatedUserRequest = Request<
  UsersDeletePublicSshKeyForAuthenticatedUserRequestPath,
  | UsersDeletePublicSshKeyForAuthenticatedUser401ResponseBody
  | UsersDeletePublicSshKeyForAuthenticatedUser403ResponseBody
  | UsersDeletePublicSshKeyForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersDeletePublicSshKeyForAuthenticatedUserResponse = Response<
  | UsersDeletePublicSshKeyForAuthenticatedUser401ResponseBody
  | UsersDeletePublicSshKeyForAuthenticatedUser403ResponseBody
  | UsersDeletePublicSshKeyForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export interface UsersDeletePublicSshKeyForAuthenticatedUserHandler {
  usersDeletePublicSshKeyForAuthenticatedUser(
    req: UsersDeletePublicSshKeyForAuthenticatedUserRequest,
    res: UsersDeletePublicSshKeyForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsListSubscriptionsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | AppsListSubscriptionsForAuthenticatedUser200ResponseBody
  | AppsListSubscriptionsForAuthenticatedUser401ResponseBody
  | AppsListSubscriptionsForAuthenticatedUser404ResponseBody,
  unknown,
  AppsListSubscriptionsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type AppsListSubscriptionsForAuthenticatedUserResponse = Response<
  | AppsListSubscriptionsForAuthenticatedUser200ResponseBody
  | AppsListSubscriptionsForAuthenticatedUser401ResponseBody
  | AppsListSubscriptionsForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 404
>;

export interface AppsListSubscriptionsForAuthenticatedUserHandler {
  appsListSubscriptionsForAuthenticatedUser(
    req: AppsListSubscriptionsForAuthenticatedUserRequest,
    res: AppsListSubscriptionsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsListSubscriptionsForAuthenticatedUserStubbedRequest = Request<
  ParamsDictionary,
  | AppsListSubscriptionsForAuthenticatedUserStubbed200ResponseBody
  | AppsListSubscriptionsForAuthenticatedUserStubbed401ResponseBody,
  unknown,
  AppsListSubscriptionsForAuthenticatedUserStubbedRequestQuery,
  Record<string, any>
>;

export type AppsListSubscriptionsForAuthenticatedUserStubbedResponse = Response<
  | AppsListSubscriptionsForAuthenticatedUserStubbed200ResponseBody
  | AppsListSubscriptionsForAuthenticatedUserStubbed401ResponseBody,
  Record<string, any>,
  200 | 304 | 401
>;

export interface AppsListSubscriptionsForAuthenticatedUserStubbedHandler {
  appsListSubscriptionsForAuthenticatedUserStubbed(
    req: AppsListSubscriptionsForAuthenticatedUserStubbedRequest,
    res: AppsListSubscriptionsForAuthenticatedUserStubbedResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListMembershipsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | OrgsListMembershipsForAuthenticatedUser200ResponseBody
  | OrgsListMembershipsForAuthenticatedUser401ResponseBody
  | OrgsListMembershipsForAuthenticatedUser403ResponseBody
  | OrgsListMembershipsForAuthenticatedUser422ResponseBody,
  unknown,
  OrgsListMembershipsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type OrgsListMembershipsForAuthenticatedUserResponse = Response<
  | OrgsListMembershipsForAuthenticatedUser200ResponseBody
  | OrgsListMembershipsForAuthenticatedUser401ResponseBody
  | OrgsListMembershipsForAuthenticatedUser403ResponseBody
  | OrgsListMembershipsForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 422
>;

export interface OrgsListMembershipsForAuthenticatedUserHandler {
  orgsListMembershipsForAuthenticatedUser(
    req: OrgsListMembershipsForAuthenticatedUserRequest,
    res: OrgsListMembershipsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsGetMembershipForAuthenticatedUserRequest = Request<
  OrgsGetMembershipForAuthenticatedUserRequestPath,
  | OrgsGetMembershipForAuthenticatedUser200ResponseBody
  | OrgsGetMembershipForAuthenticatedUser403ResponseBody
  | OrgsGetMembershipForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type OrgsGetMembershipForAuthenticatedUserResponse = Response<
  | OrgsGetMembershipForAuthenticatedUser200ResponseBody
  | OrgsGetMembershipForAuthenticatedUser403ResponseBody
  | OrgsGetMembershipForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 403 | 404
>;

export interface OrgsGetMembershipForAuthenticatedUserHandler {
  orgsGetMembershipForAuthenticatedUser(
    req: OrgsGetMembershipForAuthenticatedUserRequest,
    res: OrgsGetMembershipForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsUpdateMembershipForAuthenticatedUserRequest = Request<
  OrgsUpdateMembershipForAuthenticatedUserRequestPath,
  | OrgsUpdateMembershipForAuthenticatedUser200ResponseBody
  | OrgsUpdateMembershipForAuthenticatedUser403ResponseBody
  | OrgsUpdateMembershipForAuthenticatedUser404ResponseBody
  | OrgsUpdateMembershipForAuthenticatedUser422ResponseBody,
  OrgsUpdateMembershipForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type OrgsUpdateMembershipForAuthenticatedUserResponse = Response<
  | OrgsUpdateMembershipForAuthenticatedUser200ResponseBody
  | OrgsUpdateMembershipForAuthenticatedUser403ResponseBody
  | OrgsUpdateMembershipForAuthenticatedUser404ResponseBody
  | OrgsUpdateMembershipForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  200 | 403 | 404 | 422
>;

export interface OrgsUpdateMembershipForAuthenticatedUserHandler {
  orgsUpdateMembershipForAuthenticatedUser(
    req: OrgsUpdateMembershipForAuthenticatedUserRequest,
    res: OrgsUpdateMembershipForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsListForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | MigrationsListForAuthenticatedUser200ResponseBody
  | MigrationsListForAuthenticatedUser401ResponseBody
  | MigrationsListForAuthenticatedUser403ResponseBody,
  unknown,
  MigrationsListForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type MigrationsListForAuthenticatedUserResponse = Response<
  | MigrationsListForAuthenticatedUser200ResponseBody
  | MigrationsListForAuthenticatedUser401ResponseBody
  | MigrationsListForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface MigrationsListForAuthenticatedUserHandler {
  migrationsListForAuthenticatedUser(
    req: MigrationsListForAuthenticatedUserRequest,
    res: MigrationsListForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsStartForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | MigrationsStartForAuthenticatedUser201ResponseBody
  | MigrationsStartForAuthenticatedUser401ResponseBody
  | MigrationsStartForAuthenticatedUser403ResponseBody
  | MigrationsStartForAuthenticatedUser422ResponseBody,
  MigrationsStartForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsStartForAuthenticatedUserResponse = Response<
  | MigrationsStartForAuthenticatedUser201ResponseBody
  | MigrationsStartForAuthenticatedUser401ResponseBody
  | MigrationsStartForAuthenticatedUser403ResponseBody
  | MigrationsStartForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 422
>;

export interface MigrationsStartForAuthenticatedUserHandler {
  migrationsStartForAuthenticatedUser(
    req: MigrationsStartForAuthenticatedUserRequest,
    res: MigrationsStartForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsGetStatusForAuthenticatedUserRequest = Request<
  MigrationsGetStatusForAuthenticatedUserRequestPath,
  | MigrationsGetStatusForAuthenticatedUser200ResponseBody
  | MigrationsGetStatusForAuthenticatedUser401ResponseBody
  | MigrationsGetStatusForAuthenticatedUser403ResponseBody
  | MigrationsGetStatusForAuthenticatedUser404ResponseBody,
  unknown,
  MigrationsGetStatusForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type MigrationsGetStatusForAuthenticatedUserResponse = Response<
  | MigrationsGetStatusForAuthenticatedUser200ResponseBody
  | MigrationsGetStatusForAuthenticatedUser401ResponseBody
  | MigrationsGetStatusForAuthenticatedUser403ResponseBody
  | MigrationsGetStatusForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export interface MigrationsGetStatusForAuthenticatedUserHandler {
  migrationsGetStatusForAuthenticatedUser(
    req: MigrationsGetStatusForAuthenticatedUserRequest,
    res: MigrationsGetStatusForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsGetArchiveForAuthenticatedUserRequest = Request<
  MigrationsGetArchiveForAuthenticatedUserRequestPath,
  | MigrationsGetArchiveForAuthenticatedUser401ResponseBody
  | MigrationsGetArchiveForAuthenticatedUser403ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsGetArchiveForAuthenticatedUserResponse = Response<
  | MigrationsGetArchiveForAuthenticatedUser401ResponseBody
  | MigrationsGetArchiveForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  302 | 304 | 401 | 403
>;

export interface MigrationsGetArchiveForAuthenticatedUserHandler {
  migrationsGetArchiveForAuthenticatedUser(
    req: MigrationsGetArchiveForAuthenticatedUserRequest,
    res: MigrationsGetArchiveForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsDeleteArchiveForAuthenticatedUserRequest = Request<
  MigrationsDeleteArchiveForAuthenticatedUserRequestPath,
  | MigrationsDeleteArchiveForAuthenticatedUser401ResponseBody
  | MigrationsDeleteArchiveForAuthenticatedUser403ResponseBody
  | MigrationsDeleteArchiveForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsDeleteArchiveForAuthenticatedUserResponse = Response<
  | MigrationsDeleteArchiveForAuthenticatedUser401ResponseBody
  | MigrationsDeleteArchiveForAuthenticatedUser403ResponseBody
  | MigrationsDeleteArchiveForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export interface MigrationsDeleteArchiveForAuthenticatedUserHandler {
  migrationsDeleteArchiveForAuthenticatedUser(
    req: MigrationsDeleteArchiveForAuthenticatedUserRequest,
    res: MigrationsDeleteArchiveForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsUnlockRepoForAuthenticatedUserRequest = Request<
  MigrationsUnlockRepoForAuthenticatedUserRequestPath,
  | MigrationsUnlockRepoForAuthenticatedUser401ResponseBody
  | MigrationsUnlockRepoForAuthenticatedUser403ResponseBody
  | MigrationsUnlockRepoForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MigrationsUnlockRepoForAuthenticatedUserResponse = Response<
  | MigrationsUnlockRepoForAuthenticatedUser401ResponseBody
  | MigrationsUnlockRepoForAuthenticatedUser403ResponseBody
  | MigrationsUnlockRepoForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export interface MigrationsUnlockRepoForAuthenticatedUserHandler {
  migrationsUnlockRepoForAuthenticatedUser(
    req: MigrationsUnlockRepoForAuthenticatedUserRequest,
    res: MigrationsUnlockRepoForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MigrationsListReposForAuthenticatedUserRequest = Request<
  MigrationsListReposForAuthenticatedUserRequestPath,
  | MigrationsListReposForAuthenticatedUser200ResponseBody
  | MigrationsListReposForAuthenticatedUser404ResponseBody,
  unknown,
  MigrationsListReposForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type MigrationsListReposForAuthenticatedUserResponse = Response<
  | MigrationsListReposForAuthenticatedUser200ResponseBody
  | MigrationsListReposForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface MigrationsListReposForAuthenticatedUserHandler {
  migrationsListReposForAuthenticatedUser(
    req: MigrationsListReposForAuthenticatedUserRequest,
    res: MigrationsListReposForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | OrgsListForAuthenticatedUser200ResponseBody
  | OrgsListForAuthenticatedUser401ResponseBody
  | OrgsListForAuthenticatedUser403ResponseBody,
  unknown,
  OrgsListForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type OrgsListForAuthenticatedUserResponse = Response<
  | OrgsListForAuthenticatedUser200ResponseBody
  | OrgsListForAuthenticatedUser401ResponseBody
  | OrgsListForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface OrgsListForAuthenticatedUserHandler {
  orgsListForAuthenticatedUser(
    req: OrgsListForAuthenticatedUserRequest,
    res: OrgsListForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesListPackagesForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  PackagesListPackagesForAuthenticatedUser200ResponseBody,
  unknown,
  PackagesListPackagesForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type PackagesListPackagesForAuthenticatedUserResponse = Response<
  PackagesListPackagesForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface PackagesListPackagesForAuthenticatedUserHandler {
  packagesListPackagesForAuthenticatedUser(
    req: PackagesListPackagesForAuthenticatedUserRequest,
    res: PackagesListPackagesForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesGetPackageForAuthenticatedUserRequest = Request<
  PackagesGetPackageForAuthenticatedUserRequestPath,
  PackagesGetPackageForAuthenticatedUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetPackageForAuthenticatedUserResponse = Response<
  PackagesGetPackageForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface PackagesGetPackageForAuthenticatedUserHandler {
  packagesGetPackageForAuthenticatedUser(
    req: PackagesGetPackageForAuthenticatedUserRequest,
    res: PackagesGetPackageForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesDeletePackageForAuthenticatedUserRequest = Request<
  PackagesDeletePackageForAuthenticatedUserRequestPath,
  | PackagesDeletePackageForAuthenticatedUser401ResponseBody
  | PackagesDeletePackageForAuthenticatedUser403ResponseBody
  | PackagesDeletePackageForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesDeletePackageForAuthenticatedUserResponse = Response<
  | PackagesDeletePackageForAuthenticatedUser401ResponseBody
  | PackagesDeletePackageForAuthenticatedUser403ResponseBody
  | PackagesDeletePackageForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export interface PackagesDeletePackageForAuthenticatedUserHandler {
  packagesDeletePackageForAuthenticatedUser(
    req: PackagesDeletePackageForAuthenticatedUserRequest,
    res: PackagesDeletePackageForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesRestorePackageForAuthenticatedUserRequest = Request<
  PackagesRestorePackageForAuthenticatedUserRequestPath,
  | PackagesRestorePackageForAuthenticatedUser401ResponseBody
  | PackagesRestorePackageForAuthenticatedUser403ResponseBody
  | PackagesRestorePackageForAuthenticatedUser404ResponseBody,
  unknown,
  PackagesRestorePackageForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type PackagesRestorePackageForAuthenticatedUserResponse = Response<
  | PackagesRestorePackageForAuthenticatedUser401ResponseBody
  | PackagesRestorePackageForAuthenticatedUser403ResponseBody
  | PackagesRestorePackageForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export interface PackagesRestorePackageForAuthenticatedUserHandler {
  packagesRestorePackageForAuthenticatedUser(
    req: PackagesRestorePackageForAuthenticatedUserRequest,
    res: PackagesRestorePackageForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest = Request<
  PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequestPath,
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser200ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser401ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser403ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser404ResponseBody,
  unknown,
  PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse = Response<
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser200ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser401ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser403ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404
>;

export interface PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserHandler {
  packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(
    req: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest,
    res: PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesGetPackageVersionForAuthenticatedUserRequest = Request<
  PackagesGetPackageVersionForAuthenticatedUserRequestPath,
  PackagesGetPackageVersionForAuthenticatedUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetPackageVersionForAuthenticatedUserResponse = Response<
  PackagesGetPackageVersionForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface PackagesGetPackageVersionForAuthenticatedUserHandler {
  packagesGetPackageVersionForAuthenticatedUser(
    req: PackagesGetPackageVersionForAuthenticatedUserRequest,
    res: PackagesGetPackageVersionForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesDeletePackageVersionForAuthenticatedUserRequest = Request<
  PackagesDeletePackageVersionForAuthenticatedUserRequestPath,
  | PackagesDeletePackageVersionForAuthenticatedUser401ResponseBody
  | PackagesDeletePackageVersionForAuthenticatedUser403ResponseBody
  | PackagesDeletePackageVersionForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesDeletePackageVersionForAuthenticatedUserResponse = Response<
  | PackagesDeletePackageVersionForAuthenticatedUser401ResponseBody
  | PackagesDeletePackageVersionForAuthenticatedUser403ResponseBody
  | PackagesDeletePackageVersionForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export interface PackagesDeletePackageVersionForAuthenticatedUserHandler {
  packagesDeletePackageVersionForAuthenticatedUser(
    req: PackagesDeletePackageVersionForAuthenticatedUserRequest,
    res: PackagesDeletePackageVersionForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesRestorePackageVersionForAuthenticatedUserRequest = Request<
  PackagesRestorePackageVersionForAuthenticatedUserRequestPath,
  | PackagesRestorePackageVersionForAuthenticatedUser401ResponseBody
  | PackagesRestorePackageVersionForAuthenticatedUser403ResponseBody
  | PackagesRestorePackageVersionForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesRestorePackageVersionForAuthenticatedUserResponse = Response<
  | PackagesRestorePackageVersionForAuthenticatedUser401ResponseBody
  | PackagesRestorePackageVersionForAuthenticatedUser403ResponseBody
  | PackagesRestorePackageVersionForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export interface PackagesRestorePackageVersionForAuthenticatedUserHandler {
  packagesRestorePackageVersionForAuthenticatedUser(
    req: PackagesRestorePackageVersionForAuthenticatedUserRequest,
    res: PackagesRestorePackageVersionForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsCreateForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ProjectsCreateForAuthenticatedUser201ResponseBody
  | ProjectsCreateForAuthenticatedUser401ResponseBody
  | ProjectsCreateForAuthenticatedUser403ResponseBody
  | ProjectsCreateForAuthenticatedUser422ResponseBody,
  ProjectsCreateForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ProjectsCreateForAuthenticatedUserResponse = Response<
  | ProjectsCreateForAuthenticatedUser201ResponseBody
  | ProjectsCreateForAuthenticatedUser401ResponseBody
  | ProjectsCreateForAuthenticatedUser403ResponseBody
  | ProjectsCreateForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 422
>;

export interface ProjectsCreateForAuthenticatedUserHandler {
  projectsCreateForAuthenticatedUser(
    req: ProjectsCreateForAuthenticatedUserRequest,
    res: ProjectsCreateForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListPublicEmailsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListPublicEmailsForAuthenticatedUser200ResponseBody
  | UsersListPublicEmailsForAuthenticatedUser401ResponseBody
  | UsersListPublicEmailsForAuthenticatedUser403ResponseBody
  | UsersListPublicEmailsForAuthenticatedUser404ResponseBody,
  unknown,
  UsersListPublicEmailsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListPublicEmailsForAuthenticatedUserResponse = Response<
  | UsersListPublicEmailsForAuthenticatedUser200ResponseBody
  | UsersListPublicEmailsForAuthenticatedUser401ResponseBody
  | UsersListPublicEmailsForAuthenticatedUser403ResponseBody
  | UsersListPublicEmailsForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export interface UsersListPublicEmailsForAuthenticatedUserHandler {
  usersListPublicEmailsForAuthenticatedUser(
    req: UsersListPublicEmailsForAuthenticatedUserRequest,
    res: UsersListPublicEmailsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ReposListForAuthenticatedUser200ResponseBody
  | ReposListForAuthenticatedUser401ResponseBody
  | ReposListForAuthenticatedUser403ResponseBody
  | ReposListForAuthenticatedUser422ResponseBody,
  unknown,
  ReposListForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ReposListForAuthenticatedUserResponse = Response<
  | ReposListForAuthenticatedUser200ResponseBody
  | ReposListForAuthenticatedUser401ResponseBody
  | ReposListForAuthenticatedUser403ResponseBody
  | ReposListForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 422
>;

export interface ReposListForAuthenticatedUserHandler {
  reposListForAuthenticatedUser(
    req: ReposListForAuthenticatedUserRequest,
    res: ReposListForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposCreateForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ReposCreateForAuthenticatedUser201ResponseBody
  | ReposCreateForAuthenticatedUser400ResponseBody
  | ReposCreateForAuthenticatedUser401ResponseBody
  | ReposCreateForAuthenticatedUser403ResponseBody
  | ReposCreateForAuthenticatedUser404ResponseBody
  | ReposCreateForAuthenticatedUser422ResponseBody,
  ReposCreateForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type ReposCreateForAuthenticatedUserResponse = Response<
  | ReposCreateForAuthenticatedUser201ResponseBody
  | ReposCreateForAuthenticatedUser400ResponseBody
  | ReposCreateForAuthenticatedUser401ResponseBody
  | ReposCreateForAuthenticatedUser403ResponseBody
  | ReposCreateForAuthenticatedUser404ResponseBody
  | ReposCreateForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 400 | 401 | 403 | 404 | 422
>;

export interface ReposCreateForAuthenticatedUserHandler {
  reposCreateForAuthenticatedUser(
    req: ReposCreateForAuthenticatedUserRequest,
    res: ReposCreateForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListInvitationsForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ReposListInvitationsForAuthenticatedUser200ResponseBody
  | ReposListInvitationsForAuthenticatedUser401ResponseBody
  | ReposListInvitationsForAuthenticatedUser403ResponseBody
  | ReposListInvitationsForAuthenticatedUser404ResponseBody,
  unknown,
  ReposListInvitationsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ReposListInvitationsForAuthenticatedUserResponse = Response<
  | ReposListInvitationsForAuthenticatedUser200ResponseBody
  | ReposListInvitationsForAuthenticatedUser401ResponseBody
  | ReposListInvitationsForAuthenticatedUser403ResponseBody
  | ReposListInvitationsForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export interface ReposListInvitationsForAuthenticatedUserHandler {
  reposListInvitationsForAuthenticatedUser(
    req: ReposListInvitationsForAuthenticatedUserRequest,
    res: ReposListInvitationsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposAcceptInvitationForAuthenticatedUserRequest = Request<
  ReposAcceptInvitationForAuthenticatedUserRequestPath,
  | ReposAcceptInvitationForAuthenticatedUser403ResponseBody
  | ReposAcceptInvitationForAuthenticatedUser404ResponseBody
  | ReposAcceptInvitationForAuthenticatedUser409ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposAcceptInvitationForAuthenticatedUserResponse = Response<
  | ReposAcceptInvitationForAuthenticatedUser403ResponseBody
  | ReposAcceptInvitationForAuthenticatedUser404ResponseBody
  | ReposAcceptInvitationForAuthenticatedUser409ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404 | 409
>;

export interface ReposAcceptInvitationForAuthenticatedUserHandler {
  reposAcceptInvitationForAuthenticatedUser(
    req: ReposAcceptInvitationForAuthenticatedUserRequest,
    res: ReposAcceptInvitationForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposDeclineInvitationForAuthenticatedUserRequest = Request<
  ReposDeclineInvitationForAuthenticatedUserRequestPath,
  | ReposDeclineInvitationForAuthenticatedUser403ResponseBody
  | ReposDeclineInvitationForAuthenticatedUser404ResponseBody
  | ReposDeclineInvitationForAuthenticatedUser409ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ReposDeclineInvitationForAuthenticatedUserResponse = Response<
  | ReposDeclineInvitationForAuthenticatedUser403ResponseBody
  | ReposDeclineInvitationForAuthenticatedUser404ResponseBody
  | ReposDeclineInvitationForAuthenticatedUser409ResponseBody,
  Record<string, any>,
  204 | 304 | 403 | 404 | 409
>;

export interface ReposDeclineInvitationForAuthenticatedUserHandler {
  reposDeclineInvitationForAuthenticatedUser(
    req: ReposDeclineInvitationForAuthenticatedUserRequest,
    res: ReposDeclineInvitationForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListSshSigningKeysForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersListSshSigningKeysForAuthenticatedUser200ResponseBody
  | UsersListSshSigningKeysForAuthenticatedUser401ResponseBody
  | UsersListSshSigningKeysForAuthenticatedUser403ResponseBody
  | UsersListSshSigningKeysForAuthenticatedUser404ResponseBody,
  unknown,
  UsersListSshSigningKeysForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type UsersListSshSigningKeysForAuthenticatedUserResponse = Response<
  | UsersListSshSigningKeysForAuthenticatedUser200ResponseBody
  | UsersListSshSigningKeysForAuthenticatedUser401ResponseBody
  | UsersListSshSigningKeysForAuthenticatedUser403ResponseBody
  | UsersListSshSigningKeysForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export interface UsersListSshSigningKeysForAuthenticatedUserHandler {
  usersListSshSigningKeysForAuthenticatedUser(
    req: UsersListSshSigningKeysForAuthenticatedUserRequest,
    res: UsersListSshSigningKeysForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersCreateSshSigningKeyForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | UsersCreateSshSigningKeyForAuthenticatedUser201ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser401ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser403ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser404ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser422ResponseBody,
  UsersCreateSshSigningKeyForAuthenticatedUserRequestBody,
  ParsedQs,
  Record<string, any>
>;

export type UsersCreateSshSigningKeyForAuthenticatedUserResponse = Response<
  | UsersCreateSshSigningKeyForAuthenticatedUser201ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser401ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser403ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser404ResponseBody
  | UsersCreateSshSigningKeyForAuthenticatedUser422ResponseBody,
  Record<string, any>,
  201 | 304 | 401 | 403 | 404 | 422
>;

export interface UsersCreateSshSigningKeyForAuthenticatedUserHandler {
  usersCreateSshSigningKeyForAuthenticatedUser(
    req: UsersCreateSshSigningKeyForAuthenticatedUserRequest,
    res: UsersCreateSshSigningKeyForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersGetSshSigningKeyForAuthenticatedUserRequest = Request<
  UsersGetSshSigningKeyForAuthenticatedUserRequestPath,
  | UsersGetSshSigningKeyForAuthenticatedUser200ResponseBody
  | UsersGetSshSigningKeyForAuthenticatedUser401ResponseBody
  | UsersGetSshSigningKeyForAuthenticatedUser403ResponseBody
  | UsersGetSshSigningKeyForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersGetSshSigningKeyForAuthenticatedUserResponse = Response<
  | UsersGetSshSigningKeyForAuthenticatedUser200ResponseBody
  | UsersGetSshSigningKeyForAuthenticatedUser401ResponseBody
  | UsersGetSshSigningKeyForAuthenticatedUser403ResponseBody
  | UsersGetSshSigningKeyForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403 | 404
>;

export interface UsersGetSshSigningKeyForAuthenticatedUserHandler {
  usersGetSshSigningKeyForAuthenticatedUser(
    req: UsersGetSshSigningKeyForAuthenticatedUserRequest,
    res: UsersGetSshSigningKeyForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersDeleteSshSigningKeyForAuthenticatedUserRequest = Request<
  UsersDeleteSshSigningKeyForAuthenticatedUserRequestPath,
  | UsersDeleteSshSigningKeyForAuthenticatedUser401ResponseBody
  | UsersDeleteSshSigningKeyForAuthenticatedUser403ResponseBody
  | UsersDeleteSshSigningKeyForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersDeleteSshSigningKeyForAuthenticatedUserResponse = Response<
  | UsersDeleteSshSigningKeyForAuthenticatedUser401ResponseBody
  | UsersDeleteSshSigningKeyForAuthenticatedUser403ResponseBody
  | UsersDeleteSshSigningKeyForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export interface UsersDeleteSshSigningKeyForAuthenticatedUserHandler {
  usersDeleteSshSigningKeyForAuthenticatedUser(
    req: UsersDeleteSshSigningKeyForAuthenticatedUserRequest,
    res: UsersDeleteSshSigningKeyForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListReposStarredByAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ActivityListReposStarredByAuthenticatedUser200ResponseBody
  | ActivityListReposStarredByAuthenticatedUser401ResponseBody
  | ActivityListReposStarredByAuthenticatedUser403ResponseBody,
  unknown,
  ActivityListReposStarredByAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ActivityListReposStarredByAuthenticatedUserResponse = Response<
  | ActivityListReposStarredByAuthenticatedUser200ResponseBody
  | ActivityListReposStarredByAuthenticatedUser401ResponseBody
  | ActivityListReposStarredByAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface ActivityListReposStarredByAuthenticatedUserHandler {
  activityListReposStarredByAuthenticatedUser(
    req: ActivityListReposStarredByAuthenticatedUserRequest,
    res: ActivityListReposStarredByAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityCheckRepoIsStarredByAuthenticatedUserRequest = Request<
  ActivityCheckRepoIsStarredByAuthenticatedUserRequestPath,
  | ActivityCheckRepoIsStarredByAuthenticatedUser401ResponseBody
  | ActivityCheckRepoIsStarredByAuthenticatedUser403ResponseBody
  | ActivityCheckRepoIsStarredByAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityCheckRepoIsStarredByAuthenticatedUserResponse = Response<
  | ActivityCheckRepoIsStarredByAuthenticatedUser401ResponseBody
  | ActivityCheckRepoIsStarredByAuthenticatedUser403ResponseBody
  | ActivityCheckRepoIsStarredByAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export interface ActivityCheckRepoIsStarredByAuthenticatedUserHandler {
  activityCheckRepoIsStarredByAuthenticatedUser(
    req: ActivityCheckRepoIsStarredByAuthenticatedUserRequest,
    res: ActivityCheckRepoIsStarredByAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityStarRepoForAuthenticatedUserRequest = Request<
  ActivityStarRepoForAuthenticatedUserRequestPath,
  | ActivityStarRepoForAuthenticatedUser401ResponseBody
  | ActivityStarRepoForAuthenticatedUser403ResponseBody
  | ActivityStarRepoForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityStarRepoForAuthenticatedUserResponse = Response<
  | ActivityStarRepoForAuthenticatedUser401ResponseBody
  | ActivityStarRepoForAuthenticatedUser403ResponseBody
  | ActivityStarRepoForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export interface ActivityStarRepoForAuthenticatedUserHandler {
  activityStarRepoForAuthenticatedUser(
    req: ActivityStarRepoForAuthenticatedUserRequest,
    res: ActivityStarRepoForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityUnstarRepoForAuthenticatedUserRequest = Request<
  ActivityUnstarRepoForAuthenticatedUserRequestPath,
  | ActivityUnstarRepoForAuthenticatedUser401ResponseBody
  | ActivityUnstarRepoForAuthenticatedUser403ResponseBody
  | ActivityUnstarRepoForAuthenticatedUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type ActivityUnstarRepoForAuthenticatedUserResponse = Response<
  | ActivityUnstarRepoForAuthenticatedUser401ResponseBody
  | ActivityUnstarRepoForAuthenticatedUser403ResponseBody
  | ActivityUnstarRepoForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  204 | 304 | 401 | 403 | 404
>;

export interface ActivityUnstarRepoForAuthenticatedUserHandler {
  activityUnstarRepoForAuthenticatedUser(
    req: ActivityUnstarRepoForAuthenticatedUserRequest,
    res: ActivityUnstarRepoForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListWatchedReposForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | ActivityListWatchedReposForAuthenticatedUser200ResponseBody
  | ActivityListWatchedReposForAuthenticatedUser401ResponseBody
  | ActivityListWatchedReposForAuthenticatedUser403ResponseBody,
  unknown,
  ActivityListWatchedReposForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ActivityListWatchedReposForAuthenticatedUserResponse = Response<
  | ActivityListWatchedReposForAuthenticatedUser200ResponseBody
  | ActivityListWatchedReposForAuthenticatedUser401ResponseBody
  | ActivityListWatchedReposForAuthenticatedUser403ResponseBody,
  Record<string, any>,
  200 | 304 | 401 | 403
>;

export interface ActivityListWatchedReposForAuthenticatedUserHandler {
  activityListWatchedReposForAuthenticatedUser(
    req: ActivityListWatchedReposForAuthenticatedUserRequest,
    res: ActivityListWatchedReposForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type TeamsListForAuthenticatedUserRequest = Request<
  ParamsDictionary,
  | TeamsListForAuthenticatedUser200ResponseBody
  | TeamsListForAuthenticatedUser403ResponseBody
  | TeamsListForAuthenticatedUser404ResponseBody,
  unknown,
  TeamsListForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type TeamsListForAuthenticatedUserResponse = Response<
  | TeamsListForAuthenticatedUser200ResponseBody
  | TeamsListForAuthenticatedUser403ResponseBody
  | TeamsListForAuthenticatedUser404ResponseBody,
  Record<string, any>,
  200 | 304 | 403 | 404
>;

export interface TeamsListForAuthenticatedUserHandler {
  teamsListForAuthenticatedUser(
    req: TeamsListForAuthenticatedUserRequest,
    res: TeamsListForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListRequest = Request<
  ParamsDictionary,
  UsersList200ResponseBody,
  unknown,
  UsersListRequestQuery,
  Record<string, any>
>;

export type UsersListResponse = Response<
  UsersList200ResponseBody,
  Record<string, any>,
  200 | 304
>;

export interface UsersListHandler {
  usersList(
    req: UsersListRequest,
    res: UsersListResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersGetByUsernameRequest = Request<
  UsersGetByUsernameRequestPath,
  UsersGetByUsername200ResponseBody | UsersGetByUsername404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersGetByUsernameResponse = Response<
  UsersGetByUsername200ResponseBody | UsersGetByUsername404ResponseBody,
  Record<string, any>,
  200 | 404
>;

export interface UsersGetByUsernameHandler {
  usersGetByUsername(
    req: UsersGetByUsernameRequest,
    res: UsersGetByUsernameResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListEventsForAuthenticatedUserRequest = Request<
  ActivityListEventsForAuthenticatedUserRequestPath,
  ActivityListEventsForAuthenticatedUser200ResponseBody,
  unknown,
  ActivityListEventsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ActivityListEventsForAuthenticatedUserResponse = Response<
  ActivityListEventsForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActivityListEventsForAuthenticatedUserHandler {
  activityListEventsForAuthenticatedUser(
    req: ActivityListEventsForAuthenticatedUserRequest,
    res: ActivityListEventsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListOrgEventsForAuthenticatedUserRequest = Request<
  ActivityListOrgEventsForAuthenticatedUserRequestPath,
  ActivityListOrgEventsForAuthenticatedUser200ResponseBody,
  unknown,
  ActivityListOrgEventsForAuthenticatedUserRequestQuery,
  Record<string, any>
>;

export type ActivityListOrgEventsForAuthenticatedUserResponse = Response<
  ActivityListOrgEventsForAuthenticatedUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActivityListOrgEventsForAuthenticatedUserHandler {
  activityListOrgEventsForAuthenticatedUser(
    req: ActivityListOrgEventsForAuthenticatedUserRequest,
    res: ActivityListOrgEventsForAuthenticatedUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListPublicEventsForUserRequest = Request<
  ActivityListPublicEventsForUserRequestPath,
  ActivityListPublicEventsForUser200ResponseBody,
  unknown,
  ActivityListPublicEventsForUserRequestQuery,
  Record<string, any>
>;

export type ActivityListPublicEventsForUserResponse = Response<
  ActivityListPublicEventsForUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActivityListPublicEventsForUserHandler {
  activityListPublicEventsForUser(
    req: ActivityListPublicEventsForUserRequest,
    res: ActivityListPublicEventsForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListFollowersForUserRequest = Request<
  UsersListFollowersForUserRequestPath,
  UsersListFollowersForUser200ResponseBody,
  unknown,
  UsersListFollowersForUserRequestQuery,
  Record<string, any>
>;

export type UsersListFollowersForUserResponse = Response<
  UsersListFollowersForUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface UsersListFollowersForUserHandler {
  usersListFollowersForUser(
    req: UsersListFollowersForUserRequest,
    res: UsersListFollowersForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListFollowingForUserRequest = Request<
  UsersListFollowingForUserRequestPath,
  UsersListFollowingForUser200ResponseBody,
  unknown,
  UsersListFollowingForUserRequestQuery,
  Record<string, any>
>;

export type UsersListFollowingForUserResponse = Response<
  UsersListFollowingForUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface UsersListFollowingForUserHandler {
  usersListFollowingForUser(
    req: UsersListFollowingForUserRequest,
    res: UsersListFollowingForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersCheckFollowingForUserRequest = Request<
  UsersCheckFollowingForUserRequestPath,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type UsersCheckFollowingForUserResponse = Response<
  unknown,
  Record<string, any>,
  204 | 404
>;

export interface UsersCheckFollowingForUserHandler {
  usersCheckFollowingForUser(
    req: UsersCheckFollowingForUserRequest,
    res: UsersCheckFollowingForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type GistsListForUserRequest = Request<
  GistsListForUserRequestPath,
  GistsListForUser200ResponseBody | GistsListForUser422ResponseBody,
  unknown,
  GistsListForUserRequestQuery,
  Record<string, any>
>;

export type GistsListForUserResponse = Response<
  GistsListForUser200ResponseBody | GistsListForUser422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface GistsListForUserHandler {
  gistsListForUser(
    req: GistsListForUserRequest,
    res: GistsListForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListGpgKeysForUserRequest = Request<
  UsersListGpgKeysForUserRequestPath,
  UsersListGpgKeysForUser200ResponseBody,
  unknown,
  UsersListGpgKeysForUserRequestQuery,
  Record<string, any>
>;

export type UsersListGpgKeysForUserResponse = Response<
  UsersListGpgKeysForUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface UsersListGpgKeysForUserHandler {
  usersListGpgKeysForUser(
    req: UsersListGpgKeysForUserRequest,
    res: UsersListGpgKeysForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersGetContextForUserRequest = Request<
  UsersGetContextForUserRequestPath,
  | UsersGetContextForUser200ResponseBody
  | UsersGetContextForUser404ResponseBody
  | UsersGetContextForUser422ResponseBody,
  unknown,
  UsersGetContextForUserRequestQuery,
  Record<string, any>
>;

export type UsersGetContextForUserResponse = Response<
  | UsersGetContextForUser200ResponseBody
  | UsersGetContextForUser404ResponseBody
  | UsersGetContextForUser422ResponseBody,
  Record<string, any>,
  200 | 404 | 422
>;

export interface UsersGetContextForUserHandler {
  usersGetContextForUser(
    req: UsersGetContextForUserRequest,
    res: UsersGetContextForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type AppsGetUserInstallationRequest = Request<
  AppsGetUserInstallationRequestPath,
  AppsGetUserInstallation200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type AppsGetUserInstallationResponse = Response<
  AppsGetUserInstallation200ResponseBody,
  Record<string, any>,
  200
>;

export interface AppsGetUserInstallationHandler {
  appsGetUserInstallation(
    req: AppsGetUserInstallationRequest,
    res: AppsGetUserInstallationResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListPublicKeysForUserRequest = Request<
  UsersListPublicKeysForUserRequestPath,
  UsersListPublicKeysForUser200ResponseBody,
  unknown,
  UsersListPublicKeysForUserRequestQuery,
  Record<string, any>
>;

export type UsersListPublicKeysForUserResponse = Response<
  UsersListPublicKeysForUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface UsersListPublicKeysForUserHandler {
  usersListPublicKeysForUser(
    req: UsersListPublicKeysForUserRequest,
    res: UsersListPublicKeysForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type OrgsListForUserRequest = Request<
  OrgsListForUserRequestPath,
  OrgsListForUser200ResponseBody,
  unknown,
  OrgsListForUserRequestQuery,
  Record<string, any>
>;

export type OrgsListForUserResponse = Response<
  OrgsListForUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface OrgsListForUserHandler {
  orgsListForUser(
    req: OrgsListForUserRequest,
    res: OrgsListForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesListPackagesForUserRequest = Request<
  PackagesListPackagesForUserRequestPath,
  | PackagesListPackagesForUser200ResponseBody
  | PackagesListPackagesForUser401ResponseBody
  | PackagesListPackagesForUser403ResponseBody,
  unknown,
  PackagesListPackagesForUserRequestQuery,
  Record<string, any>
>;

export type PackagesListPackagesForUserResponse = Response<
  | PackagesListPackagesForUser200ResponseBody
  | PackagesListPackagesForUser401ResponseBody
  | PackagesListPackagesForUser403ResponseBody,
  Record<string, any>,
  200 | 401 | 403
>;

export interface PackagesListPackagesForUserHandler {
  packagesListPackagesForUser(
    req: PackagesListPackagesForUserRequest,
    res: PackagesListPackagesForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesGetPackageForUserRequest = Request<
  PackagesGetPackageForUserRequestPath,
  PackagesGetPackageForUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetPackageForUserResponse = Response<
  PackagesGetPackageForUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface PackagesGetPackageForUserHandler {
  packagesGetPackageForUser(
    req: PackagesGetPackageForUserRequest,
    res: PackagesGetPackageForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesDeletePackageForUserRequest = Request<
  PackagesDeletePackageForUserRequestPath,
  | PackagesDeletePackageForUser401ResponseBody
  | PackagesDeletePackageForUser403ResponseBody
  | PackagesDeletePackageForUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesDeletePackageForUserResponse = Response<
  | PackagesDeletePackageForUser401ResponseBody
  | PackagesDeletePackageForUser403ResponseBody
  | PackagesDeletePackageForUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export interface PackagesDeletePackageForUserHandler {
  packagesDeletePackageForUser(
    req: PackagesDeletePackageForUserRequest,
    res: PackagesDeletePackageForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesRestorePackageForUserRequest = Request<
  PackagesRestorePackageForUserRequestPath,
  | PackagesRestorePackageForUser401ResponseBody
  | PackagesRestorePackageForUser403ResponseBody
  | PackagesRestorePackageForUser404ResponseBody,
  unknown,
  PackagesRestorePackageForUserRequestQuery,
  Record<string, any>
>;

export type PackagesRestorePackageForUserResponse = Response<
  | PackagesRestorePackageForUser401ResponseBody
  | PackagesRestorePackageForUser403ResponseBody
  | PackagesRestorePackageForUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export interface PackagesRestorePackageForUserHandler {
  packagesRestorePackageForUser(
    req: PackagesRestorePackageForUserRequest,
    res: PackagesRestorePackageForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesGetAllPackageVersionsForPackageOwnedByUserRequest = Request<
  PackagesGetAllPackageVersionsForPackageOwnedByUserRequestPath,
  | PackagesGetAllPackageVersionsForPackageOwnedByUser200ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByUser401ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByUser403ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetAllPackageVersionsForPackageOwnedByUserResponse = Response<
  | PackagesGetAllPackageVersionsForPackageOwnedByUser200ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByUser401ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByUser403ResponseBody
  | PackagesGetAllPackageVersionsForPackageOwnedByUser404ResponseBody,
  Record<string, any>,
  200 | 401 | 403 | 404
>;

export interface PackagesGetAllPackageVersionsForPackageOwnedByUserHandler {
  packagesGetAllPackageVersionsForPackageOwnedByUser(
    req: PackagesGetAllPackageVersionsForPackageOwnedByUserRequest,
    res: PackagesGetAllPackageVersionsForPackageOwnedByUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesGetPackageVersionForUserRequest = Request<
  PackagesGetPackageVersionForUserRequestPath,
  PackagesGetPackageVersionForUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesGetPackageVersionForUserResponse = Response<
  PackagesGetPackageVersionForUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface PackagesGetPackageVersionForUserHandler {
  packagesGetPackageVersionForUser(
    req: PackagesGetPackageVersionForUserRequest,
    res: PackagesGetPackageVersionForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesDeletePackageVersionForUserRequest = Request<
  PackagesDeletePackageVersionForUserRequestPath,
  | PackagesDeletePackageVersionForUser401ResponseBody
  | PackagesDeletePackageVersionForUser403ResponseBody
  | PackagesDeletePackageVersionForUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesDeletePackageVersionForUserResponse = Response<
  | PackagesDeletePackageVersionForUser401ResponseBody
  | PackagesDeletePackageVersionForUser403ResponseBody
  | PackagesDeletePackageVersionForUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export interface PackagesDeletePackageVersionForUserHandler {
  packagesDeletePackageVersionForUser(
    req: PackagesDeletePackageVersionForUserRequest,
    res: PackagesDeletePackageVersionForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type PackagesRestorePackageVersionForUserRequest = Request<
  PackagesRestorePackageVersionForUserRequestPath,
  | PackagesRestorePackageVersionForUser401ResponseBody
  | PackagesRestorePackageVersionForUser403ResponseBody
  | PackagesRestorePackageVersionForUser404ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type PackagesRestorePackageVersionForUserResponse = Response<
  | PackagesRestorePackageVersionForUser401ResponseBody
  | PackagesRestorePackageVersionForUser403ResponseBody
  | PackagesRestorePackageVersionForUser404ResponseBody,
  Record<string, any>,
  204 | 401 | 403 | 404
>;

export interface PackagesRestorePackageVersionForUserHandler {
  packagesRestorePackageVersionForUser(
    req: PackagesRestorePackageVersionForUserRequest,
    res: PackagesRestorePackageVersionForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ProjectsListForUserRequest = Request<
  ProjectsListForUserRequestPath,
  ProjectsListForUser200ResponseBody | ProjectsListForUser422ResponseBody,
  unknown,
  ProjectsListForUserRequestQuery,
  Record<string, any>
>;

export type ProjectsListForUserResponse = Response<
  ProjectsListForUser200ResponseBody | ProjectsListForUser422ResponseBody,
  Record<string, any>,
  200 | 422
>;

export interface ProjectsListForUserHandler {
  projectsListForUser(
    req: ProjectsListForUserRequest,
    res: ProjectsListForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListReceivedEventsForUserRequest = Request<
  ActivityListReceivedEventsForUserRequestPath,
  ActivityListReceivedEventsForUser200ResponseBody,
  unknown,
  ActivityListReceivedEventsForUserRequestQuery,
  Record<string, any>
>;

export type ActivityListReceivedEventsForUserResponse = Response<
  ActivityListReceivedEventsForUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActivityListReceivedEventsForUserHandler {
  activityListReceivedEventsForUser(
    req: ActivityListReceivedEventsForUserRequest,
    res: ActivityListReceivedEventsForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListReceivedPublicEventsForUserRequest = Request<
  ActivityListReceivedPublicEventsForUserRequestPath,
  ActivityListReceivedPublicEventsForUser200ResponseBody,
  unknown,
  ActivityListReceivedPublicEventsForUserRequestQuery,
  Record<string, any>
>;

export type ActivityListReceivedPublicEventsForUserResponse = Response<
  ActivityListReceivedPublicEventsForUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActivityListReceivedPublicEventsForUserHandler {
  activityListReceivedPublicEventsForUser(
    req: ActivityListReceivedPublicEventsForUserRequest,
    res: ActivityListReceivedPublicEventsForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ReposListForUserRequest = Request<
  ReposListForUserRequestPath,
  ReposListForUser200ResponseBody,
  unknown,
  ReposListForUserRequestQuery,
  Record<string, any>
>;

export type ReposListForUserResponse = Response<
  ReposListForUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface ReposListForUserHandler {
  reposListForUser(
    req: ReposListForUserRequest,
    res: ReposListForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type BillingGetGithubActionsBillingUserRequest = Request<
  BillingGetGithubActionsBillingUserRequestPath,
  BillingGetGithubActionsBillingUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type BillingGetGithubActionsBillingUserResponse = Response<
  BillingGetGithubActionsBillingUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface BillingGetGithubActionsBillingUserHandler {
  billingGetGithubActionsBillingUser(
    req: BillingGetGithubActionsBillingUserRequest,
    res: BillingGetGithubActionsBillingUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type BillingGetGithubPackagesBillingUserRequest = Request<
  BillingGetGithubPackagesBillingUserRequestPath,
  BillingGetGithubPackagesBillingUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type BillingGetGithubPackagesBillingUserResponse = Response<
  BillingGetGithubPackagesBillingUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface BillingGetGithubPackagesBillingUserHandler {
  billingGetGithubPackagesBillingUser(
    req: BillingGetGithubPackagesBillingUserRequest,
    res: BillingGetGithubPackagesBillingUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type BillingGetSharedStorageBillingUserRequest = Request<
  BillingGetSharedStorageBillingUserRequestPath,
  BillingGetSharedStorageBillingUser200ResponseBody,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type BillingGetSharedStorageBillingUserResponse = Response<
  BillingGetSharedStorageBillingUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface BillingGetSharedStorageBillingUserHandler {
  billingGetSharedStorageBillingUser(
    req: BillingGetSharedStorageBillingUserRequest,
    res: BillingGetSharedStorageBillingUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type UsersListSshSigningKeysForUserRequest = Request<
  UsersListSshSigningKeysForUserRequestPath,
  UsersListSshSigningKeysForUser200ResponseBody,
  unknown,
  UsersListSshSigningKeysForUserRequestQuery,
  Record<string, any>
>;

export type UsersListSshSigningKeysForUserResponse = Response<
  UsersListSshSigningKeysForUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface UsersListSshSigningKeysForUserHandler {
  usersListSshSigningKeysForUser(
    req: UsersListSshSigningKeysForUserRequest,
    res: UsersListSshSigningKeysForUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListReposStarredByUserRequest = Request<
  ActivityListReposStarredByUserRequestPath,
  ActivityListReposStarredByUser200ResponseBody,
  unknown,
  ActivityListReposStarredByUserRequestQuery,
  Record<string, any>
>;

export type ActivityListReposStarredByUserResponse = Response<
  ActivityListReposStarredByUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActivityListReposStarredByUserHandler {
  activityListReposStarredByUser(
    req: ActivityListReposStarredByUserRequest,
    res: ActivityListReposStarredByUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type ActivityListReposWatchedByUserRequest = Request<
  ActivityListReposWatchedByUserRequestPath,
  ActivityListReposWatchedByUser200ResponseBody,
  unknown,
  ActivityListReposWatchedByUserRequestQuery,
  Record<string, any>
>;

export type ActivityListReposWatchedByUserResponse = Response<
  ActivityListReposWatchedByUser200ResponseBody,
  Record<string, any>,
  200
>;

export interface ActivityListReposWatchedByUserHandler {
  activityListReposWatchedByUser(
    req: ActivityListReposWatchedByUserRequest,
    res: ActivityListReposWatchedByUserResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export type MetaGetZenRequest = Request<
  ParamsDictionary,
  unknown,
  unknown,
  ParsedQs,
  Record<string, any>
>;

export type MetaGetZenResponse = Response<unknown, Record<string, any>, 200>;

export interface MetaGetZenHandler {
  metaGetZen(
    req: MetaGetZenRequest,
    res: MetaGetZenResponse,
    next: NextFunction
  ): Promise<unknown | void>;
}

export interface RequestResolver {
  resolve<T>(token: { new (...args: any[]): T } | string | symbol): T;
}

@injectable()
export class RequestResolverFactory {
  constructor(public readonly forRequest: (req: Request) => RequestResolver) {}
}

@injectable()
export class ControllerMiddleware {
  constructor(private readonly resolver: RequestResolverFactory) {}

  private static validate = new Validator({ strict: false, coerceTypes: true })
    .validate;

  private addMetaRootHandler(router: Router): void {
    router.get(
      '/',

      asyncRequestHandler<MetaRootRequest, MetaRootResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<MetaRootHandler>(Handlers.MetaRootHandler);

          await controller.metaRoot(req, res, next);
        }
      )
    );
  }

  private addAppsGetAuthenticatedHandler(router: Router): void {
    router.get(
      '/app',

      asyncRequestHandler<
        AppsGetAuthenticatedRequest,
        AppsGetAuthenticatedResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsGetAuthenticatedHandler>(
            Handlers.AppsGetAuthenticatedHandler
          );

        await controller.appsGetAuthenticated(req, res, next);
      })
    );
  }

  private addAppsCreateFromManifestHandler(router: Router): void {
    router.post(
      '/app-manifests/:code/conversions',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { code: { type: 'string' } },
          required: ['code']
        }
      }),

      asyncRequestHandler<
        AppsCreateFromManifestRequest,
        AppsCreateFromManifestResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsCreateFromManifestHandler>(
            Handlers.AppsCreateFromManifestHandler
          );

        await controller.appsCreateFromManifest(req, res, next);
      })
    );
  }

  private addAppsGetWebhookConfigForAppHandler(router: Router): void {
    router.get(
      '/app/hook/config',

      asyncRequestHandler<
        AppsGetWebhookConfigForAppRequest,
        AppsGetWebhookConfigForAppResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsGetWebhookConfigForAppHandler>(
            Handlers.AppsGetWebhookConfigForAppHandler
          );

        await controller.appsGetWebhookConfigForApp(req, res, next);
      })
    );
  }

  private addAppsUpdateWebhookConfigForAppHandler(router: Router): void {
    router.patch(
      '/app/hook/config',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            url: { $ref: '#/definitions/webhook-config-url' },
            content_type: { $ref: '#/definitions/webhook-config-content-type' },
            secret: { $ref: '#/definitions/webhook-config-secret' },
            insecure_ssl: { $ref: '#/definitions/webhook-config-insecure-ssl' }
          },
          definitions: {
            'webhook-config-url': {
              type: 'string',
              description: 'The URL to which the payloads will be delivered.',
              example: 'https://example.com/webhook',
              format: 'uri',
              title: 'webhook-config-url'
            },
            'webhook-config-content-type': {
              type: 'string',
              description:
                'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
              example: '"json"',
              title: 'webhook-config-content-type'
            },
            'webhook-config-secret': {
              type: 'string',
              description:
                'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
              example: '"********"',
              title: 'webhook-config-secret'
            },
            'webhook-config-insecure-ssl': {
              oneOf: [
                {
                  type: 'string',
                  description:
                    'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                  example: '"0"'
                },
                { type: 'number' }
              ],
              title: 'webhook-config-insecure-ssl'
            }
          }
        }
      }),

      asyncRequestHandler<
        AppsUpdateWebhookConfigForAppRequest,
        AppsUpdateWebhookConfigForAppResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsUpdateWebhookConfigForAppHandler>(
            Handlers.AppsUpdateWebhookConfigForAppHandler
          );

        await controller.appsUpdateWebhookConfigForApp(req, res, next);
      })
    );
  }

  private addAppsListWebhookDeliveriesHandler(router: Router): void {
    router.get(
      '/app/hook/deliveries',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            cursor: { type: 'string' }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        AppsListWebhookDeliveriesRequest,
        AppsListWebhookDeliveriesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsListWebhookDeliveriesHandler>(
            Handlers.AppsListWebhookDeliveriesHandler
          );

        await controller.appsListWebhookDeliveries(req, res, next);
      })
    );
  }

  private addAppsGetWebhookDeliveryHandler(router: Router): void {
    router.get(
      '/app/hook/deliveries/:delivery_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { delivery_id: { type: 'integer' } },
          required: ['delivery_id']
        }
      }),

      asyncRequestHandler<
        AppsGetWebhookDeliveryRequest,
        AppsGetWebhookDeliveryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsGetWebhookDeliveryHandler>(
            Handlers.AppsGetWebhookDeliveryHandler
          );

        await controller.appsGetWebhookDelivery(req, res, next);
      })
    );
  }

  private addAppsRedeliverWebhookDeliveryHandler(router: Router): void {
    router.post(
      '/app/hook/deliveries/:delivery_id/attempts',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { delivery_id: { type: 'integer' } },
          required: ['delivery_id']
        }
      }),

      asyncRequestHandler<
        AppsRedeliverWebhookDeliveryRequest,
        AppsRedeliverWebhookDeliveryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsRedeliverWebhookDeliveryHandler>(
            Handlers.AppsRedeliverWebhookDeliveryHandler
          );

        await controller.appsRedeliverWebhookDelivery(req, res, next);
      })
    );
  }

  private addAppsListInstallationsHandler(router: Router): void {
    router.get(
      '/app/installations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 },
            since: { type: 'string', format: 'date-time' },
            outdated: { type: 'string' }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        AppsListInstallationsRequest,
        AppsListInstallationsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsListInstallationsHandler>(
            Handlers.AppsListInstallationsHandler
          );

        await controller.appsListInstallations(req, res, next);
      })
    );
  }

  private addAppsGetInstallationHandler(router: Router): void {
    router.get(
      '/app/installations/:installation_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { installation_id: { type: 'integer' } },
          required: ['installation_id']
        }
      }),

      asyncRequestHandler<
        AppsGetInstallationRequest,
        AppsGetInstallationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsGetInstallationHandler>(
            Handlers.AppsGetInstallationHandler
          );

        await controller.appsGetInstallation(req, res, next);
      })
    );
  }

  private addAppsDeleteInstallationHandler(router: Router): void {
    router.delete(
      '/app/installations/:installation_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { installation_id: { type: 'integer' } },
          required: ['installation_id']
        }
      }),

      asyncRequestHandler<
        AppsDeleteInstallationRequest,
        AppsDeleteInstallationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsDeleteInstallationHandler>(
            Handlers.AppsDeleteInstallationHandler
          );

        await controller.appsDeleteInstallation(req, res, next);
      })
    );
  }

  private addAppsCreateInstallationAccessTokenHandler(router: Router): void {
    router.post(
      '/app/installations/:installation_id/access_tokens',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            repositories: {
              description:
                'List of repository names that the token should have access to',
              type: 'array',
              items: { type: 'string', example: 'rails' }
            },
            repository_ids: {
              description:
                'List of repository IDs that the token should have access to',
              example: [1],
              type: 'array',
              items: { type: 'integer' }
            },
            permissions: { $ref: '#/definitions/app-permissions' }
          },
          definitions: {
            'app-permissions': {
              title: 'App Permissions',
              type: 'object',
              description:
                'The permissions granted to the user-to-server access token.',
              properties: {
                actions: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts.',
                  enum: ['read', 'write']
                },
                administration: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation.',
                  enum: ['read', 'write']
                },
                checks: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for checks on code.',
                  enum: ['read', 'write']
                },
                contents: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges.',
                  enum: ['read', 'write']
                },
                deployments: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for deployments and deployment statuses.',
                  enum: ['read', 'write']
                },
                environments: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for managing repository environments.',
                  enum: ['read', 'write']
                },
                issues: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones.',
                  enum: ['read', 'write']
                },
                metadata: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata.',
                  enum: ['read', 'write']
                },
                packages: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for packages published to GitHub Packages.',
                  enum: ['read', 'write']
                },
                pages: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds.',
                  enum: ['read', 'write']
                },
                pull_requests: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges.',
                  enum: ['read', 'write']
                },
                repository_announcement_banners: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to view and manage announcement banners for a repository.',
                  enum: ['read', 'write']
                },
                repository_hooks: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage the post-receive hooks for a repository.',
                  enum: ['read', 'write']
                },
                repository_projects: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage repository projects, columns, and cards.',
                  enum: ['read', 'write', 'admin']
                },
                secret_scanning_alerts: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to view and manage secret scanning alerts.',
                  enum: ['read', 'write']
                },
                secrets: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage repository secrets.',
                  enum: ['read', 'write']
                },
                security_events: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to view and manage security events like code scanning alerts.',
                  enum: ['read', 'write']
                },
                single_file: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage just a single file.',
                  enum: ['read', 'write']
                },
                statuses: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for commit statuses.',
                  enum: ['read', 'write']
                },
                vulnerability_alerts: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage Dependabot alerts.',
                  enum: ['read', 'write']
                },
                workflows: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to update GitHub Actions workflow files.',
                  enum: ['write']
                },
                members: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for organization teams and members.',
                  enum: ['read', 'write']
                },
                organization_administration: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage access to an organization.',
                  enum: ['read', 'write']
                },
                organization_custom_roles: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for custom roles management. This property is in beta and is subject to change.',
                  enum: ['read', 'write']
                },
                organization_announcement_banners: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to view and manage announcement banners for an organization.',
                  enum: ['read', 'write']
                },
                organization_hooks: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage the post-receive hooks for an organization.',
                  enum: ['read', 'write']
                },
                organization_plan: {
                  type: 'string',
                  description:
                    "The level of permission to grant the access token for viewing an organization's plan.",
                  enum: ['read']
                },
                organization_projects: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage organization projects and projects beta (where available).',
                  enum: ['read', 'write', 'admin']
                },
                organization_packages: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for organization packages published to GitHub Packages.',
                  enum: ['read', 'write']
                },
                organization_secrets: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage organization secrets.',
                  enum: ['read', 'write']
                },
                organization_self_hosted_runners: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization.',
                  enum: ['read', 'write']
                },
                organization_user_blocking: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to view and manage users blocked by the organization.',
                  enum: ['read', 'write']
                },
                team_discussions: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage team discussions and related comments.',
                  enum: ['read', 'write']
                }
              },
              example: {
                contents: 'read',
                issues: 'read',
                deployments: 'write',
                single_file: 'read'
              }
            }
          }
        },

        params: {
          type: 'object',
          properties: { installation_id: { type: 'integer' } },
          required: ['installation_id']
        }
      }),

      asyncRequestHandler<
        AppsCreateInstallationAccessTokenRequest,
        AppsCreateInstallationAccessTokenResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsCreateInstallationAccessTokenHandler>(
            Handlers.AppsCreateInstallationAccessTokenHandler
          );

        await controller.appsCreateInstallationAccessToken(req, res, next);
      })
    );
  }

  private addAppsSuspendInstallationHandler(router: Router): void {
    router.put(
      '/app/installations/:installation_id/suspended',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { installation_id: { type: 'integer' } },
          required: ['installation_id']
        }
      }),

      asyncRequestHandler<
        AppsSuspendInstallationRequest,
        AppsSuspendInstallationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsSuspendInstallationHandler>(
            Handlers.AppsSuspendInstallationHandler
          );

        await controller.appsSuspendInstallation(req, res, next);
      })
    );
  }

  private addAppsUnsuspendInstallationHandler(router: Router): void {
    router.delete(
      '/app/installations/:installation_id/suspended',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { installation_id: { type: 'integer' } },
          required: ['installation_id']
        }
      }),

      asyncRequestHandler<
        AppsUnsuspendInstallationRequest,
        AppsUnsuspendInstallationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsUnsuspendInstallationHandler>(
            Handlers.AppsUnsuspendInstallationHandler
          );

        await controller.appsUnsuspendInstallation(req, res, next);
      })
    );
  }

  private addAppsDeleteAuthorizationHandler(router: Router): void {
    router.delete(
      '/applications/:client_id/grant',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            access_token: {
              type: 'string',
              description:
                'The OAuth access token used to authenticate to the GitHub API.'
            }
          },
          required: ['access_token']
        },

        params: {
          type: 'object',
          properties: { client_id: { type: 'string' } },
          required: ['client_id']
        }
      }),

      asyncRequestHandler<
        AppsDeleteAuthorizationRequest,
        AppsDeleteAuthorizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsDeleteAuthorizationHandler>(
            Handlers.AppsDeleteAuthorizationHandler
          );

        await controller.appsDeleteAuthorization(req, res, next);
      })
    );
  }

  private addAppsCheckTokenHandler(router: Router): void {
    router.post(
      '/applications/:client_id/token',

      ControllerMiddleware.validate({
        body: {
          properties: {
            access_token: {
              description: 'The access_token of the OAuth application.',
              type: 'string'
            }
          },
          required: ['access_token'],
          type: 'object'
        },

        params: {
          type: 'object',
          properties: { client_id: { type: 'string' } },
          required: ['client_id']
        }
      }),

      asyncRequestHandler<AppsCheckTokenRequest, AppsCheckTokenResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<AppsCheckTokenHandler>(Handlers.AppsCheckTokenHandler);

          await controller.appsCheckToken(req, res, next);
        }
      )
    );
  }

  private addAppsResetTokenHandler(router: Router): void {
    router.patch(
      '/applications/:client_id/token',

      ControllerMiddleware.validate({
        body: {
          properties: {
            access_token: {
              description: 'The access_token of the OAuth application.',
              type: 'string'
            }
          },
          required: ['access_token'],
          type: 'object'
        },

        params: {
          type: 'object',
          properties: { client_id: { type: 'string' } },
          required: ['client_id']
        }
      }),

      asyncRequestHandler<AppsResetTokenRequest, AppsResetTokenResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<AppsResetTokenHandler>(Handlers.AppsResetTokenHandler);

          await controller.appsResetToken(req, res, next);
        }
      )
    );
  }

  private addAppsDeleteTokenHandler(router: Router): void {
    router.delete(
      '/applications/:client_id/token',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            access_token: {
              type: 'string',
              description:
                'The OAuth access token used to authenticate to the GitHub API.'
            }
          },
          required: ['access_token']
        },

        params: {
          type: 'object',
          properties: { client_id: { type: 'string' } },
          required: ['client_id']
        }
      }),

      asyncRequestHandler<AppsDeleteTokenRequest, AppsDeleteTokenResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<AppsDeleteTokenHandler>(Handlers.AppsDeleteTokenHandler);

          await controller.appsDeleteToken(req, res, next);
        }
      )
    );
  }

  private addAppsScopeTokenHandler(router: Router): void {
    router.post(
      '/applications/:client_id/token/scoped',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            access_token: {
              type: 'string',
              description:
                'The OAuth access token used to authenticate to the GitHub API.',
              example: 'e72e16c7e42f292c6912e7710c838347ae178b4a'
            },
            target: {
              description:
                'The name of the user or organization to scope the user-to-server access token to. **Required** unless `target_id` is specified.',
              type: 'string',
              example: 'octocat'
            },
            target_id: {
              description:
                'The ID of the user or organization to scope the user-to-server access token to. **Required** unless `target` is specified.',
              example: 1,
              type: 'integer'
            },
            repositories: {
              description:
                'The list of repository names to scope the user-to-server access token to. `repositories` may not be specified if `repository_ids` is specified.',
              type: 'array',
              items: { type: 'string', example: 'rails' }
            },
            repository_ids: {
              description:
                'The list of repository IDs to scope the user-to-server access token to. `repository_ids` may not be specified if `repositories` is specified.',
              example: [1],
              type: 'array',
              items: { type: 'integer' }
            },
            permissions: { $ref: '#/definitions/app-permissions' }
          },
          required: ['access_token'],
          definitions: {
            'app-permissions': {
              title: 'App Permissions',
              type: 'object',
              description:
                'The permissions granted to the user-to-server access token.',
              properties: {
                actions: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for GitHub Actions workflows, workflow runs, and artifacts.',
                  enum: ['read', 'write']
                },
                administration: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for repository creation, deletion, settings, teams, and collaborators creation.',
                  enum: ['read', 'write']
                },
                checks: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for checks on code.',
                  enum: ['read', 'write']
                },
                contents: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for repository contents, commits, branches, downloads, releases, and merges.',
                  enum: ['read', 'write']
                },
                deployments: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for deployments and deployment statuses.',
                  enum: ['read', 'write']
                },
                environments: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for managing repository environments.',
                  enum: ['read', 'write']
                },
                issues: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for issues and related comments, assignees, labels, and milestones.',
                  enum: ['read', 'write']
                },
                metadata: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to search repositories, list collaborators, and access repository metadata.',
                  enum: ['read', 'write']
                },
                packages: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for packages published to GitHub Packages.',
                  enum: ['read', 'write']
                },
                pages: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to retrieve Pages statuses, configuration, and builds, as well as create new builds.',
                  enum: ['read', 'write']
                },
                pull_requests: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for pull requests and related comments, assignees, labels, milestones, and merges.',
                  enum: ['read', 'write']
                },
                repository_announcement_banners: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to view and manage announcement banners for a repository.',
                  enum: ['read', 'write']
                },
                repository_hooks: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage the post-receive hooks for a repository.',
                  enum: ['read', 'write']
                },
                repository_projects: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage repository projects, columns, and cards.',
                  enum: ['read', 'write', 'admin']
                },
                secret_scanning_alerts: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to view and manage secret scanning alerts.',
                  enum: ['read', 'write']
                },
                secrets: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage repository secrets.',
                  enum: ['read', 'write']
                },
                security_events: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to view and manage security events like code scanning alerts.',
                  enum: ['read', 'write']
                },
                single_file: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage just a single file.',
                  enum: ['read', 'write']
                },
                statuses: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for commit statuses.',
                  enum: ['read', 'write']
                },
                vulnerability_alerts: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage Dependabot alerts.',
                  enum: ['read', 'write']
                },
                workflows: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to update GitHub Actions workflow files.',
                  enum: ['write']
                },
                members: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for organization teams and members.',
                  enum: ['read', 'write']
                },
                organization_administration: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage access to an organization.',
                  enum: ['read', 'write']
                },
                organization_custom_roles: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for custom roles management. This property is in beta and is subject to change.',
                  enum: ['read', 'write']
                },
                organization_announcement_banners: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to view and manage announcement banners for an organization.',
                  enum: ['read', 'write']
                },
                organization_hooks: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage the post-receive hooks for an organization.',
                  enum: ['read', 'write']
                },
                organization_plan: {
                  type: 'string',
                  description:
                    "The level of permission to grant the access token for viewing an organization's plan.",
                  enum: ['read']
                },
                organization_projects: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage organization projects and projects beta (where available).',
                  enum: ['read', 'write', 'admin']
                },
                organization_packages: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token for organization packages published to GitHub Packages.',
                  enum: ['read', 'write']
                },
                organization_secrets: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage organization secrets.',
                  enum: ['read', 'write']
                },
                organization_self_hosted_runners: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to view and manage GitHub Actions self-hosted runners available to an organization.',
                  enum: ['read', 'write']
                },
                organization_user_blocking: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to view and manage users blocked by the organization.',
                  enum: ['read', 'write']
                },
                team_discussions: {
                  type: 'string',
                  description:
                    'The level of permission to grant the access token to manage team discussions and related comments.',
                  enum: ['read', 'write']
                }
              },
              example: {
                contents: 'read',
                issues: 'read',
                deployments: 'write',
                single_file: 'read'
              }
            }
          }
        },

        params: {
          type: 'object',
          properties: { client_id: { type: 'string' } },
          required: ['client_id']
        }
      }),

      asyncRequestHandler<AppsScopeTokenRequest, AppsScopeTokenResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<AppsScopeTokenHandler>(Handlers.AppsScopeTokenHandler);

          await controller.appsScopeToken(req, res, next);
        }
      )
    );
  }

  private addAppsGetBySlugHandler(router: Router): void {
    router.get(
      '/apps/:app_slug',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { app_slug: { type: 'string' } },
          required: ['app_slug']
        }
      }),

      asyncRequestHandler<AppsGetBySlugRequest, AppsGetBySlugResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<AppsGetBySlugHandler>(Handlers.AppsGetBySlugHandler);

          await controller.appsGetBySlug(req, res, next);
        }
      )
    );
  }

  private addCodesOfConductGetAllCodesOfConductHandler(router: Router): void {
    router.get(
      '/codes_of_conduct',

      asyncRequestHandler<
        CodesOfConductGetAllCodesOfConductRequest,
        CodesOfConductGetAllCodesOfConductResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodesOfConductGetAllCodesOfConductHandler>(
            Handlers.CodesOfConductGetAllCodesOfConductHandler
          );

        await controller.codesOfConductGetAllCodesOfConduct(req, res, next);
      })
    );
  }

  private addCodesOfConductGetConductCodeHandler(router: Router): void {
    router.get(
      '/codes_of_conduct/:key',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { key: { type: 'string' } },
          required: ['key']
        }
      }),

      asyncRequestHandler<
        CodesOfConductGetConductCodeRequest,
        CodesOfConductGetConductCodeResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodesOfConductGetConductCodeHandler>(
            Handlers.CodesOfConductGetConductCodeHandler
          );

        await controller.codesOfConductGetConductCode(req, res, next);
      })
    );
  }

  private addEmojisGetHandler(router: Router): void {
    router.get(
      '/emojis',

      asyncRequestHandler<EmojisGetRequest, EmojisGetResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<EmojisGetHandler>(Handlers.EmojisGetHandler);

          await controller.emojisGet(req, res, next);
        }
      )
    );
  }

  private addEnterpriseAdminGetServerStatisticsHandler(router: Router): void {
    router.get(
      '/enterprise-installation/:enterprise_or_org/server-statistics',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            date_start: { type: 'string' },
            date_end: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { enterprise_or_org: { type: 'string' } },
          required: ['enterprise_or_org']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminGetServerStatisticsRequest,
        EnterpriseAdminGetServerStatisticsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminGetServerStatisticsHandler>(
            Handlers.EnterpriseAdminGetServerStatisticsHandler
          );

        await controller.enterpriseAdminGetServerStatistics(req, res, next);
      })
    );
  }

  private addActionsGetActionsCacheUsageForEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/actions/cache/usage',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        ActionsGetActionsCacheUsageForEnterpriseRequest,
        ActionsGetActionsCacheUsageForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetActionsCacheUsageForEnterpriseHandler>(
            Handlers.ActionsGetActionsCacheUsageForEnterpriseHandler
          );

        await controller.actionsGetActionsCacheUsageForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminGetGithubActionsPermissionsEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/actions/permissions',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminGetGithubActionsPermissionsEnterpriseRequest,
        EnterpriseAdminGetGithubActionsPermissionsEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminGetGithubActionsPermissionsEnterpriseHandler>(
            Handlers.EnterpriseAdminGetGithubActionsPermissionsEnterpriseHandler
          );

        await controller.enterpriseAdminGetGithubActionsPermissionsEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminSetGithubActionsPermissionsEnterpriseHandler(
    router: Router
  ): void {
    router.put(
      '/enterprises/:enterprise/actions/permissions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            enabled_organizations: {
              $ref: '#/definitions/enabled-organizations'
            },
            allowed_actions: { $ref: '#/definitions/allowed-actions' }
          },
          required: ['enabled_organizations'],
          definitions: {
            'enabled-organizations': {
              type: 'string',
              description:
                'The policy that controls the organizations in the enterprise that are allowed to run GitHub Actions.',
              enum: ['all', 'none', 'selected'],
              title: 'enabled-organizations'
            },
            'allowed-actions': {
              type: 'string',
              description:
                'The permissions policy that controls the actions and reusable workflows that are allowed to run.',
              enum: ['all', 'local_only', 'selected'],
              title: 'allowed-actions'
            }
          }
        },

        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminSetGithubActionsPermissionsEnterpriseRequest,
        EnterpriseAdminSetGithubActionsPermissionsEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminSetGithubActionsPermissionsEnterpriseHandler>(
            Handlers.EnterpriseAdminSetGithubActionsPermissionsEnterpriseHandler
          );

        await controller.enterpriseAdminSetGithubActionsPermissionsEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/actions/permissions/organizations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseRequest,
        EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseHandler>(
            Handlers.EnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseHandler
          );

        await controller.enterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseHandler(
    router: Router
  ): void {
    router.put(
      '/enterprises/:enterprise/actions/permissions/organizations',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            selected_organization_ids: {
              description:
                'List of organization IDs to enable for GitHub Actions.',
              type: 'array',
              items: {
                type: 'integer',
                description: 'Unique identifier of the organization.'
              }
            }
          },
          required: ['selected_organization_ids']
        },

        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseRequest,
        EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseHandler>(
            Handlers.EnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseHandler
          );

        await controller.enterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseHandler(
    router: Router
  ): void {
    router.put(
      '/enterprises/:enterprise/actions/permissions/organizations/:org_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            org_id: { type: 'integer' }
          },
          required: ['enterprise', 'org_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseRequest,
        EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseHandler>(
            Handlers.EnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseHandler
          );

        await controller.enterpriseAdminEnableSelectedOrganizationGithubActionsEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseHandler(
    router: Router
  ): void {
    router.delete(
      '/enterprises/:enterprise/actions/permissions/organizations/:org_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            org_id: { type: 'integer' }
          },
          required: ['enterprise', 'org_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseRequest,
        EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseHandler>(
            Handlers.EnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseHandler
          );

        await controller.enterpriseAdminDisableSelectedOrganizationGithubActionsEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminGetAllowedActionsEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/actions/permissions/selected-actions',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminGetAllowedActionsEnterpriseRequest,
        EnterpriseAdminGetAllowedActionsEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminGetAllowedActionsEnterpriseHandler>(
            Handlers.EnterpriseAdminGetAllowedActionsEnterpriseHandler
          );

        await controller.enterpriseAdminGetAllowedActionsEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminSetAllowedActionsEnterpriseHandler(
    router: Router
  ): void {
    router.put(
      '/enterprises/:enterprise/actions/permissions/selected-actions',

      ControllerMiddleware.validate({
        body: {
          $ref: '#/definitions/selected-actions',
          definitions: {
            'selected-actions': {
              type: 'object',
              properties: {
                github_owned_allowed: {
                  type: 'boolean',
                  description:
                    'Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.'
                },
                verified_allowed: {
                  type: 'boolean',
                  description:
                    'Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators.'
                },
                patterns_allowed: {
                  type: 'array',
                  description:
                    'Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`."',
                  items: { type: 'string' }
                }
              },
              title: 'selected-actions'
            }
          }
        },

        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminSetAllowedActionsEnterpriseRequest,
        EnterpriseAdminSetAllowedActionsEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminSetAllowedActionsEnterpriseHandler>(
            Handlers.EnterpriseAdminSetAllowedActionsEnterpriseHandler
          );

        await controller.enterpriseAdminSetAllowedActionsEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/actions/permissions/workflow',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest,
        ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler>(
            Handlers.ActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler
          );

        await controller.actionsGetGithubActionsDefaultWorkflowPermissionsEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler(
    router: Router
  ): void {
    router.put(
      '/enterprises/:enterprise/actions/permissions/workflow',

      ControllerMiddleware.validate({
        body: {
          $ref: '#/definitions/actions-set-default-workflow-permissions',
          definitions: {
            'actions-set-default-workflow-permissions': {
              type: 'object',
              properties: {
                default_workflow_permissions: {
                  $ref: '#/definitions/actions-default-workflow-permissions'
                },
                can_approve_pull_request_reviews: {
                  $ref: '#/definitions/actions-can-approve-pull-request-reviews'
                }
              },
              title: 'actions-set-default-workflow-permissions'
            },
            'actions-default-workflow-permissions': {
              type: 'string',
              description:
                'The default workflow permissions granted to the GITHUB_TOKEN when running workflows.',
              enum: ['read', 'write'],
              title: 'actions-default-workflow-permissions'
            },
            'actions-can-approve-pull-request-reviews': {
              type: 'boolean',
              description:
                'Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.',
              title: 'actions-can-approve-pull-request-reviews'
            }
          }
        },

        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseRequest,
        ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler>(
            Handlers.ActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler
          );

        await controller.actionsSetGithubActionsDefaultWorkflowPermissionsEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/actions/runner-groups',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 },
            visible_to_organization: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseRequest,
        EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseHandler>(
            Handlers.EnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseHandler
          );

        await controller.enterpriseAdminListSelfHostedRunnerGroupsForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseHandler(
    router: Router
  ): void {
    router.post(
      '/enterprises/:enterprise/actions/runner-groups',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: { description: 'Name of the runner group.', type: 'string' },
            visibility: {
              description:
                'Visibility of a runner group. You can select all organizations or select individual organization.',
              type: 'string',
              enum: ['selected', 'all']
            },
            selected_organization_ids: {
              description:
                'List of organization IDs that can access the runner group.',
              type: 'array',
              items: {
                type: 'integer',
                description: 'Unique identifier of the organization.'
              }
            },
            runners: {
              description: 'List of runner IDs to add to the runner group.',
              type: 'array',
              items: {
                type: 'integer',
                description: 'Unique identifier of the runner.'
              }
            },
            allows_public_repositories: {
              description:
                'Whether the runner group can be used by `public` repositories.',
              type: 'boolean',
              default: false
            },
            restricted_to_workflows: {
              description:
                'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.',
              type: 'boolean',
              default: false
            },
            selected_workflows: {
              description:
                'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.',
              type: 'array',
              items: {
                type: 'string',
                description:
                  'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.',
                example: 'octo-org/octo-repo/.github/workflows/deploy.yaml@main'
              }
            }
          },
          required: ['name']
        },

        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseRequest,
        EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseHandler>(
            Handlers.EnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseHandler
          );

        await controller.enterpriseAdminCreateSelfHostedRunnerGroupForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/actions/runner-groups/:runner_group_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseRequest,
        EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseHandler>(
            Handlers.EnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseHandler
          );

        await controller.enterpriseAdminGetSelfHostedRunnerGroupForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseHandler(
    router: Router
  ): void {
    router.patch(
      '/enterprises/:enterprise/actions/runner-groups/:runner_group_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: { description: 'Name of the runner group.', type: 'string' },
            visibility: {
              description:
                'Visibility of a runner group. You can select all organizations or select individual organizations.',
              type: 'string',
              enum: ['selected', 'all'],
              default: 'all'
            },
            allows_public_repositories: {
              description:
                'Whether the runner group can be used by `public` repositories.',
              type: 'boolean',
              default: false
            },
            restricted_to_workflows: {
              description:
                'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.',
              type: 'boolean',
              default: false
            },
            selected_workflows: {
              description:
                'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.',
              type: 'array',
              items: {
                type: 'string',
                description:
                  'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.',
                example: 'octo-org/octo-repo/.github/workflows/deploy.yaml@main'
              }
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseRequest,
        EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseHandler>(
            Handlers.EnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseHandler
          );

        await controller.enterpriseAdminUpdateSelfHostedRunnerGroupForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseHandler(
    router: Router
  ): void {
    router.delete(
      '/enterprises/:enterprise/actions/runner-groups/:runner_group_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseRequest,
        EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseHandler>(
            Handlers.EnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseHandler
          );

        await controller.enterpriseAdminDeleteSelfHostedRunnerGroupFromEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/organizations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
        EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler>(
            Handlers.EnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler
          );

        await controller.enterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler(
    router: Router
  ): void {
    router.put(
      '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/organizations',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            selected_organization_ids: {
              description:
                'List of organization IDs that can access the runner group.',
              type: 'array',
              items: {
                type: 'integer',
                description: 'Unique identifier of the organization.'
              }
            }
          },
          required: ['selected_organization_ids']
        },

        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
        EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler>(
            Handlers.EnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler
          );

        await controller.enterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler(
    router: Router
  ): void {
    router.put(
      '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/organizations/:org_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_group_id: { type: 'integer' },
            org_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_group_id', 'org_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
        EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler>(
            Handlers.EnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler
          );

        await controller.enterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler(
    router: Router
  ): void {
    router.delete(
      '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/organizations/:org_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_group_id: { type: 'integer' },
            org_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_group_id', 'org_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseRequest,
        EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler>(
            Handlers.EnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler
          );

        await controller.enterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/runners',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseRequest,
        EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseHandler>(
            Handlers.EnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseHandler
          );

        await controller.enterpriseAdminListSelfHostedRunnersInGroupForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseHandler(
    router: Router
  ): void {
    router.put(
      '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/runners',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            runners: {
              description: 'List of runner IDs to add to the runner group.',
              type: 'array',
              items: {
                type: 'integer',
                description: 'Unique identifier of the runner.'
              }
            }
          },
          required: ['runners']
        },

        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseRequest,
        EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseHandler>(
            Handlers.EnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseHandler
          );

        await controller.enterpriseAdminSetSelfHostedRunnersInGroupForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseHandler(
    router: Router
  ): void {
    router.put(
      '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/runners/:runner_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_group_id: { type: 'integer' },
            runner_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_group_id', 'runner_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseRequest,
        EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseHandler>(
            Handlers.EnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseHandler
          );

        await controller.enterpriseAdminAddSelfHostedRunnerToGroupForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseHandler(
    router: Router
  ): void {
    router.delete(
      '/enterprises/:enterprise/actions/runner-groups/:runner_group_id/runners/:runner_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_group_id: { type: 'integer' },
            runner_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_group_id', 'runner_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseRequest,
        EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseHandler>(
            Handlers.EnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseHandler
          );

        await controller.enterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminListSelfHostedRunnersForEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/actions/runners',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminListSelfHostedRunnersForEnterpriseRequest,
        EnterpriseAdminListSelfHostedRunnersForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminListSelfHostedRunnersForEnterpriseHandler>(
            Handlers.EnterpriseAdminListSelfHostedRunnersForEnterpriseHandler
          );

        await controller.enterpriseAdminListSelfHostedRunnersForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminListRunnerApplicationsForEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/actions/runners/downloads',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminListRunnerApplicationsForEnterpriseRequest,
        EnterpriseAdminListRunnerApplicationsForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminListRunnerApplicationsForEnterpriseHandler>(
            Handlers.EnterpriseAdminListRunnerApplicationsForEnterpriseHandler
          );

        await controller.enterpriseAdminListRunnerApplicationsForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminCreateRegistrationTokenForEnterpriseHandler(
    router: Router
  ): void {
    router.post(
      '/enterprises/:enterprise/actions/runners/registration-token',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminCreateRegistrationTokenForEnterpriseRequest,
        EnterpriseAdminCreateRegistrationTokenForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminCreateRegistrationTokenForEnterpriseHandler>(
            Handlers.EnterpriseAdminCreateRegistrationTokenForEnterpriseHandler
          );

        await controller.enterpriseAdminCreateRegistrationTokenForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminCreateRemoveTokenForEnterpriseHandler(
    router: Router
  ): void {
    router.post(
      '/enterprises/:enterprise/actions/runners/remove-token',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminCreateRemoveTokenForEnterpriseRequest,
        EnterpriseAdminCreateRemoveTokenForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminCreateRemoveTokenForEnterpriseHandler>(
            Handlers.EnterpriseAdminCreateRemoveTokenForEnterpriseHandler
          );

        await controller.enterpriseAdminCreateRemoveTokenForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminGetSelfHostedRunnerForEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/actions/runners/:runner_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminGetSelfHostedRunnerForEnterpriseRequest,
        EnterpriseAdminGetSelfHostedRunnerForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminGetSelfHostedRunnerForEnterpriseHandler>(
            Handlers.EnterpriseAdminGetSelfHostedRunnerForEnterpriseHandler
          );

        await controller.enterpriseAdminGetSelfHostedRunnerForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseHandler(
    router: Router
  ): void {
    router.delete(
      '/enterprises/:enterprise/actions/runners/:runner_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseRequest,
        EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseHandler>(
            Handlers.EnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseHandler
          );

        await controller.enterpriseAdminDeleteSelfHostedRunnerFromEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/actions/runners/:runner_id/labels',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseRequest,
        EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseHandler>(
            Handlers.EnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseHandler
          );

        await controller.enterpriseAdminListLabelsForSelfHostedRunnerForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseHandler(
    router: Router
  ): void {
    router.post(
      '/enterprises/:enterprise/actions/runners/:runner_id/labels',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          required: ['labels'],
          properties: {
            labels: {
              type: 'array',
              minItems: 1,
              maxItems: 100,
              description:
                'The names of the custom labels to add to the runner.',
              items: { type: 'string' }
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseRequest,
        EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseHandler>(
            Handlers.EnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseHandler
          );

        await controller.enterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseHandler(
    router: Router
  ): void {
    router.put(
      '/enterprises/:enterprise/actions/runners/:runner_id/labels',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          required: ['labels'],
          properties: {
            labels: {
              type: 'array',
              minItems: 0,
              maxItems: 100,
              description:
                'The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.',
              items: { type: 'string' }
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseRequest,
        EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseHandler>(
            Handlers.EnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseHandler
          );

        await controller.enterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseHandler(
    router: Router
  ): void {
    router.delete(
      '/enterprises/:enterprise/actions/runners/:runner_id/labels',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['enterprise', 'runner_id']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseRequest,
        EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseHandler>(
            Handlers.EnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseHandler
          );

        await controller.enterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addEnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseHandler(
    router: Router
  ): void {
    router.delete(
      '/enterprises/:enterprise/actions/runners/:runner_id/labels/:name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            enterprise: { type: 'string' },
            runner_id: { type: 'integer' },
            name: { type: 'string' }
          },
          required: ['enterprise', 'runner_id', 'name']
        }
      }),

      asyncRequestHandler<
        EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseRequest,
        EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseHandler>(
            Handlers.EnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseHandler
          );

        await controller.enterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterprise(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodeScanningListAlertsForEnterpriseHandler(router: Router): void {
    router.get(
      '/enterprises/:enterprise/code-scanning/alerts',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            tool_name: {
              $ref: '#/definitions/code-scanning-analysis-tool-name'
            },
            tool_guid: {
              $ref: '#/definitions/code-scanning-analysis-tool-guid'
            },
            before: { type: 'string' },
            after: { type: 'string' },
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            state: { $ref: '#/definitions/code-scanning-alert-state' },
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            }
          },
          required: [],
          definitions: {
            'code-scanning-analysis-tool-name': {
              type: 'string',
              description:
                'The name of the tool used to generate the code scanning analysis.',
              title: 'code-scanning-analysis-tool-name'
            },
            'code-scanning-analysis-tool-guid': {
              nullable: true,
              type: 'string',
              description:
                'The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.',
              title: 'code-scanning-analysis-tool-guid'
            },
            'code-scanning-alert-state': {
              type: 'string',
              description: 'State of a code scanning alert.',
              enum: ['open', 'closed', 'dismissed', 'fixed'],
              title: 'code-scanning-alert-state'
            }
          }
        },
        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        CodeScanningListAlertsForEnterpriseRequest,
        CodeScanningListAlertsForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodeScanningListAlertsForEnterpriseHandler>(
            Handlers.CodeScanningListAlertsForEnterpriseHandler
          );

        await controller.codeScanningListAlertsForEnterprise(req, res, next);
      })
    );
  }

  private addSecretScanningListAlertsForEnterpriseHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/secret-scanning/alerts',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            state: { type: 'string', enum: ['open', 'resolved'] },
            secret_type: { type: 'string' },
            resolution: { type: 'string' },
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            per_page: { type: 'integer', default: 30 },
            before: { type: 'string' },
            after: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        SecretScanningListAlertsForEnterpriseRequest,
        SecretScanningListAlertsForEnterpriseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<SecretScanningListAlertsForEnterpriseHandler>(
            Handlers.SecretScanningListAlertsForEnterpriseHandler
          );

        await controller.secretScanningListAlertsForEnterprise(req, res, next);
      })
    );
  }

  private addBillingGetGithubAdvancedSecurityBillingGheHandler(
    router: Router
  ): void {
    router.get(
      '/enterprises/:enterprise/settings/billing/advanced-security',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { enterprise: { type: 'string' } },
          required: ['enterprise']
        }
      }),

      asyncRequestHandler<
        BillingGetGithubAdvancedSecurityBillingGheRequest,
        BillingGetGithubAdvancedSecurityBillingGheResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<BillingGetGithubAdvancedSecurityBillingGheHandler>(
            Handlers.BillingGetGithubAdvancedSecurityBillingGheHandler
          );

        await controller.billingGetGithubAdvancedSecurityBillingGhe(
          req,
          res,
          next
        );
      })
    );
  }

  private addActivityListPublicEventsHandler(router: Router): void {
    router.get(
      '/events',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        ActivityListPublicEventsRequest,
        ActivityListPublicEventsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListPublicEventsHandler>(
            Handlers.ActivityListPublicEventsHandler
          );

        await controller.activityListPublicEvents(req, res, next);
      })
    );
  }

  private addActivityGetFeedsHandler(router: Router): void {
    router.get(
      '/feeds',

      asyncRequestHandler<ActivityGetFeedsRequest, ActivityGetFeedsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ActivityGetFeedsHandler>(Handlers.ActivityGetFeedsHandler);

          await controller.activityGetFeeds(req, res, next);
        }
      )
    );
  }

  private addGistsListHandler(router: Router): void {
    router.get(
      '/gists',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            since: { type: 'string', format: 'date-time' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<GistsListRequest, GistsListResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsListHandler>(Handlers.GistsListHandler);

          await controller.gistsList(req, res, next);
        }
      )
    );
  }

  private addGistsCreateHandler(router: Router): void {
    router.post(
      '/gists',

      ControllerMiddleware.validate({
        body: {
          properties: {
            description: {
              description: 'Description of the gist',
              example: 'Example Ruby script',
              type: 'string'
            },
            files: {
              description:
                'Names and content for the files that make up the gist',
              example: { 'hello.rb': { content: 'puts "Hello, World!"' } },
              type: 'object',
              additionalProperties: {
                type: 'object',
                properties: {
                  content: {
                    description: 'Content of the file',
                    readOnly: false,
                    type: 'string'
                  }
                },
                required: ['content']
              }
            },
            public: {
              oneOf: [
                {
                  description: 'Flag indicating whether the gist is public',
                  example: true,
                  type: 'boolean',
                  default: false
                },
                {
                  type: 'string',
                  example: 'true',
                  default: 'false',
                  enum: ['true', 'false']
                }
              ]
            }
          },
          required: ['files'],
          type: 'object'
        }
      }),

      asyncRequestHandler<GistsCreateRequest, GistsCreateResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsCreateHandler>(Handlers.GistsCreateHandler);

          await controller.gistsCreate(req, res, next);
        }
      )
    );
  }

  private addGistsListPublicHandler(router: Router): void {
    router.get(
      '/gists/public',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            since: { type: 'string', format: 'date-time' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<GistsListPublicRequest, GistsListPublicResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsListPublicHandler>(Handlers.GistsListPublicHandler);

          await controller.gistsListPublic(req, res, next);
        }
      )
    );
  }

  private addGistsListStarredHandler(router: Router): void {
    router.get(
      '/gists/starred',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            since: { type: 'string', format: 'date-time' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<GistsListStarredRequest, GistsListStarredResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsListStarredHandler>(Handlers.GistsListStarredHandler);

          await controller.gistsListStarred(req, res, next);
        }
      )
    );
  }

  private addGistsGetHandler(router: Router): void {
    router.get(
      '/gists/:gist_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { gist_id: { type: 'string' } },
          required: ['gist_id']
        }
      }),

      asyncRequestHandler<GistsGetRequest, GistsGetResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsGetHandler>(Handlers.GistsGetHandler);

          await controller.gistsGet(req, res, next);
        }
      )
    );
  }

  private addGistsUpdateHandler(router: Router): void {
    router.patch(
      '/gists/:gist_id',

      ControllerMiddleware.validate({
        body: {
          properties: {
            description: {
              description: 'The description of the gist.',
              example: 'Example Ruby script',
              type: 'string'
            },
            files: {
              description:
                'The gist files to be updated, renamed, or deleted. Each `key` must match the current filename\n(including extension) of the targeted gist file. For example: `hello.py`.\n\nTo delete a file, set the whole file to null. For example: `hello.py : null`.',
              example: {
                'hello.rb': { content: 'blah', filename: 'goodbye.rb' }
              },
              type: 'object',
              additionalProperties: {
                type: 'object',
                nullable: true,
                properties: {
                  content: {
                    description: 'The new content of the file.',
                    type: 'string'
                  },
                  filename: {
                    description: 'The new filename for the file.',
                    type: 'string',
                    nullable: true
                  }
                },
                anyOf: [
                  { required: ['content'] },
                  { required: ['filename'] },
                  { type: 'object', maxProperties: 0 }
                ]
              }
            }
          },
          anyOf: [{ required: ['description'] }, { required: ['files'] }],
          type: 'object',
          nullable: true
        },

        params: {
          type: 'object',
          properties: { gist_id: { type: 'string' } },
          required: ['gist_id']
        }
      }),

      asyncRequestHandler<GistsUpdateRequest, GistsUpdateResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsUpdateHandler>(Handlers.GistsUpdateHandler);

          await controller.gistsUpdate(req, res, next);
        }
      )
    );
  }

  private addGistsDeleteHandler(router: Router): void {
    router.delete(
      '/gists/:gist_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { gist_id: { type: 'string' } },
          required: ['gist_id']
        }
      }),

      asyncRequestHandler<GistsDeleteRequest, GistsDeleteResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsDeleteHandler>(Handlers.GistsDeleteHandler);

          await controller.gistsDelete(req, res, next);
        }
      )
    );
  }

  private addGistsListCommentsHandler(router: Router): void {
    router.get(
      '/gists/:gist_id/comments',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { gist_id: { type: 'string' } },
          required: ['gist_id']
        }
      }),

      asyncRequestHandler<GistsListCommentsRequest, GistsListCommentsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsListCommentsHandler>(
              Handlers.GistsListCommentsHandler
            );

          await controller.gistsListComments(req, res, next);
        }
      )
    );
  }

  private addGistsCreateCommentHandler(router: Router): void {
    router.post(
      '/gists/:gist_id/comments',

      ControllerMiddleware.validate({
        body: {
          properties: {
            body: {
              description: 'The comment text.',
              type: 'string',
              maxLength: 65535,
              example: 'Body of the attachment'
            }
          },
          type: 'object',
          required: ['body']
        },

        params: {
          type: 'object',
          properties: { gist_id: { type: 'string' } },
          required: ['gist_id']
        }
      }),

      asyncRequestHandler<
        GistsCreateCommentRequest,
        GistsCreateCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<GistsCreateCommentHandler>(
            Handlers.GistsCreateCommentHandler
          );

        await controller.gistsCreateComment(req, res, next);
      })
    );
  }

  private addGistsGetCommentHandler(router: Router): void {
    router.get(
      '/gists/:gist_id/comments/:comment_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            gist_id: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['gist_id', 'comment_id']
        }
      }),

      asyncRequestHandler<GistsGetCommentRequest, GistsGetCommentResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsGetCommentHandler>(Handlers.GistsGetCommentHandler);

          await controller.gistsGetComment(req, res, next);
        }
      )
    );
  }

  private addGistsUpdateCommentHandler(router: Router): void {
    router.patch(
      '/gists/:gist_id/comments/:comment_id',

      ControllerMiddleware.validate({
        body: {
          properties: {
            body: {
              description: 'The comment text.',
              type: 'string',
              maxLength: 65535,
              example: 'Body of the attachment'
            }
          },
          type: 'object',
          required: ['body']
        },

        params: {
          type: 'object',
          properties: {
            gist_id: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['gist_id', 'comment_id']
        }
      }),

      asyncRequestHandler<
        GistsUpdateCommentRequest,
        GistsUpdateCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<GistsUpdateCommentHandler>(
            Handlers.GistsUpdateCommentHandler
          );

        await controller.gistsUpdateComment(req, res, next);
      })
    );
  }

  private addGistsDeleteCommentHandler(router: Router): void {
    router.delete(
      '/gists/:gist_id/comments/:comment_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            gist_id: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['gist_id', 'comment_id']
        }
      }),

      asyncRequestHandler<
        GistsDeleteCommentRequest,
        GistsDeleteCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<GistsDeleteCommentHandler>(
            Handlers.GistsDeleteCommentHandler
          );

        await controller.gistsDeleteComment(req, res, next);
      })
    );
  }

  private addGistsListCommitsHandler(router: Router): void {
    router.get(
      '/gists/:gist_id/commits',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { gist_id: { type: 'string' } },
          required: ['gist_id']
        }
      }),

      asyncRequestHandler<GistsListCommitsRequest, GistsListCommitsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsListCommitsHandler>(Handlers.GistsListCommitsHandler);

          await controller.gistsListCommits(req, res, next);
        }
      )
    );
  }

  private addGistsListForksHandler(router: Router): void {
    router.get(
      '/gists/:gist_id/forks',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { gist_id: { type: 'string' } },
          required: ['gist_id']
        }
      }),

      asyncRequestHandler<GistsListForksRequest, GistsListForksResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsListForksHandler>(Handlers.GistsListForksHandler);

          await controller.gistsListForks(req, res, next);
        }
      )
    );
  }

  private addGistsForkHandler(router: Router): void {
    router.post(
      '/gists/:gist_id/forks',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { gist_id: { type: 'string' } },
          required: ['gist_id']
        }
      }),

      asyncRequestHandler<GistsForkRequest, GistsForkResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsForkHandler>(Handlers.GistsForkHandler);

          await controller.gistsFork(req, res, next);
        }
      )
    );
  }

  private addGistsCheckIsStarredHandler(router: Router): void {
    router.get(
      '/gists/:gist_id/star',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { gist_id: { type: 'string' } },
          required: ['gist_id']
        }
      }),

      asyncRequestHandler<
        GistsCheckIsStarredRequest,
        GistsCheckIsStarredResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<GistsCheckIsStarredHandler>(
            Handlers.GistsCheckIsStarredHandler
          );

        await controller.gistsCheckIsStarred(req, res, next);
      })
    );
  }

  private addGistsStarHandler(router: Router): void {
    router.put(
      '/gists/:gist_id/star',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { gist_id: { type: 'string' } },
          required: ['gist_id']
        }
      }),

      asyncRequestHandler<GistsStarRequest, GistsStarResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsStarHandler>(Handlers.GistsStarHandler);

          await controller.gistsStar(req, res, next);
        }
      )
    );
  }

  private addGistsUnstarHandler(router: Router): void {
    router.delete(
      '/gists/:gist_id/star',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { gist_id: { type: 'string' } },
          required: ['gist_id']
        }
      }),

      asyncRequestHandler<GistsUnstarRequest, GistsUnstarResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsUnstarHandler>(Handlers.GistsUnstarHandler);

          await controller.gistsUnstar(req, res, next);
        }
      )
    );
  }

  private addGistsGetRevisionHandler(router: Router): void {
    router.get(
      '/gists/:gist_id/:sha',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { gist_id: { type: 'string' }, sha: { type: 'string' } },
          required: ['gist_id', 'sha']
        }
      }),

      asyncRequestHandler<GistsGetRevisionRequest, GistsGetRevisionResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsGetRevisionHandler>(Handlers.GistsGetRevisionHandler);

          await controller.gistsGetRevision(req, res, next);
        }
      )
    );
  }

  private addGitignoreGetAllTemplatesHandler(router: Router): void {
    router.get(
      '/gitignore/templates',

      asyncRequestHandler<
        GitignoreGetAllTemplatesRequest,
        GitignoreGetAllTemplatesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<GitignoreGetAllTemplatesHandler>(
            Handlers.GitignoreGetAllTemplatesHandler
          );

        await controller.gitignoreGetAllTemplates(req, res, next);
      })
    );
  }

  private addGitignoreGetTemplateHandler(router: Router): void {
    router.get(
      '/gitignore/templates/:name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { name: { type: 'string' } },
          required: ['name']
        }
      }),

      asyncRequestHandler<
        GitignoreGetTemplateRequest,
        GitignoreGetTemplateResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<GitignoreGetTemplateHandler>(
            Handlers.GitignoreGetTemplateHandler
          );

        await controller.gitignoreGetTemplate(req, res, next);
      })
    );
  }

  private addAppsListReposAccessibleToInstallationHandler(
    router: Router
  ): void {
    router.get(
      '/installation/repositories',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        AppsListReposAccessibleToInstallationRequest,
        AppsListReposAccessibleToInstallationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsListReposAccessibleToInstallationHandler>(
            Handlers.AppsListReposAccessibleToInstallationHandler
          );

        await controller.appsListReposAccessibleToInstallation(req, res, next);
      })
    );
  }

  private addAppsRevokeInstallationAccessTokenHandler(router: Router): void {
    router.delete(
      '/installation/token',

      asyncRequestHandler<
        AppsRevokeInstallationAccessTokenRequest,
        AppsRevokeInstallationAccessTokenResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsRevokeInstallationAccessTokenHandler>(
            Handlers.AppsRevokeInstallationAccessTokenHandler
          );

        await controller.appsRevokeInstallationAccessToken(req, res, next);
      })
    );
  }

  private addIssuesListHandler(router: Router): void {
    router.get(
      '/issues',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            filter: {
              type: 'string',
              enum: [
                'assigned',
                'created',
                'mentioned',
                'subscribed',
                'repos',
                'all'
              ],
              default: 'assigned'
            },
            state: {
              type: 'string',
              enum: ['open', 'closed', 'all'],
              default: 'open'
            },
            labels: { type: 'string' },
            sort: {
              type: 'string',
              enum: ['created', 'updated', 'comments'],
              default: 'created'
            },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            since: { type: 'string', format: 'date-time' },
            collab: { type: 'boolean' },
            orgs: { type: 'boolean' },
            owned: { type: 'boolean' },
            pulls: { type: 'boolean' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<IssuesListRequest, IssuesListResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesListHandler>(Handlers.IssuesListHandler);

          await controller.issuesList(req, res, next);
        }
      )
    );
  }

  private addLicensesGetAllCommonlyUsedHandler(router: Router): void {
    router.get(
      '/licenses',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            featured: { type: 'boolean' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        LicensesGetAllCommonlyUsedRequest,
        LicensesGetAllCommonlyUsedResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<LicensesGetAllCommonlyUsedHandler>(
            Handlers.LicensesGetAllCommonlyUsedHandler
          );

        await controller.licensesGetAllCommonlyUsed(req, res, next);
      })
    );
  }

  private addLicensesGetHandler(router: Router): void {
    router.get(
      '/licenses/:license',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { license: { type: 'string' } },
          required: ['license']
        }
      }),

      asyncRequestHandler<LicensesGetRequest, LicensesGetResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<LicensesGetHandler>(Handlers.LicensesGetHandler);

          await controller.licensesGet(req, res, next);
        }
      )
    );
  }

  private addMarkdownRenderHandler(router: Router): void {
    router.post(
      '/markdown',

      ControllerMiddleware.validate({
        body: {
          properties: {
            text: {
              description: 'The Markdown text to render in HTML.',
              type: 'string'
            },
            mode: {
              description: 'The rendering mode.',
              enum: ['markdown', 'gfm'],
              default: 'markdown',
              example: 'markdown',
              type: 'string'
            },
            context: {
              description:
                'The repository context to use when creating references in `gfm` mode.  For example, setting `context` to `octo-org/octo-repo` will change the text `#42` into an HTML link to issue 42 in the `octo-org/octo-repo` repository.',
              type: 'string'
            }
          },
          required: ['text'],
          type: 'object'
        }
      }),

      asyncRequestHandler<MarkdownRenderRequest, MarkdownRenderResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<MarkdownRenderHandler>(Handlers.MarkdownRenderHandler);

          await controller.markdownRender(req, res, next);
        }
      )
    );
  }

  private addMarkdownRenderRawHandler(router: Router): void {
    router.post(
      '/markdown/raw',

      asyncRequestHandler<MarkdownRenderRawRequest, MarkdownRenderRawResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<MarkdownRenderRawHandler>(
              Handlers.MarkdownRenderRawHandler
            );

          await controller.markdownRenderRaw(req, res, next);
        }
      )
    );
  }

  private addAppsGetSubscriptionPlanForAccountHandler(router: Router): void {
    router.get(
      '/marketplace_listing/accounts/:account_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { account_id: { type: 'integer' } },
          required: ['account_id']
        }
      }),

      asyncRequestHandler<
        AppsGetSubscriptionPlanForAccountRequest,
        AppsGetSubscriptionPlanForAccountResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsGetSubscriptionPlanForAccountHandler>(
            Handlers.AppsGetSubscriptionPlanForAccountHandler
          );

        await controller.appsGetSubscriptionPlanForAccount(req, res, next);
      })
    );
  }

  private addAppsListPlansHandler(router: Router): void {
    router.get(
      '/marketplace_listing/plans',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<AppsListPlansRequest, AppsListPlansResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<AppsListPlansHandler>(Handlers.AppsListPlansHandler);

          await controller.appsListPlans(req, res, next);
        }
      )
    );
  }

  private addAppsListAccountsForPlanHandler(router: Router): void {
    router.get(
      '/marketplace_listing/plans/:plan_id/accounts',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            },
            direction: { type: 'string', enum: ['asc', 'desc'] },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { plan_id: { type: 'integer' } },
          required: ['plan_id']
        }
      }),

      asyncRequestHandler<
        AppsListAccountsForPlanRequest,
        AppsListAccountsForPlanResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsListAccountsForPlanHandler>(
            Handlers.AppsListAccountsForPlanHandler
          );

        await controller.appsListAccountsForPlan(req, res, next);
      })
    );
  }

  private addAppsGetSubscriptionPlanForAccountStubbedHandler(
    router: Router
  ): void {
    router.get(
      '/marketplace_listing/stubbed/accounts/:account_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { account_id: { type: 'integer' } },
          required: ['account_id']
        }
      }),

      asyncRequestHandler<
        AppsGetSubscriptionPlanForAccountStubbedRequest,
        AppsGetSubscriptionPlanForAccountStubbedResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsGetSubscriptionPlanForAccountStubbedHandler>(
            Handlers.AppsGetSubscriptionPlanForAccountStubbedHandler
          );

        await controller.appsGetSubscriptionPlanForAccountStubbed(
          req,
          res,
          next
        );
      })
    );
  }

  private addAppsListPlansStubbedHandler(router: Router): void {
    router.get(
      '/marketplace_listing/stubbed/plans',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        AppsListPlansStubbedRequest,
        AppsListPlansStubbedResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsListPlansStubbedHandler>(
            Handlers.AppsListPlansStubbedHandler
          );

        await controller.appsListPlansStubbed(req, res, next);
      })
    );
  }

  private addAppsListAccountsForPlanStubbedHandler(router: Router): void {
    router.get(
      '/marketplace_listing/stubbed/plans/:plan_id/accounts',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            },
            direction: { type: 'string', enum: ['asc', 'desc'] },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { plan_id: { type: 'integer' } },
          required: ['plan_id']
        }
      }),

      asyncRequestHandler<
        AppsListAccountsForPlanStubbedRequest,
        AppsListAccountsForPlanStubbedResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsListAccountsForPlanStubbedHandler>(
            Handlers.AppsListAccountsForPlanStubbedHandler
          );

        await controller.appsListAccountsForPlanStubbed(req, res, next);
      })
    );
  }

  private addMetaGetHandler(router: Router): void {
    router.get(
      '/meta',

      asyncRequestHandler<MetaGetRequest, MetaGetResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<MetaGetHandler>(Handlers.MetaGetHandler);

          await controller.metaGet(req, res, next);
        }
      )
    );
  }

  private addActivityListPublicEventsForRepoNetworkHandler(
    router: Router
  ): void {
    router.get(
      '/networks/:owner/:repo/events',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActivityListPublicEventsForRepoNetworkRequest,
        ActivityListPublicEventsForRepoNetworkResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListPublicEventsForRepoNetworkHandler>(
            Handlers.ActivityListPublicEventsForRepoNetworkHandler
          );

        await controller.activityListPublicEventsForRepoNetwork(req, res, next);
      })
    );
  }

  private addActivityListNotificationsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/notifications',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            all: { type: 'boolean', default: false },
            participating: { type: 'boolean', default: false },
            since: { type: 'string', format: 'date-time' },
            before: { type: 'string', format: 'date-time' },
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 50 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        ActivityListNotificationsForAuthenticatedUserRequest,
        ActivityListNotificationsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListNotificationsForAuthenticatedUserHandler>(
            Handlers.ActivityListNotificationsForAuthenticatedUserHandler
          );

        await controller.activityListNotificationsForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addActivityMarkNotificationsAsReadHandler(router: Router): void {
    router.put(
      '/notifications',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            last_read_at: {
              description:
                'Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.',
              type: 'string',
              format: 'date-time'
            },
            read: {
              description: 'Whether the notification has been read.',
              type: 'boolean'
            }
          }
        }
      }),

      asyncRequestHandler<
        ActivityMarkNotificationsAsReadRequest,
        ActivityMarkNotificationsAsReadResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityMarkNotificationsAsReadHandler>(
            Handlers.ActivityMarkNotificationsAsReadHandler
          );

        await controller.activityMarkNotificationsAsRead(req, res, next);
      })
    );
  }

  private addActivityGetThreadHandler(router: Router): void {
    router.get(
      '/notifications/threads/:thread_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { thread_id: { type: 'integer' } },
          required: ['thread_id']
        }
      }),

      asyncRequestHandler<ActivityGetThreadRequest, ActivityGetThreadResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ActivityGetThreadHandler>(
              Handlers.ActivityGetThreadHandler
            );

          await controller.activityGetThread(req, res, next);
        }
      )
    );
  }

  private addActivityMarkThreadAsReadHandler(router: Router): void {
    router.patch(
      '/notifications/threads/:thread_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { thread_id: { type: 'integer' } },
          required: ['thread_id']
        }
      }),

      asyncRequestHandler<
        ActivityMarkThreadAsReadRequest,
        ActivityMarkThreadAsReadResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityMarkThreadAsReadHandler>(
            Handlers.ActivityMarkThreadAsReadHandler
          );

        await controller.activityMarkThreadAsRead(req, res, next);
      })
    );
  }

  private addActivityGetThreadSubscriptionForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/notifications/threads/:thread_id/subscription',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { thread_id: { type: 'integer' } },
          required: ['thread_id']
        }
      }),

      asyncRequestHandler<
        ActivityGetThreadSubscriptionForAuthenticatedUserRequest,
        ActivityGetThreadSubscriptionForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityGetThreadSubscriptionForAuthenticatedUserHandler>(
            Handlers.ActivityGetThreadSubscriptionForAuthenticatedUserHandler
          );

        await controller.activityGetThreadSubscriptionForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addActivitySetThreadSubscriptionHandler(router: Router): void {
    router.put(
      '/notifications/threads/:thread_id/subscription',

      ControllerMiddleware.validate({
        body: {
          properties: {
            ignored: {
              description: 'Whether to block all notifications from a thread.',
              default: false,
              type: 'boolean'
            }
          },
          type: 'object'
        },

        params: {
          type: 'object',
          properties: { thread_id: { type: 'integer' } },
          required: ['thread_id']
        }
      }),

      asyncRequestHandler<
        ActivitySetThreadSubscriptionRequest,
        ActivitySetThreadSubscriptionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivitySetThreadSubscriptionHandler>(
            Handlers.ActivitySetThreadSubscriptionHandler
          );

        await controller.activitySetThreadSubscription(req, res, next);
      })
    );
  }

  private addActivityDeleteThreadSubscriptionHandler(router: Router): void {
    router.delete(
      '/notifications/threads/:thread_id/subscription',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { thread_id: { type: 'integer' } },
          required: ['thread_id']
        }
      }),

      asyncRequestHandler<
        ActivityDeleteThreadSubscriptionRequest,
        ActivityDeleteThreadSubscriptionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityDeleteThreadSubscriptionHandler>(
            Handlers.ActivityDeleteThreadSubscriptionHandler
          );

        await controller.activityDeleteThreadSubscription(req, res, next);
      })
    );
  }

  private addMetaGetOctocatHandler(router: Router): void {
    router.get(
      '/octocat',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { s: { type: 'string' } },
          required: []
        }
      }),

      asyncRequestHandler<MetaGetOctocatRequest, MetaGetOctocatResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<MetaGetOctocatHandler>(Handlers.MetaGetOctocatHandler);

          await controller.metaGetOctocat(req, res, next);
        }
      )
    );
  }

  private addOrgsListHandler(router: Router): void {
    router.get(
      '/organizations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            since: { type: 'integer' },
            per_page: { type: 'integer', default: 30 }
          },
          required: []
        }
      }),

      asyncRequestHandler<OrgsListRequest, OrgsListResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsListHandler>(Handlers.OrgsListHandler);

          await controller.orgsList(req, res, next);
        }
      )
    );
  }

  private addOrgsListCustomRolesHandler(router: Router): void {
    router.get(
      '/organizations/:organization_id/custom_roles',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { organization_id: { type: 'string' } },
          required: ['organization_id']
        }
      }),

      asyncRequestHandler<
        OrgsListCustomRolesRequest,
        OrgsListCustomRolesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsListCustomRolesHandler>(
            Handlers.OrgsListCustomRolesHandler
          );

        await controller.orgsListCustomRoles(req, res, next);
      })
    );
  }

  private addOrgsGetHandler(router: Router): void {
    router.get(
      '/orgs/:org',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<OrgsGetRequest, OrgsGetResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsGetHandler>(Handlers.OrgsGetHandler);

          await controller.orgsGet(req, res, next);
        }
      )
    );
  }

  private addOrgsUpdateHandler(router: Router): void {
    router.patch(
      '/orgs/:org',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            billing_email: {
              type: 'string',
              description:
                'Billing email address. This address is not publicized.'
            },
            company: { type: 'string', description: 'The company name.' },
            email: {
              type: 'string',
              description: 'The publicly visible email address.'
            },
            twitter_username: {
              type: 'string',
              description: 'The Twitter username of the company.'
            },
            location: { type: 'string', description: 'The location.' },
            name: {
              type: 'string',
              description: 'The shorthand name of the company.'
            },
            description: {
              type: 'string',
              description: 'The description of the company.'
            },
            has_organization_projects: {
              type: 'boolean',
              description:
                'Whether an organization can use organization projects.'
            },
            has_repository_projects: {
              type: 'boolean',
              description:
                'Whether repositories that belong to the organization can use repository projects.'
            },
            default_repository_permission: {
              type: 'string',
              description:
                'Default permission level members have for organization repositories.',
              enum: ['read', 'write', 'admin', 'none'],
              default: 'read'
            },
            members_can_create_repositories: {
              type: 'boolean',
              description:
                'Whether of non-admin organization members can create repositories. **Note:** A parameter can override this parameter. See `members_allowed_repository_creation_type` in this table for details.',
              default: true
            },
            members_can_create_internal_repositories: {
              type: 'boolean',
              description:
                'Whether organization members can create internal repositories, which are visible to all enterprise members. You can only allow members to create internal repositories if your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.'
            },
            members_can_create_private_repositories: {
              type: 'boolean',
              description:
                'Whether organization members can create private repositories, which are visible to organization members with permission. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.'
            },
            members_can_create_public_repositories: {
              type: 'boolean',
              description:
                'Whether organization members can create public repositories, which are visible to anyone. For more information, see "[Restricting repository creation in your organization](https://docs.github.com/github/setting-up-and-managing-organizations-and-teams/restricting-repository-creation-in-your-organization)" in the GitHub Help documentation.'
            },
            members_allowed_repository_creation_type: {
              type: 'string',
              description:
                'Specifies which types of repositories non-admin organization members can create. `private` is only available to repositories that are part of an organization on GitHub Enterprise Cloud. \n**Note:** This parameter is deprecated and will be removed in the future. Its return value ignores internal repositories. Using this parameter overrides values set in `members_can_create_repositories`. See the parameter deprecation notice in the operation description for details.',
              enum: ['all', 'private', 'none']
            },
            members_can_create_pages: {
              type: 'boolean',
              description:
                'Whether organization members can create GitHub Pages sites. Existing published sites will not be impacted.',
              default: true
            },
            members_can_create_public_pages: {
              type: 'boolean',
              description:
                'Whether organization members can create public GitHub Pages sites. Existing published sites will not be impacted.',
              default: true
            },
            members_can_create_private_pages: {
              type: 'boolean',
              description:
                'Whether organization members can create private GitHub Pages sites. Existing published sites will not be impacted.',
              default: true
            },
            members_can_fork_private_repositories: {
              type: 'boolean',
              description:
                'Whether organization members can fork private organization repositories.',
              default: false
            },
            web_commit_signoff_required: {
              type: 'boolean',
              description:
                "Whether contributors to organization repositories are required to sign off on commits they make through GitHub's web interface.",
              default: false
            },
            blog: { type: 'string', example: '"http://github.blog"' },
            advanced_security_enabled_for_new_repositories: {
              type: 'boolean',
              description:
                'Whether GitHub Advanced Security is automatically enabled for new repositories.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
            },
            dependabot_alerts_enabled_for_new_repositories: {
              type: 'boolean',
              description:
                'Whether Dependabot alerts is automatically enabled for new repositories.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
            },
            dependabot_security_updates_enabled_for_new_repositories: {
              type: 'boolean',
              description:
                'Whether Dependabot security updates is automatically enabled for new repositories.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
            },
            dependency_graph_enabled_for_new_repositories: {
              type: 'boolean',
              description:
                'Whether dependency graph is automatically enabled for new repositories.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
            },
            secret_scanning_enabled_for_new_repositories: {
              type: 'boolean',
              description:
                'Whether secret scanning is automatically enabled for new repositories.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
            },
            secret_scanning_push_protection_enabled_for_new_repositories: {
              type: 'boolean',
              description:
                'Whether secret scanning push protection is automatically enabled for new repositories.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nYou can check which security and analysis features are currently enabled by using a `GET /orgs/{org}` request.'
            }
          }
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<OrgsUpdateRequest, OrgsUpdateResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsUpdateHandler>(Handlers.OrgsUpdateHandler);

          await controller.orgsUpdate(req, res, next);
        }
      )
    );
  }

  private addActionsGetActionsCacheUsageForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/actions/cache/usage',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsGetActionsCacheUsageForOrgRequest,
        ActionsGetActionsCacheUsageForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetActionsCacheUsageForOrgHandler>(
            Handlers.ActionsGetActionsCacheUsageForOrgHandler
          );

        await controller.actionsGetActionsCacheUsageForOrg(req, res, next);
      })
    );
  }

  private addActionsGetActionsCacheUsageByRepoForOrgHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/actions/cache/usage-by-repository',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsGetActionsCacheUsageByRepoForOrgRequest,
        ActionsGetActionsCacheUsageByRepoForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetActionsCacheUsageByRepoForOrgHandler>(
            Handlers.ActionsGetActionsCacheUsageByRepoForOrgHandler
          );

        await controller.actionsGetActionsCacheUsageByRepoForOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsGetGithubActionsPermissionsOrganizationHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/actions/permissions',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsGetGithubActionsPermissionsOrganizationRequest,
        ActionsGetGithubActionsPermissionsOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetGithubActionsPermissionsOrganizationHandler>(
            Handlers.ActionsGetGithubActionsPermissionsOrganizationHandler
          );

        await controller.actionsGetGithubActionsPermissionsOrganization(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsSetGithubActionsPermissionsOrganizationHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/actions/permissions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            enabled_repositories: {
              $ref: '#/definitions/enabled-repositories'
            },
            allowed_actions: { $ref: '#/definitions/allowed-actions' }
          },
          required: ['enabled_repositories'],
          definitions: {
            'enabled-repositories': {
              type: 'string',
              description:
                'The policy that controls the repositories in the organization that are allowed to run GitHub Actions.',
              enum: ['all', 'none', 'selected'],
              title: 'enabled-repositories'
            },
            'allowed-actions': {
              type: 'string',
              description:
                'The permissions policy that controls the actions and reusable workflows that are allowed to run.',
              enum: ['all', 'local_only', 'selected'],
              title: 'allowed-actions'
            }
          }
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsSetGithubActionsPermissionsOrganizationRequest,
        ActionsSetGithubActionsPermissionsOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetGithubActionsPermissionsOrganizationHandler>(
            Handlers.ActionsSetGithubActionsPermissionsOrganizationHandler
          );

        await controller.actionsSetGithubActionsPermissionsOrganization(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsListSelectedRepositoriesEnabledGithubActionsOrganizationHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/actions/permissions/repositories',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationRequest,
        ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationHandler>(
            Handlers.ActionsListSelectedRepositoriesEnabledGithubActionsOrganizationHandler
          );

        await controller.actionsListSelectedRepositoriesEnabledGithubActionsOrganization(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/actions/permissions/repositories',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            selected_repository_ids: {
              description:
                'List of repository IDs to enable for GitHub Actions.',
              type: 'array',
              items: {
                type: 'integer',
                description: 'Unique identifier of the repository.'
              }
            }
          },
          required: ['selected_repository_ids']
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationRequest,
        ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationHandler>(
            Handlers.ActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationHandler
          );

        await controller.actionsSetSelectedRepositoriesEnabledGithubActionsOrganization(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsEnableSelectedRepositoryGithubActionsOrganizationHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/actions/permissions/repositories/:repository_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            repository_id: { type: 'integer' }
          },
          required: ['org', 'repository_id']
        }
      }),

      asyncRequestHandler<
        ActionsEnableSelectedRepositoryGithubActionsOrganizationRequest,
        ActionsEnableSelectedRepositoryGithubActionsOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsEnableSelectedRepositoryGithubActionsOrganizationHandler>(
            Handlers.ActionsEnableSelectedRepositoryGithubActionsOrganizationHandler
          );

        await controller.actionsEnableSelectedRepositoryGithubActionsOrganization(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsDisableSelectedRepositoryGithubActionsOrganizationHandler(
    router: Router
  ): void {
    router.delete(
      '/orgs/:org/actions/permissions/repositories/:repository_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            repository_id: { type: 'integer' }
          },
          required: ['org', 'repository_id']
        }
      }),

      asyncRequestHandler<
        ActionsDisableSelectedRepositoryGithubActionsOrganizationRequest,
        ActionsDisableSelectedRepositoryGithubActionsOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDisableSelectedRepositoryGithubActionsOrganizationHandler>(
            Handlers.ActionsDisableSelectedRepositoryGithubActionsOrganizationHandler
          );

        await controller.actionsDisableSelectedRepositoryGithubActionsOrganization(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsGetAllowedActionsOrganizationHandler(router: Router): void {
    router.get(
      '/orgs/:org/actions/permissions/selected-actions',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsGetAllowedActionsOrganizationRequest,
        ActionsGetAllowedActionsOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetAllowedActionsOrganizationHandler>(
            Handlers.ActionsGetAllowedActionsOrganizationHandler
          );

        await controller.actionsGetAllowedActionsOrganization(req, res, next);
      })
    );
  }

  private addActionsSetAllowedActionsOrganizationHandler(router: Router): void {
    router.put(
      '/orgs/:org/actions/permissions/selected-actions',

      ControllerMiddleware.validate({
        body: {
          $ref: '#/definitions/selected-actions',
          definitions: {
            'selected-actions': {
              type: 'object',
              properties: {
                github_owned_allowed: {
                  type: 'boolean',
                  description:
                    'Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.'
                },
                verified_allowed: {
                  type: 'boolean',
                  description:
                    'Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators.'
                },
                patterns_allowed: {
                  type: 'array',
                  description:
                    'Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`."',
                  items: { type: 'string' }
                }
              },
              title: 'selected-actions'
            }
          }
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsSetAllowedActionsOrganizationRequest,
        ActionsSetAllowedActionsOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetAllowedActionsOrganizationHandler>(
            Handlers.ActionsSetAllowedActionsOrganizationHandler
          );

        await controller.actionsSetAllowedActionsOrganization(req, res, next);
      })
    );
  }

  private addActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/actions/permissions/workflow',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationRequest,
        ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationHandler>(
            Handlers.ActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationHandler
          );

        await controller.actionsGetGithubActionsDefaultWorkflowPermissionsOrganization(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/actions/permissions/workflow',

      ControllerMiddleware.validate({
        body: {
          $ref: '#/definitions/actions-set-default-workflow-permissions',
          definitions: {
            'actions-set-default-workflow-permissions': {
              type: 'object',
              properties: {
                default_workflow_permissions: {
                  $ref: '#/definitions/actions-default-workflow-permissions'
                },
                can_approve_pull_request_reviews: {
                  $ref: '#/definitions/actions-can-approve-pull-request-reviews'
                }
              },
              title: 'actions-set-default-workflow-permissions'
            },
            'actions-default-workflow-permissions': {
              type: 'string',
              description:
                'The default workflow permissions granted to the GITHUB_TOKEN when running workflows.',
              enum: ['read', 'write'],
              title: 'actions-default-workflow-permissions'
            },
            'actions-can-approve-pull-request-reviews': {
              type: 'boolean',
              description:
                'Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.',
              title: 'actions-can-approve-pull-request-reviews'
            }
          }
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationRequest,
        ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationHandler>(
            Handlers.ActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationHandler
          );

        await controller.actionsSetGithubActionsDefaultWorkflowPermissionsOrganization(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsListSelfHostedRunnerGroupsForOrgHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/actions/runner-groups',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 },
            visible_to_repository: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsListSelfHostedRunnerGroupsForOrgRequest,
        ActionsListSelfHostedRunnerGroupsForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListSelfHostedRunnerGroupsForOrgHandler>(
            Handlers.ActionsListSelfHostedRunnerGroupsForOrgHandler
          );

        await controller.actionsListSelfHostedRunnerGroupsForOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsCreateSelfHostedRunnerGroupForOrgHandler(
    router: Router
  ): void {
    router.post(
      '/orgs/:org/actions/runner-groups',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: { description: 'Name of the runner group.', type: 'string' },
            visibility: {
              description:
                'Visibility of a runner group. You can select all repositories, select individual repositories, or limit access to private repositories.',
              type: 'string',
              enum: ['selected', 'all', 'private'],
              default: 'all'
            },
            selected_repository_ids: {
              description:
                'List of repository IDs that can access the runner group.',
              type: 'array',
              items: {
                type: 'integer',
                description: 'Unique identifier of the repository.'
              }
            },
            runners: {
              description: 'List of runner IDs to add to the runner group.',
              type: 'array',
              items: {
                type: 'integer',
                description: 'Unique identifier of the runner.'
              }
            },
            allows_public_repositories: {
              description:
                'Whether the runner group can be used by `public` repositories.',
              type: 'boolean',
              default: false
            },
            restricted_to_workflows: {
              description:
                'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.',
              type: 'boolean',
              default: false
            },
            selected_workflows: {
              description:
                'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.',
              type: 'array',
              items: {
                type: 'string',
                description:
                  'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.',
                example: 'octo-org/octo-repo/.github/workflows/deploy.yaml@main'
              }
            }
          },
          required: ['name']
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsCreateSelfHostedRunnerGroupForOrgRequest,
        ActionsCreateSelfHostedRunnerGroupForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsCreateSelfHostedRunnerGroupForOrgHandler>(
            Handlers.ActionsCreateSelfHostedRunnerGroupForOrgHandler
          );

        await controller.actionsCreateSelfHostedRunnerGroupForOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsGetSelfHostedRunnerGroupForOrgHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/actions/runner-groups/:runner_group_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['org', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        ActionsGetSelfHostedRunnerGroupForOrgRequest,
        ActionsGetSelfHostedRunnerGroupForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetSelfHostedRunnerGroupForOrgHandler>(
            Handlers.ActionsGetSelfHostedRunnerGroupForOrgHandler
          );

        await controller.actionsGetSelfHostedRunnerGroupForOrg(req, res, next);
      })
    );
  }

  private addActionsUpdateSelfHostedRunnerGroupForOrgHandler(
    router: Router
  ): void {
    router.patch(
      '/orgs/:org/actions/runner-groups/:runner_group_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: { description: 'Name of the runner group.', type: 'string' },
            visibility: {
              description:
                'Visibility of a runner group. You can select all repositories, select individual repositories, or all private repositories.',
              type: 'string',
              enum: ['selected', 'all', 'private']
            },
            allows_public_repositories: {
              description:
                'Whether the runner group can be used by `public` repositories.',
              type: 'boolean',
              default: false
            },
            restricted_to_workflows: {
              description:
                'If `true`, the runner group will be restricted to running only the workflows specified in the `selected_workflows` array.',
              type: 'boolean',
              default: false
            },
            selected_workflows: {
              description:
                'List of workflows the runner group should be allowed to run. This setting will be ignored unless `restricted_to_workflows` is set to `true`.',
              type: 'array',
              items: {
                type: 'string',
                description:
                  'Name of workflow the runner group should be allowed to run. Note that a ref, tag, or long SHA is required.',
                example: 'octo-org/octo-repo/.github/workflows/deploy.yaml@main'
              }
            }
          },
          required: ['name']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['org', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        ActionsUpdateSelfHostedRunnerGroupForOrgRequest,
        ActionsUpdateSelfHostedRunnerGroupForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsUpdateSelfHostedRunnerGroupForOrgHandler>(
            Handlers.ActionsUpdateSelfHostedRunnerGroupForOrgHandler
          );

        await controller.actionsUpdateSelfHostedRunnerGroupForOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsDeleteSelfHostedRunnerGroupFromOrgHandler(
    router: Router
  ): void {
    router.delete(
      '/orgs/:org/actions/runner-groups/:runner_group_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['org', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        ActionsDeleteSelfHostedRunnerGroupFromOrgRequest,
        ActionsDeleteSelfHostedRunnerGroupFromOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDeleteSelfHostedRunnerGroupFromOrgHandler>(
            Handlers.ActionsDeleteSelfHostedRunnerGroupFromOrgHandler
          );

        await controller.actionsDeleteSelfHostedRunnerGroupFromOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsListRepoAccessToSelfHostedRunnerGroupInOrgHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/actions/runner-groups/:runner_group_id/repositories',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['org', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        ActionsListRepoAccessToSelfHostedRunnerGroupInOrgRequest,
        ActionsListRepoAccessToSelfHostedRunnerGroupInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListRepoAccessToSelfHostedRunnerGroupInOrgHandler>(
            Handlers.ActionsListRepoAccessToSelfHostedRunnerGroupInOrgHandler
          );

        await controller.actionsListRepoAccessToSelfHostedRunnerGroupInOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsSetRepoAccessToSelfHostedRunnerGroupInOrgHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/actions/runner-groups/:runner_group_id/repositories',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            selected_repository_ids: {
              description:
                'List of repository IDs that can access the runner group.',
              type: 'array',
              items: {
                type: 'integer',
                description: 'Unique identifier of the repository.'
              }
            }
          },
          required: ['selected_repository_ids']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['org', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgRequest,
        ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgHandler>(
            Handlers.ActionsSetRepoAccessToSelfHostedRunnerGroupInOrgHandler
          );

        await controller.actionsSetRepoAccessToSelfHostedRunnerGroupInOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgHandler(
    router: Router
  ): void {
    router.delete(
      '/orgs/:org/actions/runner-groups/:runner_group_id/repositories/:repository_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_group_id: { type: 'integer' },
            repository_id: { type: 'integer' }
          },
          required: ['org', 'runner_group_id', 'repository_id']
        }
      }),

      asyncRequestHandler<
        ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgRequest,
        ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgHandler>(
            Handlers.ActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgHandler
          );

        await controller.actionsRemoveRepoAccessToSelfHostedRunnerGroupInOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsListSelfHostedRunnersInGroupForOrgHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/actions/runner-groups/:runner_group_id/runners',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['org', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        ActionsListSelfHostedRunnersInGroupForOrgRequest,
        ActionsListSelfHostedRunnersInGroupForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListSelfHostedRunnersInGroupForOrgHandler>(
            Handlers.ActionsListSelfHostedRunnersInGroupForOrgHandler
          );

        await controller.actionsListSelfHostedRunnersInGroupForOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsSetSelfHostedRunnersInGroupForOrgHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/actions/runner-groups/:runner_group_id/runners',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            runners: {
              description: 'List of runner IDs to add to the runner group.',
              type: 'array',
              items: {
                type: 'integer',
                description: 'Unique identifier of the runner.'
              }
            }
          },
          required: ['runners']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_group_id: { type: 'integer' }
          },
          required: ['org', 'runner_group_id']
        }
      }),

      asyncRequestHandler<
        ActionsSetSelfHostedRunnersInGroupForOrgRequest,
        ActionsSetSelfHostedRunnersInGroupForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetSelfHostedRunnersInGroupForOrgHandler>(
            Handlers.ActionsSetSelfHostedRunnersInGroupForOrgHandler
          );

        await controller.actionsSetSelfHostedRunnersInGroupForOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsAddSelfHostedRunnerToGroupForOrgHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/actions/runner-groups/:runner_group_id/runners/:runner_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_group_id: { type: 'integer' },
            runner_id: { type: 'integer' }
          },
          required: ['org', 'runner_group_id', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsAddSelfHostedRunnerToGroupForOrgRequest,
        ActionsAddSelfHostedRunnerToGroupForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsAddSelfHostedRunnerToGroupForOrgHandler>(
            Handlers.ActionsAddSelfHostedRunnerToGroupForOrgHandler
          );

        await controller.actionsAddSelfHostedRunnerToGroupForOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsRemoveSelfHostedRunnerFromGroupForOrgHandler(
    router: Router
  ): void {
    router.delete(
      '/orgs/:org/actions/runner-groups/:runner_group_id/runners/:runner_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_group_id: { type: 'integer' },
            runner_id: { type: 'integer' }
          },
          required: ['org', 'runner_group_id', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsRemoveSelfHostedRunnerFromGroupForOrgRequest,
        ActionsRemoveSelfHostedRunnerFromGroupForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsRemoveSelfHostedRunnerFromGroupForOrgHandler>(
            Handlers.ActionsRemoveSelfHostedRunnerFromGroupForOrgHandler
          );

        await controller.actionsRemoveSelfHostedRunnerFromGroupForOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsListSelfHostedRunnersForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/actions/runners',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsListSelfHostedRunnersForOrgRequest,
        ActionsListSelfHostedRunnersForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListSelfHostedRunnersForOrgHandler>(
            Handlers.ActionsListSelfHostedRunnersForOrgHandler
          );

        await controller.actionsListSelfHostedRunnersForOrg(req, res, next);
      })
    );
  }

  private addActionsListRunnerApplicationsForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/actions/runners/downloads',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsListRunnerApplicationsForOrgRequest,
        ActionsListRunnerApplicationsForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListRunnerApplicationsForOrgHandler>(
            Handlers.ActionsListRunnerApplicationsForOrgHandler
          );

        await controller.actionsListRunnerApplicationsForOrg(req, res, next);
      })
    );
  }

  private addActionsCreateRegistrationTokenForOrgHandler(router: Router): void {
    router.post(
      '/orgs/:org/actions/runners/registration-token',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsCreateRegistrationTokenForOrgRequest,
        ActionsCreateRegistrationTokenForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsCreateRegistrationTokenForOrgHandler>(
            Handlers.ActionsCreateRegistrationTokenForOrgHandler
          );

        await controller.actionsCreateRegistrationTokenForOrg(req, res, next);
      })
    );
  }

  private addActionsCreateRemoveTokenForOrgHandler(router: Router): void {
    router.post(
      '/orgs/:org/actions/runners/remove-token',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsCreateRemoveTokenForOrgRequest,
        ActionsCreateRemoveTokenForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsCreateRemoveTokenForOrgHandler>(
            Handlers.ActionsCreateRemoveTokenForOrgHandler
          );

        await controller.actionsCreateRemoveTokenForOrg(req, res, next);
      })
    );
  }

  private addActionsGetSelfHostedRunnerForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/actions/runners/:runner_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['org', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsGetSelfHostedRunnerForOrgRequest,
        ActionsGetSelfHostedRunnerForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetSelfHostedRunnerForOrgHandler>(
            Handlers.ActionsGetSelfHostedRunnerForOrgHandler
          );

        await controller.actionsGetSelfHostedRunnerForOrg(req, res, next);
      })
    );
  }

  private addActionsDeleteSelfHostedRunnerFromOrgHandler(router: Router): void {
    router.delete(
      '/orgs/:org/actions/runners/:runner_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['org', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsDeleteSelfHostedRunnerFromOrgRequest,
        ActionsDeleteSelfHostedRunnerFromOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDeleteSelfHostedRunnerFromOrgHandler>(
            Handlers.ActionsDeleteSelfHostedRunnerFromOrgHandler
          );

        await controller.actionsDeleteSelfHostedRunnerFromOrg(req, res, next);
      })
    );
  }

  private addActionsListLabelsForSelfHostedRunnerForOrgHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/actions/runners/:runner_id/labels',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['org', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsListLabelsForSelfHostedRunnerForOrgRequest,
        ActionsListLabelsForSelfHostedRunnerForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListLabelsForSelfHostedRunnerForOrgHandler>(
            Handlers.ActionsListLabelsForSelfHostedRunnerForOrgHandler
          );

        await controller.actionsListLabelsForSelfHostedRunnerForOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsAddCustomLabelsToSelfHostedRunnerForOrgHandler(
    router: Router
  ): void {
    router.post(
      '/orgs/:org/actions/runners/:runner_id/labels',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          required: ['labels'],
          properties: {
            labels: {
              type: 'array',
              minItems: 1,
              maxItems: 100,
              description:
                'The names of the custom labels to add to the runner.',
              items: { type: 'string' }
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['org', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsAddCustomLabelsToSelfHostedRunnerForOrgRequest,
        ActionsAddCustomLabelsToSelfHostedRunnerForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsAddCustomLabelsToSelfHostedRunnerForOrgHandler>(
            Handlers.ActionsAddCustomLabelsToSelfHostedRunnerForOrgHandler
          );

        await controller.actionsAddCustomLabelsToSelfHostedRunnerForOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsSetCustomLabelsForSelfHostedRunnerForOrgHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/actions/runners/:runner_id/labels',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          required: ['labels'],
          properties: {
            labels: {
              type: 'array',
              minItems: 0,
              maxItems: 100,
              description:
                'The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.',
              items: { type: 'string' }
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['org', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsSetCustomLabelsForSelfHostedRunnerForOrgRequest,
        ActionsSetCustomLabelsForSelfHostedRunnerForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetCustomLabelsForSelfHostedRunnerForOrgHandler>(
            Handlers.ActionsSetCustomLabelsForSelfHostedRunnerForOrgHandler
          );

        await controller.actionsSetCustomLabelsForSelfHostedRunnerForOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgHandler(
    router: Router
  ): void {
    router.delete(
      '/orgs/:org/actions/runners/:runner_id/labels',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['org', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgRequest,
        ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgHandler>(
            Handlers.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgHandler
          );

        await controller.actionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsRemoveCustomLabelFromSelfHostedRunnerForOrgHandler(
    router: Router
  ): void {
    router.delete(
      '/orgs/:org/actions/runners/:runner_id/labels/:name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            runner_id: { type: 'integer' },
            name: { type: 'string' }
          },
          required: ['org', 'runner_id', 'name']
        }
      }),

      asyncRequestHandler<
        ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgRequest,
        ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgHandler>(
            Handlers.ActionsRemoveCustomLabelFromSelfHostedRunnerForOrgHandler
          );

        await controller.actionsRemoveCustomLabelFromSelfHostedRunnerForOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsListOrgSecretsHandler(router: Router): void {
    router.get(
      '/orgs/:org/actions/secrets',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsListOrgSecretsRequest,
        ActionsListOrgSecretsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListOrgSecretsHandler>(
            Handlers.ActionsListOrgSecretsHandler
          );

        await controller.actionsListOrgSecrets(req, res, next);
      })
    );
  }

  private addActionsGetOrgPublicKeyHandler(router: Router): void {
    router.get(
      '/orgs/:org/actions/secrets/public-key',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActionsGetOrgPublicKeyRequest,
        ActionsGetOrgPublicKeyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetOrgPublicKeyHandler>(
            Handlers.ActionsGetOrgPublicKeyHandler
          );

        await controller.actionsGetOrgPublicKey(req, res, next);
      })
    );
  }

  private addActionsGetOrgSecretHandler(router: Router): void {
    router.get(
      '/orgs/:org/actions/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        ActionsGetOrgSecretRequest,
        ActionsGetOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetOrgSecretHandler>(
            Handlers.ActionsGetOrgSecretHandler
          );

        await controller.actionsGetOrgSecret(req, res, next);
      })
    );
  }

  private addActionsCreateOrUpdateOrgSecretHandler(router: Router): void {
    router.put(
      '/orgs/:org/actions/secrets/:secret_name',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            encrypted_value: {
              type: 'string',
              description:
                'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/reference/actions#get-an-organization-public-key) endpoint.',
              pattern:
                '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
            },
            key_id: {
              type: 'string',
              description: 'ID of the key you used to encrypt the secret.'
            },
            visibility: {
              type: 'string',
              description:
                'Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.',
              enum: ['all', 'private', 'selected']
            },
            selected_repository_ids: {
              type: 'array',
              description:
                'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/reference/actions#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/reference/actions#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/reference/actions#remove-selected-repository-from-an-organization-secret) endpoints.',
              items: { type: 'integer' }
            }
          },
          required: ['visibility']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        ActionsCreateOrUpdateOrgSecretRequest,
        ActionsCreateOrUpdateOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsCreateOrUpdateOrgSecretHandler>(
            Handlers.ActionsCreateOrUpdateOrgSecretHandler
          );

        await controller.actionsCreateOrUpdateOrgSecret(req, res, next);
      })
    );
  }

  private addActionsDeleteOrgSecretHandler(router: Router): void {
    router.delete(
      '/orgs/:org/actions/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        ActionsDeleteOrgSecretRequest,
        ActionsDeleteOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDeleteOrgSecretHandler>(
            Handlers.ActionsDeleteOrgSecretHandler
          );

        await controller.actionsDeleteOrgSecret(req, res, next);
      })
    );
  }

  private addActionsListSelectedReposForOrgSecretHandler(router: Router): void {
    router.get(
      '/orgs/:org/actions/secrets/:secret_name/repositories',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        ActionsListSelectedReposForOrgSecretRequest,
        ActionsListSelectedReposForOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListSelectedReposForOrgSecretHandler>(
            Handlers.ActionsListSelectedReposForOrgSecretHandler
          );

        await controller.actionsListSelectedReposForOrgSecret(req, res, next);
      })
    );
  }

  private addActionsSetSelectedReposForOrgSecretHandler(router: Router): void {
    router.put(
      '/orgs/:org/actions/secrets/:secret_name/repositories',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            selected_repository_ids: {
              type: 'array',
              description:
                'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Add selected repository to an organization secret](https://docs.github.com/rest/actions/secrets#add-selected-repository-to-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/reference/actions#remove-selected-repository-from-an-organization-secret) endpoints.',
              items: { type: 'integer' }
            }
          },
          required: ['selected_repository_ids']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        ActionsSetSelectedReposForOrgSecretRequest,
        ActionsSetSelectedReposForOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetSelectedReposForOrgSecretHandler>(
            Handlers.ActionsSetSelectedReposForOrgSecretHandler
          );

        await controller.actionsSetSelectedReposForOrgSecret(req, res, next);
      })
    );
  }

  private addActionsAddSelectedRepoToOrgSecretHandler(router: Router): void {
    router.put(
      '/orgs/:org/actions/secrets/:secret_name/repositories/:repository_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' },
            repository_id: { type: 'integer' }
          },
          required: ['org', 'secret_name', 'repository_id']
        }
      }),

      asyncRequestHandler<
        ActionsAddSelectedRepoToOrgSecretRequest,
        ActionsAddSelectedRepoToOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsAddSelectedRepoToOrgSecretHandler>(
            Handlers.ActionsAddSelectedRepoToOrgSecretHandler
          );

        await controller.actionsAddSelectedRepoToOrgSecret(req, res, next);
      })
    );
  }

  private addActionsRemoveSelectedRepoFromOrgSecretHandler(
    router: Router
  ): void {
    router.delete(
      '/orgs/:org/actions/secrets/:secret_name/repositories/:repository_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' },
            repository_id: { type: 'integer' }
          },
          required: ['org', 'secret_name', 'repository_id']
        }
      }),

      asyncRequestHandler<
        ActionsRemoveSelectedRepoFromOrgSecretRequest,
        ActionsRemoveSelectedRepoFromOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsRemoveSelectedRepoFromOrgSecretHandler>(
            Handlers.ActionsRemoveSelectedRepoFromOrgSecretHandler
          );

        await controller.actionsRemoveSelectedRepoFromOrgSecret(req, res, next);
      })
    );
  }

  private addOrgsListBlockedUsersHandler(router: Router): void {
    router.get(
      '/orgs/:org/blocks',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        OrgsListBlockedUsersRequest,
        OrgsListBlockedUsersResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsListBlockedUsersHandler>(
            Handlers.OrgsListBlockedUsersHandler
          );

        await controller.orgsListBlockedUsers(req, res, next);
      })
    );
  }

  private addOrgsCheckBlockedUserHandler(router: Router): void {
    router.get(
      '/orgs/:org/blocks/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<
        OrgsCheckBlockedUserRequest,
        OrgsCheckBlockedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsCheckBlockedUserHandler>(
            Handlers.OrgsCheckBlockedUserHandler
          );

        await controller.orgsCheckBlockedUser(req, res, next);
      })
    );
  }

  private addOrgsBlockUserHandler(router: Router): void {
    router.put(
      '/orgs/:org/blocks/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<OrgsBlockUserRequest, OrgsBlockUserResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsBlockUserHandler>(Handlers.OrgsBlockUserHandler);

          await controller.orgsBlockUser(req, res, next);
        }
      )
    );
  }

  private addOrgsUnblockUserHandler(router: Router): void {
    router.delete(
      '/orgs/:org/blocks/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<OrgsUnblockUserRequest, OrgsUnblockUserResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsUnblockUserHandler>(Handlers.OrgsUnblockUserHandler);

          await controller.orgsUnblockUser(req, res, next);
        }
      )
    );
  }

  private addCodeScanningListAlertsForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/code-scanning/alerts',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            tool_name: {
              $ref: '#/definitions/code-scanning-analysis-tool-name'
            },
            tool_guid: {
              $ref: '#/definitions/code-scanning-analysis-tool-guid'
            },
            before: { type: 'string' },
            after: { type: 'string' },
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            state: { $ref: '#/definitions/code-scanning-alert-state' },
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            }
          },
          required: [],
          definitions: {
            'code-scanning-analysis-tool-name': {
              type: 'string',
              description:
                'The name of the tool used to generate the code scanning analysis.',
              title: 'code-scanning-analysis-tool-name'
            },
            'code-scanning-analysis-tool-guid': {
              nullable: true,
              type: 'string',
              description:
                'The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.',
              title: 'code-scanning-analysis-tool-guid'
            },
            'code-scanning-alert-state': {
              type: 'string',
              description: 'State of a code scanning alert.',
              enum: ['open', 'closed', 'dismissed', 'fixed'],
              title: 'code-scanning-alert-state'
            }
          }
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        CodeScanningListAlertsForOrgRequest,
        CodeScanningListAlertsForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodeScanningListAlertsForOrgHandler>(
            Handlers.CodeScanningListAlertsForOrgHandler
          );

        await controller.codeScanningListAlertsForOrg(req, res, next);
      })
    );
  }

  private addCodespacesListInOrganizationHandler(router: Router): void {
    router.get(
      '/orgs/:org/codespaces',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        CodespacesListInOrganizationRequest,
        CodespacesListInOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesListInOrganizationHandler>(
            Handlers.CodespacesListInOrganizationHandler
          );

        await controller.codespacesListInOrganization(req, res, next);
      })
    );
  }

  private addCodespacesSetCodespacesBillingHandler(router: Router): void {
    router.put(
      '/orgs/:org/codespaces/billing',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            visibility: {
              type: 'string',
              description:
                'Which users can access codespaces in the organization. `disabled` means that no users can access codespaces in the organization.',
              enum: [
                'disabled',
                'selected_members',
                'all_members',
                'all_members_and_outside_collaborators'
              ]
            },
            selected_usernames: {
              type: 'array',
              description:
                'The usernames of the organization members who should be granted access to codespaces in the organization. Required when `visibility` is `selected_members`.',
              items: { type: 'string' }
            }
          },
          required: ['visibility']
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        CodespacesSetCodespacesBillingRequest,
        CodespacesSetCodespacesBillingResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesSetCodespacesBillingHandler>(
            Handlers.CodespacesSetCodespacesBillingHandler
          );

        await controller.codespacesSetCodespacesBilling(req, res, next);
      })
    );
  }

  private addCodespacesListOrgSecretsHandler(router: Router): void {
    router.get(
      '/orgs/:org/codespaces/secrets',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        CodespacesListOrgSecretsRequest,
        CodespacesListOrgSecretsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesListOrgSecretsHandler>(
            Handlers.CodespacesListOrgSecretsHandler
          );

        await controller.codespacesListOrgSecrets(req, res, next);
      })
    );
  }

  private addCodespacesGetOrgPublicKeyHandler(router: Router): void {
    router.get(
      '/orgs/:org/codespaces/secrets/public-key',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        CodespacesGetOrgPublicKeyRequest,
        CodespacesGetOrgPublicKeyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesGetOrgPublicKeyHandler>(
            Handlers.CodespacesGetOrgPublicKeyHandler
          );

        await controller.codespacesGetOrgPublicKey(req, res, next);
      })
    );
  }

  private addCodespacesGetOrgSecretHandler(router: Router): void {
    router.get(
      '/orgs/:org/codespaces/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        CodespacesGetOrgSecretRequest,
        CodespacesGetOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesGetOrgSecretHandler>(
            Handlers.CodespacesGetOrgSecretHandler
          );

        await controller.codespacesGetOrgSecret(req, res, next);
      })
    );
  }

  private addCodespacesCreateOrUpdateOrgSecretHandler(router: Router): void {
    router.put(
      '/orgs/:org/codespaces/secrets/:secret_name',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            encrypted_value: {
              type: 'string',
              description:
                'The value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/reference/codespaces#get-an-organization-public-key) endpoint.',
              pattern:
                '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
            },
            key_id: {
              type: 'string',
              description: 'The ID of the key you used to encrypt the secret.'
            },
            visibility: {
              type: 'string',
              description:
                'Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.',
              enum: ['all', 'private', 'selected']
            },
            selected_repository_ids: {
              type: 'array',
              description:
                'An array of repository IDs that can access the organization secret. You can only provide a list of repository IDs when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/reference/codespaces#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/reference/codespaces#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/reference/codespaces#remove-selected-repository-from-an-organization-secret) endpoints.',
              items: { type: 'integer' }
            }
          },
          required: ['visibility']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        CodespacesCreateOrUpdateOrgSecretRequest,
        CodespacesCreateOrUpdateOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesCreateOrUpdateOrgSecretHandler>(
            Handlers.CodespacesCreateOrUpdateOrgSecretHandler
          );

        await controller.codespacesCreateOrUpdateOrgSecret(req, res, next);
      })
    );
  }

  private addCodespacesDeleteOrgSecretHandler(router: Router): void {
    router.delete(
      '/orgs/:org/codespaces/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        CodespacesDeleteOrgSecretRequest,
        CodespacesDeleteOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesDeleteOrgSecretHandler>(
            Handlers.CodespacesDeleteOrgSecretHandler
          );

        await controller.codespacesDeleteOrgSecret(req, res, next);
      })
    );
  }

  private addCodespacesListSelectedReposForOrgSecretHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/codespaces/secrets/:secret_name/repositories',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        CodespacesListSelectedReposForOrgSecretRequest,
        CodespacesListSelectedReposForOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesListSelectedReposForOrgSecretHandler>(
            Handlers.CodespacesListSelectedReposForOrgSecretHandler
          );

        await controller.codespacesListSelectedReposForOrgSecret(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesSetSelectedReposForOrgSecretHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/codespaces/secrets/:secret_name/repositories',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            selected_repository_ids: {
              type: 'array',
              description:
                'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/reference/codespaces#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/reference/codespaces#remove-selected-repository-from-an-organization-secret) endpoints.',
              items: { type: 'integer' }
            }
          },
          required: ['selected_repository_ids']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        CodespacesSetSelectedReposForOrgSecretRequest,
        CodespacesSetSelectedReposForOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesSetSelectedReposForOrgSecretHandler>(
            Handlers.CodespacesSetSelectedReposForOrgSecretHandler
          );

        await controller.codespacesSetSelectedReposForOrgSecret(req, res, next);
      })
    );
  }

  private addCodespacesAddSelectedRepoToOrgSecretHandler(router: Router): void {
    router.put(
      '/orgs/:org/codespaces/secrets/:secret_name/repositories/:repository_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' },
            repository_id: { type: 'integer' }
          },
          required: ['org', 'secret_name', 'repository_id']
        }
      }),

      asyncRequestHandler<
        CodespacesAddSelectedRepoToOrgSecretRequest,
        CodespacesAddSelectedRepoToOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesAddSelectedRepoToOrgSecretHandler>(
            Handlers.CodespacesAddSelectedRepoToOrgSecretHandler
          );

        await controller.codespacesAddSelectedRepoToOrgSecret(req, res, next);
      })
    );
  }

  private addCodespacesRemoveSelectedRepoFromOrgSecretHandler(
    router: Router
  ): void {
    router.delete(
      '/orgs/:org/codespaces/secrets/:secret_name/repositories/:repository_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' },
            repository_id: { type: 'integer' }
          },
          required: ['org', 'secret_name', 'repository_id']
        }
      }),

      asyncRequestHandler<
        CodespacesRemoveSelectedRepoFromOrgSecretRequest,
        CodespacesRemoveSelectedRepoFromOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesRemoveSelectedRepoFromOrgSecretHandler>(
            Handlers.CodespacesRemoveSelectedRepoFromOrgSecretHandler
          );

        await controller.codespacesRemoveSelectedRepoFromOrgSecret(
          req,
          res,
          next
        );
      })
    );
  }

  private addOrgsCreateCustomRoleHandler(router: Router): void {
    router.post(
      '/orgs/:org/custom_roles',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description: 'The name of the custom role.'
            },
            description: {
              type: 'string',
              description:
                'A short description about the intended usage of this role or what permissions it grants.'
            },
            base_role: {
              type: 'string',
              enum: ['read', 'triage', 'write', 'maintain'],
              description:
                'The system role from which this role inherits permissions.'
            },
            permissions: {
              type: 'array',
              description:
                'A list of additional permissions included in this role.',
              items: { type: 'string' }
            }
          },
          required: ['name', 'base_role', 'permissions']
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        OrgsCreateCustomRoleRequest,
        OrgsCreateCustomRoleResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsCreateCustomRoleHandler>(
            Handlers.OrgsCreateCustomRoleHandler
          );

        await controller.orgsCreateCustomRole(req, res, next);
      })
    );
  }

  private addOrgsGetCustomRoleHandler(router: Router): void {
    router.get(
      '/orgs/:org/custom_roles/:role_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, role_id: { type: 'integer' } },
          required: ['org', 'role_id']
        }
      }),

      asyncRequestHandler<OrgsGetCustomRoleRequest, OrgsGetCustomRoleResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsGetCustomRoleHandler>(
              Handlers.OrgsGetCustomRoleHandler
            );

          await controller.orgsGetCustomRole(req, res, next);
        }
      )
    );
  }

  private addOrgsUpdateCustomRoleHandler(router: Router): void {
    router.patch(
      '/orgs/:org/custom_roles/:role_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description: 'The name of the custom role.'
            },
            description: {
              type: 'string',
              description:
                'A short description about who this role is for or what permissions it grants.'
            },
            base_role: {
              type: 'string',
              enum: ['read', 'triage', 'write', 'maintain'],
              description:
                'The system role from which this role inherits permissions.'
            },
            permissions: {
              type: 'array',
              description:
                'A list of additional permissions included in this role. If specified, these permissions will replace any currently set on the role.',
              items: { type: 'string' }
            }
          }
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' }, role_id: { type: 'integer' } },
          required: ['org', 'role_id']
        }
      }),

      asyncRequestHandler<
        OrgsUpdateCustomRoleRequest,
        OrgsUpdateCustomRoleResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsUpdateCustomRoleHandler>(
            Handlers.OrgsUpdateCustomRoleHandler
          );

        await controller.orgsUpdateCustomRole(req, res, next);
      })
    );
  }

  private addOrgsDeleteCustomRoleHandler(router: Router): void {
    router.delete(
      '/orgs/:org/custom_roles/:role_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, role_id: { type: 'integer' } },
          required: ['org', 'role_id']
        }
      }),

      asyncRequestHandler<
        OrgsDeleteCustomRoleRequest,
        OrgsDeleteCustomRoleResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsDeleteCustomRoleHandler>(
            Handlers.OrgsDeleteCustomRoleHandler
          );

        await controller.orgsDeleteCustomRole(req, res, next);
      })
    );
  }

  private addDependabotListAlertsForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/dependabot/alerts',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            state: { type: 'string' },
            severity: { type: 'string' },
            ecosystem: { type: 'string' },
            package: { type: 'string' },
            scope: { type: 'string', enum: ['development', 'runtime'] },
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            before: { type: 'string' },
            after: { type: 'string' },
            first: { type: 'integer', minimum: 1, maximum: 100, default: 30 },
            last: { type: 'integer', minimum: 1, maximum: 100 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        DependabotListAlertsForOrgRequest,
        DependabotListAlertsForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotListAlertsForOrgHandler>(
            Handlers.DependabotListAlertsForOrgHandler
          );

        await controller.dependabotListAlertsForOrg(req, res, next);
      })
    );
  }

  private addDependabotListOrgSecretsHandler(router: Router): void {
    router.get(
      '/orgs/:org/dependabot/secrets',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        DependabotListOrgSecretsRequest,
        DependabotListOrgSecretsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotListOrgSecretsHandler>(
            Handlers.DependabotListOrgSecretsHandler
          );

        await controller.dependabotListOrgSecrets(req, res, next);
      })
    );
  }

  private addDependabotGetOrgPublicKeyHandler(router: Router): void {
    router.get(
      '/orgs/:org/dependabot/secrets/public-key',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        DependabotGetOrgPublicKeyRequest,
        DependabotGetOrgPublicKeyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotGetOrgPublicKeyHandler>(
            Handlers.DependabotGetOrgPublicKeyHandler
          );

        await controller.dependabotGetOrgPublicKey(req, res, next);
      })
    );
  }

  private addDependabotGetOrgSecretHandler(router: Router): void {
    router.get(
      '/orgs/:org/dependabot/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        DependabotGetOrgSecretRequest,
        DependabotGetOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotGetOrgSecretHandler>(
            Handlers.DependabotGetOrgSecretHandler
          );

        await controller.dependabotGetOrgSecret(req, res, next);
      })
    );
  }

  private addDependabotCreateOrUpdateOrgSecretHandler(router: Router): void {
    router.put(
      '/orgs/:org/dependabot/secrets/:secret_name',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            encrypted_value: {
              type: 'string',
              description:
                'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an organization public key](https://docs.github.com/rest/reference/dependabot#get-an-organization-public-key) endpoint.',
              pattern:
                '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
            },
            key_id: {
              type: 'string',
              description: 'ID of the key you used to encrypt the secret.'
            },
            visibility: {
              type: 'string',
              description:
                'Which type of organization repositories have access to the organization secret. `selected` means only the repositories specified by `selected_repository_ids` can access the secret.',
              enum: ['all', 'private', 'selected']
            },
            selected_repository_ids: {
              type: 'array',
              description:
                'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can manage the list of selected repositories using the [List selected repositories for an organization secret](https://docs.github.com/rest/reference/dependabot#list-selected-repositories-for-an-organization-secret), [Set selected repositories for an organization secret](https://docs.github.com/rest/reference/dependabot#set-selected-repositories-for-an-organization-secret), and [Remove selected repository from an organization secret](https://docs.github.com/rest/reference/dependabot#remove-selected-repository-from-an-organization-secret) endpoints.',
              items: { type: 'string' }
            }
          },
          required: ['visibility']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        DependabotCreateOrUpdateOrgSecretRequest,
        DependabotCreateOrUpdateOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotCreateOrUpdateOrgSecretHandler>(
            Handlers.DependabotCreateOrUpdateOrgSecretHandler
          );

        await controller.dependabotCreateOrUpdateOrgSecret(req, res, next);
      })
    );
  }

  private addDependabotDeleteOrgSecretHandler(router: Router): void {
    router.delete(
      '/orgs/:org/dependabot/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        DependabotDeleteOrgSecretRequest,
        DependabotDeleteOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotDeleteOrgSecretHandler>(
            Handlers.DependabotDeleteOrgSecretHandler
          );

        await controller.dependabotDeleteOrgSecret(req, res, next);
      })
    );
  }

  private addDependabotListSelectedReposForOrgSecretHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/dependabot/secrets/:secret_name/repositories',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        DependabotListSelectedReposForOrgSecretRequest,
        DependabotListSelectedReposForOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotListSelectedReposForOrgSecretHandler>(
            Handlers.DependabotListSelectedReposForOrgSecretHandler
          );

        await controller.dependabotListSelectedReposForOrgSecret(
          req,
          res,
          next
        );
      })
    );
  }

  private addDependabotSetSelectedReposForOrgSecretHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/dependabot/secrets/:secret_name/repositories',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            selected_repository_ids: {
              type: 'array',
              description:
                'An array of repository ids that can access the organization secret. You can only provide a list of repository ids when the `visibility` is set to `selected`. You can add and remove individual repositories using the [Set selected repositories for an organization secret](https://docs.github.com/rest/reference/dependabot#set-selected-repositories-for-an-organization-secret) and [Remove selected repository from an organization secret](https://docs.github.com/rest/reference/dependabot#remove-selected-repository-from-an-organization-secret) endpoints.',
              items: { type: 'integer' }
            }
          },
          required: ['selected_repository_ids']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['org', 'secret_name']
        }
      }),

      asyncRequestHandler<
        DependabotSetSelectedReposForOrgSecretRequest,
        DependabotSetSelectedReposForOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotSetSelectedReposForOrgSecretHandler>(
            Handlers.DependabotSetSelectedReposForOrgSecretHandler
          );

        await controller.dependabotSetSelectedReposForOrgSecret(req, res, next);
      })
    );
  }

  private addDependabotAddSelectedRepoToOrgSecretHandler(router: Router): void {
    router.put(
      '/orgs/:org/dependabot/secrets/:secret_name/repositories/:repository_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' },
            repository_id: { type: 'integer' }
          },
          required: ['org', 'secret_name', 'repository_id']
        }
      }),

      asyncRequestHandler<
        DependabotAddSelectedRepoToOrgSecretRequest,
        DependabotAddSelectedRepoToOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotAddSelectedRepoToOrgSecretHandler>(
            Handlers.DependabotAddSelectedRepoToOrgSecretHandler
          );

        await controller.dependabotAddSelectedRepoToOrgSecret(req, res, next);
      })
    );
  }

  private addDependabotRemoveSelectedRepoFromOrgSecretHandler(
    router: Router
  ): void {
    router.delete(
      '/orgs/:org/dependabot/secrets/:secret_name/repositories/:repository_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            secret_name: { type: 'string' },
            repository_id: { type: 'integer' }
          },
          required: ['org', 'secret_name', 'repository_id']
        }
      }),

      asyncRequestHandler<
        DependabotRemoveSelectedRepoFromOrgSecretRequest,
        DependabotRemoveSelectedRepoFromOrgSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotRemoveSelectedRepoFromOrgSecretHandler>(
            Handlers.DependabotRemoveSelectedRepoFromOrgSecretHandler
          );

        await controller.dependabotRemoveSelectedRepoFromOrgSecret(
          req,
          res,
          next
        );
      })
    );
  }

  private addActivityListPublicOrgEventsHandler(router: Router): void {
    router.get(
      '/orgs/:org/events',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ActivityListPublicOrgEventsRequest,
        ActivityListPublicOrgEventsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListPublicOrgEventsHandler>(
            Handlers.ActivityListPublicOrgEventsHandler
          );

        await controller.activityListPublicOrgEvents(req, res, next);
      })
    );
  }

  private addOrgsListFailedInvitationsHandler(router: Router): void {
    router.get(
      '/orgs/:org/failed_invitations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        OrgsListFailedInvitationsRequest,
        OrgsListFailedInvitationsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsListFailedInvitationsHandler>(
            Handlers.OrgsListFailedInvitationsHandler
          );

        await controller.orgsListFailedInvitations(req, res, next);
      })
    );
  }

  private addOrgsListFineGrainedPermissionsHandler(router: Router): void {
    router.get(
      '/orgs/:org/fine_grained_permissions',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        OrgsListFineGrainedPermissionsRequest,
        OrgsListFineGrainedPermissionsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsListFineGrainedPermissionsHandler>(
            Handlers.OrgsListFineGrainedPermissionsHandler
          );

        await controller.orgsListFineGrainedPermissions(req, res, next);
      })
    );
  }

  private addOrgsListWebhooksHandler(router: Router): void {
    router.get(
      '/orgs/:org/hooks',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<OrgsListWebhooksRequest, OrgsListWebhooksResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsListWebhooksHandler>(Handlers.OrgsListWebhooksHandler);

          await controller.orgsListWebhooks(req, res, next);
        }
      )
    );
  }

  private addOrgsCreateWebhookHandler(router: Router): void {
    router.post(
      '/orgs/:org/hooks',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'Must be passed as "web".' },
            config: {
              type: 'object',
              description:
                'Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#create-hook-config-params).',
              properties: {
                url: { $ref: '#/definitions/webhook-config-url' },
                content_type: {
                  $ref: '#/definitions/webhook-config-content-type'
                },
                secret: { $ref: '#/definitions/webhook-config-secret' },
                insecure_ssl: {
                  $ref: '#/definitions/webhook-config-insecure-ssl'
                },
                username: { type: 'string', example: '"kdaigle"' },
                password: { type: 'string', example: '"password"' }
              },
              required: ['url']
            },
            events: {
              type: 'array',
              description:
                'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. Set to `["*"]` to receive all possible events.',
              default: ['push'],
              items: { type: 'string' }
            },
            active: {
              type: 'boolean',
              description:
                'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.',
              default: true
            }
          },
          required: ['name', 'config'],
          definitions: {
            'webhook-config-url': {
              type: 'string',
              description: 'The URL to which the payloads will be delivered.',
              example: 'https://example.com/webhook',
              format: 'uri',
              title: 'webhook-config-url'
            },
            'webhook-config-content-type': {
              type: 'string',
              description:
                'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
              example: '"json"',
              title: 'webhook-config-content-type'
            },
            'webhook-config-secret': {
              type: 'string',
              description:
                'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
              example: '"********"',
              title: 'webhook-config-secret'
            },
            'webhook-config-insecure-ssl': {
              oneOf: [
                {
                  type: 'string',
                  description:
                    'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                  example: '"0"'
                },
                { type: 'number' }
              ],
              title: 'webhook-config-insecure-ssl'
            }
          }
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<OrgsCreateWebhookRequest, OrgsCreateWebhookResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsCreateWebhookHandler>(
              Handlers.OrgsCreateWebhookHandler
            );

          await controller.orgsCreateWebhook(req, res, next);
        }
      )
    );
  }

  private addOrgsGetWebhookHandler(router: Router): void {
    router.get(
      '/orgs/:org/hooks/:hook_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
          required: ['org', 'hook_id']
        }
      }),

      asyncRequestHandler<OrgsGetWebhookRequest, OrgsGetWebhookResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsGetWebhookHandler>(Handlers.OrgsGetWebhookHandler);

          await controller.orgsGetWebhook(req, res, next);
        }
      )
    );
  }

  private addOrgsUpdateWebhookHandler(router: Router): void {
    router.patch(
      '/orgs/:org/hooks/:hook_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            config: {
              type: 'object',
              description:
                'Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/orgs#update-hook-config-params).',
              properties: {
                url: { $ref: '#/definitions/webhook-config-url' },
                content_type: {
                  $ref: '#/definitions/webhook-config-content-type'
                },
                secret: { $ref: '#/definitions/webhook-config-secret' },
                insecure_ssl: {
                  $ref: '#/definitions/webhook-config-insecure-ssl'
                }
              },
              required: ['url']
            },
            events: {
              type: 'array',
              description:
                'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.',
              default: ['push'],
              items: { type: 'string' }
            },
            active: {
              type: 'boolean',
              description:
                'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.',
              default: true
            },
            name: { type: 'string', example: '"web"' }
          },
          definitions: {
            'webhook-config-url': {
              type: 'string',
              description: 'The URL to which the payloads will be delivered.',
              example: 'https://example.com/webhook',
              format: 'uri',
              title: 'webhook-config-url'
            },
            'webhook-config-content-type': {
              type: 'string',
              description:
                'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
              example: '"json"',
              title: 'webhook-config-content-type'
            },
            'webhook-config-secret': {
              type: 'string',
              description:
                'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
              example: '"********"',
              title: 'webhook-config-secret'
            },
            'webhook-config-insecure-ssl': {
              oneOf: [
                {
                  type: 'string',
                  description:
                    'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                  example: '"0"'
                },
                { type: 'number' }
              ],
              title: 'webhook-config-insecure-ssl'
            }
          }
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
          required: ['org', 'hook_id']
        }
      }),

      asyncRequestHandler<OrgsUpdateWebhookRequest, OrgsUpdateWebhookResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsUpdateWebhookHandler>(
              Handlers.OrgsUpdateWebhookHandler
            );

          await controller.orgsUpdateWebhook(req, res, next);
        }
      )
    );
  }

  private addOrgsDeleteWebhookHandler(router: Router): void {
    router.delete(
      '/orgs/:org/hooks/:hook_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
          required: ['org', 'hook_id']
        }
      }),

      asyncRequestHandler<OrgsDeleteWebhookRequest, OrgsDeleteWebhookResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsDeleteWebhookHandler>(
              Handlers.OrgsDeleteWebhookHandler
            );

          await controller.orgsDeleteWebhook(req, res, next);
        }
      )
    );
  }

  private addOrgsGetWebhookConfigForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/hooks/:hook_id/config',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
          required: ['org', 'hook_id']
        }
      }),

      asyncRequestHandler<
        OrgsGetWebhookConfigForOrgRequest,
        OrgsGetWebhookConfigForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsGetWebhookConfigForOrgHandler>(
            Handlers.OrgsGetWebhookConfigForOrgHandler
          );

        await controller.orgsGetWebhookConfigForOrg(req, res, next);
      })
    );
  }

  private addOrgsUpdateWebhookConfigForOrgHandler(router: Router): void {
    router.patch(
      '/orgs/:org/hooks/:hook_id/config',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            url: { $ref: '#/definitions/webhook-config-url' },
            content_type: { $ref: '#/definitions/webhook-config-content-type' },
            secret: { $ref: '#/definitions/webhook-config-secret' },
            insecure_ssl: { $ref: '#/definitions/webhook-config-insecure-ssl' }
          },
          definitions: {
            'webhook-config-url': {
              type: 'string',
              description: 'The URL to which the payloads will be delivered.',
              example: 'https://example.com/webhook',
              format: 'uri',
              title: 'webhook-config-url'
            },
            'webhook-config-content-type': {
              type: 'string',
              description:
                'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
              example: '"json"',
              title: 'webhook-config-content-type'
            },
            'webhook-config-secret': {
              type: 'string',
              description:
                'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
              example: '"********"',
              title: 'webhook-config-secret'
            },
            'webhook-config-insecure-ssl': {
              oneOf: [
                {
                  type: 'string',
                  description:
                    'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                  example: '"0"'
                },
                { type: 'number' }
              ],
              title: 'webhook-config-insecure-ssl'
            }
          }
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
          required: ['org', 'hook_id']
        }
      }),

      asyncRequestHandler<
        OrgsUpdateWebhookConfigForOrgRequest,
        OrgsUpdateWebhookConfigForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsUpdateWebhookConfigForOrgHandler>(
            Handlers.OrgsUpdateWebhookConfigForOrgHandler
          );

        await controller.orgsUpdateWebhookConfigForOrg(req, res, next);
      })
    );
  }

  private addOrgsListWebhookDeliveriesHandler(router: Router): void {
    router.get(
      '/orgs/:org/hooks/:hook_id/deliveries',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            cursor: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
          required: ['org', 'hook_id']
        }
      }),

      asyncRequestHandler<
        OrgsListWebhookDeliveriesRequest,
        OrgsListWebhookDeliveriesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsListWebhookDeliveriesHandler>(
            Handlers.OrgsListWebhookDeliveriesHandler
          );

        await controller.orgsListWebhookDeliveries(req, res, next);
      })
    );
  }

  private addOrgsGetWebhookDeliveryHandler(router: Router): void {
    router.get(
      '/orgs/:org/hooks/:hook_id/deliveries/:delivery_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            hook_id: { type: 'integer' },
            delivery_id: { type: 'integer' }
          },
          required: ['org', 'hook_id', 'delivery_id']
        }
      }),

      asyncRequestHandler<
        OrgsGetWebhookDeliveryRequest,
        OrgsGetWebhookDeliveryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsGetWebhookDeliveryHandler>(
            Handlers.OrgsGetWebhookDeliveryHandler
          );

        await controller.orgsGetWebhookDelivery(req, res, next);
      })
    );
  }

  private addOrgsRedeliverWebhookDeliveryHandler(router: Router): void {
    router.post(
      '/orgs/:org/hooks/:hook_id/deliveries/:delivery_id/attempts',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            hook_id: { type: 'integer' },
            delivery_id: { type: 'integer' }
          },
          required: ['org', 'hook_id', 'delivery_id']
        }
      }),

      asyncRequestHandler<
        OrgsRedeliverWebhookDeliveryRequest,
        OrgsRedeliverWebhookDeliveryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsRedeliverWebhookDeliveryHandler>(
            Handlers.OrgsRedeliverWebhookDeliveryHandler
          );

        await controller.orgsRedeliverWebhookDelivery(req, res, next);
      })
    );
  }

  private addOrgsPingWebhookHandler(router: Router): void {
    router.post(
      '/orgs/:org/hooks/:hook_id/pings',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, hook_id: { type: 'integer' } },
          required: ['org', 'hook_id']
        }
      }),

      asyncRequestHandler<OrgsPingWebhookRequest, OrgsPingWebhookResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsPingWebhookHandler>(Handlers.OrgsPingWebhookHandler);

          await controller.orgsPingWebhook(req, res, next);
        }
      )
    );
  }

  private addAppsGetOrgInstallationHandler(router: Router): void {
    router.get(
      '/orgs/:org/installation',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        AppsGetOrgInstallationRequest,
        AppsGetOrgInstallationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsGetOrgInstallationHandler>(
            Handlers.AppsGetOrgInstallationHandler
          );

        await controller.appsGetOrgInstallation(req, res, next);
      })
    );
  }

  private addOrgsListAppInstallationsHandler(router: Router): void {
    router.get(
      '/orgs/:org/installations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        OrgsListAppInstallationsRequest,
        OrgsListAppInstallationsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsListAppInstallationsHandler>(
            Handlers.OrgsListAppInstallationsHandler
          );

        await controller.orgsListAppInstallations(req, res, next);
      })
    );
  }

  private addInteractionsGetRestrictionsForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/interaction-limits',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        InteractionsGetRestrictionsForOrgRequest,
        InteractionsGetRestrictionsForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<InteractionsGetRestrictionsForOrgHandler>(
            Handlers.InteractionsGetRestrictionsForOrgHandler
          );

        await controller.interactionsGetRestrictionsForOrg(req, res, next);
      })
    );
  }

  private addInteractionsSetRestrictionsForOrgHandler(router: Router): void {
    router.put(
      '/orgs/:org/interaction-limits',

      ControllerMiddleware.validate({
        body: {
          $ref: '#/definitions/interaction-limit',
          definitions: {
            'interaction-limit': {
              title: 'Interaction Restrictions',
              description:
                'Limit interactions to a specific type of user for a specified duration',
              type: 'object',
              properties: {
                limit: { $ref: '#/definitions/interaction-group' },
                expiry: { $ref: '#/definitions/interaction-expiry' }
              },
              required: ['limit']
            },
            'interaction-group': {
              type: 'string',
              description:
                'The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.',
              example: 'collaborators_only',
              enum: [
                'existing_users',
                'contributors_only',
                'collaborators_only'
              ],
              title: 'interaction-group'
            },
            'interaction-expiry': {
              type: 'string',
              description:
                'The duration of the interaction restriction. Default: `one_day`.',
              example: 'one_month',
              enum: [
                'one_day',
                'three_days',
                'one_week',
                'one_month',
                'six_months'
              ],
              title: 'interaction-expiry'
            }
          }
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        InteractionsSetRestrictionsForOrgRequest,
        InteractionsSetRestrictionsForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<InteractionsSetRestrictionsForOrgHandler>(
            Handlers.InteractionsSetRestrictionsForOrgHandler
          );

        await controller.interactionsSetRestrictionsForOrg(req, res, next);
      })
    );
  }

  private addInteractionsRemoveRestrictionsForOrgHandler(router: Router): void {
    router.delete(
      '/orgs/:org/interaction-limits',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        InteractionsRemoveRestrictionsForOrgRequest,
        InteractionsRemoveRestrictionsForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<InteractionsRemoveRestrictionsForOrgHandler>(
            Handlers.InteractionsRemoveRestrictionsForOrgHandler
          );

        await controller.interactionsRemoveRestrictionsForOrg(req, res, next);
      })
    );
  }

  private addOrgsListPendingInvitationsHandler(router: Router): void {
    router.get(
      '/orgs/:org/invitations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        OrgsListPendingInvitationsRequest,
        OrgsListPendingInvitationsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsListPendingInvitationsHandler>(
            Handlers.OrgsListPendingInvitationsHandler
          );

        await controller.orgsListPendingInvitations(req, res, next);
      })
    );
  }

  private addOrgsCreateInvitationHandler(router: Router): void {
    router.post(
      '/orgs/:org/invitations',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            invitee_id: {
              type: 'integer',
              description:
                '**Required unless you provide `email`**. GitHub user ID for the person you are inviting.'
            },
            email: {
              type: 'string',
              description:
                '**Required unless you provide `invitee_id`**. Email address of the person you are inviting, which can be an existing GitHub user.'
            },
            role: {
              type: 'string',
              description:
                'The role for the new member. \n\\* `admin` - Organization owners with full administrative rights to the organization and complete access to all repositories and teams.  \n\\* `direct_member` - Non-owner organization members with ability to see other members and join teams by invitation.  \n\\* `billing_manager` - Non-owner organization members with ability to manage the billing settings of your organization.',
              enum: ['admin', 'direct_member', 'billing_manager'],
              default: 'direct_member'
            },
            team_ids: {
              type: 'array',
              description:
                'Specify IDs for the teams you want to invite new members to.',
              items: { type: 'integer' }
            }
          }
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        OrgsCreateInvitationRequest,
        OrgsCreateInvitationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsCreateInvitationHandler>(
            Handlers.OrgsCreateInvitationHandler
          );

        await controller.orgsCreateInvitation(req, res, next);
      })
    );
  }

  private addOrgsCancelInvitationHandler(router: Router): void {
    router.delete(
      '/orgs/:org/invitations/:invitation_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            invitation_id: { type: 'integer' }
          },
          required: ['org', 'invitation_id']
        }
      }),

      asyncRequestHandler<
        OrgsCancelInvitationRequest,
        OrgsCancelInvitationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsCancelInvitationHandler>(
            Handlers.OrgsCancelInvitationHandler
          );

        await controller.orgsCancelInvitation(req, res, next);
      })
    );
  }

  private addOrgsListInvitationTeamsHandler(router: Router): void {
    router.get(
      '/orgs/:org/invitations/:invitation_id/teams',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            invitation_id: { type: 'integer' }
          },
          required: ['org', 'invitation_id']
        }
      }),

      asyncRequestHandler<
        OrgsListInvitationTeamsRequest,
        OrgsListInvitationTeamsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsListInvitationTeamsHandler>(
            Handlers.OrgsListInvitationTeamsHandler
          );

        await controller.orgsListInvitationTeams(req, res, next);
      })
    );
  }

  private addIssuesListForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/issues',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            filter: {
              type: 'string',
              enum: [
                'assigned',
                'created',
                'mentioned',
                'subscribed',
                'repos',
                'all'
              ],
              default: 'assigned'
            },
            state: {
              type: 'string',
              enum: ['open', 'closed', 'all'],
              default: 'open'
            },
            labels: { type: 'string' },
            sort: {
              type: 'string',
              enum: ['created', 'updated', 'comments'],
              default: 'created'
            },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            since: { type: 'string', format: 'date-time' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<IssuesListForOrgRequest, IssuesListForOrgResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesListForOrgHandler>(Handlers.IssuesListForOrgHandler);

          await controller.issuesListForOrg(req, res, next);
        }
      )
    );
  }

  private addOrgsListMembersHandler(router: Router): void {
    router.get(
      '/orgs/:org/members',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            filter: {
              type: 'string',
              enum: ['2fa_disabled', 'all'],
              default: 'all'
            },
            role: {
              type: 'string',
              enum: ['all', 'admin', 'member'],
              default: 'all'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<OrgsListMembersRequest, OrgsListMembersResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsListMembersHandler>(Handlers.OrgsListMembersHandler);

          await controller.orgsListMembers(req, res, next);
        }
      )
    );
  }

  private addOrgsCheckMembershipForUserHandler(router: Router): void {
    router.get(
      '/orgs/:org/members/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<
        OrgsCheckMembershipForUserRequest,
        OrgsCheckMembershipForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsCheckMembershipForUserHandler>(
            Handlers.OrgsCheckMembershipForUserHandler
          );

        await controller.orgsCheckMembershipForUser(req, res, next);
      })
    );
  }

  private addOrgsRemoveMemberHandler(router: Router): void {
    router.delete(
      '/orgs/:org/members/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<OrgsRemoveMemberRequest, OrgsRemoveMemberResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsRemoveMemberHandler>(Handlers.OrgsRemoveMemberHandler);

          await controller.orgsRemoveMember(req, res, next);
        }
      )
    );
  }

  private addCodespacesGetCodespacesForUserInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/members/:username/codespaces',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<
        CodespacesGetCodespacesForUserInOrgRequest,
        CodespacesGetCodespacesForUserInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesGetCodespacesForUserInOrgHandler>(
            Handlers.CodespacesGetCodespacesForUserInOrgHandler
          );

        await controller.codespacesGetCodespacesForUserInOrg(req, res, next);
      })
    );
  }

  private addCodespacesDeleteFromOrganizationHandler(router: Router): void {
    router.delete(
      '/orgs/:org/members/:username/codespaces/:codespace_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            username: { type: 'string' },
            codespace_name: { type: 'string' }
          },
          required: ['org', 'username', 'codespace_name']
        }
      }),

      asyncRequestHandler<
        CodespacesDeleteFromOrganizationRequest,
        CodespacesDeleteFromOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesDeleteFromOrganizationHandler>(
            Handlers.CodespacesDeleteFromOrganizationHandler
          );

        await controller.codespacesDeleteFromOrganization(req, res, next);
      })
    );
  }

  private addCodespacesStopInOrganizationHandler(router: Router): void {
    router.post(
      '/orgs/:org/members/:username/codespaces/:codespace_name/stop',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            username: { type: 'string' },
            codespace_name: { type: 'string' }
          },
          required: ['org', 'username', 'codespace_name']
        }
      }),

      asyncRequestHandler<
        CodespacesStopInOrganizationRequest,
        CodespacesStopInOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesStopInOrganizationHandler>(
            Handlers.CodespacesStopInOrganizationHandler
          );

        await controller.codespacesStopInOrganization(req, res, next);
      })
    );
  }

  private addOrgsGetMembershipForUserHandler(router: Router): void {
    router.get(
      '/orgs/:org/memberships/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<
        OrgsGetMembershipForUserRequest,
        OrgsGetMembershipForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsGetMembershipForUserHandler>(
            Handlers.OrgsGetMembershipForUserHandler
          );

        await controller.orgsGetMembershipForUser(req, res, next);
      })
    );
  }

  private addOrgsSetMembershipForUserHandler(router: Router): void {
    router.put(
      '/orgs/:org/memberships/:username',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            role: {
              type: 'string',
              description:
                'The role to give the user in the organization. Can be one of:  \n\\* `admin` - The user will become an owner of the organization.  \n\\* `member` - The user will become a non-owner member of the organization.',
              enum: ['admin', 'member'],
              default: 'member'
            }
          }
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<
        OrgsSetMembershipForUserRequest,
        OrgsSetMembershipForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsSetMembershipForUserHandler>(
            Handlers.OrgsSetMembershipForUserHandler
          );

        await controller.orgsSetMembershipForUser(req, res, next);
      })
    );
  }

  private addOrgsRemoveMembershipForUserHandler(router: Router): void {
    router.delete(
      '/orgs/:org/memberships/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<
        OrgsRemoveMembershipForUserRequest,
        OrgsRemoveMembershipForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsRemoveMembershipForUserHandler>(
            Handlers.OrgsRemoveMembershipForUserHandler
          );

        await controller.orgsRemoveMembershipForUser(req, res, next);
      })
    );
  }

  private addMigrationsListForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/migrations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 },
            exclude: {
              anyOf: [
                {
                  type: 'array',
                  items: {
                    description:
                      'Allowed values that can be passed to the exclude param.',
                    enum: ['repositories'],
                    example: 'repositories',
                    type: 'string'
                  }
                },
                {
                  description:
                    'Allowed values that can be passed to the exclude param.',
                  enum: ['repositories'],
                  example: 'repositories',
                  type: 'string'
                }
              ]
            }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        MigrationsListForOrgRequest,
        MigrationsListForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsListForOrgHandler>(
            Handlers.MigrationsListForOrgHandler
          );

        await controller.migrationsListForOrg(req, res, next);
      })
    );
  }

  private addMigrationsStartForOrgHandler(router: Router): void {
    router.post(
      '/orgs/:org/migrations',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            repositories: {
              type: 'array',
              description:
                'A list of arrays indicating which repositories should be migrated.',
              items: { type: 'string' }
            },
            lock_repositories: {
              type: 'boolean',
              example: true,
              description:
                'Indicates whether repositories should be locked (to prevent manipulation) while migrating data.',
              default: false
            },
            exclude_metadata: {
              type: 'boolean',
              description:
                'Indicates whether metadata should be excluded and only git source should be included for the migration.',
              default: false
            },
            exclude_git_data: {
              type: 'boolean',
              description:
                'Indicates whether the repository git data should be excluded from the migration.',
              default: false
            },
            exclude_attachments: {
              type: 'boolean',
              example: true,
              description:
                'Indicates whether attachments should be excluded from the migration (to reduce migration archive file size).',
              default: false
            },
            exclude_releases: {
              type: 'boolean',
              example: true,
              description:
                'Indicates whether releases should be excluded from the migration (to reduce migration archive file size).',
              default: false
            },
            exclude_owner_projects: {
              type: 'boolean',
              example: true,
              description:
                'Indicates whether projects owned by the organization or users should be excluded. from the migration.',
              default: false
            },
            org_metadata_only: {
              type: 'boolean',
              example: true,
              description:
                'Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).',
              default: false
            },
            exclude: {
              type: 'array',
              description:
                'Exclude related items from being returned in the response in order to improve performance of the request. The array can include any of: `"repositories"`.',
              items: { type: 'string', enum: ['repositories'] }
            }
          },
          required: ['repositories']
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        MigrationsStartForOrgRequest,
        MigrationsStartForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsStartForOrgHandler>(
            Handlers.MigrationsStartForOrgHandler
          );

        await controller.migrationsStartForOrg(req, res, next);
      })
    );
  }

  private addMigrationsGetStatusForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/migrations/:migration_id',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            exclude: {
              anyOf: [
                {
                  type: 'array',
                  items: {
                    description:
                      'Allowed values that can be passed to the exclude param.',
                    enum: ['repositories'],
                    example: 'repositories',
                    type: 'string'
                  }
                },
                {
                  description:
                    'Allowed values that can be passed to the exclude param.',
                  enum: ['repositories'],
                  example: 'repositories',
                  type: 'string'
                }
              ]
            }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            migration_id: { type: 'integer' }
          },
          required: ['org', 'migration_id']
        }
      }),

      asyncRequestHandler<
        MigrationsGetStatusForOrgRequest,
        MigrationsGetStatusForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsGetStatusForOrgHandler>(
            Handlers.MigrationsGetStatusForOrgHandler
          );

        await controller.migrationsGetStatusForOrg(req, res, next);
      })
    );
  }

  private addMigrationsDownloadArchiveForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/migrations/:migration_id/archive',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            migration_id: { type: 'integer' }
          },
          required: ['org', 'migration_id']
        }
      }),

      asyncRequestHandler<
        MigrationsDownloadArchiveForOrgRequest,
        MigrationsDownloadArchiveForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsDownloadArchiveForOrgHandler>(
            Handlers.MigrationsDownloadArchiveForOrgHandler
          );

        await controller.migrationsDownloadArchiveForOrg(req, res, next);
      })
    );
  }

  private addMigrationsDeleteArchiveForOrgHandler(router: Router): void {
    router.delete(
      '/orgs/:org/migrations/:migration_id/archive',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            migration_id: { type: 'integer' }
          },
          required: ['org', 'migration_id']
        }
      }),

      asyncRequestHandler<
        MigrationsDeleteArchiveForOrgRequest,
        MigrationsDeleteArchiveForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsDeleteArchiveForOrgHandler>(
            Handlers.MigrationsDeleteArchiveForOrgHandler
          );

        await controller.migrationsDeleteArchiveForOrg(req, res, next);
      })
    );
  }

  private addMigrationsUnlockRepoForOrgHandler(router: Router): void {
    router.delete(
      '/orgs/:org/migrations/:migration_id/repos/:repo_name/lock',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            migration_id: { type: 'integer' },
            repo_name: { type: 'string' }
          },
          required: ['org', 'migration_id', 'repo_name']
        }
      }),

      asyncRequestHandler<
        MigrationsUnlockRepoForOrgRequest,
        MigrationsUnlockRepoForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsUnlockRepoForOrgHandler>(
            Handlers.MigrationsUnlockRepoForOrgHandler
          );

        await controller.migrationsUnlockRepoForOrg(req, res, next);
      })
    );
  }

  private addMigrationsListReposForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/migrations/:migration_id/repositories',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            migration_id: { type: 'integer' }
          },
          required: ['org', 'migration_id']
        }
      }),

      asyncRequestHandler<
        MigrationsListReposForOrgRequest,
        MigrationsListReposForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsListReposForOrgHandler>(
            Handlers.MigrationsListReposForOrgHandler
          );

        await controller.migrationsListReposForOrg(req, res, next);
      })
    );
  }

  private addOrgsListOutsideCollaboratorsHandler(router: Router): void {
    router.get(
      '/orgs/:org/outside_collaborators',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            filter: {
              type: 'string',
              enum: ['2fa_disabled', 'all'],
              default: 'all'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        OrgsListOutsideCollaboratorsRequest,
        OrgsListOutsideCollaboratorsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsListOutsideCollaboratorsHandler>(
            Handlers.OrgsListOutsideCollaboratorsHandler
          );

        await controller.orgsListOutsideCollaborators(req, res, next);
      })
    );
  }

  private addOrgsConvertMemberToOutsideCollaboratorHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/outside_collaborators/:username',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            async: {
              type: 'boolean',
              description:
                'When set to `true`, the request will be performed asynchronously. Returns a 202 status code when the job is successfully queued.',
              default: false
            }
          }
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<
        OrgsConvertMemberToOutsideCollaboratorRequest,
        OrgsConvertMemberToOutsideCollaboratorResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsConvertMemberToOutsideCollaboratorHandler>(
            Handlers.OrgsConvertMemberToOutsideCollaboratorHandler
          );

        await controller.orgsConvertMemberToOutsideCollaborator(req, res, next);
      })
    );
  }

  private addOrgsRemoveOutsideCollaboratorHandler(router: Router): void {
    router.delete(
      '/orgs/:org/outside_collaborators/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<
        OrgsRemoveOutsideCollaboratorRequest,
        OrgsRemoveOutsideCollaboratorResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsRemoveOutsideCollaboratorHandler>(
            Handlers.OrgsRemoveOutsideCollaboratorHandler
          );

        await controller.orgsRemoveOutsideCollaborator(req, res, next);
      })
    );
  }

  private addPackagesListPackagesForOrganizationHandler(router: Router): void {
    router.get(
      '/orgs/:org/packages',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            visibility: {
              type: 'string',
              enum: ['public', 'private', 'internal']
            }
          },
          required: ['package_type']
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        PackagesListPackagesForOrganizationRequest,
        PackagesListPackagesForOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesListPackagesForOrganizationHandler>(
            Handlers.PackagesListPackagesForOrganizationHandler
          );

        await controller.packagesListPackagesForOrganization(req, res, next);
      })
    );
  }

  private addPackagesGetPackageForOrganizationHandler(router: Router): void {
    router.get(
      '/orgs/:org/packages/:package_type/:package_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            org: { type: 'string' }
          },
          required: ['package_type', 'package_name', 'org']
        }
      }),

      asyncRequestHandler<
        PackagesGetPackageForOrganizationRequest,
        PackagesGetPackageForOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesGetPackageForOrganizationHandler>(
            Handlers.PackagesGetPackageForOrganizationHandler
          );

        await controller.packagesGetPackageForOrganization(req, res, next);
      })
    );
  }

  private addPackagesDeletePackageForOrgHandler(router: Router): void {
    router.delete(
      '/orgs/:org/packages/:package_type/:package_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            org: { type: 'string' }
          },
          required: ['package_type', 'package_name', 'org']
        }
      }),

      asyncRequestHandler<
        PackagesDeletePackageForOrgRequest,
        PackagesDeletePackageForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesDeletePackageForOrgHandler>(
            Handlers.PackagesDeletePackageForOrgHandler
          );

        await controller.packagesDeletePackageForOrg(req, res, next);
      })
    );
  }

  private addPackagesRestorePackageForOrgHandler(router: Router): void {
    router.post(
      '/orgs/:org/packages/:package_type/:package_name/restore',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { token: { type: 'string' } },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            org: { type: 'string' }
          },
          required: ['package_type', 'package_name', 'org']
        }
      }),

      asyncRequestHandler<
        PackagesRestorePackageForOrgRequest,
        PackagesRestorePackageForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesRestorePackageForOrgHandler>(
            Handlers.PackagesRestorePackageForOrgHandler
          );

        await controller.packagesRestorePackageForOrg(req, res, next);
      })
    );
  }

  private addPackagesGetAllPackageVersionsForPackageOwnedByOrgHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/packages/:package_type/:package_name/versions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 },
            state: {
              type: 'string',
              enum: ['active', 'deleted'],
              default: 'active'
            }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            org: { type: 'string' }
          },
          required: ['package_type', 'package_name', 'org']
        }
      }),

      asyncRequestHandler<
        PackagesGetAllPackageVersionsForPackageOwnedByOrgRequest,
        PackagesGetAllPackageVersionsForPackageOwnedByOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesGetAllPackageVersionsForPackageOwnedByOrgHandler>(
            Handlers.PackagesGetAllPackageVersionsForPackageOwnedByOrgHandler
          );

        await controller.packagesGetAllPackageVersionsForPackageOwnedByOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addPackagesGetPackageVersionForOrganizationHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            org: { type: 'string' },
            package_version_id: { type: 'integer' }
          },
          required: [
            'package_type',
            'package_name',
            'org',
            'package_version_id'
          ]
        }
      }),

      asyncRequestHandler<
        PackagesGetPackageVersionForOrganizationRequest,
        PackagesGetPackageVersionForOrganizationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesGetPackageVersionForOrganizationHandler>(
            Handlers.PackagesGetPackageVersionForOrganizationHandler
          );

        await controller.packagesGetPackageVersionForOrganization(
          req,
          res,
          next
        );
      })
    );
  }

  private addPackagesDeletePackageVersionForOrgHandler(router: Router): void {
    router.delete(
      '/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            org: { type: 'string' },
            package_version_id: { type: 'integer' }
          },
          required: [
            'package_type',
            'package_name',
            'org',
            'package_version_id'
          ]
        }
      }),

      asyncRequestHandler<
        PackagesDeletePackageVersionForOrgRequest,
        PackagesDeletePackageVersionForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesDeletePackageVersionForOrgHandler>(
            Handlers.PackagesDeletePackageVersionForOrgHandler
          );

        await controller.packagesDeletePackageVersionForOrg(req, res, next);
      })
    );
  }

  private addPackagesRestorePackageVersionForOrgHandler(router: Router): void {
    router.post(
      '/orgs/:org/packages/:package_type/:package_name/versions/:package_version_id/restore',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            org: { type: 'string' },
            package_version_id: { type: 'integer' }
          },
          required: [
            'package_type',
            'package_name',
            'org',
            'package_version_id'
          ]
        }
      }),

      asyncRequestHandler<
        PackagesRestorePackageVersionForOrgRequest,
        PackagesRestorePackageVersionForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesRestorePackageVersionForOrgHandler>(
            Handlers.PackagesRestorePackageVersionForOrgHandler
          );

        await controller.packagesRestorePackageVersionForOrg(req, res, next);
      })
    );
  }

  private addProjectsListForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/projects',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            state: {
              type: 'string',
              enum: ['open', 'closed', 'all'],
              default: 'open'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ProjectsListForOrgRequest,
        ProjectsListForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsListForOrgHandler>(
            Handlers.ProjectsListForOrgHandler
          );

        await controller.projectsListForOrg(req, res, next);
      })
    );
  }

  private addProjectsCreateForOrgHandler(router: Router): void {
    router.post(
      '/orgs/:org/projects',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'The name of the project.' },
            body: {
              type: 'string',
              description: 'The description of the project.'
            }
          },
          required: ['name']
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        ProjectsCreateForOrgRequest,
        ProjectsCreateForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsCreateForOrgHandler>(
            Handlers.ProjectsCreateForOrgHandler
          );

        await controller.projectsCreateForOrg(req, res, next);
      })
    );
  }

  private addOrgsListPublicMembersHandler(router: Router): void {
    router.get(
      '/orgs/:org/public_members',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        OrgsListPublicMembersRequest,
        OrgsListPublicMembersResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsListPublicMembersHandler>(
            Handlers.OrgsListPublicMembersHandler
          );

        await controller.orgsListPublicMembers(req, res, next);
      })
    );
  }

  private addOrgsCheckPublicMembershipForUserHandler(router: Router): void {
    router.get(
      '/orgs/:org/public_members/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<
        OrgsCheckPublicMembershipForUserRequest,
        OrgsCheckPublicMembershipForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsCheckPublicMembershipForUserHandler>(
            Handlers.OrgsCheckPublicMembershipForUserHandler
          );

        await controller.orgsCheckPublicMembershipForUser(req, res, next);
      })
    );
  }

  private addOrgsSetPublicMembershipForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/public_members/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<
        OrgsSetPublicMembershipForAuthenticatedUserRequest,
        OrgsSetPublicMembershipForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsSetPublicMembershipForAuthenticatedUserHandler>(
            Handlers.OrgsSetPublicMembershipForAuthenticatedUserHandler
          );

        await controller.orgsSetPublicMembershipForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addOrgsRemovePublicMembershipForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/orgs/:org/public_members/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' }, username: { type: 'string' } },
          required: ['org', 'username']
        }
      }),

      asyncRequestHandler<
        OrgsRemovePublicMembershipForAuthenticatedUserRequest,
        OrgsRemovePublicMembershipForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsRemovePublicMembershipForAuthenticatedUserHandler>(
            Handlers.OrgsRemovePublicMembershipForAuthenticatedUserHandler
          );

        await controller.orgsRemovePublicMembershipForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addReposListForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/repos',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            type: {
              type: 'string',
              enum: [
                'all',
                'public',
                'private',
                'forks',
                'sources',
                'member',
                'internal'
              ]
            },
            sort: {
              type: 'string',
              enum: ['created', 'updated', 'pushed', 'full_name'],
              default: 'created'
            },
            direction: { type: 'string', enum: ['asc', 'desc'] },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<ReposListForOrgRequest, ReposListForOrgResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposListForOrgHandler>(Handlers.ReposListForOrgHandler);

          await controller.reposListForOrg(req, res, next);
        }
      )
    );
  }

  private addReposCreateInOrgHandler(router: Router): void {
    router.post(
      '/orgs/:org/repos',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description: 'The name of the repository.'
            },
            description: {
              type: 'string',
              description: 'A short description of the repository.'
            },
            homepage: {
              type: 'string',
              description: 'A URL with more information about the repository.'
            },
            private: {
              type: 'boolean',
              description: 'Whether the repository is private.',
              default: false
            },
            visibility: {
              type: 'string',
              description:
                'Can be `public` or `private`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `visibility` can also be `internal`. Note: For GitHub Enterprise Server and GitHub AE, this endpoint will only list repositories available to all users on the enterprise. For more information, see "[Creating an internal repository](https://docs.github.com/en/github/creating-cloning-and-archiving-repositories/about-repository-visibility#about-internal-repositories)" in the GitHub Help documentation.',
              enum: ['public', 'private', 'internal']
            },
            has_issues: {
              type: 'boolean',
              description:
                'Either `true` to enable issues for this repository or `false` to disable them.',
              default: true
            },
            has_projects: {
              type: 'boolean',
              description:
                "Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.",
              default: true
            },
            has_wiki: {
              type: 'boolean',
              description:
                'Either `true` to enable the wiki for this repository or `false` to disable it.',
              default: true
            },
            is_template: {
              type: 'boolean',
              description:
                'Either `true` to make this repo available as a template repository or `false` to prevent it.',
              default: false
            },
            team_id: {
              type: 'integer',
              description:
                'The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.'
            },
            auto_init: {
              type: 'boolean',
              description:
                'Pass `true` to create an initial commit with empty README.',
              default: false
            },
            gitignore_template: {
              type: 'string',
              description:
                'Desired language or platform [.gitignore template](https://github.com/github/gitignore) to apply. Use the name of the template without the extension. For example, "Haskell".'
            },
            license_template: {
              type: 'string',
              description:
                'Choose an [open source license template](https://choosealicense.com/) that best suits your needs, and then use the [license keyword](https://docs.github.com/articles/licensing-a-repository/#searching-github-by-license-type) as the `license_template` string. For example, "mit" or "mpl-2.0".'
            },
            allow_squash_merge: {
              type: 'boolean',
              description:
                'Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.',
              default: true
            },
            allow_merge_commit: {
              type: 'boolean',
              description:
                'Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.',
              default: true
            },
            allow_rebase_merge: {
              type: 'boolean',
              description:
                'Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.',
              default: true
            },
            allow_auto_merge: {
              type: 'boolean',
              description:
                'Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.',
              default: false
            },
            delete_branch_on_merge: {
              type: 'boolean',
              description:
                'Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.',
              default: false
            },
            use_squash_pr_title_as_default: {
              type: 'boolean',
              description:
                'Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property has been deprecated. Please use `squash_merge_commit_title` instead.',
              default: false,
              deprecated: true
            },
            squash_merge_commit_title: {
              type: 'string',
              enum: ['PR_TITLE', 'COMMIT_OR_PR_TITLE'],
              description:
                "The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
            },
            squash_merge_commit_message: {
              type: 'string',
              enum: ['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'],
              description:
                "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
            },
            merge_commit_title: {
              type: 'string',
              enum: ['PR_TITLE', 'MERGE_MESSAGE'],
              description:
                "The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
            },
            merge_commit_message: {
              type: 'string',
              enum: ['PR_BODY', 'PR_TITLE', 'BLANK'],
              description:
                "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
            }
          },
          required: ['name']
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<ReposCreateInOrgRequest, ReposCreateInOrgResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposCreateInOrgHandler>(Handlers.ReposCreateInOrgHandler);

          await controller.reposCreateInOrg(req, res, next);
        }
      )
    );
  }

  private addSecretScanningListAlertsForOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/secret-scanning/alerts',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            state: { type: 'string', enum: ['open', 'resolved'] },
            secret_type: { type: 'string' },
            resolution: { type: 'string' },
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 },
            before: { type: 'string' },
            after: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        SecretScanningListAlertsForOrgRequest,
        SecretScanningListAlertsForOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<SecretScanningListAlertsForOrgHandler>(
            Handlers.SecretScanningListAlertsForOrgHandler
          );

        await controller.secretScanningListAlertsForOrg(req, res, next);
      })
    );
  }

  private addOrgsListSecurityManagerTeamsHandler(router: Router): void {
    router.get(
      '/orgs/:org/security-managers',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        OrgsListSecurityManagerTeamsRequest,
        OrgsListSecurityManagerTeamsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsListSecurityManagerTeamsHandler>(
            Handlers.OrgsListSecurityManagerTeamsHandler
          );

        await controller.orgsListSecurityManagerTeams(req, res, next);
      })
    );
  }

  private addOrgsAddSecurityManagerTeamHandler(router: Router): void {
    router.put(
      '/orgs/:org/security-managers/teams/:team_slug',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' }
          },
          required: ['org', 'team_slug']
        }
      }),

      asyncRequestHandler<
        OrgsAddSecurityManagerTeamRequest,
        OrgsAddSecurityManagerTeamResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsAddSecurityManagerTeamHandler>(
            Handlers.OrgsAddSecurityManagerTeamHandler
          );

        await controller.orgsAddSecurityManagerTeam(req, res, next);
      })
    );
  }

  private addOrgsRemoveSecurityManagerTeamHandler(router: Router): void {
    router.delete(
      '/orgs/:org/security-managers/teams/:team_slug',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' }
          },
          required: ['org', 'team_slug']
        }
      }),

      asyncRequestHandler<
        OrgsRemoveSecurityManagerTeamRequest,
        OrgsRemoveSecurityManagerTeamResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsRemoveSecurityManagerTeamHandler>(
            Handlers.OrgsRemoveSecurityManagerTeamHandler
          );

        await controller.orgsRemoveSecurityManagerTeam(req, res, next);
      })
    );
  }

  private addBillingGetGithubActionsBillingOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/settings/billing/actions',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        BillingGetGithubActionsBillingOrgRequest,
        BillingGetGithubActionsBillingOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<BillingGetGithubActionsBillingOrgHandler>(
            Handlers.BillingGetGithubActionsBillingOrgHandler
          );

        await controller.billingGetGithubActionsBillingOrg(req, res, next);
      })
    );
  }

  private addBillingGetGithubAdvancedSecurityBillingOrgHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/settings/billing/advanced-security',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        BillingGetGithubAdvancedSecurityBillingOrgRequest,
        BillingGetGithubAdvancedSecurityBillingOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<BillingGetGithubAdvancedSecurityBillingOrgHandler>(
            Handlers.BillingGetGithubAdvancedSecurityBillingOrgHandler
          );

        await controller.billingGetGithubAdvancedSecurityBillingOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addBillingGetGithubPackagesBillingOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/settings/billing/packages',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        BillingGetGithubPackagesBillingOrgRequest,
        BillingGetGithubPackagesBillingOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<BillingGetGithubPackagesBillingOrgHandler>(
            Handlers.BillingGetGithubPackagesBillingOrgHandler
          );

        await controller.billingGetGithubPackagesBillingOrg(req, res, next);
      })
    );
  }

  private addBillingGetSharedStorageBillingOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/settings/billing/shared-storage',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        BillingGetSharedStorageBillingOrgRequest,
        BillingGetSharedStorageBillingOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<BillingGetSharedStorageBillingOrgHandler>(
            Handlers.BillingGetSharedStorageBillingOrgHandler
          );

        await controller.billingGetSharedStorageBillingOrg(req, res, next);
      })
    );
  }

  private addTeamsListHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<TeamsListRequest, TeamsListResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<TeamsListHandler>(Handlers.TeamsListHandler);

          await controller.teamsList(req, res, next);
        }
      )
    );
  }

  private addTeamsCreateHandler(router: Router): void {
    router.post(
      '/orgs/:org/teams',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'The name of the team.' },
            description: {
              type: 'string',
              description: 'The description of the team.'
            },
            maintainers: {
              type: 'array',
              description:
                'List GitHub IDs for organization members who will become team maintainers.',
              items: { type: 'string' }
            },
            repo_names: {
              type: 'array',
              description:
                'The full name (e.g., "organization-name/repository-name") of repositories to add the team to.',
              items: { type: 'string' }
            },
            privacy: {
              type: 'string',
              description:
                'The level of privacy this team should have. The options are:  \n**For a non-nested team:**  \n\\* `secret` - only visible to organization owners and members of this team.  \n\\* `closed` - visible to all members of this organization.  \nDefault: `secret`  \n**For a parent or child team:**  \n\\* `closed` - visible to all members of this organization.  \nDefault for child team: `closed`',
              enum: ['secret', 'closed']
            },
            permission: {
              type: 'string',
              description:
                '**Deprecated**. The permission that new repositories will be added to the team with when none is specified.',
              enum: ['pull', 'push'],
              default: 'pull'
            },
            parent_team_id: {
              type: 'integer',
              description: 'The ID of a team to set as the parent team.'
            }
          },
          required: ['name']
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<TeamsCreateRequest, TeamsCreateResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<TeamsCreateHandler>(Handlers.TeamsCreateHandler);

          await controller.teamsCreate(req, res, next);
        }
      )
    );
  }

  private addTeamsGetByNameHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' }
          },
          required: ['org', 'team_slug']
        }
      }),

      asyncRequestHandler<TeamsGetByNameRequest, TeamsGetByNameResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<TeamsGetByNameHandler>(Handlers.TeamsGetByNameHandler);

          await controller.teamsGetByName(req, res, next);
        }
      )
    );
  }

  private addTeamsUpdateInOrgHandler(router: Router): void {
    router.patch(
      '/orgs/:org/teams/:team_slug',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'The name of the team.' },
            description: {
              type: 'string',
              description: 'The description of the team.'
            },
            privacy: {
              type: 'string',
              description:
                'The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. When a team is nested, the `privacy` for parent teams cannot be `secret`. The options are:  \n**For a non-nested team:**  \n\\* `secret` - only visible to organization owners and members of this team.  \n\\* `closed` - visible to all members of this organization.  \n**For a parent or child team:**  \n\\* `closed` - visible to all members of this organization.',
              enum: ['secret', 'closed']
            },
            permission: {
              type: 'string',
              description:
                '**Deprecated**. The permission that new repositories will be added to the team with when none is specified.',
              enum: ['pull', 'push', 'admin'],
              default: 'pull'
            },
            parent_team_id: {
              type: 'integer',
              description: 'The ID of a team to set as the parent team.',
              nullable: true
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' }
          },
          required: ['org', 'team_slug']
        }
      }),

      asyncRequestHandler<TeamsUpdateInOrgRequest, TeamsUpdateInOrgResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<TeamsUpdateInOrgHandler>(Handlers.TeamsUpdateInOrgHandler);

          await controller.teamsUpdateInOrg(req, res, next);
        }
      )
    );
  }

  private addTeamsDeleteInOrgHandler(router: Router): void {
    router.delete(
      '/orgs/:org/teams/:team_slug',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' }
          },
          required: ['org', 'team_slug']
        }
      }),

      asyncRequestHandler<TeamsDeleteInOrgRequest, TeamsDeleteInOrgResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<TeamsDeleteInOrgHandler>(Handlers.TeamsDeleteInOrgHandler);

          await controller.teamsDeleteInOrg(req, res, next);
        }
      )
    );
  }

  private addTeamsListDiscussionsInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug/discussions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 },
            pinned: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' }
          },
          required: ['org', 'team_slug']
        }
      }),

      asyncRequestHandler<
        TeamsListDiscussionsInOrgRequest,
        TeamsListDiscussionsInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListDiscussionsInOrgHandler>(
            Handlers.TeamsListDiscussionsInOrgHandler
          );

        await controller.teamsListDiscussionsInOrg(req, res, next);
      })
    );
  }

  private addTeamsCreateDiscussionInOrgHandler(router: Router): void {
    router.post(
      '/orgs/:org/teams/:team_slug/discussions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            title: {
              type: 'string',
              description: "The discussion post's title."
            },
            body: {
              type: 'string',
              description: "The discussion post's body text."
            },
            private: {
              type: 'boolean',
              description:
                'Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.',
              default: false
            }
          },
          required: ['title', 'body']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' }
          },
          required: ['org', 'team_slug']
        }
      }),

      asyncRequestHandler<
        TeamsCreateDiscussionInOrgRequest,
        TeamsCreateDiscussionInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsCreateDiscussionInOrgHandler>(
            Handlers.TeamsCreateDiscussionInOrgHandler
          );

        await controller.teamsCreateDiscussionInOrg(req, res, next);
      })
    );
  }

  private addTeamsGetDiscussionInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        TeamsGetDiscussionInOrgRequest,
        TeamsGetDiscussionInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsGetDiscussionInOrgHandler>(
            Handlers.TeamsGetDiscussionInOrgHandler
          );

        await controller.teamsGetDiscussionInOrg(req, res, next);
      })
    );
  }

  private addTeamsUpdateDiscussionInOrgHandler(router: Router): void {
    router.patch(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            title: {
              type: 'string',
              description: "The discussion post's title."
            },
            body: {
              type: 'string',
              description: "The discussion post's body text."
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        TeamsUpdateDiscussionInOrgRequest,
        TeamsUpdateDiscussionInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsUpdateDiscussionInOrgHandler>(
            Handlers.TeamsUpdateDiscussionInOrgHandler
          );

        await controller.teamsUpdateDiscussionInOrg(req, res, next);
      })
    );
  }

  private addTeamsDeleteDiscussionInOrgHandler(router: Router): void {
    router.delete(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        TeamsDeleteDiscussionInOrgRequest,
        TeamsDeleteDiscussionInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsDeleteDiscussionInOrgHandler>(
            Handlers.TeamsDeleteDiscussionInOrgHandler
          );

        await controller.teamsDeleteDiscussionInOrg(req, res, next);
      })
    );
  }

  private addTeamsListDiscussionCommentsInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        TeamsListDiscussionCommentsInOrgRequest,
        TeamsListDiscussionCommentsInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListDiscussionCommentsInOrgHandler>(
            Handlers.TeamsListDiscussionCommentsInOrgHandler
          );

        await controller.teamsListDiscussionCommentsInOrg(req, res, next);
      })
    );
  }

  private addTeamsCreateDiscussionCommentInOrgHandler(router: Router): void {
    router.post(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
              description: "The discussion comment's body text."
            }
          },
          required: ['body']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        TeamsCreateDiscussionCommentInOrgRequest,
        TeamsCreateDiscussionCommentInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsCreateDiscussionCommentInOrgHandler>(
            Handlers.TeamsCreateDiscussionCommentInOrgHandler
          );

        await controller.teamsCreateDiscussionCommentInOrg(req, res, next);
      })
    );
  }

  private addTeamsGetDiscussionCommentInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' },
            comment_number: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'discussion_number', 'comment_number']
        }
      }),

      asyncRequestHandler<
        TeamsGetDiscussionCommentInOrgRequest,
        TeamsGetDiscussionCommentInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsGetDiscussionCommentInOrgHandler>(
            Handlers.TeamsGetDiscussionCommentInOrgHandler
          );

        await controller.teamsGetDiscussionCommentInOrg(req, res, next);
      })
    );
  }

  private addTeamsUpdateDiscussionCommentInOrgHandler(router: Router): void {
    router.patch(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
              description: "The discussion comment's body text."
            }
          },
          required: ['body']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' },
            comment_number: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'discussion_number', 'comment_number']
        }
      }),

      asyncRequestHandler<
        TeamsUpdateDiscussionCommentInOrgRequest,
        TeamsUpdateDiscussionCommentInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsUpdateDiscussionCommentInOrgHandler>(
            Handlers.TeamsUpdateDiscussionCommentInOrgHandler
          );

        await controller.teamsUpdateDiscussionCommentInOrg(req, res, next);
      })
    );
  }

  private addTeamsDeleteDiscussionCommentInOrgHandler(router: Router): void {
    router.delete(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' },
            comment_number: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'discussion_number', 'comment_number']
        }
      }),

      asyncRequestHandler<
        TeamsDeleteDiscussionCommentInOrgRequest,
        TeamsDeleteDiscussionCommentInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsDeleteDiscussionCommentInOrgHandler>(
            Handlers.TeamsDeleteDiscussionCommentInOrgHandler
          );

        await controller.teamsDeleteDiscussionCommentInOrg(req, res, next);
      })
    );
  }

  private addReactionsListForTeamDiscussionCommentInOrgHandler(
    router: Router
  ): void {
    router.get(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' },
            comment_number: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'discussion_number', 'comment_number']
        }
      }),

      asyncRequestHandler<
        ReactionsListForTeamDiscussionCommentInOrgRequest,
        ReactionsListForTeamDiscussionCommentInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsListForTeamDiscussionCommentInOrgHandler>(
            Handlers.ReactionsListForTeamDiscussionCommentInOrgHandler
          );

        await controller.reactionsListForTeamDiscussionCommentInOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addReactionsCreateForTeamDiscussionCommentInOrgHandler(
    router: Router
  ): void {
    router.post(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              description:
                'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion comment.',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            }
          },
          required: ['content']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' },
            comment_number: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'discussion_number', 'comment_number']
        }
      }),

      asyncRequestHandler<
        ReactionsCreateForTeamDiscussionCommentInOrgRequest,
        ReactionsCreateForTeamDiscussionCommentInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsCreateForTeamDiscussionCommentInOrgHandler>(
            Handlers.ReactionsCreateForTeamDiscussionCommentInOrgHandler
          );

        await controller.reactionsCreateForTeamDiscussionCommentInOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addReactionsDeleteForTeamDiscussionCommentHandler(
    router: Router
  ): void {
    router.delete(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number/comments/:comment_number/reactions/:reaction_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' },
            comment_number: { type: 'integer' },
            reaction_id: { type: 'integer' }
          },
          required: [
            'org',
            'team_slug',
            'discussion_number',
            'comment_number',
            'reaction_id'
          ]
        }
      }),

      asyncRequestHandler<
        ReactionsDeleteForTeamDiscussionCommentRequest,
        ReactionsDeleteForTeamDiscussionCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsDeleteForTeamDiscussionCommentHandler>(
            Handlers.ReactionsDeleteForTeamDiscussionCommentHandler
          );

        await controller.reactionsDeleteForTeamDiscussionComment(
          req,
          res,
          next
        );
      })
    );
  }

  private addReactionsListForTeamDiscussionInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        ReactionsListForTeamDiscussionInOrgRequest,
        ReactionsListForTeamDiscussionInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsListForTeamDiscussionInOrgHandler>(
            Handlers.ReactionsListForTeamDiscussionInOrgHandler
          );

        await controller.reactionsListForTeamDiscussionInOrg(req, res, next);
      })
    );
  }

  private addReactionsCreateForTeamDiscussionInOrgHandler(
    router: Router
  ): void {
    router.post(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              description:
                'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion.',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            }
          },
          required: ['content']
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        ReactionsCreateForTeamDiscussionInOrgRequest,
        ReactionsCreateForTeamDiscussionInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsCreateForTeamDiscussionInOrgHandler>(
            Handlers.ReactionsCreateForTeamDiscussionInOrgHandler
          );

        await controller.reactionsCreateForTeamDiscussionInOrg(req, res, next);
      })
    );
  }

  private addReactionsDeleteForTeamDiscussionHandler(router: Router): void {
    router.delete(
      '/orgs/:org/teams/:team_slug/discussions/:discussion_number/reactions/:reaction_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            discussion_number: { type: 'integer' },
            reaction_id: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'discussion_number', 'reaction_id']
        }
      }),

      asyncRequestHandler<
        ReactionsDeleteForTeamDiscussionRequest,
        ReactionsDeleteForTeamDiscussionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsDeleteForTeamDiscussionHandler>(
            Handlers.ReactionsDeleteForTeamDiscussionHandler
          );

        await controller.reactionsDeleteForTeamDiscussion(req, res, next);
      })
    );
  }

  private addTeamsListPendingInvitationsInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug/invitations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' }
          },
          required: ['org', 'team_slug']
        }
      }),

      asyncRequestHandler<
        TeamsListPendingInvitationsInOrgRequest,
        TeamsListPendingInvitationsInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListPendingInvitationsInOrgHandler>(
            Handlers.TeamsListPendingInvitationsInOrgHandler
          );

        await controller.teamsListPendingInvitationsInOrg(req, res, next);
      })
    );
  }

  private addTeamsListMembersInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug/members',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            role: {
              type: 'string',
              enum: ['member', 'maintainer', 'all'],
              default: 'all'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' }
          },
          required: ['org', 'team_slug']
        }
      }),

      asyncRequestHandler<
        TeamsListMembersInOrgRequest,
        TeamsListMembersInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListMembersInOrgHandler>(
            Handlers.TeamsListMembersInOrgHandler
          );

        await controller.teamsListMembersInOrg(req, res, next);
      })
    );
  }

  private addTeamsGetMembershipForUserInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug/memberships/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            username: { type: 'string' }
          },
          required: ['org', 'team_slug', 'username']
        }
      }),

      asyncRequestHandler<
        TeamsGetMembershipForUserInOrgRequest,
        TeamsGetMembershipForUserInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsGetMembershipForUserInOrgHandler>(
            Handlers.TeamsGetMembershipForUserInOrgHandler
          );

        await controller.teamsGetMembershipForUserInOrg(req, res, next);
      })
    );
  }

  private addTeamsAddOrUpdateMembershipForUserInOrgHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/teams/:team_slug/memberships/:username',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            role: {
              type: 'string',
              description: 'The role that this user should have in the team.',
              enum: ['member', 'maintainer'],
              default: 'member'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            username: { type: 'string' }
          },
          required: ['org', 'team_slug', 'username']
        }
      }),

      asyncRequestHandler<
        TeamsAddOrUpdateMembershipForUserInOrgRequest,
        TeamsAddOrUpdateMembershipForUserInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsAddOrUpdateMembershipForUserInOrgHandler>(
            Handlers.TeamsAddOrUpdateMembershipForUserInOrgHandler
          );

        await controller.teamsAddOrUpdateMembershipForUserInOrg(req, res, next);
      })
    );
  }

  private addTeamsRemoveMembershipForUserInOrgHandler(router: Router): void {
    router.delete(
      '/orgs/:org/teams/:team_slug/memberships/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            username: { type: 'string' }
          },
          required: ['org', 'team_slug', 'username']
        }
      }),

      asyncRequestHandler<
        TeamsRemoveMembershipForUserInOrgRequest,
        TeamsRemoveMembershipForUserInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsRemoveMembershipForUserInOrgHandler>(
            Handlers.TeamsRemoveMembershipForUserInOrgHandler
          );

        await controller.teamsRemoveMembershipForUserInOrg(req, res, next);
      })
    );
  }

  private addTeamsListProjectsInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug/projects',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' }
          },
          required: ['org', 'team_slug']
        }
      }),

      asyncRequestHandler<
        TeamsListProjectsInOrgRequest,
        TeamsListProjectsInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListProjectsInOrgHandler>(
            Handlers.TeamsListProjectsInOrgHandler
          );

        await controller.teamsListProjectsInOrg(req, res, next);
      })
    );
  }

  private addTeamsCheckPermissionsForProjectInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug/projects/:project_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            project_id: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'project_id']
        }
      }),

      asyncRequestHandler<
        TeamsCheckPermissionsForProjectInOrgRequest,
        TeamsCheckPermissionsForProjectInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsCheckPermissionsForProjectInOrgHandler>(
            Handlers.TeamsCheckPermissionsForProjectInOrgHandler
          );

        await controller.teamsCheckPermissionsForProjectInOrg(req, res, next);
      })
    );
  }

  private addTeamsAddOrUpdateProjectPermissionsInOrgHandler(
    router: Router
  ): void {
    router.put(
      '/orgs/:org/teams/:team_slug/projects/:project_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            permission: {
              type: 'string',
              description:
                'The permission to grant to the team for this project. Default: the team\'s `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you\'ll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."',
              enum: ['read', 'write', 'admin']
            }
          },
          nullable: true
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            project_id: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'project_id']
        }
      }),

      asyncRequestHandler<
        TeamsAddOrUpdateProjectPermissionsInOrgRequest,
        TeamsAddOrUpdateProjectPermissionsInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsAddOrUpdateProjectPermissionsInOrgHandler>(
            Handlers.TeamsAddOrUpdateProjectPermissionsInOrgHandler
          );

        await controller.teamsAddOrUpdateProjectPermissionsInOrg(
          req,
          res,
          next
        );
      })
    );
  }

  private addTeamsRemoveProjectInOrgHandler(router: Router): void {
    router.delete(
      '/orgs/:org/teams/:team_slug/projects/:project_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            project_id: { type: 'integer' }
          },
          required: ['org', 'team_slug', 'project_id']
        }
      }),

      asyncRequestHandler<
        TeamsRemoveProjectInOrgRequest,
        TeamsRemoveProjectInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsRemoveProjectInOrgHandler>(
            Handlers.TeamsRemoveProjectInOrgHandler
          );

        await controller.teamsRemoveProjectInOrg(req, res, next);
      })
    );
  }

  private addTeamsListReposInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug/repos',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' }
          },
          required: ['org', 'team_slug']
        }
      }),

      asyncRequestHandler<
        TeamsListReposInOrgRequest,
        TeamsListReposInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListReposInOrgHandler>(
            Handlers.TeamsListReposInOrgHandler
          );

        await controller.teamsListReposInOrg(req, res, next);
      })
    );
  }

  private addTeamsCheckPermissionsForRepoInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug/repos/:owner/:repo',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            owner: { type: 'string' },
            repo: { type: 'string' }
          },
          required: ['org', 'team_slug', 'owner', 'repo']
        }
      }),

      asyncRequestHandler<
        TeamsCheckPermissionsForRepoInOrgRequest,
        TeamsCheckPermissionsForRepoInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsCheckPermissionsForRepoInOrgHandler>(
            Handlers.TeamsCheckPermissionsForRepoInOrgHandler
          );

        await controller.teamsCheckPermissionsForRepoInOrg(req, res, next);
      })
    );
  }

  private addTeamsAddOrUpdateRepoPermissionsInOrgHandler(router: Router): void {
    router.put(
      '/orgs/:org/teams/:team_slug/repos/:owner/:repo',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            permission: {
              type: 'string',
              description:
                "The permission to grant the team on this repository. We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.",
              default: 'push'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            owner: { type: 'string' },
            repo: { type: 'string' }
          },
          required: ['org', 'team_slug', 'owner', 'repo']
        }
      }),

      asyncRequestHandler<
        TeamsAddOrUpdateRepoPermissionsInOrgRequest,
        TeamsAddOrUpdateRepoPermissionsInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsAddOrUpdateRepoPermissionsInOrgHandler>(
            Handlers.TeamsAddOrUpdateRepoPermissionsInOrgHandler
          );

        await controller.teamsAddOrUpdateRepoPermissionsInOrg(req, res, next);
      })
    );
  }

  private addTeamsRemoveRepoInOrgHandler(router: Router): void {
    router.delete(
      '/orgs/:org/teams/:team_slug/repos/:owner/:repo',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' },
            owner: { type: 'string' },
            repo: { type: 'string' }
          },
          required: ['org', 'team_slug', 'owner', 'repo']
        }
      }),

      asyncRequestHandler<
        TeamsRemoveRepoInOrgRequest,
        TeamsRemoveRepoInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsRemoveRepoInOrgHandler>(
            Handlers.TeamsRemoveRepoInOrgHandler
          );

        await controller.teamsRemoveRepoInOrg(req, res, next);
      })
    );
  }

  private addTeamsListChildInOrgHandler(router: Router): void {
    router.get(
      '/orgs/:org/teams/:team_slug/teams',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            team_slug: { type: 'string' }
          },
          required: ['org', 'team_slug']
        }
      }),

      asyncRequestHandler<
        TeamsListChildInOrgRequest,
        TeamsListChildInOrgResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListChildInOrgHandler>(
            Handlers.TeamsListChildInOrgHandler
          );

        await controller.teamsListChildInOrg(req, res, next);
      })
    );
  }

  private addOrgsEnableOrDisableSecurityProductOnAllOrgReposHandler(
    router: Router
  ): void {
    router.post(
      '/orgs/:org/:security_product/:enablement',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            org: { type: 'string' },
            security_product: {
              type: 'string',
              enum: [
                'dependency_graph',
                'dependabot_alerts',
                'dependabot_security_updates',
                'advanced_security',
                'secret_scanning',
                'secret_scanning_push_protection'
              ]
            },
            enablement: { type: 'string', enum: ['enable_all', 'disable_all'] }
          },
          required: ['org', 'security_product', 'enablement']
        }
      }),

      asyncRequestHandler<
        OrgsEnableOrDisableSecurityProductOnAllOrgReposRequest,
        OrgsEnableOrDisableSecurityProductOnAllOrgReposResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsEnableOrDisableSecurityProductOnAllOrgReposHandler>(
            Handlers.OrgsEnableOrDisableSecurityProductOnAllOrgReposHandler
          );

        await controller.orgsEnableOrDisableSecurityProductOnAllOrgRepos(
          req,
          res,
          next
        );
      })
    );
  }

  private addProjectsGetCardHandler(router: Router): void {
    router.get(
      '/projects/columns/cards/:card_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { card_id: { type: 'integer' } },
          required: ['card_id']
        }
      }),

      asyncRequestHandler<ProjectsGetCardRequest, ProjectsGetCardResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ProjectsGetCardHandler>(Handlers.ProjectsGetCardHandler);

          await controller.projectsGetCard(req, res, next);
        }
      )
    );
  }

  private addProjectsUpdateCardHandler(router: Router): void {
    router.patch(
      '/projects/columns/cards/:card_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            note: {
              description: "The project card's note",
              example: 'Update all gems',
              type: 'string',
              nullable: true
            },
            archived: {
              description: 'Whether or not the card is archived',
              example: false,
              type: 'boolean'
            }
          }
        },

        params: {
          type: 'object',
          properties: { card_id: { type: 'integer' } },
          required: ['card_id']
        }
      }),

      asyncRequestHandler<
        ProjectsUpdateCardRequest,
        ProjectsUpdateCardResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsUpdateCardHandler>(
            Handlers.ProjectsUpdateCardHandler
          );

        await controller.projectsUpdateCard(req, res, next);
      })
    );
  }

  private addProjectsDeleteCardHandler(router: Router): void {
    router.delete(
      '/projects/columns/cards/:card_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { card_id: { type: 'integer' } },
          required: ['card_id']
        }
      }),

      asyncRequestHandler<
        ProjectsDeleteCardRequest,
        ProjectsDeleteCardResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsDeleteCardHandler>(
            Handlers.ProjectsDeleteCardHandler
          );

        await controller.projectsDeleteCard(req, res, next);
      })
    );
  }

  private addProjectsMoveCardHandler(router: Router): void {
    router.post(
      '/projects/columns/cards/:card_id/moves',

      ControllerMiddleware.validate({
        body: {
          properties: {
            position: {
              description:
                'The position of the card in a column. Can be one of: `top`, `bottom`, or `after:<card_id>` to place after the specified card.',
              example: 'bottom',
              type: 'string',
              pattern: '^(?:top|bottom|after:\\d+)$'
            },
            column_id: {
              description:
                'The unique identifier of the column the card should be moved to',
              example: 42,
              type: 'integer'
            }
          },
          required: ['position'],
          type: 'object'
        },

        params: {
          type: 'object',
          properties: { card_id: { type: 'integer' } },
          required: ['card_id']
        }
      }),

      asyncRequestHandler<ProjectsMoveCardRequest, ProjectsMoveCardResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ProjectsMoveCardHandler>(Handlers.ProjectsMoveCardHandler);

          await controller.projectsMoveCard(req, res, next);
        }
      )
    );
  }

  private addProjectsGetColumnHandler(router: Router): void {
    router.get(
      '/projects/columns/:column_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { column_id: { type: 'integer' } },
          required: ['column_id']
        }
      }),

      asyncRequestHandler<ProjectsGetColumnRequest, ProjectsGetColumnResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ProjectsGetColumnHandler>(
              Handlers.ProjectsGetColumnHandler
            );

          await controller.projectsGetColumn(req, res, next);
        }
      )
    );
  }

  private addProjectsUpdateColumnHandler(router: Router): void {
    router.patch(
      '/projects/columns/:column_id',

      ControllerMiddleware.validate({
        body: {
          properties: {
            name: {
              description: 'Name of the project column',
              example: 'Remaining tasks',
              type: 'string'
            }
          },
          required: ['name'],
          type: 'object'
        },

        params: {
          type: 'object',
          properties: { column_id: { type: 'integer' } },
          required: ['column_id']
        }
      }),

      asyncRequestHandler<
        ProjectsUpdateColumnRequest,
        ProjectsUpdateColumnResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsUpdateColumnHandler>(
            Handlers.ProjectsUpdateColumnHandler
          );

        await controller.projectsUpdateColumn(req, res, next);
      })
    );
  }

  private addProjectsDeleteColumnHandler(router: Router): void {
    router.delete(
      '/projects/columns/:column_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { column_id: { type: 'integer' } },
          required: ['column_id']
        }
      }),

      asyncRequestHandler<
        ProjectsDeleteColumnRequest,
        ProjectsDeleteColumnResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsDeleteColumnHandler>(
            Handlers.ProjectsDeleteColumnHandler
          );

        await controller.projectsDeleteColumn(req, res, next);
      })
    );
  }

  private addProjectsListCardsHandler(router: Router): void {
    router.get(
      '/projects/columns/:column_id/cards',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            archived_state: {
              type: 'string',
              enum: ['all', 'archived', 'not_archived'],
              default: 'not_archived'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { column_id: { type: 'integer' } },
          required: ['column_id']
        }
      }),

      asyncRequestHandler<ProjectsListCardsRequest, ProjectsListCardsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ProjectsListCardsHandler>(
              Handlers.ProjectsListCardsHandler
            );

          await controller.projectsListCards(req, res, next);
        }
      )
    );
  }

  private addProjectsCreateCardHandler(router: Router): void {
    router.post(
      '/projects/columns/:column_id/cards',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                note: {
                  description: "The project card's note",
                  example: 'Update all gems',
                  type: 'string',
                  nullable: true
                }
              },
              required: ['note']
            },
            {
              type: 'object',
              properties: {
                content_id: {
                  description:
                    'The unique identifier of the content associated with the card',
                  example: 42,
                  type: 'integer'
                },
                content_type: {
                  description: 'The piece of content associated with the card',
                  example: 'PullRequest',
                  type: 'string'
                }
              },
              required: ['content_id', 'content_type']
            }
          ]
        },

        params: {
          type: 'object',
          properties: { column_id: { type: 'integer' } },
          required: ['column_id']
        }
      }),

      asyncRequestHandler<
        ProjectsCreateCardRequest,
        ProjectsCreateCardResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsCreateCardHandler>(
            Handlers.ProjectsCreateCardHandler
          );

        await controller.projectsCreateCard(req, res, next);
      })
    );
  }

  private addProjectsMoveColumnHandler(router: Router): void {
    router.post(
      '/projects/columns/:column_id/moves',

      ControllerMiddleware.validate({
        body: {
          properties: {
            position: {
              description:
                'The position of the column in a project. Can be one of: `first`, `last`, or `after:<column_id>` to place after the specified column.',
              example: 'last',
              type: 'string',
              pattern: '^(?:first|last|after:\\d+)$'
            }
          },
          required: ['position'],
          type: 'object'
        },

        params: {
          type: 'object',
          properties: { column_id: { type: 'integer' } },
          required: ['column_id']
        }
      }),

      asyncRequestHandler<
        ProjectsMoveColumnRequest,
        ProjectsMoveColumnResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsMoveColumnHandler>(
            Handlers.ProjectsMoveColumnHandler
          );

        await controller.projectsMoveColumn(req, res, next);
      })
    );
  }

  private addProjectsGetHandler(router: Router): void {
    router.get(
      '/projects/:project_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { project_id: { type: 'integer' } },
          required: ['project_id']
        }
      }),

      asyncRequestHandler<ProjectsGetRequest, ProjectsGetResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ProjectsGetHandler>(Handlers.ProjectsGetHandler);

          await controller.projectsGet(req, res, next);
        }
      )
    );
  }

  private addProjectsUpdateHandler(router: Router): void {
    router.patch(
      '/projects/:project_id',

      ControllerMiddleware.validate({
        body: {
          properties: {
            name: {
              description: 'Name of the project',
              example: 'Week One Sprint',
              type: 'string'
            },
            body: {
              description: 'Body of the project',
              example:
                'This project represents the sprint of the first week in January',
              type: 'string',
              nullable: true
            },
            state: {
              description: "State of the project; either 'open' or 'closed'",
              example: 'open',
              type: 'string'
            },
            organization_permission: {
              description:
                'The baseline permission that all organization members have on this project',
              type: 'string',
              enum: ['read', 'write', 'admin', 'none']
            },
            private: {
              description:
                'Whether or not this project can be seen by everyone.',
              type: 'boolean'
            }
          },
          type: 'object'
        },

        params: {
          type: 'object',
          properties: { project_id: { type: 'integer' } },
          required: ['project_id']
        }
      }),

      asyncRequestHandler<ProjectsUpdateRequest, ProjectsUpdateResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ProjectsUpdateHandler>(Handlers.ProjectsUpdateHandler);

          await controller.projectsUpdate(req, res, next);
        }
      )
    );
  }

  private addProjectsDeleteHandler(router: Router): void {
    router.delete(
      '/projects/:project_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { project_id: { type: 'integer' } },
          required: ['project_id']
        }
      }),

      asyncRequestHandler<ProjectsDeleteRequest, ProjectsDeleteResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ProjectsDeleteHandler>(Handlers.ProjectsDeleteHandler);

          await controller.projectsDelete(req, res, next);
        }
      )
    );
  }

  private addProjectsListCollaboratorsHandler(router: Router): void {
    router.get(
      '/projects/:project_id/collaborators',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            affiliation: {
              type: 'string',
              enum: ['outside', 'direct', 'all'],
              default: 'all'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { project_id: { type: 'integer' } },
          required: ['project_id']
        }
      }),

      asyncRequestHandler<
        ProjectsListCollaboratorsRequest,
        ProjectsListCollaboratorsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsListCollaboratorsHandler>(
            Handlers.ProjectsListCollaboratorsHandler
          );

        await controller.projectsListCollaborators(req, res, next);
      })
    );
  }

  private addProjectsAddCollaboratorHandler(router: Router): void {
    router.put(
      '/projects/:project_id/collaborators/:username',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            permission: {
              description: 'The permission to grant the collaborator.',
              enum: ['read', 'write', 'admin'],
              default: 'write',
              example: 'write',
              type: 'string'
            }
          },
          nullable: true
        },

        params: {
          type: 'object',
          properties: {
            project_id: { type: 'integer' },
            username: { type: 'string' }
          },
          required: ['project_id', 'username']
        }
      }),

      asyncRequestHandler<
        ProjectsAddCollaboratorRequest,
        ProjectsAddCollaboratorResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsAddCollaboratorHandler>(
            Handlers.ProjectsAddCollaboratorHandler
          );

        await controller.projectsAddCollaborator(req, res, next);
      })
    );
  }

  private addProjectsRemoveCollaboratorHandler(router: Router): void {
    router.delete(
      '/projects/:project_id/collaborators/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            project_id: { type: 'integer' },
            username: { type: 'string' }
          },
          required: ['project_id', 'username']
        }
      }),

      asyncRequestHandler<
        ProjectsRemoveCollaboratorRequest,
        ProjectsRemoveCollaboratorResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsRemoveCollaboratorHandler>(
            Handlers.ProjectsRemoveCollaboratorHandler
          );

        await controller.projectsRemoveCollaborator(req, res, next);
      })
    );
  }

  private addProjectsGetPermissionForUserHandler(router: Router): void {
    router.get(
      '/projects/:project_id/collaborators/:username/permission',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            project_id: { type: 'integer' },
            username: { type: 'string' }
          },
          required: ['project_id', 'username']
        }
      }),

      asyncRequestHandler<
        ProjectsGetPermissionForUserRequest,
        ProjectsGetPermissionForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsGetPermissionForUserHandler>(
            Handlers.ProjectsGetPermissionForUserHandler
          );

        await controller.projectsGetPermissionForUser(req, res, next);
      })
    );
  }

  private addProjectsListColumnsHandler(router: Router): void {
    router.get(
      '/projects/:project_id/columns',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { project_id: { type: 'integer' } },
          required: ['project_id']
        }
      }),

      asyncRequestHandler<
        ProjectsListColumnsRequest,
        ProjectsListColumnsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsListColumnsHandler>(
            Handlers.ProjectsListColumnsHandler
          );

        await controller.projectsListColumns(req, res, next);
      })
    );
  }

  private addProjectsCreateColumnHandler(router: Router): void {
    router.post(
      '/projects/:project_id/columns',

      ControllerMiddleware.validate({
        body: {
          properties: {
            name: {
              description: 'Name of the project column',
              example: 'Remaining tasks',
              type: 'string'
            }
          },
          required: ['name'],
          type: 'object'
        },

        params: {
          type: 'object',
          properties: { project_id: { type: 'integer' } },
          required: ['project_id']
        }
      }),

      asyncRequestHandler<
        ProjectsCreateColumnRequest,
        ProjectsCreateColumnResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsCreateColumnHandler>(
            Handlers.ProjectsCreateColumnHandler
          );

        await controller.projectsCreateColumn(req, res, next);
      })
    );
  }

  private addRateLimitGetHandler(router: Router): void {
    router.get(
      '/rate_limit',

      asyncRequestHandler<RateLimitGetRequest, RateLimitGetResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<RateLimitGetHandler>(Handlers.RateLimitGetHandler);

          await controller.rateLimitGet(req, res, next);
        }
      )
    );
  }

  private addReposGetHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposGetRequest, ReposGetResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetHandler>(Handlers.ReposGetHandler);

          await controller.reposGet(req, res, next);
        }
      )
    );
  }

  private addReposUpdateHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description: 'The name of the repository.'
            },
            description: {
              type: 'string',
              description: 'A short description of the repository.'
            },
            homepage: {
              type: 'string',
              description: 'A URL with more information about the repository.'
            },
            private: {
              type: 'boolean',
              description:
                'Either `true` to make the repository private or `false` to make it public. Default: `false`.  \n**Note**: You will get a `422` error if the organization restricts [changing repository visibility](https://docs.github.com/articles/repository-permission-levels-for-an-organization#changing-the-visibility-of-repositories) to organization owners and a non-owner tries to change the value of private.',
              default: false
            },
            visibility: {
              type: 'string',
              description:
                'Can be `public` or `private`. If your organization is associated with an enterprise account using GitHub Enterprise Cloud or GitHub Enterprise Server 2.20+, `visibility` can also be `internal`."',
              enum: ['public', 'private', 'internal']
            },
            security_and_analysis: {
              type: 'object',
              description:
                'Specify which security and analysis features to enable or disable for the repository.\n\nTo use this parameter, you must have admin permissions for the repository or be an owner or security manager for the organization that owns the repository. For more information, see "[Managing security managers in your organization](https://docs.github.com/organizations/managing-peoples-access-to-your-organization-with-roles/managing-security-managers-in-your-organization)."\n\nFor example, to enable GitHub Advanced Security, use this data in the body of the `PATCH` request:\n`{ "security_and_analysis": {"advanced_security": { "status": "enabled" } } }`.\n\nYou can check which security and analysis features are currently enabled by using a `GET /repos/{owner}/{repo}` request.',
              nullable: true,
              properties: {
                advanced_security: {
                  type: 'object',
                  description:
                    'Use the `status` property to enable or disable GitHub Advanced Security for this repository. For more information, see "[About GitHub Advanced Security](/github/getting-started-with-github/learning-about-github/about-github-advanced-security)."',
                  properties: {
                    status: {
                      type: 'string',
                      description: 'Can be `enabled` or `disabled`.'
                    }
                  }
                },
                secret_scanning: {
                  type: 'object',
                  description:
                    'Use the `status` property to enable or disable secret scanning for this repository. For more information, see "[About secret scanning](/code-security/secret-security/about-secret-scanning)."',
                  properties: {
                    status: {
                      type: 'string',
                      description: 'Can be `enabled` or `disabled`.'
                    }
                  }
                },
                secret_scanning_push_protection: {
                  type: 'object',
                  description:
                    'Use the `status` property to enable or disable secret scanning push protection for this repository. For more information, see "[Protecting pushes with secret scanning](/code-security/secret-scanning/protecting-pushes-with-secret-scanning)."',
                  properties: {
                    status: {
                      type: 'string',
                      description: 'Can be `enabled` or `disabled`.'
                    }
                  }
                }
              }
            },
            has_issues: {
              type: 'boolean',
              description:
                'Either `true` to enable issues for this repository or `false` to disable them.',
              default: true
            },
            has_projects: {
              type: 'boolean',
              description:
                "Either `true` to enable projects for this repository or `false` to disable them. **Note:** If you're creating a repository in an organization that has disabled repository projects, the default is `false`, and if you pass `true`, the API returns an error.",
              default: true
            },
            has_wiki: {
              type: 'boolean',
              description:
                'Either `true` to enable the wiki for this repository or `false` to disable it.',
              default: true
            },
            is_template: {
              type: 'boolean',
              description:
                'Either `true` to make this repo available as a template repository or `false` to prevent it.',
              default: false
            },
            default_branch: {
              type: 'string',
              description: 'Updates the default branch for this repository.'
            },
            allow_squash_merge: {
              type: 'boolean',
              description:
                'Either `true` to allow squash-merging pull requests, or `false` to prevent squash-merging.',
              default: true
            },
            allow_merge_commit: {
              type: 'boolean',
              description:
                'Either `true` to allow merging pull requests with a merge commit, or `false` to prevent merging pull requests with merge commits.',
              default: true
            },
            allow_rebase_merge: {
              type: 'boolean',
              description:
                'Either `true` to allow rebase-merging pull requests, or `false` to prevent rebase-merging.',
              default: true
            },
            allow_auto_merge: {
              type: 'boolean',
              description:
                'Either `true` to allow auto-merge on pull requests, or `false` to disallow auto-merge.',
              default: false
            },
            delete_branch_on_merge: {
              type: 'boolean',
              description:
                'Either `true` to allow automatically deleting head branches when pull requests are merged, or `false` to prevent automatic deletion.',
              default: false
            },
            allow_update_branch: {
              type: 'boolean',
              description:
                'Either `true` to always allow a pull request head branch that is behind its base branch to be updated even if it is not required to be up to date before merging, or false otherwise.',
              default: false
            },
            use_squash_pr_title_as_default: {
              type: 'boolean',
              description:
                'Either `true` to allow squash-merge commits to use pull request title, or `false` to use commit message. **This property has been deprecated. Please use `squash_merge_commit_title` instead.',
              default: false,
              deprecated: true
            },
            squash_merge_commit_title: {
              type: 'string',
              enum: ['PR_TITLE', 'COMMIT_OR_PR_TITLE'],
              description:
                "The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
            },
            squash_merge_commit_message: {
              type: 'string',
              enum: ['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'],
              description:
                "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
            },
            merge_commit_title: {
              type: 'string',
              enum: ['PR_TITLE', 'MERGE_MESSAGE'],
              description:
                "The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
            },
            merge_commit_message: {
              type: 'string',
              enum: ['PR_BODY', 'PR_TITLE', 'BLANK'],
              description:
                "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
            },
            archived: {
              type: 'boolean',
              description:
                '`true` to archive this repository. **Note**: You cannot unarchive repositories through the API.',
              default: false
            },
            allow_forking: {
              type: 'boolean',
              description:
                'Either `true` to allow private forks, or `false` to prevent private forks.',
              default: false
            },
            web_commit_signoff_required: {
              type: 'boolean',
              description:
                'Either `true` to require contributors to sign off on web-based commits, or `false` to not require contributors to sign off on web-based commits.',
              default: false
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposUpdateRequest, ReposUpdateResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposUpdateHandler>(Handlers.ReposUpdateHandler);

          await controller.reposUpdate(req, res, next);
        }
      )
    );
  }

  private addReposDeleteHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposDeleteRequest, ReposDeleteResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposDeleteHandler>(Handlers.ReposDeleteHandler);

          await controller.reposDelete(req, res, next);
        }
      )
    );
  }

  private addActionsListArtifactsForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/artifacts',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 },
            name: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsListArtifactsForRepoRequest,
        ActionsListArtifactsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListArtifactsForRepoHandler>(
            Handlers.ActionsListArtifactsForRepoHandler
          );

        await controller.actionsListArtifactsForRepo(req, res, next);
      })
    );
  }

  private addActionsGetArtifactHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/artifacts/:artifact_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            artifact_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'artifact_id']
        }
      }),

      asyncRequestHandler<
        ActionsGetArtifactRequest,
        ActionsGetArtifactResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetArtifactHandler>(
            Handlers.ActionsGetArtifactHandler
          );

        await controller.actionsGetArtifact(req, res, next);
      })
    );
  }

  private addActionsDeleteArtifactHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/actions/artifacts/:artifact_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            artifact_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'artifact_id']
        }
      }),

      asyncRequestHandler<
        ActionsDeleteArtifactRequest,
        ActionsDeleteArtifactResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDeleteArtifactHandler>(
            Handlers.ActionsDeleteArtifactHandler
          );

        await controller.actionsDeleteArtifact(req, res, next);
      })
    );
  }

  private addActionsDownloadArtifactHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/artifacts/:artifact_id/:archive_format',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            artifact_id: { type: 'integer' },
            archive_format: { type: 'string' }
          },
          required: ['owner', 'repo', 'artifact_id', 'archive_format']
        }
      }),

      asyncRequestHandler<
        ActionsDownloadArtifactRequest,
        ActionsDownloadArtifactResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDownloadArtifactHandler>(
            Handlers.ActionsDownloadArtifactHandler
          );

        await controller.actionsDownloadArtifact(req, res, next);
      })
    );
  }

  private addActionsGetActionsCacheUsageHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/cache/usage',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsGetActionsCacheUsageRequest,
        ActionsGetActionsCacheUsageResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetActionsCacheUsageHandler>(
            Handlers.ActionsGetActionsCacheUsageHandler
          );

        await controller.actionsGetActionsCacheUsage(req, res, next);
      })
    );
  }

  private addActionsGetActionsCacheListHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/caches',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 },
            ref: { $ref: '#/definitions/code-scanning-ref' },
            key: { type: 'string' },
            sort: {
              type: 'string',
              enum: ['created_at', 'last_accessed_at', 'size_in_bytes'],
              default: 'last_accessed_at'
            },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            }
          },
          required: [],
          definitions: {
            'code-scanning-ref': {
              type: 'string',
              description:
                'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.',
              title: 'code-scanning-ref'
            }
          }
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsGetActionsCacheListRequest,
        ActionsGetActionsCacheListResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetActionsCacheListHandler>(
            Handlers.ActionsGetActionsCacheListHandler
          );

        await controller.actionsGetActionsCacheList(req, res, next);
      })
    );
  }

  private addActionsDeleteActionsCacheByKeyHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/actions/caches',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            key: { type: 'string' },
            ref: { $ref: '#/definitions/code-scanning-ref' }
          },
          required: ['key'],
          definitions: {
            'code-scanning-ref': {
              type: 'string',
              description:
                'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.',
              title: 'code-scanning-ref'
            }
          }
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsDeleteActionsCacheByKeyRequest,
        ActionsDeleteActionsCacheByKeyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDeleteActionsCacheByKeyHandler>(
            Handlers.ActionsDeleteActionsCacheByKeyHandler
          );

        await controller.actionsDeleteActionsCacheByKey(req, res, next);
      })
    );
  }

  private addActionsDeleteActionsCacheByIdHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/actions/caches/:cache_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            cache_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'cache_id']
        }
      }),

      asyncRequestHandler<
        ActionsDeleteActionsCacheByIdRequest,
        ActionsDeleteActionsCacheByIdResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDeleteActionsCacheByIdHandler>(
            Handlers.ActionsDeleteActionsCacheByIdHandler
          );

        await controller.actionsDeleteActionsCacheById(req, res, next);
      })
    );
  }

  private addActionsGetJobForWorkflowRunHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/jobs/:job_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            job_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'job_id']
        }
      }),

      asyncRequestHandler<
        ActionsGetJobForWorkflowRunRequest,
        ActionsGetJobForWorkflowRunResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetJobForWorkflowRunHandler>(
            Handlers.ActionsGetJobForWorkflowRunHandler
          );

        await controller.actionsGetJobForWorkflowRun(req, res, next);
      })
    );
  }

  private addActionsDownloadJobLogsForWorkflowRunHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/jobs/:job_id/logs',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            job_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'job_id']
        }
      }),

      asyncRequestHandler<
        ActionsDownloadJobLogsForWorkflowRunRequest,
        ActionsDownloadJobLogsForWorkflowRunResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDownloadJobLogsForWorkflowRunHandler>(
            Handlers.ActionsDownloadJobLogsForWorkflowRunHandler
          );

        await controller.actionsDownloadJobLogsForWorkflowRun(req, res, next);
      })
    );
  }

  private addActionsReRunJobForWorkflowRunHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/actions/jobs/:job_id/rerun',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          nullable: true,
          properties: {
            enable_debug_logging: {
              type: 'boolean',
              default: false,
              description: 'Whether to enable debug logging for the re-run.'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            job_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'job_id']
        }
      }),

      asyncRequestHandler<
        ActionsReRunJobForWorkflowRunRequest,
        ActionsReRunJobForWorkflowRunResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsReRunJobForWorkflowRunHandler>(
            Handlers.ActionsReRunJobForWorkflowRunHandler
          );

        await controller.actionsReRunJobForWorkflowRun(req, res, next);
      })
    );
  }

  private addActionsGetGithubActionsPermissionsRepositoryHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/actions/permissions',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsGetGithubActionsPermissionsRepositoryRequest,
        ActionsGetGithubActionsPermissionsRepositoryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetGithubActionsPermissionsRepositoryHandler>(
            Handlers.ActionsGetGithubActionsPermissionsRepositoryHandler
          );

        await controller.actionsGetGithubActionsPermissionsRepository(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsSetGithubActionsPermissionsRepositoryHandler(
    router: Router
  ): void {
    router.put(
      '/repos/:owner/:repo/actions/permissions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            enabled: { $ref: '#/definitions/actions-enabled' },
            allowed_actions: { $ref: '#/definitions/allowed-actions' }
          },
          required: ['enabled'],
          definitions: {
            'actions-enabled': {
              type: 'boolean',
              description:
                'Whether GitHub Actions is enabled on the repository.',
              title: 'actions-enabled'
            },
            'allowed-actions': {
              type: 'string',
              description:
                'The permissions policy that controls the actions and reusable workflows that are allowed to run.',
              enum: ['all', 'local_only', 'selected'],
              title: 'allowed-actions'
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsSetGithubActionsPermissionsRepositoryRequest,
        ActionsSetGithubActionsPermissionsRepositoryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetGithubActionsPermissionsRepositoryHandler>(
            Handlers.ActionsSetGithubActionsPermissionsRepositoryHandler
          );

        await controller.actionsSetGithubActionsPermissionsRepository(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsGetWorkflowAccessToRepositoryHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/permissions/access',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsGetWorkflowAccessToRepositoryRequest,
        ActionsGetWorkflowAccessToRepositoryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetWorkflowAccessToRepositoryHandler>(
            Handlers.ActionsGetWorkflowAccessToRepositoryHandler
          );

        await controller.actionsGetWorkflowAccessToRepository(req, res, next);
      })
    );
  }

  private addActionsSetWorkflowAccessToRepositoryHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/actions/permissions/access',

      ControllerMiddleware.validate({
        body: {
          $ref: '#/definitions/actions-workflow-access-to-repository',
          definitions: {
            'actions-workflow-access-to-repository': {
              type: 'object',
              properties: {
                access_level: {
                  type: 'string',
                  description:
                    'Defines the level of access that workflows outside of the repository have to actions and reusable workflows within the\nrepository. `none` means access is only possible from workflows in this repository.',
                  enum: ['none', 'organization', 'enterprise']
                }
              },
              required: ['access_level'],
              title: 'actions-workflow-access-to-repository'
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsSetWorkflowAccessToRepositoryRequest,
        ActionsSetWorkflowAccessToRepositoryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetWorkflowAccessToRepositoryHandler>(
            Handlers.ActionsSetWorkflowAccessToRepositoryHandler
          );

        await controller.actionsSetWorkflowAccessToRepository(req, res, next);
      })
    );
  }

  private addActionsGetAllowedActionsRepositoryHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/permissions/selected-actions',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsGetAllowedActionsRepositoryRequest,
        ActionsGetAllowedActionsRepositoryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetAllowedActionsRepositoryHandler>(
            Handlers.ActionsGetAllowedActionsRepositoryHandler
          );

        await controller.actionsGetAllowedActionsRepository(req, res, next);
      })
    );
  }

  private addActionsSetAllowedActionsRepositoryHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/actions/permissions/selected-actions',

      ControllerMiddleware.validate({
        body: {
          $ref: '#/definitions/selected-actions',
          definitions: {
            'selected-actions': {
              type: 'object',
              properties: {
                github_owned_allowed: {
                  type: 'boolean',
                  description:
                    'Whether GitHub-owned actions are allowed. For example, this includes the actions in the `actions` organization.'
                },
                verified_allowed: {
                  type: 'boolean',
                  description:
                    'Whether actions from GitHub Marketplace verified creators are allowed. Set to `true` to allow all actions by GitHub Marketplace verified creators.'
                },
                patterns_allowed: {
                  type: 'array',
                  description:
                    'Specifies a list of string-matching patterns to allow specific action(s) and reusable workflow(s). Wildcards, tags, and SHAs are allowed. For example, `monalisa/octocat@*`, `monalisa/octocat@v2`, `monalisa/*`."',
                  items: { type: 'string' }
                }
              },
              title: 'selected-actions'
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsSetAllowedActionsRepositoryRequest,
        ActionsSetAllowedActionsRepositoryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetAllowedActionsRepositoryHandler>(
            Handlers.ActionsSetAllowedActionsRepositoryHandler
          );

        await controller.actionsSetAllowedActionsRepository(req, res, next);
      })
    );
  }

  private addActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/actions/permissions/workflow',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryRequest,
        ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryHandler>(
            Handlers.ActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryHandler
          );

        await controller.actionsGetGithubActionsDefaultWorkflowPermissionsRepository(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryHandler(
    router: Router
  ): void {
    router.put(
      '/repos/:owner/:repo/actions/permissions/workflow',

      ControllerMiddleware.validate({
        body: {
          $ref: '#/definitions/actions-set-default-workflow-permissions',
          definitions: {
            'actions-set-default-workflow-permissions': {
              type: 'object',
              properties: {
                default_workflow_permissions: {
                  $ref: '#/definitions/actions-default-workflow-permissions'
                },
                can_approve_pull_request_reviews: {
                  $ref: '#/definitions/actions-can-approve-pull-request-reviews'
                }
              },
              title: 'actions-set-default-workflow-permissions'
            },
            'actions-default-workflow-permissions': {
              type: 'string',
              description:
                'The default workflow permissions granted to the GITHUB_TOKEN when running workflows.',
              enum: ['read', 'write'],
              title: 'actions-default-workflow-permissions'
            },
            'actions-can-approve-pull-request-reviews': {
              type: 'boolean',
              description:
                'Whether GitHub Actions can approve pull requests. Enabling this can be a security risk.',
              title: 'actions-can-approve-pull-request-reviews'
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryRequest,
        ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryHandler>(
            Handlers.ActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryHandler
          );

        await controller.actionsSetGithubActionsDefaultWorkflowPermissionsRepository(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsListSelfHostedRunnersForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/runners',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsListSelfHostedRunnersForRepoRequest,
        ActionsListSelfHostedRunnersForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListSelfHostedRunnersForRepoHandler>(
            Handlers.ActionsListSelfHostedRunnersForRepoHandler
          );

        await controller.actionsListSelfHostedRunnersForRepo(req, res, next);
      })
    );
  }

  private addActionsListRunnerApplicationsForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/runners/downloads',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsListRunnerApplicationsForRepoRequest,
        ActionsListRunnerApplicationsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListRunnerApplicationsForRepoHandler>(
            Handlers.ActionsListRunnerApplicationsForRepoHandler
          );

        await controller.actionsListRunnerApplicationsForRepo(req, res, next);
      })
    );
  }

  private addActionsCreateRegistrationTokenForRepoHandler(
    router: Router
  ): void {
    router.post(
      '/repos/:owner/:repo/actions/runners/registration-token',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsCreateRegistrationTokenForRepoRequest,
        ActionsCreateRegistrationTokenForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsCreateRegistrationTokenForRepoHandler>(
            Handlers.ActionsCreateRegistrationTokenForRepoHandler
          );

        await controller.actionsCreateRegistrationTokenForRepo(req, res, next);
      })
    );
  }

  private addActionsCreateRemoveTokenForRepoHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/actions/runners/remove-token',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsCreateRemoveTokenForRepoRequest,
        ActionsCreateRemoveTokenForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsCreateRemoveTokenForRepoHandler>(
            Handlers.ActionsCreateRemoveTokenForRepoHandler
          );

        await controller.actionsCreateRemoveTokenForRepo(req, res, next);
      })
    );
  }

  private addActionsGetSelfHostedRunnerForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/runners/:runner_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsGetSelfHostedRunnerForRepoRequest,
        ActionsGetSelfHostedRunnerForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetSelfHostedRunnerForRepoHandler>(
            Handlers.ActionsGetSelfHostedRunnerForRepoHandler
          );

        await controller.actionsGetSelfHostedRunnerForRepo(req, res, next);
      })
    );
  }

  private addActionsDeleteSelfHostedRunnerFromRepoHandler(
    router: Router
  ): void {
    router.delete(
      '/repos/:owner/:repo/actions/runners/:runner_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsDeleteSelfHostedRunnerFromRepoRequest,
        ActionsDeleteSelfHostedRunnerFromRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDeleteSelfHostedRunnerFromRepoHandler>(
            Handlers.ActionsDeleteSelfHostedRunnerFromRepoHandler
          );

        await controller.actionsDeleteSelfHostedRunnerFromRepo(req, res, next);
      })
    );
  }

  private addActionsListLabelsForSelfHostedRunnerForRepoHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/actions/runners/:runner_id/labels',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsListLabelsForSelfHostedRunnerForRepoRequest,
        ActionsListLabelsForSelfHostedRunnerForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListLabelsForSelfHostedRunnerForRepoHandler>(
            Handlers.ActionsListLabelsForSelfHostedRunnerForRepoHandler
          );

        await controller.actionsListLabelsForSelfHostedRunnerForRepo(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsAddCustomLabelsToSelfHostedRunnerForRepoHandler(
    router: Router
  ): void {
    router.post(
      '/repos/:owner/:repo/actions/runners/:runner_id/labels',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          required: ['labels'],
          properties: {
            labels: {
              type: 'array',
              minItems: 1,
              maxItems: 100,
              description:
                'The names of the custom labels to add to the runner.',
              items: { type: 'string' }
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsAddCustomLabelsToSelfHostedRunnerForRepoRequest,
        ActionsAddCustomLabelsToSelfHostedRunnerForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsAddCustomLabelsToSelfHostedRunnerForRepoHandler>(
            Handlers.ActionsAddCustomLabelsToSelfHostedRunnerForRepoHandler
          );

        await controller.actionsAddCustomLabelsToSelfHostedRunnerForRepo(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsSetCustomLabelsForSelfHostedRunnerForRepoHandler(
    router: Router
  ): void {
    router.put(
      '/repos/:owner/:repo/actions/runners/:runner_id/labels',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          required: ['labels'],
          properties: {
            labels: {
              type: 'array',
              minItems: 0,
              maxItems: 100,
              description:
                'The names of the custom labels to set for the runner. You can pass an empty array to remove all custom labels.',
              items: { type: 'string' }
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsSetCustomLabelsForSelfHostedRunnerForRepoRequest,
        ActionsSetCustomLabelsForSelfHostedRunnerForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsSetCustomLabelsForSelfHostedRunnerForRepoHandler>(
            Handlers.ActionsSetCustomLabelsForSelfHostedRunnerForRepoHandler
          );

        await controller.actionsSetCustomLabelsForSelfHostedRunnerForRepo(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoHandler(
    router: Router
  ): void {
    router.delete(
      '/repos/:owner/:repo/actions/runners/:runner_id/labels',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            runner_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'runner_id']
        }
      }),

      asyncRequestHandler<
        ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoRequest,
        ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoHandler>(
            Handlers.ActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoHandler
          );

        await controller.actionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepo(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsRemoveCustomLabelFromSelfHostedRunnerForRepoHandler(
    router: Router
  ): void {
    router.delete(
      '/repos/:owner/:repo/actions/runners/:runner_id/labels/:name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            runner_id: { type: 'integer' },
            name: { type: 'string' }
          },
          required: ['owner', 'repo', 'runner_id', 'name']
        }
      }),

      asyncRequestHandler<
        ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoRequest,
        ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoHandler>(
            Handlers.ActionsRemoveCustomLabelFromSelfHostedRunnerForRepoHandler
          );

        await controller.actionsRemoveCustomLabelFromSelfHostedRunnerForRepo(
          req,
          res,
          next
        );
      })
    );
  }

  private addActionsListWorkflowRunsForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/runs',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            actor: { type: 'string' },
            branch: { type: 'string' },
            event: { type: 'string' },
            status: {
              type: 'string',
              enum: [
                'completed',
                'action_required',
                'cancelled',
                'failure',
                'neutral',
                'skipped',
                'stale',
                'success',
                'timed_out',
                'in_progress',
                'queued',
                'requested',
                'waiting'
              ]
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 },
            created: { type: 'string', format: 'date-time' },
            exclude_pull_requests: { type: 'boolean', default: false },
            check_suite_id: { type: 'integer' },
            head_sha: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsListWorkflowRunsForRepoRequest,
        ActionsListWorkflowRunsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListWorkflowRunsForRepoHandler>(
            Handlers.ActionsListWorkflowRunsForRepoHandler
          );

        await controller.actionsListWorkflowRunsForRepo(req, res, next);
      })
    );
  }

  private addActionsGetWorkflowRunHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/runs/:run_id',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            exclude_pull_requests: { type: 'boolean', default: false }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsGetWorkflowRunRequest,
        ActionsGetWorkflowRunResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetWorkflowRunHandler>(
            Handlers.ActionsGetWorkflowRunHandler
          );

        await controller.actionsGetWorkflowRun(req, res, next);
      })
    );
  }

  private addActionsDeleteWorkflowRunHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/actions/runs/:run_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsDeleteWorkflowRunRequest,
        ActionsDeleteWorkflowRunResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDeleteWorkflowRunHandler>(
            Handlers.ActionsDeleteWorkflowRunHandler
          );

        await controller.actionsDeleteWorkflowRun(req, res, next);
      })
    );
  }

  private addActionsGetReviewsForRunHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/runs/:run_id/approvals',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsGetReviewsForRunRequest,
        ActionsGetReviewsForRunResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetReviewsForRunHandler>(
            Handlers.ActionsGetReviewsForRunHandler
          );

        await controller.actionsGetReviewsForRun(req, res, next);
      })
    );
  }

  private addActionsApproveWorkflowRunHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/actions/runs/:run_id/approve',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsApproveWorkflowRunRequest,
        ActionsApproveWorkflowRunResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsApproveWorkflowRunHandler>(
            Handlers.ActionsApproveWorkflowRunHandler
          );

        await controller.actionsApproveWorkflowRun(req, res, next);
      })
    );
  }

  private addActionsListWorkflowRunArtifactsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/runs/:run_id/artifacts',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsListWorkflowRunArtifactsRequest,
        ActionsListWorkflowRunArtifactsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListWorkflowRunArtifactsHandler>(
            Handlers.ActionsListWorkflowRunArtifactsHandler
          );

        await controller.actionsListWorkflowRunArtifacts(req, res, next);
      })
    );
  }

  private addActionsGetWorkflowRunAttemptHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            exclude_pull_requests: { type: 'boolean', default: false }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' },
            attempt_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id', 'attempt_number']
        }
      }),

      asyncRequestHandler<
        ActionsGetWorkflowRunAttemptRequest,
        ActionsGetWorkflowRunAttemptResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetWorkflowRunAttemptHandler>(
            Handlers.ActionsGetWorkflowRunAttemptHandler
          );

        await controller.actionsGetWorkflowRunAttempt(req, res, next);
      })
    );
  }

  private addActionsListJobsForWorkflowRunAttemptHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number/jobs',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' },
            attempt_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id', 'attempt_number']
        }
      }),

      asyncRequestHandler<
        ActionsListJobsForWorkflowRunAttemptRequest,
        ActionsListJobsForWorkflowRunAttemptResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListJobsForWorkflowRunAttemptHandler>(
            Handlers.ActionsListJobsForWorkflowRunAttemptHandler
          );

        await controller.actionsListJobsForWorkflowRunAttempt(req, res, next);
      })
    );
  }

  private addActionsDownloadWorkflowRunAttemptLogsHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/actions/runs/:run_id/attempts/:attempt_number/logs',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' },
            attempt_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id', 'attempt_number']
        }
      }),

      asyncRequestHandler<
        ActionsDownloadWorkflowRunAttemptLogsRequest,
        ActionsDownloadWorkflowRunAttemptLogsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDownloadWorkflowRunAttemptLogsHandler>(
            Handlers.ActionsDownloadWorkflowRunAttemptLogsHandler
          );

        await controller.actionsDownloadWorkflowRunAttemptLogs(req, res, next);
      })
    );
  }

  private addActionsCancelWorkflowRunHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/actions/runs/:run_id/cancel',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsCancelWorkflowRunRequest,
        ActionsCancelWorkflowRunResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsCancelWorkflowRunHandler>(
            Handlers.ActionsCancelWorkflowRunHandler
          );

        await controller.actionsCancelWorkflowRun(req, res, next);
      })
    );
  }

  private addActionsListJobsForWorkflowRunHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/runs/:run_id/jobs',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            filter: {
              type: 'string',
              enum: ['latest', 'all'],
              default: 'latest'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsListJobsForWorkflowRunRequest,
        ActionsListJobsForWorkflowRunResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListJobsForWorkflowRunHandler>(
            Handlers.ActionsListJobsForWorkflowRunHandler
          );

        await controller.actionsListJobsForWorkflowRun(req, res, next);
      })
    );
  }

  private addActionsDownloadWorkflowRunLogsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/runs/:run_id/logs',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsDownloadWorkflowRunLogsRequest,
        ActionsDownloadWorkflowRunLogsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDownloadWorkflowRunLogsHandler>(
            Handlers.ActionsDownloadWorkflowRunLogsHandler
          );

        await controller.actionsDownloadWorkflowRunLogs(req, res, next);
      })
    );
  }

  private addActionsDeleteWorkflowRunLogsHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/actions/runs/:run_id/logs',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsDeleteWorkflowRunLogsRequest,
        ActionsDeleteWorkflowRunLogsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDeleteWorkflowRunLogsHandler>(
            Handlers.ActionsDeleteWorkflowRunLogsHandler
          );

        await controller.actionsDeleteWorkflowRunLogs(req, res, next);
      })
    );
  }

  private addActionsGetPendingDeploymentsForRunHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/runs/:run_id/pending_deployments',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsGetPendingDeploymentsForRunRequest,
        ActionsGetPendingDeploymentsForRunResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetPendingDeploymentsForRunHandler>(
            Handlers.ActionsGetPendingDeploymentsForRunHandler
          );

        await controller.actionsGetPendingDeploymentsForRun(req, res, next);
      })
    );
  }

  private addActionsReviewPendingDeploymentsForRunHandler(
    router: Router
  ): void {
    router.post(
      '/repos/:owner/:repo/actions/runs/:run_id/pending_deployments',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            environment_ids: {
              type: 'array',
              description: 'The list of environment ids to approve or reject',
              example: [161171787, 161171795],
              items: { type: 'integer', example: 161171787 }
            },
            state: {
              type: 'string',
              description:
                'Whether to approve or reject deployment to the specified environments.',
              enum: ['approved', 'rejected'],
              example: 'approved'
            },
            comment: {
              type: 'string',
              description: 'A comment to accompany the deployment review',
              example: 'Ship it!'
            }
          },
          required: ['environment_ids', 'state', 'comment']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsReviewPendingDeploymentsForRunRequest,
        ActionsReviewPendingDeploymentsForRunResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsReviewPendingDeploymentsForRunHandler>(
            Handlers.ActionsReviewPendingDeploymentsForRunHandler
          );

        await controller.actionsReviewPendingDeploymentsForRun(req, res, next);
      })
    );
  }

  private addActionsReRunWorkflowHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/actions/runs/:run_id/rerun',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          nullable: true,
          properties: {
            enable_debug_logging: {
              type: 'boolean',
              default: false,
              description: 'Whether to enable debug logging for the re-run.'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsReRunWorkflowRequest,
        ActionsReRunWorkflowResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsReRunWorkflowHandler>(
            Handlers.ActionsReRunWorkflowHandler
          );

        await controller.actionsReRunWorkflow(req, res, next);
      })
    );
  }

  private addActionsReRunWorkflowFailedJobsHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/actions/runs/:run_id/rerun-failed-jobs',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          nullable: true,
          properties: {
            enable_debug_logging: {
              type: 'boolean',
              default: false,
              description: 'Whether to enable debug logging for the re-run.'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsReRunWorkflowFailedJobsRequest,
        ActionsReRunWorkflowFailedJobsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsReRunWorkflowFailedJobsHandler>(
            Handlers.ActionsReRunWorkflowFailedJobsHandler
          );

        await controller.actionsReRunWorkflowFailedJobs(req, res, next);
      })
    );
  }

  private addActionsGetWorkflowRunUsageHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/runs/:run_id/timing',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'run_id']
        }
      }),

      asyncRequestHandler<
        ActionsGetWorkflowRunUsageRequest,
        ActionsGetWorkflowRunUsageResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetWorkflowRunUsageHandler>(
            Handlers.ActionsGetWorkflowRunUsageHandler
          );

        await controller.actionsGetWorkflowRunUsage(req, res, next);
      })
    );
  }

  private addActionsListRepoSecretsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/secrets',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsListRepoSecretsRequest,
        ActionsListRepoSecretsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListRepoSecretsHandler>(
            Handlers.ActionsListRepoSecretsHandler
          );

        await controller.actionsListRepoSecrets(req, res, next);
      })
    );
  }

  private addActionsGetRepoPublicKeyHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/secrets/public-key',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsGetRepoPublicKeyRequest,
        ActionsGetRepoPublicKeyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetRepoPublicKeyHandler>(
            Handlers.ActionsGetRepoPublicKeyHandler
          );

        await controller.actionsGetRepoPublicKey(req, res, next);
      })
    );
  }

  private addActionsGetRepoSecretHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'secret_name']
        }
      }),

      asyncRequestHandler<
        ActionsGetRepoSecretRequest,
        ActionsGetRepoSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetRepoSecretHandler>(
            Handlers.ActionsGetRepoSecretHandler
          );

        await controller.actionsGetRepoSecret(req, res, next);
      })
    );
  }

  private addActionsCreateOrUpdateRepoSecretHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/actions/secrets/:secret_name',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            encrypted_value: {
              type: 'string',
              description:
                'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/reference/actions#get-a-repository-public-key) endpoint.',
              pattern:
                '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
            },
            key_id: {
              type: 'string',
              description: 'ID of the key you used to encrypt the secret.'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'secret_name']
        }
      }),

      asyncRequestHandler<
        ActionsCreateOrUpdateRepoSecretRequest,
        ActionsCreateOrUpdateRepoSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsCreateOrUpdateRepoSecretHandler>(
            Handlers.ActionsCreateOrUpdateRepoSecretHandler
          );

        await controller.actionsCreateOrUpdateRepoSecret(req, res, next);
      })
    );
  }

  private addActionsDeleteRepoSecretHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/actions/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'secret_name']
        }
      }),

      asyncRequestHandler<
        ActionsDeleteRepoSecretRequest,
        ActionsDeleteRepoSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDeleteRepoSecretHandler>(
            Handlers.ActionsDeleteRepoSecretHandler
          );

        await controller.actionsDeleteRepoSecret(req, res, next);
      })
    );
  }

  private addActionsListRepoWorkflowsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/workflows',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActionsListRepoWorkflowsRequest,
        ActionsListRepoWorkflowsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListRepoWorkflowsHandler>(
            Handlers.ActionsListRepoWorkflowsHandler
          );

        await controller.actionsListRepoWorkflows(req, res, next);
      })
    );
  }

  private addActionsGetWorkflowHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/workflows/:workflow_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            workflow_id: { oneOf: [{ type: 'integer' }, { type: 'string' }] }
          },
          required: ['owner', 'repo', 'workflow_id']
        }
      }),

      asyncRequestHandler<
        ActionsGetWorkflowRequest,
        ActionsGetWorkflowResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetWorkflowHandler>(
            Handlers.ActionsGetWorkflowHandler
          );

        await controller.actionsGetWorkflow(req, res, next);
      })
    );
  }

  private addActionsDisableWorkflowHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/actions/workflows/:workflow_id/disable',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            workflow_id: { oneOf: [{ type: 'integer' }, { type: 'string' }] }
          },
          required: ['owner', 'repo', 'workflow_id']
        }
      }),

      asyncRequestHandler<
        ActionsDisableWorkflowRequest,
        ActionsDisableWorkflowResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDisableWorkflowHandler>(
            Handlers.ActionsDisableWorkflowHandler
          );

        await controller.actionsDisableWorkflow(req, res, next);
      })
    );
  }

  private addActionsCreateWorkflowDispatchHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/actions/workflows/:workflow_id/dispatches',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            ref: {
              type: 'string',
              description:
                'The git reference for the workflow. The reference can be a branch or tag name.'
            },
            inputs: {
              type: 'object',
              description:
                'Input keys and values configured in the workflow file. The maximum number of properties is 10. Any default properties configured in the workflow file will be used when `inputs` are omitted.',
              additionalProperties: { type: 'string' },
              maxProperties: 10
            }
          },
          required: ['ref']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            workflow_id: { oneOf: [{ type: 'integer' }, { type: 'string' }] }
          },
          required: ['owner', 'repo', 'workflow_id']
        }
      }),

      asyncRequestHandler<
        ActionsCreateWorkflowDispatchRequest,
        ActionsCreateWorkflowDispatchResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsCreateWorkflowDispatchHandler>(
            Handlers.ActionsCreateWorkflowDispatchHandler
          );

        await controller.actionsCreateWorkflowDispatch(req, res, next);
      })
    );
  }

  private addActionsEnableWorkflowHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/actions/workflows/:workflow_id/enable',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            workflow_id: { oneOf: [{ type: 'integer' }, { type: 'string' }] }
          },
          required: ['owner', 'repo', 'workflow_id']
        }
      }),

      asyncRequestHandler<
        ActionsEnableWorkflowRequest,
        ActionsEnableWorkflowResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsEnableWorkflowHandler>(
            Handlers.ActionsEnableWorkflowHandler
          );

        await controller.actionsEnableWorkflow(req, res, next);
      })
    );
  }

  private addActionsListWorkflowRunsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/workflows/:workflow_id/runs',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            actor: { type: 'string' },
            branch: { type: 'string' },
            event: { type: 'string' },
            status: {
              type: 'string',
              enum: [
                'completed',
                'action_required',
                'cancelled',
                'failure',
                'neutral',
                'skipped',
                'stale',
                'success',
                'timed_out',
                'in_progress',
                'queued',
                'requested',
                'waiting'
              ]
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 },
            created: { type: 'string', format: 'date-time' },
            exclude_pull_requests: { type: 'boolean', default: false },
            check_suite_id: { type: 'integer' },
            head_sha: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            workflow_id: { oneOf: [{ type: 'integer' }, { type: 'string' }] }
          },
          required: ['owner', 'repo', 'workflow_id']
        }
      }),

      asyncRequestHandler<
        ActionsListWorkflowRunsRequest,
        ActionsListWorkflowRunsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListWorkflowRunsHandler>(
            Handlers.ActionsListWorkflowRunsHandler
          );

        await controller.actionsListWorkflowRuns(req, res, next);
      })
    );
  }

  private addActionsGetWorkflowUsageHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/actions/workflows/:workflow_id/timing',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            workflow_id: { oneOf: [{ type: 'integer' }, { type: 'string' }] }
          },
          required: ['owner', 'repo', 'workflow_id']
        }
      }),

      asyncRequestHandler<
        ActionsGetWorkflowUsageRequest,
        ActionsGetWorkflowUsageResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetWorkflowUsageHandler>(
            Handlers.ActionsGetWorkflowUsageHandler
          );

        await controller.actionsGetWorkflowUsage(req, res, next);
      })
    );
  }

  private addIssuesListAssigneesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/assignees',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        IssuesListAssigneesRequest,
        IssuesListAssigneesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesListAssigneesHandler>(
            Handlers.IssuesListAssigneesHandler
          );

        await controller.issuesListAssignees(req, res, next);
      })
    );
  }

  private addIssuesCheckUserCanBeAssignedHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/assignees/:assignee',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            assignee: { type: 'string' }
          },
          required: ['owner', 'repo', 'assignee']
        }
      }),

      asyncRequestHandler<
        IssuesCheckUserCanBeAssignedRequest,
        IssuesCheckUserCanBeAssignedResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesCheckUserCanBeAssignedHandler>(
            Handlers.IssuesCheckUserCanBeAssignedHandler
          );

        await controller.issuesCheckUserCanBeAssigned(req, res, next);
      })
    );
  }

  private addReposListAutolinksHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/autolinks',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { page: { type: 'integer', default: 1 } },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposListAutolinksRequest,
        ReposListAutolinksResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListAutolinksHandler>(
            Handlers.ReposListAutolinksHandler
          );

        await controller.reposListAutolinks(req, res, next);
      })
    );
  }

  private addReposCreateAutolinkHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/autolinks',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            key_prefix: {
              type: 'string',
              description:
                'This prefix appended by certain characters will generate a link any time it is found in an issue, pull request, or commit.'
            },
            url_template: {
              type: 'string',
              description:
                'The URL must contain `<num>` for the reference number. `<num>` matches different characters depending on the value of `is_alphanumeric`.'
            },
            is_alphanumeric: {
              type: 'boolean',
              default: 'true',
              description:
                'Whether this autolink reference matches alphanumeric characters. If true, the `<num>` parameter of the `url_template` matches alphanumeric characters `A-Z` (case insensitive), `0-9`, and `-`. If false, this autolink reference only matches numeric characters.'
            }
          },
          required: ['key_prefix', 'url_template']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposCreateAutolinkRequest,
        ReposCreateAutolinkResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateAutolinkHandler>(
            Handlers.ReposCreateAutolinkHandler
          );

        await controller.reposCreateAutolink(req, res, next);
      })
    );
  }

  private addReposGetAutolinkHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/autolinks/:autolink_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            autolink_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'autolink_id']
        }
      }),

      asyncRequestHandler<ReposGetAutolinkRequest, ReposGetAutolinkResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetAutolinkHandler>(Handlers.ReposGetAutolinkHandler);

          await controller.reposGetAutolink(req, res, next);
        }
      )
    );
  }

  private addReposDeleteAutolinkHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/autolinks/:autolink_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            autolink_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'autolink_id']
        }
      }),

      asyncRequestHandler<
        ReposDeleteAutolinkRequest,
        ReposDeleteAutolinkResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteAutolinkHandler>(
            Handlers.ReposDeleteAutolinkHandler
          );

        await controller.reposDeleteAutolink(req, res, next);
      })
    );
  }

  private addReposEnableAutomatedSecurityFixesHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/automated-security-fixes',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposEnableAutomatedSecurityFixesRequest,
        ReposEnableAutomatedSecurityFixesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposEnableAutomatedSecurityFixesHandler>(
            Handlers.ReposEnableAutomatedSecurityFixesHandler
          );

        await controller.reposEnableAutomatedSecurityFixes(req, res, next);
      })
    );
  }

  private addReposDisableAutomatedSecurityFixesHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/automated-security-fixes',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposDisableAutomatedSecurityFixesRequest,
        ReposDisableAutomatedSecurityFixesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDisableAutomatedSecurityFixesHandler>(
            Handlers.ReposDisableAutomatedSecurityFixesHandler
          );

        await controller.reposDisableAutomatedSecurityFixes(req, res, next);
      })
    );
  }

  private addReposListBranchesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/branches',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            protected: { type: 'boolean' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposListBranchesRequest, ReposListBranchesResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposListBranchesHandler>(
              Handlers.ReposListBranchesHandler
            );

          await controller.reposListBranches(req, res, next);
        }
      )
    );
  }

  private addReposGetBranchHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/branches/:branch',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<ReposGetBranchRequest, ReposGetBranchResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetBranchHandler>(Handlers.ReposGetBranchHandler);

          await controller.reposGetBranch(req, res, next);
        }
      )
    );
  }

  private addReposGetBranchProtectionHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/branches/:branch/protection',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposGetBranchProtectionRequest,
        ReposGetBranchProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetBranchProtectionHandler>(
            Handlers.ReposGetBranchProtectionHandler
          );

        await controller.reposGetBranchProtection(req, res, next);
      })
    );
  }

  private addReposUpdateBranchProtectionHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/branches/:branch/protection',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            required_status_checks: {
              type: 'object',
              description:
                'Require status checks to pass before merging. Set to `null` to disable.',
              nullable: true,
              properties: {
                strict: {
                  type: 'boolean',
                  description:
                    'Require branches to be up to date before merging.'
                },
                contexts: {
                  type: 'array',
                  deprecated: true,
                  description:
                    '**Deprecated**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.\n',
                  items: { type: 'string' }
                },
                checks: {
                  type: 'array',
                  description:
                    'The list of status checks to require in order to merge into this branch.',
                  items: {
                    type: 'object',
                    required: ['context'],
                    properties: {
                      context: {
                        type: 'string',
                        description: 'The name of the required check'
                      },
                      app_id: {
                        type: 'integer',
                        description:
                          'The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.'
                      }
                    }
                  }
                }
              },
              required: ['strict', 'contexts']
            },
            enforce_admins: {
              type: 'boolean',
              description:
                'Enforce all configured restrictions for administrators. Set to `true` to enforce required status checks for repository administrators. Set to `null` to disable.',
              nullable: true
            },
            required_pull_request_reviews: {
              type: 'object',
              description:
                'Require at least one approving review on a pull request, before merging. Set to `null` to disable.',
              nullable: true,
              properties: {
                dismissal_restrictions: {
                  type: 'object',
                  description:
                    'Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.',
                  properties: {
                    users: {
                      type: 'array',
                      description:
                        'The list of user `login`s with dismissal access',
                      items: { type: 'string' }
                    },
                    teams: {
                      type: 'array',
                      description:
                        'The list of team `slug`s with dismissal access',
                      items: { type: 'string' }
                    },
                    apps: {
                      type: 'array',
                      description:
                        'The list of app `slug`s with dismissal access',
                      items: { type: 'string' }
                    }
                  }
                },
                dismiss_stale_reviews: {
                  type: 'boolean',
                  description:
                    'Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.'
                },
                require_code_owner_reviews: {
                  type: 'boolean',
                  description:
                    'Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) review them.'
                },
                required_approving_review_count: {
                  type: 'integer',
                  description:
                    'Specify the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.'
                },
                require_last_push_approval: {
                  type: 'boolean',
                  description:
                    'Whether someone other than the person who last pushed to the branch must approve this pull request. Default: `false`.',
                  default: false
                },
                bypass_pull_request_allowances: {
                  type: 'object',
                  description:
                    'Allow specific users, teams, or apps to bypass pull request requirements.',
                  properties: {
                    users: {
                      type: 'array',
                      description:
                        'The list of user `login`s allowed to bypass pull request requirements.',
                      items: { type: 'string' }
                    },
                    teams: {
                      type: 'array',
                      description:
                        'The list of team `slug`s allowed to bypass pull request requirements.',
                      items: { type: 'string' }
                    },
                    apps: {
                      type: 'array',
                      description:
                        'The list of app `slug`s allowed to bypass pull request requirements.',
                      items: { type: 'string' }
                    }
                  }
                }
              }
            },
            restrictions: {
              type: 'object',
              description:
                'Restrict who can push to the protected branch. User, app, and team `restrictions` are only available for organization-owned repositories. Set to `null` to disable.',
              nullable: true,
              properties: {
                users: {
                  type: 'array',
                  description: 'The list of user `login`s with push access',
                  items: { type: 'string' }
                },
                teams: {
                  type: 'array',
                  description: 'The list of team `slug`s with push access',
                  items: { type: 'string' }
                },
                apps: {
                  type: 'array',
                  description: 'The list of app `slug`s with push access',
                  items: { type: 'string' }
                }
              },
              required: ['users', 'teams']
            },
            required_linear_history: {
              type: 'boolean',
              description:
                'Enforces a linear commit Git history, which prevents anyone from pushing merge commits to a branch. Set to `true` to enforce a linear commit history. Set to `false` to disable a linear commit Git history. Your repository must allow squash merging or rebase merging before you can enable a linear commit history. Default: `false`. For more information, see "[Requiring a linear commit history](https://docs.github.com/github/administering-a-repository/requiring-a-linear-commit-history)" in the GitHub Help documentation.'
            },
            allow_force_pushes: {
              type: 'boolean',
              description:
                'Permits force pushes to the protected branch by anyone with write access to the repository. Set to `true` to allow force pushes. Set to `false` or `null` to block force pushes. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation."',
              nullable: true
            },
            allow_deletions: {
              type: 'boolean',
              description:
                'Allows deletion of the protected branch by anyone with write access to the repository. Set to `false` to prevent deletion of the protected branch. Default: `false`. For more information, see "[Enabling force pushes to a protected branch](https://docs.github.com/en/github/administering-a-repository/enabling-force-pushes-to-a-protected-branch)" in the GitHub Help documentation.'
            },
            block_creations: {
              type: 'boolean',
              description:
                'If set to `true`, the `restrictions` branch protection settings which limits who can push will also block pushes which create new branches, unless the push is initiated by a user, team, or app which has the ability to push. Set to `true` to restrict new branch creation. Default: `false`.'
            },
            required_conversation_resolution: {
              type: 'boolean',
              description:
                'Requires all conversations on code to be resolved before a pull request can be merged into a branch that matches this rule. Set to `false` to disable. Default: `false`.'
            },
            lock_branch: {
              type: 'boolean',
              description:
                'Whether to set the branch as read-only. If this is true, users will not be able to push to the branch. Default: `false`.',
              default: false
            },
            allow_fork_syncing: {
              type: 'boolean',
              description:
                'Whether users can pull changes from upstream when the branch is locked. Set to `true` to allow fork syncing. Set to `false` to prevent fork syncing. Default: `false`.',
              default: false
            }
          },
          required: [
            'required_status_checks',
            'enforce_admins',
            'required_pull_request_reviews',
            'restrictions'
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposUpdateBranchProtectionRequest,
        ReposUpdateBranchProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposUpdateBranchProtectionHandler>(
            Handlers.ReposUpdateBranchProtectionHandler
          );

        await controller.reposUpdateBranchProtection(req, res, next);
      })
    );
  }

  private addReposDeleteBranchProtectionHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/branches/:branch/protection',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposDeleteBranchProtectionRequest,
        ReposDeleteBranchProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteBranchProtectionHandler>(
            Handlers.ReposDeleteBranchProtectionHandler
          );

        await controller.reposDeleteBranchProtection(req, res, next);
      })
    );
  }

  private addReposGetAdminBranchProtectionHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/branches/:branch/protection/enforce_admins',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposGetAdminBranchProtectionRequest,
        ReposGetAdminBranchProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetAdminBranchProtectionHandler>(
            Handlers.ReposGetAdminBranchProtectionHandler
          );

        await controller.reposGetAdminBranchProtection(req, res, next);
      })
    );
  }

  private addReposSetAdminBranchProtectionHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/branches/:branch/protection/enforce_admins',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposSetAdminBranchProtectionRequest,
        ReposSetAdminBranchProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposSetAdminBranchProtectionHandler>(
            Handlers.ReposSetAdminBranchProtectionHandler
          );

        await controller.reposSetAdminBranchProtection(req, res, next);
      })
    );
  }

  private addReposDeleteAdminBranchProtectionHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/branches/:branch/protection/enforce_admins',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposDeleteAdminBranchProtectionRequest,
        ReposDeleteAdminBranchProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteAdminBranchProtectionHandler>(
            Handlers.ReposDeleteAdminBranchProtectionHandler
          );

        await controller.reposDeleteAdminBranchProtection(req, res, next);
      })
    );
  }

  private addReposGetPullRequestReviewProtectionHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposGetPullRequestReviewProtectionRequest,
        ReposGetPullRequestReviewProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetPullRequestReviewProtectionHandler>(
            Handlers.ReposGetPullRequestReviewProtectionHandler
          );

        await controller.reposGetPullRequestReviewProtection(req, res, next);
      })
    );
  }

  private addReposUpdatePullRequestReviewProtectionHandler(
    router: Router
  ): void {
    router.patch(
      '/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            dismissal_restrictions: {
              type: 'object',
              description:
                'Specify which users, teams, and apps can dismiss pull request reviews. Pass an empty `dismissal_restrictions` object to disable. User and team `dismissal_restrictions` are only available for organization-owned repositories. Omit this parameter for personal repositories.',
              properties: {
                users: {
                  type: 'array',
                  description:
                    'The list of user `login`s with dismissal access',
                  items: { type: 'string' }
                },
                teams: {
                  type: 'array',
                  description: 'The list of team `slug`s with dismissal access',
                  items: { type: 'string' }
                },
                apps: {
                  type: 'array',
                  description: 'The list of app `slug`s with dismissal access',
                  items: { type: 'string' }
                }
              }
            },
            dismiss_stale_reviews: {
              type: 'boolean',
              description:
                'Set to `true` if you want to automatically dismiss approving reviews when someone pushes a new commit.'
            },
            require_code_owner_reviews: {
              type: 'boolean',
              description:
                'Blocks merging pull requests until [code owners](https://docs.github.com/articles/about-code-owners/) have reviewed.'
            },
            required_approving_review_count: {
              type: 'integer',
              description:
                'Specifies the number of reviewers required to approve pull requests. Use a number between 1 and 6 or 0 to not require reviewers.'
            },
            require_last_push_approval: {
              type: 'boolean',
              description:
                'Whether someone other than the person who last pushed to the branch must approve this pull request. Default: `false`',
              default: false
            },
            bypass_pull_request_allowances: {
              type: 'object',
              description:
                'Allow specific users, teams, or apps to bypass pull request requirements.',
              properties: {
                users: {
                  type: 'array',
                  description:
                    'The list of user `login`s allowed to bypass pull request requirements.',
                  items: { type: 'string' }
                },
                teams: {
                  type: 'array',
                  description:
                    'The list of team `slug`s allowed to bypass pull request requirements.',
                  items: { type: 'string' }
                },
                apps: {
                  type: 'array',
                  description:
                    'The list of app `slug`s allowed to bypass pull request requirements.',
                  items: { type: 'string' }
                }
              }
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposUpdatePullRequestReviewProtectionRequest,
        ReposUpdatePullRequestReviewProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposUpdatePullRequestReviewProtectionHandler>(
            Handlers.ReposUpdatePullRequestReviewProtectionHandler
          );

        await controller.reposUpdatePullRequestReviewProtection(req, res, next);
      })
    );
  }

  private addReposDeletePullRequestReviewProtectionHandler(
    router: Router
  ): void {
    router.delete(
      '/repos/:owner/:repo/branches/:branch/protection/required_pull_request_reviews',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposDeletePullRequestReviewProtectionRequest,
        ReposDeletePullRequestReviewProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeletePullRequestReviewProtectionHandler>(
            Handlers.ReposDeletePullRequestReviewProtectionHandler
          );

        await controller.reposDeletePullRequestReviewProtection(req, res, next);
      })
    );
  }

  private addReposGetCommitSignatureProtectionHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/branches/:branch/protection/required_signatures',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposGetCommitSignatureProtectionRequest,
        ReposGetCommitSignatureProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetCommitSignatureProtectionHandler>(
            Handlers.ReposGetCommitSignatureProtectionHandler
          );

        await controller.reposGetCommitSignatureProtection(req, res, next);
      })
    );
  }

  private addReposCreateCommitSignatureProtectionHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/branches/:branch/protection/required_signatures',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposCreateCommitSignatureProtectionRequest,
        ReposCreateCommitSignatureProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateCommitSignatureProtectionHandler>(
            Handlers.ReposCreateCommitSignatureProtectionHandler
          );

        await controller.reposCreateCommitSignatureProtection(req, res, next);
      })
    );
  }

  private addReposDeleteCommitSignatureProtectionHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/branches/:branch/protection/required_signatures',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposDeleteCommitSignatureProtectionRequest,
        ReposDeleteCommitSignatureProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteCommitSignatureProtectionHandler>(
            Handlers.ReposDeleteCommitSignatureProtectionHandler
          );

        await controller.reposDeleteCommitSignatureProtection(req, res, next);
      })
    );
  }

  private addReposGetStatusChecksProtectionHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/branches/:branch/protection/required_status_checks',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposGetStatusChecksProtectionRequest,
        ReposGetStatusChecksProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetStatusChecksProtectionHandler>(
            Handlers.ReposGetStatusChecksProtectionHandler
          );

        await controller.reposGetStatusChecksProtection(req, res, next);
      })
    );
  }

  private addReposUpdateStatusCheckProtectionHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/branches/:branch/protection/required_status_checks',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            strict: {
              type: 'boolean',
              description: 'Require branches to be up to date before merging.'
            },
            contexts: {
              type: 'array',
              deprecated: true,
              description:
                '**Deprecated**: The list of status checks to require in order to merge into this branch. If any of these checks have recently been set by a particular GitHub App, they will be required to come from that app in future for the branch to merge. Use `checks` instead of `contexts` for more fine-grained control.\n',
              items: { type: 'string' }
            },
            checks: {
              type: 'array',
              description:
                'The list of status checks to require in order to merge into this branch.',
              items: {
                type: 'object',
                required: ['context'],
                properties: {
                  context: {
                    type: 'string',
                    description: 'The name of the required check'
                  },
                  app_id: {
                    type: 'integer',
                    description:
                      'The ID of the GitHub App that must provide this check. Omit this field to automatically select the GitHub App that has recently provided this check, or any app if it was not set by a GitHub App. Pass -1 to explicitly allow any app to set the status.'
                  }
                }
              }
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposUpdateStatusCheckProtectionRequest,
        ReposUpdateStatusCheckProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposUpdateStatusCheckProtectionHandler>(
            Handlers.ReposUpdateStatusCheckProtectionHandler
          );

        await controller.reposUpdateStatusCheckProtection(req, res, next);
      })
    );
  }

  private addReposRemoveStatusCheckProtectionHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/branches/:branch/protection/required_status_checks',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposRemoveStatusCheckProtectionRequest,
        ReposRemoveStatusCheckProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposRemoveStatusCheckProtectionHandler>(
            Handlers.ReposRemoveStatusCheckProtectionHandler
          );

        await controller.reposRemoveStatusCheckProtection(req, res, next);
      })
    );
  }

  private addReposGetAllStatusCheckContextsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposGetAllStatusCheckContextsRequest,
        ReposGetAllStatusCheckContextsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetAllStatusCheckContextsHandler>(
            Handlers.ReposGetAllStatusCheckContextsHandler
          );

        await controller.reposGetAllStatusCheckContexts(req, res, next);
      })
    );
  }

  private addReposAddStatusCheckContextsHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                contexts: {
                  type: 'array',
                  description: 'The name of the status checks',
                  items: { type: 'string' }
                }
              },
              required: ['contexts'],
              example: { contexts: ['contexts'] }
            },
            {
              type: 'array',
              description: 'The name of the status checks',
              items: { type: 'string' }
            }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposAddStatusCheckContextsRequest,
        ReposAddStatusCheckContextsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposAddStatusCheckContextsHandler>(
            Handlers.ReposAddStatusCheckContextsHandler
          );

        await controller.reposAddStatusCheckContexts(req, res, next);
      })
    );
  }

  private addReposSetStatusCheckContextsHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                contexts: {
                  type: 'array',
                  description: 'The name of the status checks',
                  items: { type: 'string' }
                }
              },
              required: ['contexts'],
              example: { contexts: ['contexts'] }
            },
            {
              type: 'array',
              description: 'The name of the status checks',
              items: { type: 'string' }
            }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposSetStatusCheckContextsRequest,
        ReposSetStatusCheckContextsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposSetStatusCheckContextsHandler>(
            Handlers.ReposSetStatusCheckContextsHandler
          );

        await controller.reposSetStatusCheckContexts(req, res, next);
      })
    );
  }

  private addReposRemoveStatusCheckContextsHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/branches/:branch/protection/required_status_checks/contexts',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                contexts: {
                  type: 'array',
                  description: 'The name of the status checks',
                  items: { type: 'string' }
                }
              },
              required: ['contexts'],
              example: { contexts: ['contexts'] }
            },
            {
              type: 'array',
              description: 'The name of the status checks',
              items: { type: 'string' }
            }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposRemoveStatusCheckContextsRequest,
        ReposRemoveStatusCheckContextsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposRemoveStatusCheckContextsHandler>(
            Handlers.ReposRemoveStatusCheckContextsHandler
          );

        await controller.reposRemoveStatusCheckContexts(req, res, next);
      })
    );
  }

  private addReposGetAccessRestrictionsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposGetAccessRestrictionsRequest,
        ReposGetAccessRestrictionsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetAccessRestrictionsHandler>(
            Handlers.ReposGetAccessRestrictionsHandler
          );

        await controller.reposGetAccessRestrictions(req, res, next);
      })
    );
  }

  private addReposDeleteAccessRestrictionsHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposDeleteAccessRestrictionsRequest,
        ReposDeleteAccessRestrictionsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteAccessRestrictionsHandler>(
            Handlers.ReposDeleteAccessRestrictionsHandler
          );

        await controller.reposDeleteAccessRestrictions(req, res, next);
      })
    );
  }

  private addReposGetAppsWithAccessToProtectedBranchHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions/apps',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposGetAppsWithAccessToProtectedBranchRequest,
        ReposGetAppsWithAccessToProtectedBranchResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetAppsWithAccessToProtectedBranchHandler>(
            Handlers.ReposGetAppsWithAccessToProtectedBranchHandler
          );

        await controller.reposGetAppsWithAccessToProtectedBranch(
          req,
          res,
          next
        );
      })
    );
  }

  private addReposAddAppAccessRestrictionsHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions/apps',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                apps: {
                  type: 'array',
                  description: 'apps parameter',
                  items: { type: 'string' }
                }
              },
              required: ['apps'],
              example: { apps: ['my-app'] }
            },
            { type: 'array', items: { type: 'string' } }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposAddAppAccessRestrictionsRequest,
        ReposAddAppAccessRestrictionsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposAddAppAccessRestrictionsHandler>(
            Handlers.ReposAddAppAccessRestrictionsHandler
          );

        await controller.reposAddAppAccessRestrictions(req, res, next);
      })
    );
  }

  private addReposSetAppAccessRestrictionsHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions/apps',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                apps: {
                  type: 'array',
                  description: 'apps parameter',
                  items: { type: 'string' }
                }
              },
              required: ['apps'],
              example: { apps: ['my-app'] }
            },
            { type: 'array', items: { type: 'string' } }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposSetAppAccessRestrictionsRequest,
        ReposSetAppAccessRestrictionsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposSetAppAccessRestrictionsHandler>(
            Handlers.ReposSetAppAccessRestrictionsHandler
          );

        await controller.reposSetAppAccessRestrictions(req, res, next);
      })
    );
  }

  private addReposRemoveAppAccessRestrictionsHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions/apps',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                apps: {
                  type: 'array',
                  description: 'apps parameter',
                  items: { type: 'string' }
                }
              },
              required: ['apps'],
              example: { apps: ['my-app'] }
            },
            { type: 'array', items: { type: 'string' } }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposRemoveAppAccessRestrictionsRequest,
        ReposRemoveAppAccessRestrictionsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposRemoveAppAccessRestrictionsHandler>(
            Handlers.ReposRemoveAppAccessRestrictionsHandler
          );

        await controller.reposRemoveAppAccessRestrictions(req, res, next);
      })
    );
  }

  private addReposGetTeamsWithAccessToProtectedBranchHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions/teams',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposGetTeamsWithAccessToProtectedBranchRequest,
        ReposGetTeamsWithAccessToProtectedBranchResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetTeamsWithAccessToProtectedBranchHandler>(
            Handlers.ReposGetTeamsWithAccessToProtectedBranchHandler
          );

        await controller.reposGetTeamsWithAccessToProtectedBranch(
          req,
          res,
          next
        );
      })
    );
  }

  private addReposAddTeamAccessRestrictionsHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions/teams',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                teams: {
                  type: 'array',
                  description: 'The slug values for teams',
                  items: { type: 'string' }
                }
              },
              required: ['teams'],
              example: { teams: ['my-team'] }
            },
            {
              type: 'array',
              description: 'The slug values for teams',
              items: { type: 'string' }
            }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposAddTeamAccessRestrictionsRequest,
        ReposAddTeamAccessRestrictionsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposAddTeamAccessRestrictionsHandler>(
            Handlers.ReposAddTeamAccessRestrictionsHandler
          );

        await controller.reposAddTeamAccessRestrictions(req, res, next);
      })
    );
  }

  private addReposSetTeamAccessRestrictionsHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions/teams',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                teams: {
                  type: 'array',
                  description: 'The slug values for teams',
                  items: { type: 'string' }
                }
              },
              required: ['teams'],
              example: { teams: ['justice-league'] }
            },
            {
              type: 'array',
              description: 'The slug values for teams',
              items: { type: 'string' }
            }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposSetTeamAccessRestrictionsRequest,
        ReposSetTeamAccessRestrictionsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposSetTeamAccessRestrictionsHandler>(
            Handlers.ReposSetTeamAccessRestrictionsHandler
          );

        await controller.reposSetTeamAccessRestrictions(req, res, next);
      })
    );
  }

  private addReposRemoveTeamAccessRestrictionsHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions/teams',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                teams: {
                  type: 'array',
                  description: 'The slug values for teams',
                  items: { type: 'string' }
                }
              },
              required: ['teams'],
              example: { teams: ['my-team'] }
            },
            {
              type: 'array',
              description: 'The slug values for teams',
              items: { type: 'string' }
            }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposRemoveTeamAccessRestrictionsRequest,
        ReposRemoveTeamAccessRestrictionsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposRemoveTeamAccessRestrictionsHandler>(
            Handlers.ReposRemoveTeamAccessRestrictionsHandler
          );

        await controller.reposRemoveTeamAccessRestrictions(req, res, next);
      })
    );
  }

  private addReposGetUsersWithAccessToProtectedBranchHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions/users',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposGetUsersWithAccessToProtectedBranchRequest,
        ReposGetUsersWithAccessToProtectedBranchResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetUsersWithAccessToProtectedBranchHandler>(
            Handlers.ReposGetUsersWithAccessToProtectedBranchHandler
          );

        await controller.reposGetUsersWithAccessToProtectedBranch(
          req,
          res,
          next
        );
      })
    );
  }

  private addReposAddUserAccessRestrictionsHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions/users',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                users: {
                  type: 'array',
                  description: 'The username for users',
                  items: { type: 'string' }
                }
              },
              required: ['users'],
              example: { users: ['mona'] }
            },
            { type: 'array', items: { type: 'string' } }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposAddUserAccessRestrictionsRequest,
        ReposAddUserAccessRestrictionsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposAddUserAccessRestrictionsHandler>(
            Handlers.ReposAddUserAccessRestrictionsHandler
          );

        await controller.reposAddUserAccessRestrictions(req, res, next);
      })
    );
  }

  private addReposSetUserAccessRestrictionsHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions/users',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                users: {
                  type: 'array',
                  description: 'The username for users',
                  items: { type: 'string' }
                }
              },
              required: ['users'],
              example: { users: ['mona'] }
            },
            { type: 'array', items: { type: 'string' } }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposSetUserAccessRestrictionsRequest,
        ReposSetUserAccessRestrictionsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposSetUserAccessRestrictionsHandler>(
            Handlers.ReposSetUserAccessRestrictionsHandler
          );

        await controller.reposSetUserAccessRestrictions(req, res, next);
      })
    );
  }

  private addReposRemoveUserAccessRestrictionsHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/branches/:branch/protection/restrictions/users',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                users: {
                  type: 'array',
                  description: 'The username for users',
                  items: { type: 'string' }
                }
              },
              required: ['users'],
              example: { users: ['mona'] }
            },
            { type: 'array', items: { type: 'string' } }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<
        ReposRemoveUserAccessRestrictionsRequest,
        ReposRemoveUserAccessRestrictionsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposRemoveUserAccessRestrictionsHandler>(
            Handlers.ReposRemoveUserAccessRestrictionsHandler
          );

        await controller.reposRemoveUserAccessRestrictions(req, res, next);
      })
    );
  }

  private addReposRenameBranchHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/branches/:branch/rename',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            new_name: {
              type: 'string',
              description: 'The new name of the branch.'
            }
          },
          required: ['new_name']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            branch: { type: 'string' }
          },
          required: ['owner', 'repo', 'branch']
        }
      }),

      asyncRequestHandler<ReposRenameBranchRequest, ReposRenameBranchResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposRenameBranchHandler>(
              Handlers.ReposRenameBranchHandler
            );

          await controller.reposRenameBranch(req, res, next);
        }
      )
    );
  }

  private addChecksCreateHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/check-runs',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description:
                'The name of the check. For example, "code-coverage".'
            },
            head_sha: { type: 'string', description: 'The SHA of the commit.' },
            details_url: {
              type: 'string',
              description:
                "The URL of the integrator's site that has the full details of the check. If the integrator does not provide this, then the homepage of the GitHub app is used."
            },
            external_id: {
              type: 'string',
              description: "A reference for the run on the integrator's system."
            },
            status: {
              type: 'string',
              description: 'The current status.',
              enum: ['queued', 'in_progress', 'completed'],
              default: 'queued'
            },
            started_at: {
              type: 'string',
              format: 'date-time',
              description:
                'The time that the check run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
            },
            conclusion: {
              type: 'string',
              description:
                '**Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. \n**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.',
              enum: [
                'action_required',
                'cancelled',
                'failure',
                'neutral',
                'success',
                'skipped',
                'stale',
                'timed_out'
              ]
            },
            completed_at: {
              type: 'string',
              format: 'date-time',
              description:
                'The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
            },
            output: {
              type: 'object',
              description:
                'Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.',
              properties: {
                title: {
                  type: 'string',
                  description: 'The title of the check run.'
                },
                summary: {
                  type: 'string',
                  maxLength: 65535,
                  description:
                    'The summary of the check run. This parameter supports Markdown. **Maximum length**: 65535 characters.'
                },
                text: {
                  type: 'string',
                  maxLength: 65535,
                  description:
                    'The details of the check run. This parameter supports Markdown. **Maximum length**: 65535 characters.'
                },
                annotations: {
                  type: 'array',
                  description:
                    'Adds information from your analysis to specific lines of code. Annotations are visible on GitHub in the **Checks** and **Files changed** tab of the pull request. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/rest/reference/checks#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. For details about how you can view annotations on GitHub, see "[About status checks](https://docs.github.com/articles/about-status-checks#checks)".',
                  maxItems: 50,
                  items: {
                    type: 'object',
                    properties: {
                      path: {
                        type: 'string',
                        description:
                          'The path of the file to add an annotation to. For example, `assets/css/main.css`.'
                      },
                      start_line: {
                        type: 'integer',
                        description:
                          'The start line of the annotation. Line numbers start at 1.'
                      },
                      end_line: {
                        type: 'integer',
                        description: 'The end line of the annotation.'
                      },
                      start_column: {
                        type: 'integer',
                        description:
                          'The start column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values. Column numbers start at 1.'
                      },
                      end_column: {
                        type: 'integer',
                        description:
                          'The end column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values.'
                      },
                      annotation_level: {
                        type: 'string',
                        description: 'The level of the annotation.',
                        enum: ['notice', 'warning', 'failure']
                      },
                      message: {
                        type: 'string',
                        description:
                          'A short description of the feedback for these lines of code. The maximum size is 64 KB.'
                      },
                      title: {
                        type: 'string',
                        description:
                          'The title that represents the annotation. The maximum size is 255 characters.'
                      },
                      raw_details: {
                        type: 'string',
                        description:
                          'Details about this annotation. The maximum size is 64 KB.'
                      }
                    },
                    required: [
                      'path',
                      'start_line',
                      'end_line',
                      'annotation_level',
                      'message'
                    ]
                  }
                },
                images: {
                  type: 'array',
                  description:
                    'Adds images to the output displayed in the GitHub pull request UI.',
                  items: {
                    type: 'object',
                    properties: {
                      alt: {
                        type: 'string',
                        description: 'The alternative text for the image.'
                      },
                      image_url: {
                        type: 'string',
                        description: 'The full URL of the image.'
                      },
                      caption: {
                        type: 'string',
                        description: 'A short image description.'
                      }
                    },
                    required: ['alt', 'image_url']
                  }
                }
              },
              required: ['title', 'summary']
            },
            actions: {
              type: 'array',
              description:
                'Displays a button on GitHub that can be clicked to alert your app to do additional tasks. For example, a code linting app can display a button that automatically fixes detected errors. The button created in this object is displayed after the check run completes. When a user clicks the button, GitHub sends the [`check_run.requested_action` webhook](https://docs.github.com/webhooks/event-payloads/#check_run) to your app. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/rest/reference/checks#check-runs-and-requested-actions)."',
              maxItems: 3,
              items: {
                type: 'object',
                properties: {
                  label: {
                    type: 'string',
                    maxLength: 20,
                    description:
                      'The text to be displayed on a button in the web UI. The maximum size is 20 characters.'
                  },
                  description: {
                    type: 'string',
                    maxLength: 40,
                    description:
                      'A short explanation of what this action would do. The maximum size is 40 characters.'
                  },
                  identifier: {
                    type: 'string',
                    maxLength: 20,
                    description:
                      "A reference for the action on the integrator's system. The maximum size is 20 characters."
                  }
                },
                required: ['label', 'description', 'identifier']
              }
            }
          },
          required: ['name', 'head_sha'],
          oneOf: [
            {
              properties: { status: { enum: ['completed'] } },
              required: ['status', 'conclusion'],
              additionalProperties: true
            },
            {
              properties: { status: { enum: ['queued', 'in_progress'] } },
              additionalProperties: true
            }
          ]
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ChecksCreateRequest, ChecksCreateResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ChecksCreateHandler>(Handlers.ChecksCreateHandler);

          await controller.checksCreate(req, res, next);
        }
      )
    );
  }

  private addChecksGetHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/check-runs/:check_run_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            check_run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'check_run_id']
        }
      }),

      asyncRequestHandler<ChecksGetRequest, ChecksGetResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ChecksGetHandler>(Handlers.ChecksGetHandler);

          await controller.checksGet(req, res, next);
        }
      )
    );
  }

  private addChecksUpdateHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/check-runs/:check_run_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description:
                'The name of the check. For example, "code-coverage".'
            },
            details_url: {
              type: 'string',
              description:
                "The URL of the integrator's site that has the full details of the check."
            },
            external_id: {
              type: 'string',
              description: "A reference for the run on the integrator's system."
            },
            started_at: {
              type: 'string',
              format: 'date-time',
              description:
                'This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
            },
            status: {
              type: 'string',
              description: 'The current status.',
              enum: ['queued', 'in_progress', 'completed']
            },
            conclusion: {
              type: 'string',
              description:
                '**Required if you provide `completed_at` or a `status` of `completed`**. The final conclusion of the check. \n**Note:** Providing `conclusion` will automatically set the `status` parameter to `completed`. You cannot change a check run conclusion to `stale`, only GitHub can set this.',
              enum: [
                'action_required',
                'cancelled',
                'failure',
                'neutral',
                'success',
                'skipped',
                'stale',
                'timed_out'
              ]
            },
            completed_at: {
              type: 'string',
              format: 'date-time',
              description:
                'The time the check completed. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
            },
            output: {
              type: 'object',
              description:
                'Check runs can accept a variety of data in the `output` object, including a `title` and `summary` and can optionally provide descriptive details about the run.',
              properties: {
                title: { type: 'string', description: '**Required**.' },
                summary: {
                  type: 'string',
                  description: 'Can contain Markdown.',
                  maxLength: 65535
                },
                text: {
                  type: 'string',
                  description: 'Can contain Markdown.',
                  maxLength: 65535
                },
                annotations: {
                  type: 'array',
                  description:
                    'Adds information from your analysis to specific lines of code. Annotations are visible in GitHub\'s pull request UI. Annotations are visible in GitHub\'s pull request UI. The Checks API limits the number of annotations to a maximum of 50 per API request. To create more than 50 annotations, you have to make multiple requests to the [Update a check run](https://docs.github.com/rest/reference/checks#update-a-check-run) endpoint. Each time you update the check run, annotations are appended to the list of annotations that already exist for the check run. For details about annotations in the UI, see "[About status checks](https://docs.github.com/articles/about-status-checks#checks)".',
                  maxItems: 50,
                  items: {
                    type: 'object',
                    properties: {
                      path: {
                        type: 'string',
                        description:
                          'The path of the file to add an annotation to. For example, `assets/css/main.css`.'
                      },
                      start_line: {
                        type: 'integer',
                        description:
                          'The start line of the annotation. Line numbers start at 1.'
                      },
                      end_line: {
                        type: 'integer',
                        description: 'The end line of the annotation.'
                      },
                      start_column: {
                        type: 'integer',
                        description:
                          'The start column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values. Column numbers start at 1.'
                      },
                      end_column: {
                        type: 'integer',
                        description:
                          'The end column of the annotation. Annotations only support `start_column` and `end_column` on the same line. Omit this parameter if `start_line` and `end_line` have different values.'
                      },
                      annotation_level: {
                        type: 'string',
                        description: 'The level of the annotation.',
                        enum: ['notice', 'warning', 'failure']
                      },
                      message: {
                        type: 'string',
                        description:
                          'A short description of the feedback for these lines of code. The maximum size is 64 KB.'
                      },
                      title: {
                        type: 'string',
                        description:
                          'The title that represents the annotation. The maximum size is 255 characters.'
                      },
                      raw_details: {
                        type: 'string',
                        description:
                          'Details about this annotation. The maximum size is 64 KB.'
                      }
                    },
                    required: [
                      'path',
                      'start_line',
                      'end_line',
                      'annotation_level',
                      'message'
                    ]
                  }
                },
                images: {
                  type: 'array',
                  description:
                    'Adds images to the output displayed in the GitHub pull request UI.',
                  items: {
                    type: 'object',
                    properties: {
                      alt: {
                        type: 'string',
                        description: 'The alternative text for the image.'
                      },
                      image_url: {
                        type: 'string',
                        description: 'The full URL of the image.'
                      },
                      caption: {
                        type: 'string',
                        description: 'A short image description.'
                      }
                    },
                    required: ['alt', 'image_url']
                  }
                }
              },
              required: ['summary']
            },
            actions: {
              type: 'array',
              description:
                'Possible further actions the integrator can perform, which a user may trigger. Each action includes a `label`, `identifier` and `description`. A maximum of three actions are accepted. See the [`actions` object](https://docs.github.com/rest/reference/checks#actions-object) description. To learn more about check runs and requested actions, see "[Check runs and requested actions](https://docs.github.com/rest/reference/checks#check-runs-and-requested-actions)."',
              maxItems: 3,
              items: {
                type: 'object',
                properties: {
                  label: {
                    type: 'string',
                    maxLength: 20,
                    description:
                      'The text to be displayed on a button in the web UI. The maximum size is 20 characters.'
                  },
                  description: {
                    type: 'string',
                    maxLength: 40,
                    description:
                      'A short explanation of what this action would do. The maximum size is 40 characters.'
                  },
                  identifier: {
                    type: 'string',
                    maxLength: 20,
                    description:
                      "A reference for the action on the integrator's system. The maximum size is 20 characters."
                  }
                },
                required: ['label', 'description', 'identifier']
              }
            }
          },
          anyOf: [
            {
              properties: { status: { enum: ['completed'] } },
              required: ['conclusion'],
              additionalProperties: true
            },
            {
              properties: { status: { enum: ['queued', 'in_progress'] } },
              additionalProperties: true
            }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            check_run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'check_run_id']
        }
      }),

      asyncRequestHandler<ChecksUpdateRequest, ChecksUpdateResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ChecksUpdateHandler>(Handlers.ChecksUpdateHandler);

          await controller.checksUpdate(req, res, next);
        }
      )
    );
  }

  private addChecksListAnnotationsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/check-runs/:check_run_id/annotations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            check_run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'check_run_id']
        }
      }),

      asyncRequestHandler<
        ChecksListAnnotationsRequest,
        ChecksListAnnotationsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ChecksListAnnotationsHandler>(
            Handlers.ChecksListAnnotationsHandler
          );

        await controller.checksListAnnotations(req, res, next);
      })
    );
  }

  private addChecksRerequestRunHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/check-runs/:check_run_id/rerequest',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            check_run_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'check_run_id']
        }
      }),

      asyncRequestHandler<
        ChecksRerequestRunRequest,
        ChecksRerequestRunResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ChecksRerequestRunHandler>(
            Handlers.ChecksRerequestRunHandler
          );

        await controller.checksRerequestRun(req, res, next);
      })
    );
  }

  private addChecksCreateSuiteHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/check-suites',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            head_sha: {
              type: 'string',
              description: 'The sha of the head commit.'
            }
          },
          required: ['head_sha']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ChecksCreateSuiteRequest, ChecksCreateSuiteResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ChecksCreateSuiteHandler>(
              Handlers.ChecksCreateSuiteHandler
            );

          await controller.checksCreateSuite(req, res, next);
        }
      )
    );
  }

  private addChecksSetSuitesPreferencesHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/check-suites/preferences',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            auto_trigger_checks: {
              type: 'array',
              description:
                'Enables or disables automatic creation of CheckSuite events upon pushes to the repository. Enabled by default.',
              items: {
                type: 'object',
                properties: {
                  app_id: {
                    type: 'integer',
                    description: 'The `id` of the GitHub App.'
                  },
                  setting: {
                    type: 'boolean',
                    description:
                      'Set to `true` to enable automatic creation of CheckSuite events upon pushes to the repository, or `false` to disable them.',
                    default: true
                  }
                },
                required: ['app_id', 'setting']
              }
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ChecksSetSuitesPreferencesRequest,
        ChecksSetSuitesPreferencesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ChecksSetSuitesPreferencesHandler>(
            Handlers.ChecksSetSuitesPreferencesHandler
          );

        await controller.checksSetSuitesPreferences(req, res, next);
      })
    );
  }

  private addChecksGetSuiteHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/check-suites/:check_suite_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            check_suite_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'check_suite_id']
        }
      }),

      asyncRequestHandler<ChecksGetSuiteRequest, ChecksGetSuiteResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ChecksGetSuiteHandler>(Handlers.ChecksGetSuiteHandler);

          await controller.checksGetSuite(req, res, next);
        }
      )
    );
  }

  private addChecksListForSuiteHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/check-suites/:check_suite_id/check-runs',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            check_name: { type: 'string' },
            status: {
              type: 'string',
              enum: ['queued', 'in_progress', 'completed']
            },
            filter: {
              type: 'string',
              enum: ['latest', 'all'],
              default: 'latest'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            check_suite_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'check_suite_id']
        }
      }),

      asyncRequestHandler<
        ChecksListForSuiteRequest,
        ChecksListForSuiteResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ChecksListForSuiteHandler>(
            Handlers.ChecksListForSuiteHandler
          );

        await controller.checksListForSuite(req, res, next);
      })
    );
  }

  private addChecksRerequestSuiteHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/check-suites/:check_suite_id/rerequest',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            check_suite_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'check_suite_id']
        }
      }),

      asyncRequestHandler<
        ChecksRerequestSuiteRequest,
        ChecksRerequestSuiteResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ChecksRerequestSuiteHandler>(
            Handlers.ChecksRerequestSuiteHandler
          );

        await controller.checksRerequestSuite(req, res, next);
      })
    );
  }

  private addCodeScanningListAlertsForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/code-scanning/alerts',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            tool_name: {
              $ref: '#/definitions/code-scanning-analysis-tool-name'
            },
            tool_guid: {
              $ref: '#/definitions/code-scanning-analysis-tool-guid'
            },
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 },
            ref: { $ref: '#/definitions/code-scanning-ref' },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            },
            state: { $ref: '#/definitions/code-scanning-alert-state' }
          },
          required: [],
          definitions: {
            'code-scanning-analysis-tool-name': {
              type: 'string',
              description:
                'The name of the tool used to generate the code scanning analysis.',
              title: 'code-scanning-analysis-tool-name'
            },
            'code-scanning-analysis-tool-guid': {
              nullable: true,
              type: 'string',
              description:
                'The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.',
              title: 'code-scanning-analysis-tool-guid'
            },
            'code-scanning-ref': {
              type: 'string',
              description:
                'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.',
              title: 'code-scanning-ref'
            },
            'code-scanning-alert-state': {
              type: 'string',
              description: 'State of a code scanning alert.',
              enum: ['open', 'closed', 'dismissed', 'fixed'],
              title: 'code-scanning-alert-state'
            }
          }
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        CodeScanningListAlertsForRepoRequest,
        CodeScanningListAlertsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodeScanningListAlertsForRepoHandler>(
            Handlers.CodeScanningListAlertsForRepoHandler
          );

        await controller.codeScanningListAlertsForRepo(req, res, next);
      })
    );
  }

  private addCodeScanningGetAlertHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/code-scanning/alerts/:alert_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            alert_number: { $ref: '#/definitions/alert-number' }
          },
          required: ['owner', 'repo', 'alert_number'],
          definitions: {
            'alert-number': {
              type: 'integer',
              description: 'The security alert number.',
              readOnly: true,
              title: 'alert-number'
            }
          }
        }
      }),

      asyncRequestHandler<
        CodeScanningGetAlertRequest,
        CodeScanningGetAlertResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodeScanningGetAlertHandler>(
            Handlers.CodeScanningGetAlertHandler
          );

        await controller.codeScanningGetAlert(req, res, next);
      })
    );
  }

  private addCodeScanningUpdateAlertHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/code-scanning/alerts/:alert_number',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            state: { $ref: '#/definitions/code-scanning-alert-set-state' },
            dismissed_reason: {
              $ref: '#/definitions/code-scanning-alert-dismissed-reason'
            },
            dismissed_comment: {
              $ref: '#/definitions/code-scanning-alert-dismissed-comment'
            }
          },
          required: ['state'],
          definitions: {
            'code-scanning-alert-set-state': {
              description:
                'Sets the state of the code scanning alert. You must provide `dismissed_reason` when you set the state to `dismissed`.',
              type: 'string',
              enum: ['open', 'dismissed'],
              title: 'code-scanning-alert-set-state'
            },
            'code-scanning-alert-dismissed-reason': {
              type: 'string',
              description:
                '**Required when the state is dismissed.** The reason for dismissing or closing the alert.',
              nullable: true,
              enum: [null, 'false positive', "won't fix", 'used in tests'],
              title: 'code-scanning-alert-dismissed-reason'
            },
            'code-scanning-alert-dismissed-comment': {
              type: 'string',
              description:
                'The dismissal comment associated with the dismissal of the alert.',
              nullable: true,
              maxLength: 280,
              title: 'code-scanning-alert-dismissed-comment'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            alert_number: { $ref: '#/definitions/alert-number' }
          },
          required: ['owner', 'repo', 'alert_number'],
          definitions: {
            'alert-number': {
              type: 'integer',
              description: 'The security alert number.',
              readOnly: true,
              title: 'alert-number'
            }
          }
        }
      }),

      asyncRequestHandler<
        CodeScanningUpdateAlertRequest,
        CodeScanningUpdateAlertResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodeScanningUpdateAlertHandler>(
            Handlers.CodeScanningUpdateAlertHandler
          );

        await controller.codeScanningUpdateAlert(req, res, next);
      })
    );
  }

  private addCodeScanningListAlertInstancesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/code-scanning/alerts/:alert_number/instances',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 },
            ref: { $ref: '#/definitions/code-scanning-ref' }
          },
          required: [],
          definitions: {
            'code-scanning-ref': {
              type: 'string',
              description:
                'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.',
              title: 'code-scanning-ref'
            }
          }
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            alert_number: { $ref: '#/definitions/alert-number' }
          },
          required: ['owner', 'repo', 'alert_number'],
          definitions: {
            'alert-number': {
              type: 'integer',
              description: 'The security alert number.',
              readOnly: true,
              title: 'alert-number'
            }
          }
        }
      }),

      asyncRequestHandler<
        CodeScanningListAlertInstancesRequest,
        CodeScanningListAlertInstancesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodeScanningListAlertInstancesHandler>(
            Handlers.CodeScanningListAlertInstancesHandler
          );

        await controller.codeScanningListAlertInstances(req, res, next);
      })
    );
  }

  private addCodeScanningListRecentAnalysesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/code-scanning/analyses',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            tool_name: {
              $ref: '#/definitions/code-scanning-analysis-tool-name'
            },
            tool_guid: {
              $ref: '#/definitions/code-scanning-analysis-tool-guid'
            },
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 },
            ref: { $ref: '#/definitions/code-scanning-ref' },
            sarif_id: { $ref: '#/definitions/code-scanning-analysis-sarif-id' },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            sort: { type: 'string', enum: ['created'], default: 'created' }
          },
          required: [],
          definitions: {
            'code-scanning-analysis-tool-name': {
              type: 'string',
              description:
                'The name of the tool used to generate the code scanning analysis.',
              title: 'code-scanning-analysis-tool-name'
            },
            'code-scanning-analysis-tool-guid': {
              nullable: true,
              type: 'string',
              description:
                'The GUID of the tool used to generate the code scanning analysis, if provided in the uploaded SARIF data.',
              title: 'code-scanning-analysis-tool-guid'
            },
            'code-scanning-ref': {
              type: 'string',
              description:
                'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.',
              title: 'code-scanning-ref'
            },
            'code-scanning-analysis-sarif-id': {
              type: 'string',
              description: 'An identifier for the upload.',
              example: '6c81cd8e-b078-4ac3-a3be-1dad7dbd0b53',
              title: 'code-scanning-analysis-sarif-id'
            }
          }
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        CodeScanningListRecentAnalysesRequest,
        CodeScanningListRecentAnalysesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodeScanningListRecentAnalysesHandler>(
            Handlers.CodeScanningListRecentAnalysesHandler
          );

        await controller.codeScanningListRecentAnalyses(req, res, next);
      })
    );
  }

  private addCodeScanningGetAnalysisHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/code-scanning/analyses/:analysis_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            analysis_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'analysis_id']
        }
      }),

      asyncRequestHandler<
        CodeScanningGetAnalysisRequest,
        CodeScanningGetAnalysisResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodeScanningGetAnalysisHandler>(
            Handlers.CodeScanningGetAnalysisHandler
          );

        await controller.codeScanningGetAnalysis(req, res, next);
      })
    );
  }

  private addCodeScanningDeleteAnalysisHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/code-scanning/analyses/:analysis_id',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { confirm_delete: { type: 'string', nullable: true } },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            analysis_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'analysis_id']
        }
      }),

      asyncRequestHandler<
        CodeScanningDeleteAnalysisRequest,
        CodeScanningDeleteAnalysisResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodeScanningDeleteAnalysisHandler>(
            Handlers.CodeScanningDeleteAnalysisHandler
          );

        await controller.codeScanningDeleteAnalysis(req, res, next);
      })
    );
  }

  private addCodeScanningListCodeqlDatabasesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/code-scanning/codeql/databases',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        CodeScanningListCodeqlDatabasesRequest,
        CodeScanningListCodeqlDatabasesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodeScanningListCodeqlDatabasesHandler>(
            Handlers.CodeScanningListCodeqlDatabasesHandler
          );

        await controller.codeScanningListCodeqlDatabases(req, res, next);
      })
    );
  }

  private addCodeScanningGetCodeqlDatabaseHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/code-scanning/codeql/databases/:language',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            language: { type: 'string' }
          },
          required: ['owner', 'repo', 'language']
        }
      }),

      asyncRequestHandler<
        CodeScanningGetCodeqlDatabaseRequest,
        CodeScanningGetCodeqlDatabaseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodeScanningGetCodeqlDatabaseHandler>(
            Handlers.CodeScanningGetCodeqlDatabaseHandler
          );

        await controller.codeScanningGetCodeqlDatabase(req, res, next);
      })
    );
  }

  private addCodeScanningUploadSarifHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/code-scanning/sarifs',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            commit_sha: {
              $ref: '#/definitions/code-scanning-analysis-commit-sha'
            },
            ref: { $ref: '#/definitions/code-scanning-ref' },
            sarif: { $ref: '#/definitions/code-scanning-analysis-sarif-file' },
            checkout_uri: {
              description:
                'The base directory used in the analysis, as it appears in the SARIF file.\nThis property is used to convert file paths from absolute to relative, so that alerts can be mapped to their correct location in the repository.',
              example: 'file:///github/workspace/',
              type: 'string',
              format: 'uri'
            },
            started_at: {
              description:
                'The time that the analysis run began. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.',
              format: 'date-time',
              type: 'string'
            },
            tool_name: {
              description:
                'The name of the tool used to generate the code scanning analysis. If this parameter is not used, the tool name defaults to "API". If the uploaded SARIF contains a tool GUID, this will be available for filtering using the `tool_guid` parameter of operations such as `GET /repos/{owner}/{repo}/code-scanning/alerts`.',
              type: 'string'
            },
            validate: {
              description:
                'Whether the SARIF file will be validated according to the code scanning specifications.\nThis parameter is intended to help integrators ensure that the uploaded SARIF files are correctly rendered by code scanning.',
              type: 'boolean'
            }
          },
          required: ['commit_sha', 'ref', 'sarif'],
          definitions: {
            'code-scanning-analysis-commit-sha': {
              description:
                'The SHA of the commit to which the analysis you are uploading relates.',
              type: 'string',
              minLength: 40,
              maxLength: 40,
              pattern: '^[0-9a-fA-F]+$',
              title: 'code-scanning-analysis-commit-sha'
            },
            'code-scanning-ref': {
              type: 'string',
              description:
                'The full Git reference, formatted as `refs/heads/<branch name>`,\n`refs/pull/<number>/merge`, or `refs/pull/<number>/head`.',
              title: 'code-scanning-ref'
            },
            'code-scanning-analysis-sarif-file': {
              description:
                'A Base64 string representing the SARIF file to upload. You must first compress your SARIF file using [`gzip`](http://www.gnu.org/software/gzip/manual/gzip.html) and then translate the contents of the file into a Base64 encoding string. For more information, see "[SARIF support for code scanning](https://docs.github.com/code-security/secure-coding/sarif-support-for-code-scanning)."',
              type: 'string',
              title: 'code-scanning-analysis-sarif-file'
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        CodeScanningUploadSarifRequest,
        CodeScanningUploadSarifResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodeScanningUploadSarifHandler>(
            Handlers.CodeScanningUploadSarifHandler
          );

        await controller.codeScanningUploadSarif(req, res, next);
      })
    );
  }

  private addCodeScanningGetSarifHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/code-scanning/sarifs/:sarif_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            sarif_id: { type: 'string' }
          },
          required: ['owner', 'repo', 'sarif_id']
        }
      }),

      asyncRequestHandler<
        CodeScanningGetSarifRequest,
        CodeScanningGetSarifResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodeScanningGetSarifHandler>(
            Handlers.CodeScanningGetSarifHandler
          );

        await controller.codeScanningGetSarif(req, res, next);
      })
    );
  }

  private addReposCodeownersErrorsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/codeowners/errors',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { ref: { type: 'string' } },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposCodeownersErrorsRequest,
        ReposCodeownersErrorsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCodeownersErrorsHandler>(
            Handlers.ReposCodeownersErrorsHandler
          );

        await controller.reposCodeownersErrors(req, res, next);
      })
    );
  }

  private addCodespacesListInRepositoryForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/codespaces',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        CodespacesListInRepositoryForAuthenticatedUserRequest,
        CodespacesListInRepositoryForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesListInRepositoryForAuthenticatedUserHandler>(
            Handlers.CodespacesListInRepositoryForAuthenticatedUserHandler
          );

        await controller.codespacesListInRepositoryForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesCreateWithRepoForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.post(
      '/repos/:owner/:repo/codespaces',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          nullable: true,
          properties: {
            ref: {
              description:
                'Git ref (typically a branch name) for this codespace',
              type: 'string'
            },
            location: {
              description:
                'Location for this codespace. Assigned by IP if not provided',
              type: 'string'
            },
            client_ip: {
              description:
                'IP for location auto-detection when proxying a request',
              type: 'string'
            },
            machine: {
              description: 'Machine type to use for this codespace',
              type: 'string'
            },
            devcontainer_path: {
              description:
                'Path to devcontainer.json config to use for this codespace',
              type: 'string'
            },
            multi_repo_permissions_opt_out: {
              description:
                'Whether to authorize requested permissions from devcontainer.json',
              type: 'boolean'
            },
            working_directory: {
              description: 'Working directory for this codespace',
              type: 'string'
            },
            idle_timeout_minutes: {
              description:
                'Time in minutes before codespace stops from inactivity',
              type: 'integer'
            },
            display_name: {
              description: 'Display name for this codespace',
              type: 'string'
            },
            retention_period_minutes: {
              description:
                'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).',
              type: 'integer'
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        CodespacesCreateWithRepoForAuthenticatedUserRequest,
        CodespacesCreateWithRepoForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesCreateWithRepoForAuthenticatedUserHandler>(
            Handlers.CodespacesCreateWithRepoForAuthenticatedUserHandler
          );

        await controller.codespacesCreateWithRepoForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesListDevcontainersInRepositoryForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/codespaces/devcontainers',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        CodespacesListDevcontainersInRepositoryForAuthenticatedUserRequest,
        CodespacesListDevcontainersInRepositoryForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesListDevcontainersInRepositoryForAuthenticatedUserHandler>(
            Handlers.CodespacesListDevcontainersInRepositoryForAuthenticatedUserHandler
          );

        await controller.codespacesListDevcontainersInRepositoryForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesRepoMachinesForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/codespaces/machines',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            location: { type: 'string', example: 'WestUs2' },
            client_ip: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        CodespacesRepoMachinesForAuthenticatedUserRequest,
        CodespacesRepoMachinesForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesRepoMachinesForAuthenticatedUserHandler>(
            Handlers.CodespacesRepoMachinesForAuthenticatedUserHandler
          );

        await controller.codespacesRepoMachinesForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesPreFlightWithRepoForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/codespaces/new',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            ref: { type: 'string', example: 'main' },
            client_ip: { type: 'string', example: '1.2.3.4' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        CodespacesPreFlightWithRepoForAuthenticatedUserRequest,
        CodespacesPreFlightWithRepoForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesPreFlightWithRepoForAuthenticatedUserHandler>(
            Handlers.CodespacesPreFlightWithRepoForAuthenticatedUserHandler
          );

        await controller.codespacesPreFlightWithRepoForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesListRepoSecretsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/codespaces/secrets',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        CodespacesListRepoSecretsRequest,
        CodespacesListRepoSecretsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesListRepoSecretsHandler>(
            Handlers.CodespacesListRepoSecretsHandler
          );

        await controller.codespacesListRepoSecrets(req, res, next);
      })
    );
  }

  private addCodespacesGetRepoPublicKeyHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/codespaces/secrets/public-key',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        CodespacesGetRepoPublicKeyRequest,
        CodespacesGetRepoPublicKeyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesGetRepoPublicKeyHandler>(
            Handlers.CodespacesGetRepoPublicKeyHandler
          );

        await controller.codespacesGetRepoPublicKey(req, res, next);
      })
    );
  }

  private addCodespacesGetRepoSecretHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/codespaces/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'secret_name']
        }
      }),

      asyncRequestHandler<
        CodespacesGetRepoSecretRequest,
        CodespacesGetRepoSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesGetRepoSecretHandler>(
            Handlers.CodespacesGetRepoSecretHandler
          );

        await controller.codespacesGetRepoSecret(req, res, next);
      })
    );
  }

  private addCodespacesCreateOrUpdateRepoSecretHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/codespaces/secrets/:secret_name',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            encrypted_value: {
              type: 'string',
              description:
                'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/reference/codespaces#get-a-repository-public-key) endpoint.',
              pattern:
                '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
            },
            key_id: {
              type: 'string',
              description: 'ID of the key you used to encrypt the secret.'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'secret_name']
        }
      }),

      asyncRequestHandler<
        CodespacesCreateOrUpdateRepoSecretRequest,
        CodespacesCreateOrUpdateRepoSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesCreateOrUpdateRepoSecretHandler>(
            Handlers.CodespacesCreateOrUpdateRepoSecretHandler
          );

        await controller.codespacesCreateOrUpdateRepoSecret(req, res, next);
      })
    );
  }

  private addCodespacesDeleteRepoSecretHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/codespaces/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'secret_name']
        }
      }),

      asyncRequestHandler<
        CodespacesDeleteRepoSecretRequest,
        CodespacesDeleteRepoSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesDeleteRepoSecretHandler>(
            Handlers.CodespacesDeleteRepoSecretHandler
          );

        await controller.codespacesDeleteRepoSecret(req, res, next);
      })
    );
  }

  private addReposListCollaboratorsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/collaborators',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            affiliation: {
              type: 'string',
              enum: ['outside', 'direct', 'all'],
              default: 'all'
            },
            permission: {
              type: 'string',
              enum: ['pull', 'triage', 'push', 'maintain', 'admin']
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposListCollaboratorsRequest,
        ReposListCollaboratorsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListCollaboratorsHandler>(
            Handlers.ReposListCollaboratorsHandler
          );

        await controller.reposListCollaborators(req, res, next);
      })
    );
  }

  private addReposCheckCollaboratorHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/collaborators/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            username: { type: 'string' }
          },
          required: ['owner', 'repo', 'username']
        }
      }),

      asyncRequestHandler<
        ReposCheckCollaboratorRequest,
        ReposCheckCollaboratorResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCheckCollaboratorHandler>(
            Handlers.ReposCheckCollaboratorHandler
          );

        await controller.reposCheckCollaborator(req, res, next);
      })
    );
  }

  private addReposAddCollaboratorHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/collaborators/:username',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            permission: {
              type: 'string',
              description:
                'The permission to grant the collaborator. **Only valid on organization-owned repositories.** We accept the following permissions to be set: `pull`, `triage`, `push`, `maintain`, `admin` and you can also specify a custom repository role name, if the owning organization has defined any.',
              default: 'push'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            username: { type: 'string' }
          },
          required: ['owner', 'repo', 'username']
        }
      }),

      asyncRequestHandler<
        ReposAddCollaboratorRequest,
        ReposAddCollaboratorResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposAddCollaboratorHandler>(
            Handlers.ReposAddCollaboratorHandler
          );

        await controller.reposAddCollaborator(req, res, next);
      })
    );
  }

  private addReposRemoveCollaboratorHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/collaborators/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            username: { type: 'string' }
          },
          required: ['owner', 'repo', 'username']
        }
      }),

      asyncRequestHandler<
        ReposRemoveCollaboratorRequest,
        ReposRemoveCollaboratorResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposRemoveCollaboratorHandler>(
            Handlers.ReposRemoveCollaboratorHandler
          );

        await controller.reposRemoveCollaborator(req, res, next);
      })
    );
  }

  private addReposGetCollaboratorPermissionLevelHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/collaborators/:username/permission',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            username: { type: 'string' }
          },
          required: ['owner', 'repo', 'username']
        }
      }),

      asyncRequestHandler<
        ReposGetCollaboratorPermissionLevelRequest,
        ReposGetCollaboratorPermissionLevelResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetCollaboratorPermissionLevelHandler>(
            Handlers.ReposGetCollaboratorPermissionLevelHandler
          );

        await controller.reposGetCollaboratorPermissionLevel(req, res, next);
      })
    );
  }

  private addReposListCommitCommentsForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/comments',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposListCommitCommentsForRepoRequest,
        ReposListCommitCommentsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListCommitCommentsForRepoHandler>(
            Handlers.ReposListCommitCommentsForRepoHandler
          );

        await controller.reposListCommitCommentsForRepo(req, res, next);
      })
    );
  }

  private addReposGetCommitCommentHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/comments/:comment_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        ReposGetCommitCommentRequest,
        ReposGetCommitCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetCommitCommentHandler>(
            Handlers.ReposGetCommitCommentHandler
          );

        await controller.reposGetCommitComment(req, res, next);
      })
    );
  }

  private addReposUpdateCommitCommentHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/comments/:comment_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            body: { type: 'string', description: 'The contents of the comment' }
          },
          required: ['body']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        ReposUpdateCommitCommentRequest,
        ReposUpdateCommitCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposUpdateCommitCommentHandler>(
            Handlers.ReposUpdateCommitCommentHandler
          );

        await controller.reposUpdateCommitComment(req, res, next);
      })
    );
  }

  private addReposDeleteCommitCommentHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/comments/:comment_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        ReposDeleteCommitCommentRequest,
        ReposDeleteCommitCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteCommitCommentHandler>(
            Handlers.ReposDeleteCommitCommentHandler
          );

        await controller.reposDeleteCommitComment(req, res, next);
      })
    );
  }

  private addReactionsListForCommitCommentHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/comments/:comment_id/reactions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        ReactionsListForCommitCommentRequest,
        ReactionsListForCommitCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsListForCommitCommentHandler>(
            Handlers.ReactionsListForCommitCommentHandler
          );

        await controller.reactionsListForCommitComment(req, res, next);
      })
    );
  }

  private addReactionsCreateForCommitCommentHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/comments/:comment_id/reactions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              description:
                'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the commit comment.',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            }
          },
          required: ['content']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        ReactionsCreateForCommitCommentRequest,
        ReactionsCreateForCommitCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsCreateForCommitCommentHandler>(
            Handlers.ReactionsCreateForCommitCommentHandler
          );

        await controller.reactionsCreateForCommitComment(req, res, next);
      })
    );
  }

  private addReactionsDeleteForCommitCommentHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/comments/:comment_id/reactions/:reaction_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' },
            reaction_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id', 'reaction_id']
        }
      }),

      asyncRequestHandler<
        ReactionsDeleteForCommitCommentRequest,
        ReactionsDeleteForCommitCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsDeleteForCommitCommentHandler>(
            Handlers.ReactionsDeleteForCommitCommentHandler
          );

        await controller.reactionsDeleteForCommitComment(req, res, next);
      })
    );
  }

  private addReposListCommitsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/commits',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            sha: { type: 'string' },
            path: { type: 'string' },
            author: { type: 'string' },
            since: { type: 'string', format: 'date-time' },
            until: { type: 'string', format: 'date-time' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposListCommitsRequest, ReposListCommitsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposListCommitsHandler>(Handlers.ReposListCommitsHandler);

          await controller.reposListCommits(req, res, next);
        }
      )
    );
  }

  private addReposListBranchesForHeadCommitHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/commits/:commit_sha/branches-where-head',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            commit_sha: { type: 'string' }
          },
          required: ['owner', 'repo', 'commit_sha']
        }
      }),

      asyncRequestHandler<
        ReposListBranchesForHeadCommitRequest,
        ReposListBranchesForHeadCommitResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListBranchesForHeadCommitHandler>(
            Handlers.ReposListBranchesForHeadCommitHandler
          );

        await controller.reposListBranchesForHeadCommit(req, res, next);
      })
    );
  }

  private addReposListCommentsForCommitHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/commits/:commit_sha/comments',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            commit_sha: { type: 'string' }
          },
          required: ['owner', 'repo', 'commit_sha']
        }
      }),

      asyncRequestHandler<
        ReposListCommentsForCommitRequest,
        ReposListCommentsForCommitResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListCommentsForCommitHandler>(
            Handlers.ReposListCommentsForCommitHandler
          );

        await controller.reposListCommentsForCommit(req, res, next);
      })
    );
  }

  private addReposCreateCommitCommentHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/commits/:commit_sha/comments',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
              description: 'The contents of the comment.'
            },
            path: {
              type: 'string',
              description: 'Relative path of the file to comment on.'
            },
            position: {
              type: 'integer',
              description: 'Line index in the diff to comment on.'
            },
            line: {
              type: 'integer',
              description:
                '**Deprecated**. Use **position** parameter instead. Line number in the file to comment on.'
            }
          },
          required: ['body']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            commit_sha: { type: 'string' }
          },
          required: ['owner', 'repo', 'commit_sha']
        }
      }),

      asyncRequestHandler<
        ReposCreateCommitCommentRequest,
        ReposCreateCommitCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateCommitCommentHandler>(
            Handlers.ReposCreateCommitCommentHandler
          );

        await controller.reposCreateCommitComment(req, res, next);
      })
    );
  }

  private addReposListPullRequestsAssociatedWithCommitHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/commits/:commit_sha/pulls',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            commit_sha: { type: 'string' }
          },
          required: ['owner', 'repo', 'commit_sha']
        }
      }),

      asyncRequestHandler<
        ReposListPullRequestsAssociatedWithCommitRequest,
        ReposListPullRequestsAssociatedWithCommitResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListPullRequestsAssociatedWithCommitHandler>(
            Handlers.ReposListPullRequestsAssociatedWithCommitHandler
          );

        await controller.reposListPullRequestsAssociatedWithCommit(
          req,
          res,
          next
        );
      })
    );
  }

  private addReposGetCommitHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/commits/:ref',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            ref: { type: 'string' }
          },
          required: ['owner', 'repo', 'ref']
        }
      }),

      asyncRequestHandler<ReposGetCommitRequest, ReposGetCommitResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetCommitHandler>(Handlers.ReposGetCommitHandler);

          await controller.reposGetCommit(req, res, next);
        }
      )
    );
  }

  private addChecksListForRefHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/commits/:ref/check-runs',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            check_name: { type: 'string' },
            status: {
              type: 'string',
              enum: ['queued', 'in_progress', 'completed']
            },
            filter: {
              type: 'string',
              enum: ['latest', 'all'],
              default: 'latest'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 },
            app_id: { type: 'integer' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            ref: { type: 'string' }
          },
          required: ['owner', 'repo', 'ref']
        }
      }),

      asyncRequestHandler<ChecksListForRefRequest, ChecksListForRefResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ChecksListForRefHandler>(Handlers.ChecksListForRefHandler);

          await controller.checksListForRef(req, res, next);
        }
      )
    );
  }

  private addChecksListSuitesForRefHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/commits/:ref/check-suites',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            app_id: { type: 'integer' },
            check_name: { type: 'string' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            ref: { type: 'string' }
          },
          required: ['owner', 'repo', 'ref']
        }
      }),

      asyncRequestHandler<
        ChecksListSuitesForRefRequest,
        ChecksListSuitesForRefResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ChecksListSuitesForRefHandler>(
            Handlers.ChecksListSuitesForRefHandler
          );

        await controller.checksListSuitesForRef(req, res, next);
      })
    );
  }

  private addReposGetCombinedStatusForRefHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/commits/:ref/status',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            ref: { type: 'string' }
          },
          required: ['owner', 'repo', 'ref']
        }
      }),

      asyncRequestHandler<
        ReposGetCombinedStatusForRefRequest,
        ReposGetCombinedStatusForRefResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetCombinedStatusForRefHandler>(
            Handlers.ReposGetCombinedStatusForRefHandler
          );

        await controller.reposGetCombinedStatusForRef(req, res, next);
      })
    );
  }

  private addReposListCommitStatusesForRefHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/commits/:ref/statuses',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            ref: { type: 'string' }
          },
          required: ['owner', 'repo', 'ref']
        }
      }),

      asyncRequestHandler<
        ReposListCommitStatusesForRefRequest,
        ReposListCommitStatusesForRefResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListCommitStatusesForRefHandler>(
            Handlers.ReposListCommitStatusesForRefHandler
          );

        await controller.reposListCommitStatusesForRef(req, res, next);
      })
    );
  }

  private addReposGetCommunityProfileMetricsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/community/profile',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposGetCommunityProfileMetricsRequest,
        ReposGetCommunityProfileMetricsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetCommunityProfileMetricsHandler>(
            Handlers.ReposGetCommunityProfileMetricsHandler
          );

        await controller.reposGetCommunityProfileMetrics(req, res, next);
      })
    );
  }

  private addReposCompareCommitsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/compare/:basehead',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            basehead: { type: 'string' }
          },
          required: ['owner', 'repo', 'basehead']
        }
      }),

      asyncRequestHandler<
        ReposCompareCommitsRequest,
        ReposCompareCommitsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCompareCommitsHandler>(
            Handlers.ReposCompareCommitsHandler
          );

        await controller.reposCompareCommits(req, res, next);
      })
    );
  }

  private addReposGetContentHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/contents/:path',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { ref: { type: 'string' } },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            path: { type: 'string' }
          },
          required: ['owner', 'repo', 'path']
        }
      }),

      asyncRequestHandler<ReposGetContentRequest, ReposGetContentResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetContentHandler>(Handlers.ReposGetContentHandler);

          await controller.reposGetContent(req, res, next);
        }
      )
    );
  }

  private addReposCreateOrUpdateFileContentsHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/contents/:path',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            message: { type: 'string', description: 'The commit message.' },
            content: {
              type: 'string',
              description: 'The new file content, using Base64 encoding.'
            },
            sha: {
              type: 'string',
              description:
                '**Required if you are updating a file**. The blob SHA of the file being replaced.'
            },
            branch: {
              type: 'string',
              description:
                'The branch name. Default: the repositorys default branch (usually `master`)'
            },
            committer: {
              type: 'object',
              description:
                'The person that committed the file. Default: the authenticated user.',
              properties: {
                name: {
                  type: 'string',
                  description:
                    "The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted."
                },
                email: {
                  type: 'string',
                  description:
                    "The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted."
                },
                date: { type: 'string', example: '"2013-01-05T13:13:22+05:00"' }
              },
              required: ['name', 'email']
            },
            author: {
              type: 'object',
              description:
                'The author of the file. Default: The `committer` or the authenticated user if you omit `committer`.',
              properties: {
                name: {
                  type: 'string',
                  description:
                    "The name of the author or committer of the commit. You'll receive a `422` status code if `name` is omitted."
                },
                email: {
                  type: 'string',
                  description:
                    "The email of the author or committer of the commit. You'll receive a `422` status code if `email` is omitted."
                },
                date: { type: 'string', example: '"2013-01-15T17:13:22+05:00"' }
              },
              required: ['name', 'email']
            }
          },
          required: ['message', 'content']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            path: { type: 'string' }
          },
          required: ['owner', 'repo', 'path']
        }
      }),

      asyncRequestHandler<
        ReposCreateOrUpdateFileContentsRequest,
        ReposCreateOrUpdateFileContentsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateOrUpdateFileContentsHandler>(
            Handlers.ReposCreateOrUpdateFileContentsHandler
          );

        await controller.reposCreateOrUpdateFileContents(req, res, next);
      })
    );
  }

  private addReposDeleteFileHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/contents/:path',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            message: { type: 'string', description: 'The commit message.' },
            sha: {
              type: 'string',
              description: 'The blob SHA of the file being deleted.'
            },
            branch: {
              type: 'string',
              description:
                'The branch name. Default: the repositorys default branch (usually `master`)'
            },
            committer: {
              type: 'object',
              description: 'object containing information about the committer.',
              properties: {
                name: {
                  type: 'string',
                  description:
                    'The name of the author (or committer) of the commit'
                },
                email: {
                  type: 'string',
                  description:
                    'The email of the author (or committer) of the commit'
                }
              }
            },
            author: {
              type: 'object',
              description: 'object containing information about the author.',
              properties: {
                name: {
                  type: 'string',
                  description:
                    'The name of the author (or committer) of the commit'
                },
                email: {
                  type: 'string',
                  description:
                    'The email of the author (or committer) of the commit'
                }
              }
            }
          },
          required: ['message', 'sha']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            path: { type: 'string' }
          },
          required: ['owner', 'repo', 'path']
        }
      }),

      asyncRequestHandler<ReposDeleteFileRequest, ReposDeleteFileResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposDeleteFileHandler>(Handlers.ReposDeleteFileHandler);

          await controller.reposDeleteFile(req, res, next);
        }
      )
    );
  }

  private addReposListContributorsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/contributors',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            anon: { type: 'string' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposListContributorsRequest,
        ReposListContributorsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListContributorsHandler>(
            Handlers.ReposListContributorsHandler
          );

        await controller.reposListContributors(req, res, next);
      })
    );
  }

  private addDependabotListAlertsForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/dependabot/alerts',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            state: { type: 'string' },
            severity: { type: 'string' },
            ecosystem: { type: 'string' },
            package: { type: 'string' },
            manifest: { type: 'string' },
            scope: { type: 'string', enum: ['development', 'runtime'] },
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 },
            before: { type: 'string' },
            after: { type: 'string' },
            first: { type: 'integer', minimum: 1, maximum: 100, default: 30 },
            last: { type: 'integer', minimum: 1, maximum: 100 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        DependabotListAlertsForRepoRequest,
        DependabotListAlertsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotListAlertsForRepoHandler>(
            Handlers.DependabotListAlertsForRepoHandler
          );

        await controller.dependabotListAlertsForRepo(req, res, next);
      })
    );
  }

  private addDependabotGetAlertHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/dependabot/alerts/:alert_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            alert_number: { $ref: '#/definitions/alert-number' }
          },
          required: ['owner', 'repo', 'alert_number'],
          definitions: {
            'alert-number': {
              type: 'integer',
              description: 'The security alert number.',
              readOnly: true,
              title: 'alert-number'
            }
          }
        }
      }),

      asyncRequestHandler<
        DependabotGetAlertRequest,
        DependabotGetAlertResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotGetAlertHandler>(
            Handlers.DependabotGetAlertHandler
          );

        await controller.dependabotGetAlert(req, res, next);
      })
    );
  }

  private addDependabotUpdateAlertHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/dependabot/alerts/:alert_number',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            state: {
              type: 'string',
              description:
                'The state of the Dependabot alert.\nA `dismissed_reason` must be provided when setting the state to `dismissed`.',
              enum: ['dismissed', 'open']
            },
            dismissed_reason: {
              type: 'string',
              description:
                '**Required when `state` is `dismissed`.** A reason for dismissing the alert.',
              enum: [
                'fix_started',
                'inaccurate',
                'no_bandwidth',
                'not_used',
                'tolerable_risk'
              ]
            },
            dismissed_comment: {
              type: 'string',
              description:
                'An optional comment associated with dismissing the alert.',
              maxLength: 280
            }
          },
          required: ['state'],
          additionalProperties: false
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            alert_number: { $ref: '#/definitions/alert-number' }
          },
          required: ['owner', 'repo', 'alert_number'],
          definitions: {
            'alert-number': {
              type: 'integer',
              description: 'The security alert number.',
              readOnly: true,
              title: 'alert-number'
            }
          }
        }
      }),

      asyncRequestHandler<
        DependabotUpdateAlertRequest,
        DependabotUpdateAlertResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotUpdateAlertHandler>(
            Handlers.DependabotUpdateAlertHandler
          );

        await controller.dependabotUpdateAlert(req, res, next);
      })
    );
  }

  private addDependabotListRepoSecretsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/dependabot/secrets',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        DependabotListRepoSecretsRequest,
        DependabotListRepoSecretsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotListRepoSecretsHandler>(
            Handlers.DependabotListRepoSecretsHandler
          );

        await controller.dependabotListRepoSecrets(req, res, next);
      })
    );
  }

  private addDependabotGetRepoPublicKeyHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/dependabot/secrets/public-key',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        DependabotGetRepoPublicKeyRequest,
        DependabotGetRepoPublicKeyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotGetRepoPublicKeyHandler>(
            Handlers.DependabotGetRepoPublicKeyHandler
          );

        await controller.dependabotGetRepoPublicKey(req, res, next);
      })
    );
  }

  private addDependabotGetRepoSecretHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/dependabot/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'secret_name']
        }
      }),

      asyncRequestHandler<
        DependabotGetRepoSecretRequest,
        DependabotGetRepoSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotGetRepoSecretHandler>(
            Handlers.DependabotGetRepoSecretHandler
          );

        await controller.dependabotGetRepoSecret(req, res, next);
      })
    );
  }

  private addDependabotCreateOrUpdateRepoSecretHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/dependabot/secrets/:secret_name',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            encrypted_value: {
              type: 'string',
              description:
                'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get a repository public key](https://docs.github.com/rest/reference/dependabot#get-a-repository-public-key) endpoint.',
              pattern:
                '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
            },
            key_id: {
              type: 'string',
              description: 'ID of the key you used to encrypt the secret.'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'secret_name']
        }
      }),

      asyncRequestHandler<
        DependabotCreateOrUpdateRepoSecretRequest,
        DependabotCreateOrUpdateRepoSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotCreateOrUpdateRepoSecretHandler>(
            Handlers.DependabotCreateOrUpdateRepoSecretHandler
          );

        await controller.dependabotCreateOrUpdateRepoSecret(req, res, next);
      })
    );
  }

  private addDependabotDeleteRepoSecretHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/dependabot/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'secret_name']
        }
      }),

      asyncRequestHandler<
        DependabotDeleteRepoSecretRequest,
        DependabotDeleteRepoSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependabotDeleteRepoSecretHandler>(
            Handlers.DependabotDeleteRepoSecretHandler
          );

        await controller.dependabotDeleteRepoSecret(req, res, next);
      })
    );
  }

  private addDependencyGraphDiffRangeHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/dependency-graph/compare/:basehead',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { name: { type: 'string' } },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            basehead: { type: 'string' }
          },
          required: ['owner', 'repo', 'basehead']
        }
      }),

      asyncRequestHandler<
        DependencyGraphDiffRangeRequest,
        DependencyGraphDiffRangeResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependencyGraphDiffRangeHandler>(
            Handlers.DependencyGraphDiffRangeHandler
          );

        await controller.dependencyGraphDiffRange(req, res, next);
      })
    );
  }

  private addDependencyGraphCreateRepositorySnapshotHandler(
    router: Router
  ): void {
    router.post(
      '/repos/:owner/:repo/dependency-graph/snapshots',

      ControllerMiddleware.validate({
        body: {
          $ref: '#/definitions/snapshot',
          definitions: {
            snapshot: {
              title: 'snapshot',
              description:
                "Create a new snapshot of a repository's dependencies.",
              type: 'object',
              properties: {
                version: {
                  description:
                    'The version of the repository snapshot submission.',
                  type: 'integer'
                },
                job: {
                  type: 'object',
                  properties: {
                    id: {
                      type: 'string',
                      description: 'The external ID of the job.',
                      example: '5622a2b0-63f6-4732-8c34-a1ab27e102a11'
                    },
                    correlator: {
                      type: 'string',
                      description:
                        'Correlator provides a key that is used to group snapshots submitted over time. Only the "latest" submitted snapshot for a given combination of `job.correlator` and `detector.name` will be considered when calculating a repository\'s current dependencies. Correlator should be as unique as it takes to distinguish all detection runs for a given "wave" of CI workflow you run. If you\'re using GitHub Actions, a good default value for this could be the environment variables GITHUB_WORKFLOW and GITHUB_JOB concatenated together. If you\'re using a build matrix, then you\'ll also need to add additional key(s) to distinguish between each submission inside a matrix variation.',
                      example: 'yourworkflowname_yourjobname'
                    },
                    html_url: {
                      type: 'string',
                      description: 'The url for the job.',
                      example: 'http://example.com/build'
                    }
                  },
                  required: ['id', 'correlator'],
                  additionalProperties: false
                },
                sha: {
                  description:
                    'The commit SHA associated with this dependency snapshot.',
                  type: 'string',
                  example: 'ddc951f4b1293222421f2c8df679786153acf689',
                  minLength: 40
                },
                ref: {
                  description:
                    'The repository branch that triggered this snapshot.',
                  type: 'string',
                  pattern: '^refs/',
                  example: 'refs/heads/main'
                },
                detector: {
                  type: 'object',
                  description: 'A description of the detector used.',
                  properties: {
                    name: {
                      type: 'string',
                      description: 'The name of the detector used.',
                      example: 'docker buildtime detector'
                    },
                    version: {
                      type: 'string',
                      description: 'The version of the detector used.',
                      example: '1.0.0'
                    },
                    url: {
                      type: 'string',
                      description: 'The url of the detector used.',
                      example: 'http://example.com/docker-buildtimer-detector'
                    }
                  },
                  required: ['name', 'version', 'url'],
                  additionalProperties: false
                },
                metadata: { $ref: '#/definitions/metadata' },
                manifests: {
                  type: 'object',
                  description:
                    'A collection of package manifests, which are a collection of related dependencies declared in a file or representing a logical group of dependencies.',
                  additionalProperties: { $ref: '#/definitions/manifest' }
                },
                scanned: {
                  type: 'string',
                  format: 'date-time',
                  description: 'The time at which the snapshot was scanned.',
                  example: '2020-06-13T14:52:50-05:00'
                }
              },
              required: ['detector', 'version', 'ref', 'sha', 'job', 'scanned'],
              additionalProperties: false
            },
            metadata: {
              title: 'metadata',
              description:
                'User-defined metadata to store domain-specific information limited to 8 keys with scalar values.',
              type: 'object',
              maxProperties: 8,
              additionalProperties: {
                nullable: true,
                anyOf: [
                  { type: 'string' },
                  { type: 'number' },
                  { type: 'boolean' }
                ]
              }
            },
            manifest: {
              type: 'object',
              properties: {
                name: {
                  type: 'string',
                  description: 'The name of the manifest.',
                  example: 'package-lock.json'
                },
                file: {
                  type: 'object',
                  properties: {
                    source_location: {
                      type: 'string',
                      description:
                        'The path of the manifest file relative to the root of the Git repository.',
                      example: '/src/build/package-lock.json'
                    }
                  },
                  additionalProperties: false
                },
                metadata: { $ref: '#/definitions/metadata' },
                resolved: {
                  type: 'object',
                  description: 'A collection of resolved package dependencies.',
                  additionalProperties: { $ref: '#/definitions/dependency' }
                }
              },
              required: ['name'],
              additionalProperties: false,
              title: 'manifest'
            },
            dependency: {
              type: 'object',
              properties: {
                package_url: {
                  type: 'string',
                  description:
                    'Package-url (PURL) of dependency. See https://github.com/package-url/purl-spec for more details.',
                  example: 'pkg:/npm/%40actions/http-client@1.0.11',
                  pattern: '^pkg'
                },
                metadata: { $ref: '#/definitions/metadata' },
                relationship: {
                  type: 'string',
                  description:
                    'A notation of whether a dependency is requested directly by this manifest or is a dependency of another dependency.',
                  example: 'direct',
                  enum: ['direct', 'indirect']
                },
                scope: {
                  type: 'string',
                  description:
                    'A notation of whether the dependency is required for the primary build artifact (runtime) or is only used for development. Future versions of this specification may allow for more granular scopes.',
                  example: 'runtime',
                  enum: ['runtime', 'development']
                },
                dependencies: {
                  type: 'array',
                  description:
                    'Array of package-url (PURLs) of direct child dependencies.',
                  example: '@actions/http-client',
                  items: { type: 'string' }
                }
              },
              additionalProperties: false,
              title: 'dependency'
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        DependencyGraphCreateRepositorySnapshotRequest,
        DependencyGraphCreateRepositorySnapshotResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<DependencyGraphCreateRepositorySnapshotHandler>(
            Handlers.DependencyGraphCreateRepositorySnapshotHandler
          );

        await controller.dependencyGraphCreateRepositorySnapshot(
          req,
          res,
          next
        );
      })
    );
  }

  private addReposListDeploymentsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/deployments',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            sha: { type: 'string', default: 'none' },
            ref: { type: 'string', default: 'none' },
            task: { type: 'string', default: 'none' },
            environment: { type: 'string', default: 'none', nullable: true },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposListDeploymentsRequest,
        ReposListDeploymentsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListDeploymentsHandler>(
            Handlers.ReposListDeploymentsHandler
          );

        await controller.reposListDeployments(req, res, next);
      })
    );
  }

  private addReposCreateDeploymentHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/deployments',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            ref: {
              type: 'string',
              description:
                'The ref to deploy. This can be a branch, tag, or SHA.'
            },
            task: {
              type: 'string',
              description:
                'Specifies a task to execute (e.g., `deploy` or `deploy:migrations`).',
              default: 'deploy'
            },
            auto_merge: {
              type: 'boolean',
              description:
                "Attempts to automatically merge the default branch into the requested ref, if it's behind the default branch.",
              default: true
            },
            required_contexts: {
              type: 'array',
              description:
                'The [status](https://docs.github.com/rest/commits/statuses) contexts to verify against commit status checks. If you omit this parameter, GitHub verifies all unique contexts before creating a deployment. To bypass checking entirely, pass an empty array. Defaults to all unique contexts.',
              items: { type: 'string' }
            },
            payload: {
              oneOf: [
                { type: 'object', additionalProperties: true },
                {
                  type: 'string',
                  description:
                    'JSON payload with extra information about the deployment.',
                  default: ''
                }
              ]
            },
            environment: {
              type: 'string',
              description:
                'Name for the target deployment environment (e.g., `production`, `staging`, `qa`).',
              default: 'production'
            },
            description: {
              type: 'string',
              description: 'Short description of the deployment.',
              default: '',
              nullable: true
            },
            transient_environment: {
              type: 'boolean',
              description:
                'Specifies if the given environment is specific to the deployment and will no longer exist at some point in the future. Default: `false`',
              default: false
            },
            production_environment: {
              type: 'boolean',
              description:
                'Specifies if the given environment is one that end-users directly interact with. Default: `true` when `environment` is `production` and `false` otherwise.'
            }
          },
          required: ['ref']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposCreateDeploymentRequest,
        ReposCreateDeploymentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateDeploymentHandler>(
            Handlers.ReposCreateDeploymentHandler
          );

        await controller.reposCreateDeployment(req, res, next);
      })
    );
  }

  private addReposGetDeploymentHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/deployments/:deployment_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            deployment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'deployment_id']
        }
      }),

      asyncRequestHandler<
        ReposGetDeploymentRequest,
        ReposGetDeploymentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetDeploymentHandler>(
            Handlers.ReposGetDeploymentHandler
          );

        await controller.reposGetDeployment(req, res, next);
      })
    );
  }

  private addReposDeleteDeploymentHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/deployments/:deployment_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            deployment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'deployment_id']
        }
      }),

      asyncRequestHandler<
        ReposDeleteDeploymentRequest,
        ReposDeleteDeploymentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteDeploymentHandler>(
            Handlers.ReposDeleteDeploymentHandler
          );

        await controller.reposDeleteDeployment(req, res, next);
      })
    );
  }

  private addReposListDeploymentStatusesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/deployments/:deployment_id/statuses',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            deployment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'deployment_id']
        }
      }),

      asyncRequestHandler<
        ReposListDeploymentStatusesRequest,
        ReposListDeploymentStatusesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListDeploymentStatusesHandler>(
            Handlers.ReposListDeploymentStatusesHandler
          );

        await controller.reposListDeploymentStatuses(req, res, next);
      })
    );
  }

  private addReposCreateDeploymentStatusHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/deployments/:deployment_id/statuses',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            state: {
              type: 'string',
              description:
                'The state of the status. When you set a transient deployment to `inactive`, the deployment will be shown as `destroyed` in GitHub.',
              enum: [
                'error',
                'failure',
                'inactive',
                'in_progress',
                'queued',
                'pending',
                'success'
              ]
            },
            target_url: {
              type: 'string',
              description:
                "The target URL to associate with this status. This URL should contain output to keep the user updated while the task is running or serve as historical information for what happened in the deployment. **Note:** It's recommended to use the `log_url` parameter, which replaces `target_url`.",
              default: ''
            },
            log_url: {
              type: 'string',
              description:
                'The full URL of the deployment\'s output. This parameter replaces `target_url`. We will continue to accept `target_url` to support legacy uses, but we recommend replacing `target_url` with `log_url`. Setting `log_url` will automatically set `target_url` to the same value. Default: `""`',
              default: ''
            },
            description: {
              type: 'string',
              description:
                'A short description of the status. The maximum description length is 140 characters.',
              default: ''
            },
            environment: {
              type: 'string',
              description:
                'Name for the target deployment environment, which can be changed when setting a deploy status. For example, `production`, `staging`, or `qa`.',
              enum: ['production', 'staging', 'qa']
            },
            environment_url: {
              type: 'string',
              description:
                'Sets the URL for accessing your environment. Default: `""`',
              default: ''
            },
            auto_inactive: {
              type: 'boolean',
              description:
                "Adds a new `inactive` status to all prior non-transient, non-production environment deployments with the same repository and `environment` name as the created status's deployment. An `inactive` status is only added to deployments that had a `success` state. Default: `true`"
            }
          },
          required: ['state']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            deployment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'deployment_id']
        }
      }),

      asyncRequestHandler<
        ReposCreateDeploymentStatusRequest,
        ReposCreateDeploymentStatusResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateDeploymentStatusHandler>(
            Handlers.ReposCreateDeploymentStatusHandler
          );

        await controller.reposCreateDeploymentStatus(req, res, next);
      })
    );
  }

  private addReposGetDeploymentStatusHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/deployments/:deployment_id/statuses/:status_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            deployment_id: { type: 'integer' },
            status_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'deployment_id', 'status_id']
        }
      }),

      asyncRequestHandler<
        ReposGetDeploymentStatusRequest,
        ReposGetDeploymentStatusResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetDeploymentStatusHandler>(
            Handlers.ReposGetDeploymentStatusHandler
          );

        await controller.reposGetDeploymentStatus(req, res, next);
      })
    );
  }

  private addReposCreateDispatchEventHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/dispatches',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          required: ['event_type'],
          properties: {
            event_type: {
              type: 'string',
              description:
                'A custom webhook event name. Must be 100 characters or fewer.',
              minLength: 1,
              maxLength: 100
            },
            client_payload: {
              type: 'object',
              description:
                'JSON payload with extra information about the webhook event that your action or workflow may use. The maximum number of top-level properties is 10.',
              additionalProperties: true,
              maxProperties: 10
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposCreateDispatchEventRequest,
        ReposCreateDispatchEventResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateDispatchEventHandler>(
            Handlers.ReposCreateDispatchEventHandler
          );

        await controller.reposCreateDispatchEvent(req, res, next);
      })
    );
  }

  private addReposGetAllEnvironmentsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/environments',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposGetAllEnvironmentsRequest,
        ReposGetAllEnvironmentsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetAllEnvironmentsHandler>(
            Handlers.ReposGetAllEnvironmentsHandler
          );

        await controller.reposGetAllEnvironments(req, res, next);
      })
    );
  }

  private addReposGetEnvironmentHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/environments/:environment_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            environment_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'environment_name']
        }
      }),

      asyncRequestHandler<
        ReposGetEnvironmentRequest,
        ReposGetEnvironmentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetEnvironmentHandler>(
            Handlers.ReposGetEnvironmentHandler
          );

        await controller.reposGetEnvironment(req, res, next);
      })
    );
  }

  private addReposCreateOrUpdateEnvironmentHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/environments/:environment_name',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          nullable: true,
          properties: {
            wait_timer: { $ref: '#/definitions/wait-timer' },
            reviewers: {
              type: 'array',
              nullable: true,
              description:
                'The people or teams that may review jobs that reference the environment. You can list up to six users or teams as reviewers. The reviewers must have at least read access to the repository. Only one of the required reviewers needs to approve the job for it to proceed.',
              items: {
                type: 'object',
                properties: {
                  type: { $ref: '#/definitions/deployment-reviewer-type' },
                  id: {
                    type: 'integer',
                    description:
                      'The id of the user or team who can review the deployment',
                    example: 4532992
                  }
                }
              }
            },
            deployment_branch_policy: {
              $ref: '#/definitions/deployment-branch-policy-settings'
            }
          },
          additionalProperties: false,
          definitions: {
            'wait-timer': {
              type: 'integer',
              example: 30,
              description:
                'The amount of time to delay a job after the job is initially triggered. The time (in minutes) must be an integer between 0 and 43,200 (30 days).',
              title: 'wait-timer'
            },
            'deployment-reviewer-type': {
              type: 'string',
              description: 'The type of reviewer.',
              enum: ['User', 'Team'],
              example: 'User',
              title: 'deployment-reviewer-type'
            },
            'deployment-branch-policy-settings': {
              type: 'object',
              description:
                'The type of deployment branch policy for this environment. To allow all branches to deploy, set to `null`.',
              properties: {
                protected_branches: {
                  type: 'boolean',
                  description:
                    'Whether only branches with branch protection rules can deploy to this environment. If `protected_branches` is `true`, `custom_branch_policies` must be `false`; if `protected_branches` is `false`, `custom_branch_policies` must be `true`.'
                },
                custom_branch_policies: {
                  type: 'boolean',
                  description:
                    'Whether only branches that match the specified name patterns can deploy to this environment.  If `custom_branch_policies` is `true`, `protected_branches` must be `false`; if `custom_branch_policies` is `false`, `protected_branches` must be `true`.'
                }
              },
              nullable: true,
              required: ['protected_branches', 'custom_branch_policies'],
              title: 'deployment-branch-policy-settings'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            environment_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'environment_name']
        }
      }),

      asyncRequestHandler<
        ReposCreateOrUpdateEnvironmentRequest,
        ReposCreateOrUpdateEnvironmentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateOrUpdateEnvironmentHandler>(
            Handlers.ReposCreateOrUpdateEnvironmentHandler
          );

        await controller.reposCreateOrUpdateEnvironment(req, res, next);
      })
    );
  }

  private addReposDeleteAnEnvironmentHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/environments/:environment_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            environment_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'environment_name']
        }
      }),

      asyncRequestHandler<
        ReposDeleteAnEnvironmentRequest,
        ReposDeleteAnEnvironmentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteAnEnvironmentHandler>(
            Handlers.ReposDeleteAnEnvironmentHandler
          );

        await controller.reposDeleteAnEnvironment(req, res, next);
      })
    );
  }

  private addReposListDeploymentBranchPoliciesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            environment_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'environment_name']
        }
      }),

      asyncRequestHandler<
        ReposListDeploymentBranchPoliciesRequest,
        ReposListDeploymentBranchPoliciesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListDeploymentBranchPoliciesHandler>(
            Handlers.ReposListDeploymentBranchPoliciesHandler
          );

        await controller.reposListDeploymentBranchPolicies(req, res, next);
      })
    );
  }

  private addReposCreateDeploymentBranchPolicyHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies',

      ControllerMiddleware.validate({
        body: {
          $ref: '#/definitions/deployment-branch-policy-name-pattern',
          definitions: {
            'deployment-branch-policy-name-pattern': {
              title: 'Deployment branch policy name pattern',
              type: 'object',
              properties: {
                name: {
                  description:
                    'The name pattern that branches must match in order to deploy to the environment.\n\nWildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.\nFor more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).',
                  type: 'string',
                  example: 'release/*'
                }
              },
              required: ['name']
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            environment_name: { type: 'string' }
          },
          required: ['owner', 'repo', 'environment_name']
        }
      }),

      asyncRequestHandler<
        ReposCreateDeploymentBranchPolicyRequest,
        ReposCreateDeploymentBranchPolicyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateDeploymentBranchPolicyHandler>(
            Handlers.ReposCreateDeploymentBranchPolicyHandler
          );

        await controller.reposCreateDeploymentBranchPolicy(req, res, next);
      })
    );
  }

  private addReposGetDeploymentBranchPolicyHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            environment_name: { type: 'string' },
            branch_policy_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'environment_name', 'branch_policy_id']
        }
      }),

      asyncRequestHandler<
        ReposGetDeploymentBranchPolicyRequest,
        ReposGetDeploymentBranchPolicyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetDeploymentBranchPolicyHandler>(
            Handlers.ReposGetDeploymentBranchPolicyHandler
          );

        await controller.reposGetDeploymentBranchPolicy(req, res, next);
      })
    );
  }

  private addReposUpdateDeploymentBranchPolicyHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id',

      ControllerMiddleware.validate({
        body: {
          $ref: '#/definitions/deployment-branch-policy-name-pattern',
          definitions: {
            'deployment-branch-policy-name-pattern': {
              title: 'Deployment branch policy name pattern',
              type: 'object',
              properties: {
                name: {
                  description:
                    'The name pattern that branches must match in order to deploy to the environment.\n\nWildcard characters will not match `/`. For example, to match branches that begin with `release/` and contain an additional single slash, use `release/*/*`.\nFor more information about pattern matching syntax, see the [Ruby File.fnmatch documentation](https://ruby-doc.org/core-2.5.1/File.html#method-c-fnmatch).',
                  type: 'string',
                  example: 'release/*'
                }
              },
              required: ['name']
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            environment_name: { type: 'string' },
            branch_policy_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'environment_name', 'branch_policy_id']
        }
      }),

      asyncRequestHandler<
        ReposUpdateDeploymentBranchPolicyRequest,
        ReposUpdateDeploymentBranchPolicyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposUpdateDeploymentBranchPolicyHandler>(
            Handlers.ReposUpdateDeploymentBranchPolicyHandler
          );

        await controller.reposUpdateDeploymentBranchPolicy(req, res, next);
      })
    );
  }

  private addReposDeleteDeploymentBranchPolicyHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/environments/:environment_name/deployment-branch-policies/:branch_policy_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            environment_name: { type: 'string' },
            branch_policy_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'environment_name', 'branch_policy_id']
        }
      }),

      asyncRequestHandler<
        ReposDeleteDeploymentBranchPolicyRequest,
        ReposDeleteDeploymentBranchPolicyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteDeploymentBranchPolicyHandler>(
            Handlers.ReposDeleteDeploymentBranchPolicyHandler
          );

        await controller.reposDeleteDeploymentBranchPolicy(req, res, next);
      })
    );
  }

  private addActivityListRepoEventsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/events',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActivityListRepoEventsRequest,
        ActivityListRepoEventsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListRepoEventsHandler>(
            Handlers.ActivityListRepoEventsHandler
          );

        await controller.activityListRepoEvents(req, res, next);
      })
    );
  }

  private addReposListForksHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/forks',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            sort: {
              type: 'string',
              enum: ['newest', 'oldest', 'stargazers', 'watchers'],
              default: 'newest'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposListForksRequest, ReposListForksResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposListForksHandler>(Handlers.ReposListForksHandler);

          await controller.reposListForks(req, res, next);
        }
      )
    );
  }

  private addReposCreateForkHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/forks',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          nullable: true,
          properties: {
            organization: {
              type: 'string',
              description:
                'Optional parameter to specify the organization name if forking into an organization.'
            },
            name: {
              type: 'string',
              description:
                'When forking from an existing repository, a new name for the fork.'
            },
            default_branch_only: {
              type: 'boolean',
              description:
                'When forking from an existing repository, fork with only the default branch.'
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposCreateForkRequest, ReposCreateForkResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposCreateForkHandler>(Handlers.ReposCreateForkHandler);

          await controller.reposCreateFork(req, res, next);
        }
      )
    );
  }

  private addGitCreateBlobHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/git/blobs',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            content: { type: 'string', description: "The new blob's content." },
            encoding: {
              type: 'string',
              description:
                'The encoding used for `content`. Currently, `"utf-8"` and `"base64"` are supported.',
              default: 'utf-8'
            }
          },
          required: ['content']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<GitCreateBlobRequest, GitCreateBlobResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GitCreateBlobHandler>(Handlers.GitCreateBlobHandler);

          await controller.gitCreateBlob(req, res, next);
        }
      )
    );
  }

  private addGitGetBlobHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/git/blobs/:file_sha',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            file_sha: { type: 'string' }
          },
          required: ['owner', 'repo', 'file_sha']
        }
      }),

      asyncRequestHandler<GitGetBlobRequest, GitGetBlobResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GitGetBlobHandler>(Handlers.GitGetBlobHandler);

          await controller.gitGetBlob(req, res, next);
        }
      )
    );
  }

  private addGitCreateCommitHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/git/commits',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            message: { type: 'string', description: 'The commit message' },
            tree: {
              type: 'string',
              description: 'The SHA of the tree object this commit points to'
            },
            parents: {
              type: 'array',
              description:
                'The SHAs of the commits that were the parents of this commit. If omitted or empty, the commit will be written as a root commit. For a single parent, an array of one SHA should be provided; for a merge commit, an array of more than one should be provided.',
              items: { type: 'string' }
            },
            author: {
              type: 'object',
              description:
                'Information about the author of the commit. By default, the `author` will be the authenticated user and the current date. See the `author` and `committer` object below for details.',
              properties: {
                name: {
                  type: 'string',
                  description:
                    'The name of the author (or committer) of the commit'
                },
                email: {
                  type: 'string',
                  description:
                    'The email of the author (or committer) of the commit'
                },
                date: {
                  type: 'string',
                  format: 'date-time',
                  description:
                    'Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
                }
              },
              required: ['name', 'email']
            },
            committer: {
              type: 'object',
              description:
                'Information about the person who is making the commit. By default, `committer` will use the information set in `author`. See the `author` and `committer` object below for details.',
              properties: {
                name: {
                  type: 'string',
                  description:
                    'The name of the author (or committer) of the commit'
                },
                email: {
                  type: 'string',
                  description:
                    'The email of the author (or committer) of the commit'
                },
                date: {
                  type: 'string',
                  format: 'date-time',
                  description:
                    'Indicates when this commit was authored (or committed). This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
                }
              }
            },
            signature: {
              type: 'string',
              description:
                'The [PGP signature](https://en.wikipedia.org/wiki/Pretty_Good_Privacy) of the commit. GitHub adds the signature to the `gpgsig` header of the created commit. For a commit signature to be verifiable by Git or GitHub, it must be an ASCII-armored detached PGP signature over the string commit as it would be written to the object database. To pass a `signature` parameter, you need to first manually create a valid PGP signature, which can be complicated. You may find it easier to [use the command line](https://git-scm.com/book/id/v2/Git-Tools-Signing-Your-Work) to create signed commits.'
            }
          },
          required: ['message', 'tree']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<GitCreateCommitRequest, GitCreateCommitResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GitCreateCommitHandler>(Handlers.GitCreateCommitHandler);

          await controller.gitCreateCommit(req, res, next);
        }
      )
    );
  }

  private addGitGetCommitHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/git/commits/:commit_sha',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            commit_sha: { type: 'string' }
          },
          required: ['owner', 'repo', 'commit_sha']
        }
      }),

      asyncRequestHandler<GitGetCommitRequest, GitGetCommitResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GitGetCommitHandler>(Handlers.GitGetCommitHandler);

          await controller.gitGetCommit(req, res, next);
        }
      )
    );
  }

  private addGitListMatchingRefsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/git/matching-refs/:ref',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            ref: { type: 'string' }
          },
          required: ['owner', 'repo', 'ref']
        }
      }),

      asyncRequestHandler<
        GitListMatchingRefsRequest,
        GitListMatchingRefsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<GitListMatchingRefsHandler>(
            Handlers.GitListMatchingRefsHandler
          );

        await controller.gitListMatchingRefs(req, res, next);
      })
    );
  }

  private addGitGetRefHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/git/ref/:ref',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            ref: { type: 'string' }
          },
          required: ['owner', 'repo', 'ref']
        }
      }),

      asyncRequestHandler<GitGetRefRequest, GitGetRefResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GitGetRefHandler>(Handlers.GitGetRefHandler);

          await controller.gitGetRef(req, res, next);
        }
      )
    );
  }

  private addGitCreateRefHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/git/refs',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            ref: {
              type: 'string',
              description:
                "The name of the fully qualified reference (ie: `refs/heads/master`). If it doesn't start with 'refs' and have at least two slashes, it will be rejected."
            },
            sha: {
              type: 'string',
              description: 'The SHA1 value for this reference.'
            },
            key: { type: 'string', example: '"refs/heads/newbranch"' }
          },
          required: ['ref', 'sha']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<GitCreateRefRequest, GitCreateRefResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GitCreateRefHandler>(Handlers.GitCreateRefHandler);

          await controller.gitCreateRef(req, res, next);
        }
      )
    );
  }

  private addGitUpdateRefHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/git/refs/:ref',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            sha: {
              type: 'string',
              description: 'The SHA1 value to set this reference to'
            },
            force: {
              type: 'boolean',
              description:
                "Indicates whether to force the update or to make sure the update is a fast-forward update. Leaving this out or setting it to `false` will make sure you're not overwriting work.",
              default: false
            }
          },
          required: ['sha']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            ref: { type: 'string' }
          },
          required: ['owner', 'repo', 'ref']
        }
      }),

      asyncRequestHandler<GitUpdateRefRequest, GitUpdateRefResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GitUpdateRefHandler>(Handlers.GitUpdateRefHandler);

          await controller.gitUpdateRef(req, res, next);
        }
      )
    );
  }

  private addGitDeleteRefHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/git/refs/:ref',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            ref: { type: 'string' }
          },
          required: ['owner', 'repo', 'ref']
        }
      }),

      asyncRequestHandler<GitDeleteRefRequest, GitDeleteRefResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GitDeleteRefHandler>(Handlers.GitDeleteRefHandler);

          await controller.gitDeleteRef(req, res, next);
        }
      )
    );
  }

  private addGitCreateTagHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/git/tags',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            tag: {
              type: 'string',
              description:
                'The tag\'s name. This is typically a version (e.g., "v0.0.1").'
            },
            message: { type: 'string', description: 'The tag message.' },
            object: {
              type: 'string',
              description: 'The SHA of the git object this is tagging.'
            },
            type: {
              type: 'string',
              description:
                "The type of the object we're tagging. Normally this is a `commit` but it can also be a `tree` or a `blob`.",
              enum: ['commit', 'tree', 'blob']
            },
            tagger: {
              type: 'object',
              description:
                'An object with information about the individual creating the tag.',
              properties: {
                name: {
                  type: 'string',
                  description: 'The name of the author of the tag'
                },
                email: {
                  type: 'string',
                  description: 'The email of the author of the tag'
                },
                date: {
                  type: 'string',
                  format: 'date-time',
                  description:
                    'When this object was tagged. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
                }
              },
              required: ['name', 'email']
            }
          },
          required: ['tag', 'message', 'object', 'type']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<GitCreateTagRequest, GitCreateTagResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GitCreateTagHandler>(Handlers.GitCreateTagHandler);

          await controller.gitCreateTag(req, res, next);
        }
      )
    );
  }

  private addGitGetTagHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/git/tags/:tag_sha',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            tag_sha: { type: 'string' }
          },
          required: ['owner', 'repo', 'tag_sha']
        }
      }),

      asyncRequestHandler<GitGetTagRequest, GitGetTagResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GitGetTagHandler>(Handlers.GitGetTagHandler);

          await controller.gitGetTag(req, res, next);
        }
      )
    );
  }

  private addGitCreateTreeHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/git/trees',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            tree: {
              type: 'array',
              description:
                'Objects (of `path`, `mode`, `type`, and `sha`) specifying a tree structure.',
              items: {
                type: 'object',
                properties: {
                  path: {
                    type: 'string',
                    description: 'The file referenced in the tree.'
                  },
                  mode: {
                    type: 'string',
                    description:
                      'The file mode; one of `100644` for file (blob), `100755` for executable (blob), `040000` for subdirectory (tree), `160000` for submodule (commit), or `120000` for a blob that specifies the path of a symlink.',
                    enum: ['100644', '100755', '040000', '160000', '120000']
                  },
                  type: {
                    type: 'string',
                    description: 'Either `blob`, `tree`, or `commit`.',
                    enum: ['blob', 'tree', 'commit']
                  },
                  sha: {
                    type: 'string',
                    description:
                      'The SHA1 checksum ID of the object in the tree. Also called `tree.sha`. If the value is `null` then the file will be deleted.  \n  \n**Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.',
                    nullable: true
                  },
                  content: {
                    type: 'string',
                    description:
                      'The content you want this file to have. GitHub will write this blob out and use that SHA for this entry. Use either this, or `tree.sha`.  \n  \n**Note:** Use either `tree.sha` or `content` to specify the contents of the entry. Using both `tree.sha` and `content` will return an error.'
                  }
                }
              }
            },
            base_tree: {
              type: 'string',
              description:
                "The SHA1 of an existing Git tree object which will be used as the base for the new tree. If provided, a new Git tree object will be created from entries in the Git tree object pointed to by `base_tree` and entries defined in the `tree` parameter. Entries defined in the `tree` parameter will overwrite items from `base_tree` with the same `path`. If you're creating new changes on a branch, then normally you'd set `base_tree` to the SHA1 of the Git tree object of the current latest commit on the branch you're working on.\nIf not provided, GitHub will create a new Git tree object from only the entries defined in the `tree` parameter. If you create a new commit pointing to such a tree, then all files which were a part of the parent commit's tree and were not defined in the `tree` parameter will be listed as deleted by the new commit.\n"
            }
          },
          required: ['tree']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<GitCreateTreeRequest, GitCreateTreeResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GitCreateTreeHandler>(Handlers.GitCreateTreeHandler);

          await controller.gitCreateTree(req, res, next);
        }
      )
    );
  }

  private addGitGetTreeHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/git/trees/:tree_sha',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { recursive: { type: 'string' } },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            tree_sha: { type: 'string' }
          },
          required: ['owner', 'repo', 'tree_sha']
        }
      }),

      asyncRequestHandler<GitGetTreeRequest, GitGetTreeResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GitGetTreeHandler>(Handlers.GitGetTreeHandler);

          await controller.gitGetTree(req, res, next);
        }
      )
    );
  }

  private addReposListWebhooksHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/hooks',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposListWebhooksRequest, ReposListWebhooksResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposListWebhooksHandler>(
              Handlers.ReposListWebhooksHandler
            );

          await controller.reposListWebhooks(req, res, next);
        }
      )
    );
  }

  private addReposCreateWebhookHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/hooks',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          nullable: true,
          properties: {
            name: {
              type: 'string',
              description:
                'Use `web` to create a webhook. Default: `web`. This parameter only accepts the value `web`.'
            },
            config: {
              type: 'object',
              description:
                'Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).',
              properties: {
                url: { $ref: '#/definitions/webhook-config-url' },
                content_type: {
                  $ref: '#/definitions/webhook-config-content-type'
                },
                secret: { $ref: '#/definitions/webhook-config-secret' },
                insecure_ssl: {
                  $ref: '#/definitions/webhook-config-insecure-ssl'
                },
                token: { type: 'string', example: '"abc"' },
                digest: { type: 'string', example: '"sha256"' }
              }
            },
            events: {
              type: 'array',
              description:
                'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for.',
              default: ['push'],
              items: { type: 'string' }
            },
            active: {
              type: 'boolean',
              description:
                'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.',
              default: true
            }
          },
          additionalProperties: false,
          definitions: {
            'webhook-config-url': {
              type: 'string',
              description: 'The URL to which the payloads will be delivered.',
              example: 'https://example.com/webhook',
              format: 'uri',
              title: 'webhook-config-url'
            },
            'webhook-config-content-type': {
              type: 'string',
              description:
                'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
              example: '"json"',
              title: 'webhook-config-content-type'
            },
            'webhook-config-secret': {
              type: 'string',
              description:
                'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
              example: '"********"',
              title: 'webhook-config-secret'
            },
            'webhook-config-insecure-ssl': {
              oneOf: [
                {
                  type: 'string',
                  description:
                    'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                  example: '"0"'
                },
                { type: 'number' }
              ],
              title: 'webhook-config-insecure-ssl'
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposCreateWebhookRequest,
        ReposCreateWebhookResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateWebhookHandler>(
            Handlers.ReposCreateWebhookHandler
          );

        await controller.reposCreateWebhook(req, res, next);
      })
    );
  }

  private addReposGetWebhookHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/hooks/:hook_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            hook_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'hook_id']
        }
      }),

      asyncRequestHandler<ReposGetWebhookRequest, ReposGetWebhookResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetWebhookHandler>(Handlers.ReposGetWebhookHandler);

          await controller.reposGetWebhook(req, res, next);
        }
      )
    );
  }

  private addReposUpdateWebhookHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/hooks/:hook_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            config: {
              type: 'object',
              description:
                'Key/value pairs to provide settings for this webhook. [These are defined below](https://docs.github.com/rest/reference/repos#create-hook-config-params).',
              properties: {
                url: { $ref: '#/definitions/webhook-config-url' },
                content_type: {
                  $ref: '#/definitions/webhook-config-content-type'
                },
                secret: { $ref: '#/definitions/webhook-config-secret' },
                insecure_ssl: {
                  $ref: '#/definitions/webhook-config-insecure-ssl'
                },
                address: { type: 'string', example: '"bar@example.com"' },
                room: { type: 'string', example: '"The Serious Room"' }
              },
              required: ['url']
            },
            events: {
              type: 'array',
              description:
                'Determines what [events](https://docs.github.com/webhooks/event-payloads) the hook is triggered for. This replaces the entire array of events.',
              default: ['push'],
              items: { type: 'string' }
            },
            add_events: {
              type: 'array',
              description:
                'Determines a list of events to be added to the list of events that the Hook triggers for.',
              items: { type: 'string' }
            },
            remove_events: {
              type: 'array',
              description:
                'Determines a list of events to be removed from the list of events that the Hook triggers for.',
              items: { type: 'string' }
            },
            active: {
              type: 'boolean',
              description:
                'Determines if notifications are sent when the webhook is triggered. Set to `true` to send notifications.',
              default: true
            }
          },
          definitions: {
            'webhook-config-url': {
              type: 'string',
              description: 'The URL to which the payloads will be delivered.',
              example: 'https://example.com/webhook',
              format: 'uri',
              title: 'webhook-config-url'
            },
            'webhook-config-content-type': {
              type: 'string',
              description:
                'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
              example: '"json"',
              title: 'webhook-config-content-type'
            },
            'webhook-config-secret': {
              type: 'string',
              description:
                'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
              example: '"********"',
              title: 'webhook-config-secret'
            },
            'webhook-config-insecure-ssl': {
              oneOf: [
                {
                  type: 'string',
                  description:
                    'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                  example: '"0"'
                },
                { type: 'number' }
              ],
              title: 'webhook-config-insecure-ssl'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            hook_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'hook_id']
        }
      }),

      asyncRequestHandler<
        ReposUpdateWebhookRequest,
        ReposUpdateWebhookResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposUpdateWebhookHandler>(
            Handlers.ReposUpdateWebhookHandler
          );

        await controller.reposUpdateWebhook(req, res, next);
      })
    );
  }

  private addReposDeleteWebhookHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/hooks/:hook_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            hook_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'hook_id']
        }
      }),

      asyncRequestHandler<
        ReposDeleteWebhookRequest,
        ReposDeleteWebhookResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteWebhookHandler>(
            Handlers.ReposDeleteWebhookHandler
          );

        await controller.reposDeleteWebhook(req, res, next);
      })
    );
  }

  private addReposGetWebhookConfigForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/hooks/:hook_id/config',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            hook_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'hook_id']
        }
      }),

      asyncRequestHandler<
        ReposGetWebhookConfigForRepoRequest,
        ReposGetWebhookConfigForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetWebhookConfigForRepoHandler>(
            Handlers.ReposGetWebhookConfigForRepoHandler
          );

        await controller.reposGetWebhookConfigForRepo(req, res, next);
      })
    );
  }

  private addReposUpdateWebhookConfigForRepoHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/hooks/:hook_id/config',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          additionalProperties: false,
          properties: {
            url: { $ref: '#/definitions/webhook-config-url' },
            content_type: { $ref: '#/definitions/webhook-config-content-type' },
            secret: { $ref: '#/definitions/webhook-config-secret' },
            insecure_ssl: { $ref: '#/definitions/webhook-config-insecure-ssl' }
          },
          definitions: {
            'webhook-config-url': {
              type: 'string',
              description: 'The URL to which the payloads will be delivered.',
              example: 'https://example.com/webhook',
              format: 'uri',
              title: 'webhook-config-url'
            },
            'webhook-config-content-type': {
              type: 'string',
              description:
                'The media type used to serialize the payloads. Supported values include `json` and `form`. The default is `form`.',
              example: '"json"',
              title: 'webhook-config-content-type'
            },
            'webhook-config-secret': {
              type: 'string',
              description:
                'If provided, the `secret` will be used as the `key` to generate the HMAC hex digest value for [delivery signature headers](https://docs.github.com/webhooks/event-payloads/#delivery-headers).',
              example: '"********"',
              title: 'webhook-config-secret'
            },
            'webhook-config-insecure-ssl': {
              oneOf: [
                {
                  type: 'string',
                  description:
                    'Determines whether the SSL certificate of the host for `url` will be verified when delivering payloads. Supported values include `0` (verification is performed) and `1` (verification is not performed). The default is `0`. **We strongly recommend not setting this to `1` as you are subject to man-in-the-middle and other attacks.**',
                  example: '"0"'
                },
                { type: 'number' }
              ],
              title: 'webhook-config-insecure-ssl'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            hook_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'hook_id']
        }
      }),

      asyncRequestHandler<
        ReposUpdateWebhookConfigForRepoRequest,
        ReposUpdateWebhookConfigForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposUpdateWebhookConfigForRepoHandler>(
            Handlers.ReposUpdateWebhookConfigForRepoHandler
          );

        await controller.reposUpdateWebhookConfigForRepo(req, res, next);
      })
    );
  }

  private addReposListWebhookDeliveriesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/hooks/:hook_id/deliveries',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            cursor: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            hook_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'hook_id']
        }
      }),

      asyncRequestHandler<
        ReposListWebhookDeliveriesRequest,
        ReposListWebhookDeliveriesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListWebhookDeliveriesHandler>(
            Handlers.ReposListWebhookDeliveriesHandler
          );

        await controller.reposListWebhookDeliveries(req, res, next);
      })
    );
  }

  private addReposGetWebhookDeliveryHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/hooks/:hook_id/deliveries/:delivery_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            hook_id: { type: 'integer' },
            delivery_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'hook_id', 'delivery_id']
        }
      }),

      asyncRequestHandler<
        ReposGetWebhookDeliveryRequest,
        ReposGetWebhookDeliveryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetWebhookDeliveryHandler>(
            Handlers.ReposGetWebhookDeliveryHandler
          );

        await controller.reposGetWebhookDelivery(req, res, next);
      })
    );
  }

  private addReposRedeliverWebhookDeliveryHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/hooks/:hook_id/deliveries/:delivery_id/attempts',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            hook_id: { type: 'integer' },
            delivery_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'hook_id', 'delivery_id']
        }
      }),

      asyncRequestHandler<
        ReposRedeliverWebhookDeliveryRequest,
        ReposRedeliverWebhookDeliveryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposRedeliverWebhookDeliveryHandler>(
            Handlers.ReposRedeliverWebhookDeliveryHandler
          );

        await controller.reposRedeliverWebhookDelivery(req, res, next);
      })
    );
  }

  private addReposPingWebhookHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/hooks/:hook_id/pings',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            hook_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'hook_id']
        }
      }),

      asyncRequestHandler<ReposPingWebhookRequest, ReposPingWebhookResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposPingWebhookHandler>(Handlers.ReposPingWebhookHandler);

          await controller.reposPingWebhook(req, res, next);
        }
      )
    );
  }

  private addReposTestPushWebhookHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/hooks/:hook_id/tests',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            hook_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'hook_id']
        }
      }),

      asyncRequestHandler<
        ReposTestPushWebhookRequest,
        ReposTestPushWebhookResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposTestPushWebhookHandler>(
            Handlers.ReposTestPushWebhookHandler
          );

        await controller.reposTestPushWebhook(req, res, next);
      })
    );
  }

  private addMigrationsGetImportStatusHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/import',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        MigrationsGetImportStatusRequest,
        MigrationsGetImportStatusResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsGetImportStatusHandler>(
            Handlers.MigrationsGetImportStatusHandler
          );

        await controller.migrationsGetImportStatus(req, res, next);
      })
    );
  }

  private addMigrationsStartImportHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/import',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            vcs_url: {
              type: 'string',
              description: 'The URL of the originating repository.'
            },
            vcs: {
              type: 'string',
              description:
                'The originating VCS type. Without this parameter, the import job will take additional time to detect the VCS type before beginning the import. This detection step will be reflected in the response.',
              enum: ['subversion', 'git', 'mercurial', 'tfvc']
            },
            vcs_username: {
              type: 'string',
              description:
                'If authentication is required, the username to provide to `vcs_url`.'
            },
            vcs_password: {
              type: 'string',
              description:
                'If authentication is required, the password to provide to `vcs_url`.'
            },
            tfvc_project: {
              type: 'string',
              description:
                'For a tfvc import, the name of the project that is being imported.'
            }
          },
          required: ['vcs_url']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        MigrationsStartImportRequest,
        MigrationsStartImportResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsStartImportHandler>(
            Handlers.MigrationsStartImportHandler
          );

        await controller.migrationsStartImport(req, res, next);
      })
    );
  }

  private addMigrationsUpdateImportHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/import',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            vcs_username: {
              type: 'string',
              description:
                'The username to provide to the originating repository.'
            },
            vcs_password: {
              type: 'string',
              description:
                'The password to provide to the originating repository.'
            },
            vcs: {
              type: 'string',
              description:
                'The type of version control system you are migrating from.',
              enum: ['subversion', 'tfvc', 'git', 'mercurial'],
              example: '"git"'
            },
            tfvc_project: {
              type: 'string',
              description:
                'For a tfvc import, the name of the project that is being imported.',
              example: '"project1"'
            }
          },
          nullable: true
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        MigrationsUpdateImportRequest,
        MigrationsUpdateImportResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsUpdateImportHandler>(
            Handlers.MigrationsUpdateImportHandler
          );

        await controller.migrationsUpdateImport(req, res, next);
      })
    );
  }

  private addMigrationsCancelImportHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/import',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        MigrationsCancelImportRequest,
        MigrationsCancelImportResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsCancelImportHandler>(
            Handlers.MigrationsCancelImportHandler
          );

        await controller.migrationsCancelImport(req, res, next);
      })
    );
  }

  private addMigrationsGetCommitAuthorsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/import/authors',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { since: { type: 'integer' } },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        MigrationsGetCommitAuthorsRequest,
        MigrationsGetCommitAuthorsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsGetCommitAuthorsHandler>(
            Handlers.MigrationsGetCommitAuthorsHandler
          );

        await controller.migrationsGetCommitAuthors(req, res, next);
      })
    );
  }

  private addMigrationsMapCommitAuthorHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/import/authors/:author_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            email: { type: 'string', description: 'The new Git author email.' },
            name: { type: 'string', description: 'The new Git author name.' }
          },
          additionalProperties: false
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            author_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'author_id']
        }
      }),

      asyncRequestHandler<
        MigrationsMapCommitAuthorRequest,
        MigrationsMapCommitAuthorResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsMapCommitAuthorHandler>(
            Handlers.MigrationsMapCommitAuthorHandler
          );

        await controller.migrationsMapCommitAuthor(req, res, next);
      })
    );
  }

  private addMigrationsGetLargeFilesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/import/large_files',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        MigrationsGetLargeFilesRequest,
        MigrationsGetLargeFilesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsGetLargeFilesHandler>(
            Handlers.MigrationsGetLargeFilesHandler
          );

        await controller.migrationsGetLargeFiles(req, res, next);
      })
    );
  }

  private addMigrationsSetLfsPreferenceHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/import/lfs',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            use_lfs: {
              type: 'string',
              description:
                'Whether to store large files during the import. `opt_in` means large files will be stored using Git LFS. `opt_out` means large files will be removed during the import.',
              enum: ['opt_in', 'opt_out']
            }
          },
          required: ['use_lfs']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        MigrationsSetLfsPreferenceRequest,
        MigrationsSetLfsPreferenceResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsSetLfsPreferenceHandler>(
            Handlers.MigrationsSetLfsPreferenceHandler
          );

        await controller.migrationsSetLfsPreference(req, res, next);
      })
    );
  }

  private addAppsGetRepoInstallationHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/installation',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        AppsGetRepoInstallationRequest,
        AppsGetRepoInstallationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsGetRepoInstallationHandler>(
            Handlers.AppsGetRepoInstallationHandler
          );

        await controller.appsGetRepoInstallation(req, res, next);
      })
    );
  }

  private addInteractionsGetRestrictionsForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/interaction-limits',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        InteractionsGetRestrictionsForRepoRequest,
        InteractionsGetRestrictionsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<InteractionsGetRestrictionsForRepoHandler>(
            Handlers.InteractionsGetRestrictionsForRepoHandler
          );

        await controller.interactionsGetRestrictionsForRepo(req, res, next);
      })
    );
  }

  private addInteractionsSetRestrictionsForRepoHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/interaction-limits',

      ControllerMiddleware.validate({
        body: {
          $ref: '#/definitions/interaction-limit',
          definitions: {
            'interaction-limit': {
              title: 'Interaction Restrictions',
              description:
                'Limit interactions to a specific type of user for a specified duration',
              type: 'object',
              properties: {
                limit: { $ref: '#/definitions/interaction-group' },
                expiry: { $ref: '#/definitions/interaction-expiry' }
              },
              required: ['limit']
            },
            'interaction-group': {
              type: 'string',
              description:
                'The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.',
              example: 'collaborators_only',
              enum: [
                'existing_users',
                'contributors_only',
                'collaborators_only'
              ],
              title: 'interaction-group'
            },
            'interaction-expiry': {
              type: 'string',
              description:
                'The duration of the interaction restriction. Default: `one_day`.',
              example: 'one_month',
              enum: [
                'one_day',
                'three_days',
                'one_week',
                'one_month',
                'six_months'
              ],
              title: 'interaction-expiry'
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        InteractionsSetRestrictionsForRepoRequest,
        InteractionsSetRestrictionsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<InteractionsSetRestrictionsForRepoHandler>(
            Handlers.InteractionsSetRestrictionsForRepoHandler
          );

        await controller.interactionsSetRestrictionsForRepo(req, res, next);
      })
    );
  }

  private addInteractionsRemoveRestrictionsForRepoHandler(
    router: Router
  ): void {
    router.delete(
      '/repos/:owner/:repo/interaction-limits',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        InteractionsRemoveRestrictionsForRepoRequest,
        InteractionsRemoveRestrictionsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<InteractionsRemoveRestrictionsForRepoHandler>(
            Handlers.InteractionsRemoveRestrictionsForRepoHandler
          );

        await controller.interactionsRemoveRestrictionsForRepo(req, res, next);
      })
    );
  }

  private addReposListInvitationsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/invitations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposListInvitationsRequest,
        ReposListInvitationsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListInvitationsHandler>(
            Handlers.ReposListInvitationsHandler
          );

        await controller.reposListInvitations(req, res, next);
      })
    );
  }

  private addReposUpdateInvitationHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/invitations/:invitation_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            permissions: {
              type: 'string',
              description:
                'The permissions that the associated user will have on the repository. Valid values are `read`, `write`, `maintain`, `triage`, and `admin`.',
              enum: ['read', 'write', 'maintain', 'triage', 'admin']
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            invitation_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'invitation_id']
        }
      }),

      asyncRequestHandler<
        ReposUpdateInvitationRequest,
        ReposUpdateInvitationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposUpdateInvitationHandler>(
            Handlers.ReposUpdateInvitationHandler
          );

        await controller.reposUpdateInvitation(req, res, next);
      })
    );
  }

  private addReposDeleteInvitationHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/invitations/:invitation_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            invitation_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'invitation_id']
        }
      }),

      asyncRequestHandler<
        ReposDeleteInvitationRequest,
        ReposDeleteInvitationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteInvitationHandler>(
            Handlers.ReposDeleteInvitationHandler
          );

        await controller.reposDeleteInvitation(req, res, next);
      })
    );
  }

  private addIssuesListForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/issues',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            milestone: { type: 'string' },
            state: {
              type: 'string',
              enum: ['open', 'closed', 'all'],
              default: 'open'
            },
            assignee: { type: 'string' },
            creator: { type: 'string' },
            mentioned: { type: 'string' },
            labels: { type: 'string' },
            sort: {
              type: 'string',
              enum: ['created', 'updated', 'comments'],
              default: 'created'
            },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            since: { type: 'string', format: 'date-time' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<IssuesListForRepoRequest, IssuesListForRepoResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesListForRepoHandler>(
              Handlers.IssuesListForRepoHandler
            );

          await controller.issuesListForRepo(req, res, next);
        }
      )
    );
  }

  private addIssuesCreateHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/issues',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            title: {
              oneOf: [{ type: 'string' }, { type: 'integer' }],
              description: 'The title of the issue.'
            },
            body: { type: 'string', description: 'The contents of the issue.' },
            assignee: {
              type: 'string',
              description:
                'Login for the user that this issue should be assigned to. _NOTE: Only users with push access can set the assignee for new issues. The assignee is silently dropped otherwise. **This field is deprecated.**_',
              nullable: true
            },
            milestone: {
              oneOf: [
                { type: 'string' },
                {
                  type: 'integer',
                  description:
                    'The `number` of the milestone to associate this issue with. _NOTE: Only users with push access can set the milestone for new issues. The milestone is silently dropped otherwise._'
                }
              ],
              nullable: true
            },
            labels: {
              type: 'array',
              description:
                'Labels to associate with this issue. _NOTE: Only users with push access can set labels for new issues. Labels are silently dropped otherwise._',
              items: {
                oneOf: [
                  { type: 'string' },
                  {
                    type: 'object',
                    properties: {
                      id: { type: 'integer' },
                      name: { type: 'string' },
                      description: { type: 'string', nullable: true },
                      color: { type: 'string', nullable: true }
                    }
                  }
                ]
              }
            },
            assignees: {
              type: 'array',
              description:
                'Logins for Users to assign to this issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._',
              items: { type: 'string' }
            }
          },
          required: ['title']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<IssuesCreateRequest, IssuesCreateResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesCreateHandler>(Handlers.IssuesCreateHandler);

          await controller.issuesCreate(req, res, next);
        }
      )
    );
  }

  private addIssuesListCommentsForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/issues/comments',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            },
            direction: { type: 'string', enum: ['asc', 'desc'] },
            since: { type: 'string', format: 'date-time' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        IssuesListCommentsForRepoRequest,
        IssuesListCommentsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesListCommentsForRepoHandler>(
            Handlers.IssuesListCommentsForRepoHandler
          );

        await controller.issuesListCommentsForRepo(req, res, next);
      })
    );
  }

  private addIssuesGetCommentHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/issues/comments/:comment_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<IssuesGetCommentRequest, IssuesGetCommentResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesGetCommentHandler>(Handlers.IssuesGetCommentHandler);

          await controller.issuesGetComment(req, res, next);
        }
      )
    );
  }

  private addIssuesUpdateCommentHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/issues/comments/:comment_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
              description: 'The contents of the comment.'
            }
          },
          required: ['body']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        IssuesUpdateCommentRequest,
        IssuesUpdateCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesUpdateCommentHandler>(
            Handlers.IssuesUpdateCommentHandler
          );

        await controller.issuesUpdateComment(req, res, next);
      })
    );
  }

  private addIssuesDeleteCommentHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/issues/comments/:comment_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        IssuesDeleteCommentRequest,
        IssuesDeleteCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesDeleteCommentHandler>(
            Handlers.IssuesDeleteCommentHandler
          );

        await controller.issuesDeleteComment(req, res, next);
      })
    );
  }

  private addReactionsListForIssueCommentHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/issues/comments/:comment_id/reactions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        ReactionsListForIssueCommentRequest,
        ReactionsListForIssueCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsListForIssueCommentHandler>(
            Handlers.ReactionsListForIssueCommentHandler
          );

        await controller.reactionsListForIssueComment(req, res, next);
      })
    );
  }

  private addReactionsCreateForIssueCommentHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/issues/comments/:comment_id/reactions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              description:
                'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the issue comment.',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            }
          },
          required: ['content']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        ReactionsCreateForIssueCommentRequest,
        ReactionsCreateForIssueCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsCreateForIssueCommentHandler>(
            Handlers.ReactionsCreateForIssueCommentHandler
          );

        await controller.reactionsCreateForIssueComment(req, res, next);
      })
    );
  }

  private addReactionsDeleteForIssueCommentHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/issues/comments/:comment_id/reactions/:reaction_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' },
            reaction_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id', 'reaction_id']
        }
      }),

      asyncRequestHandler<
        ReactionsDeleteForIssueCommentRequest,
        ReactionsDeleteForIssueCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsDeleteForIssueCommentHandler>(
            Handlers.ReactionsDeleteForIssueCommentHandler
          );

        await controller.reactionsDeleteForIssueComment(req, res, next);
      })
    );
  }

  private addIssuesListEventsForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/issues/events',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        IssuesListEventsForRepoRequest,
        IssuesListEventsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesListEventsForRepoHandler>(
            Handlers.IssuesListEventsForRepoHandler
          );

        await controller.issuesListEventsForRepo(req, res, next);
      })
    );
  }

  private addIssuesGetEventHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/issues/events/:event_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            event_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'event_id']
        }
      }),

      asyncRequestHandler<IssuesGetEventRequest, IssuesGetEventResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesGetEventHandler>(Handlers.IssuesGetEventHandler);

          await controller.issuesGetEvent(req, res, next);
        }
      )
    );
  }

  private addIssuesGetHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/issues/:issue_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<IssuesGetRequest, IssuesGetResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesGetHandler>(Handlers.IssuesGetHandler);

          await controller.issuesGet(req, res, next);
        }
      )
    );
  }

  private addIssuesUpdateHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/issues/:issue_number',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            title: {
              oneOf: [{ type: 'string' }, { type: 'integer' }],
              description: 'The title of the issue.',
              nullable: true
            },
            body: {
              type: 'string',
              description: 'The contents of the issue.',
              nullable: true
            },
            assignee: {
              type: 'string',
              nullable: true,
              description:
                'Login for the user that this issue should be assigned to. **This field is deprecated.**'
            },
            state: {
              type: 'string',
              description: 'State of the issue. Either `open` or `closed`.',
              enum: ['open', 'closed']
            },
            state_reason: {
              type: 'string',
              enum: ['completed', 'not_planned', 'reopened'],
              nullable: true,
              description: 'The reason for the current state',
              example: 'not_planned'
            },
            milestone: {
              oneOf: [
                { type: 'string' },
                {
                  type: 'integer',
                  description:
                    'The `number` of the milestone to associate this issue with or `null` to remove current. _NOTE: Only users with push access can set the milestone for issues. The milestone is silently dropped otherwise._'
                }
              ],
              nullable: true
            },
            labels: {
              type: 'array',
              description:
                'Labels to associate with this issue. Pass one or more Labels to _replace_ the set of Labels on this Issue. Send an empty array (`[]`) to clear all Labels from the Issue. _NOTE: Only users with push access can set labels for issues. Labels are silently dropped otherwise._',
              items: {
                oneOf: [
                  { type: 'string' },
                  {
                    type: 'object',
                    properties: {
                      id: { type: 'integer' },
                      name: { type: 'string' },
                      description: { type: 'string', nullable: true },
                      color: { type: 'string', nullable: true }
                    }
                  }
                ]
              }
            },
            assignees: {
              type: 'array',
              description:
                'Logins for Users to assign to this issue. Pass one or more user logins to _replace_ the set of assignees on this Issue. Send an empty array (`[]`) to clear all assignees from the Issue. _NOTE: Only users with push access can set assignees for new issues. Assignees are silently dropped otherwise._',
              items: { type: 'string' }
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<IssuesUpdateRequest, IssuesUpdateResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesUpdateHandler>(Handlers.IssuesUpdateHandler);

          await controller.issuesUpdate(req, res, next);
        }
      )
    );
  }

  private addIssuesAddAssigneesHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/issues/:issue_number/assignees',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            assignees: {
              type: 'array',
              description:
                'Usernames of people to assign this issue to. _NOTE: Only users with push access can add assignees to an issue. Assignees are silently ignored otherwise._',
              items: { type: 'string' }
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<
        IssuesAddAssigneesRequest,
        IssuesAddAssigneesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesAddAssigneesHandler>(
            Handlers.IssuesAddAssigneesHandler
          );

        await controller.issuesAddAssignees(req, res, next);
      })
    );
  }

  private addIssuesRemoveAssigneesHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/issues/:issue_number/assignees',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            assignees: {
              type: 'array',
              description:
                'Usernames of assignees to remove from an issue. _NOTE: Only users with push access can remove assignees from an issue. Assignees are silently ignored otherwise._',
              items: { type: 'string' }
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<
        IssuesRemoveAssigneesRequest,
        IssuesRemoveAssigneesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesRemoveAssigneesHandler>(
            Handlers.IssuesRemoveAssigneesHandler
          );

        await controller.issuesRemoveAssignees(req, res, next);
      })
    );
  }

  private addIssuesListCommentsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/issues/:issue_number/comments',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            since: { type: 'string', format: 'date-time' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<
        IssuesListCommentsRequest,
        IssuesListCommentsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesListCommentsHandler>(
            Handlers.IssuesListCommentsHandler
          );

        await controller.issuesListComments(req, res, next);
      })
    );
  }

  private addIssuesCreateCommentHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/issues/:issue_number/comments',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
              description: 'The contents of the comment.'
            }
          },
          required: ['body']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<
        IssuesCreateCommentRequest,
        IssuesCreateCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesCreateCommentHandler>(
            Handlers.IssuesCreateCommentHandler
          );

        await controller.issuesCreateComment(req, res, next);
      })
    );
  }

  private addIssuesListEventsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/issues/:issue_number/events',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<IssuesListEventsRequest, IssuesListEventsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesListEventsHandler>(Handlers.IssuesListEventsHandler);

          await controller.issuesListEvents(req, res, next);
        }
      )
    );
  }

  private addIssuesListLabelsOnIssueHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/issues/:issue_number/labels',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<
        IssuesListLabelsOnIssueRequest,
        IssuesListLabelsOnIssueResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesListLabelsOnIssueHandler>(
            Handlers.IssuesListLabelsOnIssueHandler
          );

        await controller.issuesListLabelsOnIssue(req, res, next);
      })
    );
  }

  private addIssuesAddLabelsHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/issues/:issue_number/labels',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                labels: {
                  type: 'array',
                  minItems: 1,
                  description:
                    'The names of the labels to add to the issue\'s existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also replace all of the labels for an issue. For more information, see "[Set labels for an issue](https://docs.github.com/rest/reference/issues#set-labels-for-an-issue)."',
                  items: { type: 'string' }
                }
              }
            },
            { type: 'array', minItems: 1, items: { type: 'string' } },
            {
              type: 'object',
              properties: {
                labels: {
                  type: 'array',
                  minItems: 1,
                  items: {
                    type: 'object',
                    properties: { name: { type: 'string' } },
                    required: ['name']
                  }
                }
              }
            },
            {
              type: 'array',
              minItems: 1,
              items: {
                type: 'object',
                properties: { name: { type: 'string' } },
                required: ['name']
              }
            },
            { type: 'string' }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<IssuesAddLabelsRequest, IssuesAddLabelsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesAddLabelsHandler>(Handlers.IssuesAddLabelsHandler);

          await controller.issuesAddLabels(req, res, next);
        }
      )
    );
  }

  private addIssuesSetLabelsHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/issues/:issue_number/labels',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                labels: {
                  type: 'array',
                  minItems: 1,
                  description:
                    'The names of the labels to set for the issue. The labels you set replace any existing labels. You can pass an empty array to remove all labels. Alternatively, you can pass a single label as a `string` or an `array` of labels directly, but GitHub recommends passing an object with the `labels` key. You can also add labels to the existing labels for an issue. For more information, see "[Add labels to an issue](https://docs.github.com/rest/reference/issues#add-labels-to-an-issue)."',
                  items: { type: 'string' }
                }
              }
            },
            { type: 'array', minItems: 1, items: { type: 'string' } },
            {
              type: 'object',
              properties: {
                labels: {
                  type: 'array',
                  minItems: 1,
                  items: {
                    type: 'object',
                    properties: { name: { type: 'string' } },
                    required: ['name']
                  }
                }
              }
            },
            {
              type: 'array',
              minItems: 1,
              items: {
                type: 'object',
                properties: { name: { type: 'string' } },
                required: ['name']
              }
            },
            { type: 'string' }
          ]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<IssuesSetLabelsRequest, IssuesSetLabelsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesSetLabelsHandler>(Handlers.IssuesSetLabelsHandler);

          await controller.issuesSetLabels(req, res, next);
        }
      )
    );
  }

  private addIssuesRemoveAllLabelsHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/issues/:issue_number/labels',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<
        IssuesRemoveAllLabelsRequest,
        IssuesRemoveAllLabelsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesRemoveAllLabelsHandler>(
            Handlers.IssuesRemoveAllLabelsHandler
          );

        await controller.issuesRemoveAllLabels(req, res, next);
      })
    );
  }

  private addIssuesRemoveLabelHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/issues/:issue_number/labels/:name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' },
            name: { type: 'string' }
          },
          required: ['owner', 'repo', 'issue_number', 'name']
        }
      }),

      asyncRequestHandler<IssuesRemoveLabelRequest, IssuesRemoveLabelResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesRemoveLabelHandler>(
              Handlers.IssuesRemoveLabelHandler
            );

          await controller.issuesRemoveLabel(req, res, next);
        }
      )
    );
  }

  private addIssuesLockHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/issues/:issue_number/lock',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          nullable: true,
          properties: {
            lock_reason: {
              type: 'string',
              description:
                "The reason for locking the issue or pull request conversation. Lock will fail if you don't use one of these reasons:  \n\\* `off-topic`  \n\\* `too heated`  \n\\* `resolved`  \n\\* `spam`",
              enum: ['off-topic', 'too heated', 'resolved', 'spam']
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<IssuesLockRequest, IssuesLockResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesLockHandler>(Handlers.IssuesLockHandler);

          await controller.issuesLock(req, res, next);
        }
      )
    );
  }

  private addIssuesUnlockHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/issues/:issue_number/lock',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<IssuesUnlockRequest, IssuesUnlockResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesUnlockHandler>(Handlers.IssuesUnlockHandler);

          await controller.issuesUnlock(req, res, next);
        }
      )
    );
  }

  private addReactionsListForIssueHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/issues/:issue_number/reactions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<
        ReactionsListForIssueRequest,
        ReactionsListForIssueResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsListForIssueHandler>(
            Handlers.ReactionsListForIssueHandler
          );

        await controller.reactionsListForIssue(req, res, next);
      })
    );
  }

  private addReactionsCreateForIssueHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/issues/:issue_number/reactions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              description:
                'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the issue.',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            }
          },
          required: ['content']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<
        ReactionsCreateForIssueRequest,
        ReactionsCreateForIssueResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsCreateForIssueHandler>(
            Handlers.ReactionsCreateForIssueHandler
          );

        await controller.reactionsCreateForIssue(req, res, next);
      })
    );
  }

  private addReactionsDeleteForIssueHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/issues/:issue_number/reactions/:reaction_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' },
            reaction_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number', 'reaction_id']
        }
      }),

      asyncRequestHandler<
        ReactionsDeleteForIssueRequest,
        ReactionsDeleteForIssueResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsDeleteForIssueHandler>(
            Handlers.ReactionsDeleteForIssueHandler
          );

        await controller.reactionsDeleteForIssue(req, res, next);
      })
    );
  }

  private addIssuesListEventsForTimelineHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/issues/:issue_number/timeline',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            issue_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'issue_number']
        }
      }),

      asyncRequestHandler<
        IssuesListEventsForTimelineRequest,
        IssuesListEventsForTimelineResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesListEventsForTimelineHandler>(
            Handlers.IssuesListEventsForTimelineHandler
          );

        await controller.issuesListEventsForTimeline(req, res, next);
      })
    );
  }

  private addReposListDeployKeysHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/keys',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposListDeployKeysRequest,
        ReposListDeployKeysResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListDeployKeysHandler>(
            Handlers.ReposListDeployKeysHandler
          );

        await controller.reposListDeployKeys(req, res, next);
      })
    );
  }

  private addReposCreateDeployKeyHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/keys',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            title: { type: 'string', description: 'A name for the key.' },
            key: { type: 'string', description: 'The contents of the key.' },
            read_only: {
              type: 'boolean',
              description:
                'If `true`, the key will only be able to read repository contents. Otherwise, the key will be able to read and write.  \n  \nDeploy keys with write access can perform the same actions as an organization member with admin access, or a collaborator on a personal repository. For more information, see "[Repository permission levels for an organization](https://docs.github.com/articles/repository-permission-levels-for-an-organization/)" and "[Permission levels for a user account repository](https://docs.github.com/articles/permission-levels-for-a-user-account-repository/)."'
            }
          },
          required: ['key']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposCreateDeployKeyRequest,
        ReposCreateDeployKeyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateDeployKeyHandler>(
            Handlers.ReposCreateDeployKeyHandler
          );

        await controller.reposCreateDeployKey(req, res, next);
      })
    );
  }

  private addReposGetDeployKeyHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/keys/:key_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            key_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'key_id']
        }
      }),

      asyncRequestHandler<ReposGetDeployKeyRequest, ReposGetDeployKeyResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetDeployKeyHandler>(
              Handlers.ReposGetDeployKeyHandler
            );

          await controller.reposGetDeployKey(req, res, next);
        }
      )
    );
  }

  private addReposDeleteDeployKeyHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/keys/:key_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            key_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'key_id']
        }
      }),

      asyncRequestHandler<
        ReposDeleteDeployKeyRequest,
        ReposDeleteDeployKeyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteDeployKeyHandler>(
            Handlers.ReposDeleteDeployKeyHandler
          );

        await controller.reposDeleteDeployKey(req, res, next);
      })
    );
  }

  private addIssuesListLabelsForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/labels',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        IssuesListLabelsForRepoRequest,
        IssuesListLabelsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesListLabelsForRepoHandler>(
            Handlers.IssuesListLabelsForRepoHandler
          );

        await controller.issuesListLabelsForRepo(req, res, next);
      })
    );
  }

  private addIssuesCreateLabelHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/labels',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description:
                'The name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."'
            },
            color: {
              type: 'string',
              description:
                'The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.'
            },
            description: {
              type: 'string',
              description:
                'A short description of the label. Must be 100 characters or fewer.'
            }
          },
          required: ['name']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<IssuesCreateLabelRequest, IssuesCreateLabelResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesCreateLabelHandler>(
              Handlers.IssuesCreateLabelHandler
            );

          await controller.issuesCreateLabel(req, res, next);
        }
      )
    );
  }

  private addIssuesGetLabelHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/labels/:name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            name: { type: 'string' }
          },
          required: ['owner', 'repo', 'name']
        }
      }),

      asyncRequestHandler<IssuesGetLabelRequest, IssuesGetLabelResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesGetLabelHandler>(Handlers.IssuesGetLabelHandler);

          await controller.issuesGetLabel(req, res, next);
        }
      )
    );
  }

  private addIssuesUpdateLabelHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/labels/:name',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            new_name: {
              type: 'string',
              description:
                'The new name of the label. Emoji can be added to label names, using either native emoji or colon-style markup. For example, typing `:strawberry:` will render the emoji ![:strawberry:](https://github.githubassets.com/images/icons/emoji/unicode/1f353.png ":strawberry:"). For a full list of available emoji and codes, see "[Emoji cheat sheet](https://github.com/ikatyang/emoji-cheat-sheet)."'
            },
            color: {
              type: 'string',
              description:
                'The [hexadecimal color code](http://www.color-hex.com/) for the label, without the leading `#`.'
            },
            description: {
              type: 'string',
              description:
                'A short description of the label. Must be 100 characters or fewer.'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            name: { type: 'string' }
          },
          required: ['owner', 'repo', 'name']
        }
      }),

      asyncRequestHandler<IssuesUpdateLabelRequest, IssuesUpdateLabelResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesUpdateLabelHandler>(
              Handlers.IssuesUpdateLabelHandler
            );

          await controller.issuesUpdateLabel(req, res, next);
        }
      )
    );
  }

  private addIssuesDeleteLabelHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/labels/:name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            name: { type: 'string' }
          },
          required: ['owner', 'repo', 'name']
        }
      }),

      asyncRequestHandler<IssuesDeleteLabelRequest, IssuesDeleteLabelResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<IssuesDeleteLabelHandler>(
              Handlers.IssuesDeleteLabelHandler
            );

          await controller.issuesDeleteLabel(req, res, next);
        }
      )
    );
  }

  private addReposListLanguagesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/languages',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposListLanguagesRequest,
        ReposListLanguagesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListLanguagesHandler>(
            Handlers.ReposListLanguagesHandler
          );

        await controller.reposListLanguages(req, res, next);
      })
    );
  }

  private addReposEnableLfsForRepoHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/lfs',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposEnableLfsForRepoRequest,
        ReposEnableLfsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposEnableLfsForRepoHandler>(
            Handlers.ReposEnableLfsForRepoHandler
          );

        await controller.reposEnableLfsForRepo(req, res, next);
      })
    );
  }

  private addReposDisableLfsForRepoHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/lfs',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposDisableLfsForRepoRequest,
        ReposDisableLfsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDisableLfsForRepoHandler>(
            Handlers.ReposDisableLfsForRepoHandler
          );

        await controller.reposDisableLfsForRepo(req, res, next);
      })
    );
  }

  private addLicensesGetForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/license',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        LicensesGetForRepoRequest,
        LicensesGetForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<LicensesGetForRepoHandler>(
            Handlers.LicensesGetForRepoHandler
          );

        await controller.licensesGetForRepo(req, res, next);
      })
    );
  }

  private addReposMergeUpstreamHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/merge-upstream',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            branch: {
              type: 'string',
              description:
                'The name of the branch which should be updated to match upstream.'
            }
          },
          required: ['branch']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposMergeUpstreamRequest,
        ReposMergeUpstreamResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposMergeUpstreamHandler>(
            Handlers.ReposMergeUpstreamHandler
          );

        await controller.reposMergeUpstream(req, res, next);
      })
    );
  }

  private addReposMergeHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/merges',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            base: {
              type: 'string',
              description:
                'The name of the base branch that the head will be merged into.'
            },
            head: {
              type: 'string',
              description:
                'The head to merge. This can be a branch name or a commit SHA1.'
            },
            commit_message: {
              type: 'string',
              description:
                'Commit message to use for the merge commit. If omitted, a default message will be used.'
            }
          },
          required: ['base', 'head']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposMergeRequest, ReposMergeResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposMergeHandler>(Handlers.ReposMergeHandler);

          await controller.reposMerge(req, res, next);
        }
      )
    );
  }

  private addIssuesListMilestonesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/milestones',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            state: {
              type: 'string',
              enum: ['open', 'closed', 'all'],
              default: 'open'
            },
            sort: {
              type: 'string',
              enum: ['due_on', 'completeness'],
              default: 'due_on'
            },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'asc'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        IssuesListMilestonesRequest,
        IssuesListMilestonesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesListMilestonesHandler>(
            Handlers.IssuesListMilestonesHandler
          );

        await controller.issuesListMilestones(req, res, next);
      })
    );
  }

  private addIssuesCreateMilestoneHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/milestones',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            title: {
              type: 'string',
              description: 'The title of the milestone.'
            },
            state: {
              type: 'string',
              description:
                'The state of the milestone. Either `open` or `closed`.',
              enum: ['open', 'closed'],
              default: 'open'
            },
            description: {
              type: 'string',
              description: 'A description of the milestone.'
            },
            due_on: {
              type: 'string',
              format: 'date-time',
              description:
                'The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
            }
          },
          required: ['title']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        IssuesCreateMilestoneRequest,
        IssuesCreateMilestoneResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesCreateMilestoneHandler>(
            Handlers.IssuesCreateMilestoneHandler
          );

        await controller.issuesCreateMilestone(req, res, next);
      })
    );
  }

  private addIssuesGetMilestoneHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/milestones/:milestone_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            milestone_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'milestone_number']
        }
      }),

      asyncRequestHandler<
        IssuesGetMilestoneRequest,
        IssuesGetMilestoneResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesGetMilestoneHandler>(
            Handlers.IssuesGetMilestoneHandler
          );

        await controller.issuesGetMilestone(req, res, next);
      })
    );
  }

  private addIssuesUpdateMilestoneHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/milestones/:milestone_number',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            title: {
              type: 'string',
              description: 'The title of the milestone.'
            },
            state: {
              type: 'string',
              description:
                'The state of the milestone. Either `open` or `closed`.',
              enum: ['open', 'closed'],
              default: 'open'
            },
            description: {
              type: 'string',
              description: 'A description of the milestone.'
            },
            due_on: {
              type: 'string',
              format: 'date-time',
              description:
                'The milestone due date. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`.'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            milestone_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'milestone_number']
        }
      }),

      asyncRequestHandler<
        IssuesUpdateMilestoneRequest,
        IssuesUpdateMilestoneResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesUpdateMilestoneHandler>(
            Handlers.IssuesUpdateMilestoneHandler
          );

        await controller.issuesUpdateMilestone(req, res, next);
      })
    );
  }

  private addIssuesDeleteMilestoneHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/milestones/:milestone_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            milestone_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'milestone_number']
        }
      }),

      asyncRequestHandler<
        IssuesDeleteMilestoneRequest,
        IssuesDeleteMilestoneResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesDeleteMilestoneHandler>(
            Handlers.IssuesDeleteMilestoneHandler
          );

        await controller.issuesDeleteMilestone(req, res, next);
      })
    );
  }

  private addIssuesListLabelsForMilestoneHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/milestones/:milestone_number/labels',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            milestone_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'milestone_number']
        }
      }),

      asyncRequestHandler<
        IssuesListLabelsForMilestoneRequest,
        IssuesListLabelsForMilestoneResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesListLabelsForMilestoneHandler>(
            Handlers.IssuesListLabelsForMilestoneHandler
          );

        await controller.issuesListLabelsForMilestone(req, res, next);
      })
    );
  }

  private addActivityListRepoNotificationsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/notifications',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            all: { type: 'boolean', default: false },
            participating: { type: 'boolean', default: false },
            since: { type: 'string', format: 'date-time' },
            before: { type: 'string', format: 'date-time' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActivityListRepoNotificationsForAuthenticatedUserRequest,
        ActivityListRepoNotificationsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListRepoNotificationsForAuthenticatedUserHandler>(
            Handlers.ActivityListRepoNotificationsForAuthenticatedUserHandler
          );

        await controller.activityListRepoNotificationsForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addActivityMarkRepoNotificationsAsReadHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/notifications',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            last_read_at: {
              type: 'string',
              format: 'date-time',
              description:
                'Describes the last point that notifications were checked. Anything updated since this time will not be marked as read. If you omit this parameter, all notifications are marked as read. This is a timestamp in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format: `YYYY-MM-DDTHH:MM:SSZ`. Default: The current timestamp.'
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActivityMarkRepoNotificationsAsReadRequest,
        ActivityMarkRepoNotificationsAsReadResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityMarkRepoNotificationsAsReadHandler>(
            Handlers.ActivityMarkRepoNotificationsAsReadHandler
          );

        await controller.activityMarkRepoNotificationsAsRead(req, res, next);
      })
    );
  }

  private addReposGetPagesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pages',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposGetPagesRequest, ReposGetPagesResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetPagesHandler>(Handlers.ReposGetPagesHandler);

          await controller.reposGetPages(req, res, next);
        }
      )
    );
  }

  private addReposCreatePagesSiteHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/pages',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          description:
            'The source branch and directory used to publish your Pages site.',
          nullable: true,
          properties: {
            build_type: {
              type: 'string',
              description:
                'The process in which the Page will be built. Possible values are `"legacy"` and `"workflow"`.',
              enum: ['legacy', 'workflow']
            },
            source: {
              type: 'object',
              description:
                'The source branch and directory used to publish your Pages site.',
              properties: {
                branch: {
                  type: 'string',
                  description:
                    "The repository branch used to publish your site's source files."
                },
                path: {
                  type: 'string',
                  description:
                    'The repository directory that includes the source files for the Pages site. Allowed paths are `/` or `/docs`. Default: `/`',
                  enum: ['/', '/docs'],
                  default: '/'
                }
              },
              required: ['branch']
            }
          },
          anyOf: [{ required: ['source'] }, { required: ['build_type'] }]
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposCreatePagesSiteRequest,
        ReposCreatePagesSiteResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreatePagesSiteHandler>(
            Handlers.ReposCreatePagesSiteHandler
          );

        await controller.reposCreatePagesSite(req, res, next);
      })
    );
  }

  private addReposUpdateInformationAboutPagesSiteHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/pages',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            cname: {
              type: 'string',
              description:
                'Specify a custom domain for the repository. Sending a `null` value will remove the custom domain. For more about custom domains, see "[Using a custom domain with GitHub Pages](https://docs.github.com/articles/using-a-custom-domain-with-github-pages/)."',
              nullable: true
            },
            https_enforced: {
              type: 'boolean',
              description:
                'Specify whether HTTPS should be enforced for the repository.'
            },
            public: {
              type: 'boolean',
              description:
                'Configures access controls for the GitHub Pages site. If public is set to `true`, the site is accessible to anyone on the internet. If set to `false`, the site will only be accessible to users who have at least `read` access to the repository that published the site. This includes anyone in your Enterprise if the repository is set to `internal` visibility. This feature is only available to repositories in an organization on an Enterprise plan.'
            },
            build_type: {
              type: 'string',
              description:
                'The process by which the GitHub Pages site will be built. `workflow` means that the site is built by a custom GitHub Actions workflow. `legacy` means that the site is built by GitHub when changes are pushed to a specific branch.',
              enum: ['legacy', 'workflow']
            },
            source: {
              anyOf: [
                {
                  type: 'string',
                  description:
                    'Update the source for the repository. Must include the branch name, and may optionally specify the subdirectory `/docs`. Possible values are `"gh-pages"`, `"master"`, and `"master /docs"`.',
                  enum: ['gh-pages', 'master', 'master /docs']
                },
                {
                  type: 'object',
                  description:
                    'Update the source for the repository. Must include the branch name and path.',
                  properties: {
                    branch: {
                      type: 'string',
                      description:
                        "The repository branch used to publish your site's source files."
                    },
                    path: {
                      type: 'string',
                      description:
                        'The repository directory that includes the source files for the Pages site. Allowed paths are `/` or `/docs`.',
                      enum: ['/', '/docs']
                    }
                  },
                  required: ['branch', 'path']
                }
              ]
            }
          },
          anyOf: [
            { required: ['build_type'] },
            { required: ['source'] },
            { required: ['cname'] },
            { required: ['public'] },
            { required: ['https_enforced'] }
          ]
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposUpdateInformationAboutPagesSiteRequest,
        ReposUpdateInformationAboutPagesSiteResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposUpdateInformationAboutPagesSiteHandler>(
            Handlers.ReposUpdateInformationAboutPagesSiteHandler
          );

        await controller.reposUpdateInformationAboutPagesSite(req, res, next);
      })
    );
  }

  private addReposDeletePagesSiteHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/pages',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposDeletePagesSiteRequest,
        ReposDeletePagesSiteResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeletePagesSiteHandler>(
            Handlers.ReposDeletePagesSiteHandler
          );

        await controller.reposDeletePagesSite(req, res, next);
      })
    );
  }

  private addReposListPagesBuildsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pages/builds',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposListPagesBuildsRequest,
        ReposListPagesBuildsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListPagesBuildsHandler>(
            Handlers.ReposListPagesBuildsHandler
          );

        await controller.reposListPagesBuilds(req, res, next);
      })
    );
  }

  private addReposRequestPagesBuildHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/pages/builds',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposRequestPagesBuildRequest,
        ReposRequestPagesBuildResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposRequestPagesBuildHandler>(
            Handlers.ReposRequestPagesBuildHandler
          );

        await controller.reposRequestPagesBuild(req, res, next);
      })
    );
  }

  private addReposGetLatestPagesBuildHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pages/builds/latest',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposGetLatestPagesBuildRequest,
        ReposGetLatestPagesBuildResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetLatestPagesBuildHandler>(
            Handlers.ReposGetLatestPagesBuildHandler
          );

        await controller.reposGetLatestPagesBuild(req, res, next);
      })
    );
  }

  private addReposGetPagesBuildHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pages/builds/:build_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            build_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'build_id']
        }
      }),

      asyncRequestHandler<
        ReposGetPagesBuildRequest,
        ReposGetPagesBuildResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetPagesBuildHandler>(
            Handlers.ReposGetPagesBuildHandler
          );

        await controller.reposGetPagesBuild(req, res, next);
      })
    );
  }

  private addReposCreatePagesDeploymentHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/pages/deployment',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          description: 'The object used to create GitHub Pages deployment',
          properties: {
            artifact_url: {
              type: 'string',
              description:
                'The URL of an artifact that contains the .zip or .tar of static assets to deploy. The artifact belongs to the repository.'
            },
            environment: {
              type: 'string',
              description:
                'The target environment for this GitHub Pages deployment.',
              default: 'github-pages'
            },
            pages_build_version: {
              type: 'string',
              description:
                'A unique string that represents the version of the build for this deployment.',
              default: 'GITHUB_SHA'
            },
            oidc_token: {
              type: 'string',
              description:
                'The OIDC token issued by GitHub Actions certifying the origin of the deployment.'
            }
          },
          required: ['artifact_url', 'pages_build_version', 'oidc_token']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposCreatePagesDeploymentRequest,
        ReposCreatePagesDeploymentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreatePagesDeploymentHandler>(
            Handlers.ReposCreatePagesDeploymentHandler
          );

        await controller.reposCreatePagesDeployment(req, res, next);
      })
    );
  }

  private addReposGetPagesHealthCheckHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pages/health',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposGetPagesHealthCheckRequest,
        ReposGetPagesHealthCheckResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetPagesHealthCheckHandler>(
            Handlers.ReposGetPagesHealthCheckHandler
          );

        await controller.reposGetPagesHealthCheck(req, res, next);
      })
    );
  }

  private addProjectsListForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/projects',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            state: {
              type: 'string',
              enum: ['open', 'closed', 'all'],
              default: 'open'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ProjectsListForRepoRequest,
        ProjectsListForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsListForRepoHandler>(
            Handlers.ProjectsListForRepoHandler
          );

        await controller.projectsListForRepo(req, res, next);
      })
    );
  }

  private addProjectsCreateForRepoHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/projects',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'The name of the project.' },
            body: {
              type: 'string',
              description: 'The description of the project.'
            }
          },
          required: ['name']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ProjectsCreateForRepoRequest,
        ProjectsCreateForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsCreateForRepoHandler>(
            Handlers.ProjectsCreateForRepoHandler
          );

        await controller.projectsCreateForRepo(req, res, next);
      })
    );
  }

  private addPullsListHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pulls',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            state: {
              type: 'string',
              enum: ['open', 'closed', 'all'],
              default: 'open'
            },
            head: { type: 'string' },
            base: { type: 'string' },
            sort: {
              type: 'string',
              enum: ['created', 'updated', 'popularity', 'long-running'],
              default: 'created'
            },
            direction: { type: 'string', enum: ['asc', 'desc'] },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<PullsListRequest, PullsListResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<PullsListHandler>(Handlers.PullsListHandler);

          await controller.pullsList(req, res, next);
        }
      )
    );
  }

  private addPullsCreateHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/pulls',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            title: {
              type: 'string',
              description:
                'The title of the new pull request. Required unless `issue` is specified.'
            },
            head: {
              type: 'string',
              description:
                'The name of the branch where your changes are implemented. For cross-repository pull requests in the same network, namespace `head` with a user like this: `username:branch`.'
            },
            base: {
              type: 'string',
              description:
                'The name of the branch you want the changes pulled into. This should be an existing branch on the current repository. You cannot submit a pull request to one repository that requests a merge to a base of another repository.'
            },
            body: {
              type: 'string',
              description: 'The contents of the pull request.'
            },
            maintainer_can_modify: {
              type: 'boolean',
              description:
                'Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.'
            },
            draft: {
              type: 'boolean',
              description:
                'Indicates whether the pull request is a draft. See "[Draft Pull Requests](https://docs.github.com/en/articles/about-pull-requests#draft-pull-requests)" in the GitHub Help documentation to learn more.'
            },
            issue: {
              type: 'integer',
              example: 1,
              description:
                'An issue in the repository to convert to a pull request. The issue title, body, and comments will become the title, body, and comments on the new pull request. Required unless `title` is specified.'
            }
          },
          required: ['head', 'base']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<PullsCreateRequest, PullsCreateResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<PullsCreateHandler>(Handlers.PullsCreateHandler);

          await controller.pullsCreate(req, res, next);
        }
      )
    );
  }

  private addPullsListReviewCommentsForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pulls/comments',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            sort: {
              type: 'string',
              enum: ['created', 'updated', 'created_at']
            },
            direction: { type: 'string', enum: ['asc', 'desc'] },
            since: { type: 'string', format: 'date-time' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        PullsListReviewCommentsForRepoRequest,
        PullsListReviewCommentsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsListReviewCommentsForRepoHandler>(
            Handlers.PullsListReviewCommentsForRepoHandler
          );

        await controller.pullsListReviewCommentsForRepo(req, res, next);
      })
    );
  }

  private addPullsGetReviewCommentHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pulls/comments/:comment_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        PullsGetReviewCommentRequest,
        PullsGetReviewCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsGetReviewCommentHandler>(
            Handlers.PullsGetReviewCommentHandler
          );

        await controller.pullsGetReviewComment(req, res, next);
      })
    );
  }

  private addPullsUpdateReviewCommentHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/pulls/comments/:comment_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
              description: 'The text of the reply to the review comment.'
            }
          },
          required: ['body']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        PullsUpdateReviewCommentRequest,
        PullsUpdateReviewCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsUpdateReviewCommentHandler>(
            Handlers.PullsUpdateReviewCommentHandler
          );

        await controller.pullsUpdateReviewComment(req, res, next);
      })
    );
  }

  private addPullsDeleteReviewCommentHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/pulls/comments/:comment_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        PullsDeleteReviewCommentRequest,
        PullsDeleteReviewCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsDeleteReviewCommentHandler>(
            Handlers.PullsDeleteReviewCommentHandler
          );

        await controller.pullsDeleteReviewComment(req, res, next);
      })
    );
  }

  private addReactionsListForPullRequestReviewCommentHandler(
    router: Router
  ): void {
    router.get(
      '/repos/:owner/:repo/pulls/comments/:comment_id/reactions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        ReactionsListForPullRequestReviewCommentRequest,
        ReactionsListForPullRequestReviewCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsListForPullRequestReviewCommentHandler>(
            Handlers.ReactionsListForPullRequestReviewCommentHandler
          );

        await controller.reactionsListForPullRequestReviewComment(
          req,
          res,
          next
        );
      })
    );
  }

  private addReactionsCreateForPullRequestReviewCommentHandler(
    router: Router
  ): void {
    router.post(
      '/repos/:owner/:repo/pulls/comments/:comment_id/reactions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              description:
                'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the pull request review comment.',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            }
          },
          required: ['content']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id']
        }
      }),

      asyncRequestHandler<
        ReactionsCreateForPullRequestReviewCommentRequest,
        ReactionsCreateForPullRequestReviewCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsCreateForPullRequestReviewCommentHandler>(
            Handlers.ReactionsCreateForPullRequestReviewCommentHandler
          );

        await controller.reactionsCreateForPullRequestReviewComment(
          req,
          res,
          next
        );
      })
    );
  }

  private addReactionsDeleteForPullRequestCommentHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/pulls/comments/:comment_id/reactions/:reaction_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            comment_id: { type: 'integer' },
            reaction_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'comment_id', 'reaction_id']
        }
      }),

      asyncRequestHandler<
        ReactionsDeleteForPullRequestCommentRequest,
        ReactionsDeleteForPullRequestCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsDeleteForPullRequestCommentHandler>(
            Handlers.ReactionsDeleteForPullRequestCommentHandler
          );

        await controller.reactionsDeleteForPullRequestComment(req, res, next);
      })
    );
  }

  private addPullsGetHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pulls/:pull_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<PullsGetRequest, PullsGetResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<PullsGetHandler>(Handlers.PullsGetHandler);

          await controller.pullsGet(req, res, next);
        }
      )
    );
  }

  private addPullsUpdateHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/pulls/:pull_number',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            title: {
              type: 'string',
              description: 'The title of the pull request.'
            },
            body: {
              type: 'string',
              description: 'The contents of the pull request.'
            },
            state: {
              type: 'string',
              description:
                'State of this Pull Request. Either `open` or `closed`.',
              enum: ['open', 'closed']
            },
            base: {
              type: 'string',
              description:
                'The name of the branch you want your changes pulled into. This should be an existing branch on the current repository. You cannot update the base branch on a pull request to point to another repository.'
            },
            maintainer_can_modify: {
              type: 'boolean',
              description:
                'Indicates whether [maintainers can modify](https://docs.github.com/articles/allowing-changes-to-a-pull-request-branch-created-from-a-fork/) the pull request.'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<PullsUpdateRequest, PullsUpdateResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<PullsUpdateHandler>(Handlers.PullsUpdateHandler);

          await controller.pullsUpdate(req, res, next);
        }
      )
    );
  }

  private addCodespacesCreateWithPrForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.post(
      '/repos/:owner/:repo/pulls/:pull_number/codespaces',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          nullable: true,
          properties: {
            location: {
              description:
                'Location for this codespace. Assigned by IP if not provided',
              type: 'string'
            },
            client_ip: {
              description:
                'IP for location auto-detection when proxying a request',
              type: 'string'
            },
            machine: {
              description: 'Machine type to use for this codespace',
              type: 'string'
            },
            devcontainer_path: {
              description:
                'Path to devcontainer.json config to use for this codespace',
              type: 'string'
            },
            multi_repo_permissions_opt_out: {
              description:
                'Whether to authorize requested permissions from devcontainer.json',
              type: 'boolean'
            },
            working_directory: {
              description: 'Working directory for this codespace',
              type: 'string'
            },
            idle_timeout_minutes: {
              description:
                'Time in minutes before codespace stops from inactivity',
              type: 'integer'
            },
            display_name: {
              description: 'Display name for this codespace',
              type: 'string'
            },
            retention_period_minutes: {
              description:
                'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).',
              type: 'integer'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<
        CodespacesCreateWithPrForAuthenticatedUserRequest,
        CodespacesCreateWithPrForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesCreateWithPrForAuthenticatedUserHandler>(
            Handlers.CodespacesCreateWithPrForAuthenticatedUserHandler
          );

        await controller.codespacesCreateWithPrForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addPullsListReviewCommentsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pulls/:pull_number/comments',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            },
            direction: { type: 'string', enum: ['asc', 'desc'] },
            since: { type: 'string', format: 'date-time' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<
        PullsListReviewCommentsRequest,
        PullsListReviewCommentsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsListReviewCommentsHandler>(
            Handlers.PullsListReviewCommentsHandler
          );

        await controller.pullsListReviewComments(req, res, next);
      })
    );
  }

  private addPullsCreateReviewCommentHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/pulls/:pull_number/comments',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
              description: 'The text of the review comment.'
            },
            commit_id: {
              type: 'string',
              description:
                'The SHA of the commit needing a comment. Not using the latest commit SHA may render your comment outdated if a subsequent commit modifies the line you specify as the `position`.'
            },
            path: {
              type: 'string',
              description:
                'The relative path to the file that necessitates a comment.'
            },
            position: {
              type: 'integer',
              description:
                '**This parameter is deprecated. Use `line` instead**. The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. For help finding the position value, read the note above.',
              deprecated: true,
              'x-github': { deprecationDate: '2022-11-01' }
            },
            side: {
              type: 'string',
              description:
                'In a split diff view, the side of the diff that the pull request\'s changes appear on. Can be `LEFT` or `RIGHT`. Use `LEFT` for deletions that appear in red. Use `RIGHT` for additions that appear in green or unchanged lines that appear in white and are shown for context. For a multi-line comment, side represents whether the last line of the comment range is a deletion or addition. For more information, see "[Diff view options](https://docs.github.com/en/articles/about-comparing-branches-in-pull-requests#diff-view-options)" in the GitHub Help documentation.',
              enum: ['LEFT', 'RIGHT']
            },
            line: {
              type: 'integer',
              description:
                'The line of the blob in the pull request diff that the comment applies to. For a multi-line comment, the last line of the range that your comment applies to.'
            },
            start_line: {
              type: 'integer',
              description:
                '**Required when using multi-line comments unless using `in_reply_to`**. The `start_line` is the first line in the pull request diff that your multi-line comment applies to. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation.'
            },
            start_side: {
              type: 'string',
              description:
                '**Required when using multi-line comments unless using `in_reply_to`**. The `start_side` is the starting side of the diff that the comment applies to. Can be `LEFT` or `RIGHT`. To learn more about multi-line comments, see "[Commenting on a pull request](https://docs.github.com/en/articles/commenting-on-a-pull-request#adding-line-comments-to-a-pull-request)" in the GitHub Help documentation. See `side` in this table for additional context.',
              enum: ['LEFT', 'RIGHT', 'side']
            },
            in_reply_to: {
              type: 'integer',
              example: 2,
              description:
                'The ID of the review comment to reply to. To find the ID of a review comment with ["List review comments on a pull request"](#list-review-comments-on-a-pull-request). When specified, all parameters other than `body` in the request body are ignored.'
            }
          },
          required: ['body', 'commit_id', 'path', 'line']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<
        PullsCreateReviewCommentRequest,
        PullsCreateReviewCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsCreateReviewCommentHandler>(
            Handlers.PullsCreateReviewCommentHandler
          );

        await controller.pullsCreateReviewComment(req, res, next);
      })
    );
  }

  private addPullsCreateReplyForReviewCommentHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/pulls/:pull_number/comments/:comment_id/replies',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
              description: 'The text of the review comment.'
            }
          },
          required: ['body']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' },
            comment_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number', 'comment_id']
        }
      }),

      asyncRequestHandler<
        PullsCreateReplyForReviewCommentRequest,
        PullsCreateReplyForReviewCommentResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsCreateReplyForReviewCommentHandler>(
            Handlers.PullsCreateReplyForReviewCommentHandler
          );

        await controller.pullsCreateReplyForReviewComment(req, res, next);
      })
    );
  }

  private addPullsListCommitsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pulls/:pull_number/commits',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<PullsListCommitsRequest, PullsListCommitsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<PullsListCommitsHandler>(Handlers.PullsListCommitsHandler);

          await controller.pullsListCommits(req, res, next);
        }
      )
    );
  }

  private addPullsListFilesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pulls/:pull_number/files',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<PullsListFilesRequest, PullsListFilesResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<PullsListFilesHandler>(Handlers.PullsListFilesHandler);

          await controller.pullsListFiles(req, res, next);
        }
      )
    );
  }

  private addPullsCheckIfMergedHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pulls/:pull_number/merge',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<
        PullsCheckIfMergedRequest,
        PullsCheckIfMergedResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsCheckIfMergedHandler>(
            Handlers.PullsCheckIfMergedHandler
          );

        await controller.pullsCheckIfMerged(req, res, next);
      })
    );
  }

  private addPullsMergeHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/pulls/:pull_number/merge',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          nullable: true,
          properties: {
            commit_title: {
              type: 'string',
              description: 'Title for the automatic commit message.'
            },
            commit_message: {
              type: 'string',
              description: 'Extra detail to append to automatic commit message.'
            },
            sha: {
              type: 'string',
              description:
                'SHA that pull request head must match to allow merge.'
            },
            merge_method: {
              type: 'string',
              description: 'The merge method to use.',
              enum: ['merge', 'squash', 'rebase']
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<PullsMergeRequest, PullsMergeResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<PullsMergeHandler>(Handlers.PullsMergeHandler);

          await controller.pullsMerge(req, res, next);
        }
      )
    );
  }

  private addPullsListRequestedReviewersHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pulls/:pull_number/requested_reviewers',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<
        PullsListRequestedReviewersRequest,
        PullsListRequestedReviewersResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsListRequestedReviewersHandler>(
            Handlers.PullsListRequestedReviewersHandler
          );

        await controller.pullsListRequestedReviewers(req, res, next);
      })
    );
  }

  private addPullsRequestReviewersHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/pulls/:pull_number/requested_reviewers',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            reviewers: {
              type: 'array',
              description: 'An array of user `login`s that will be requested.',
              items: { type: 'string' }
            },
            team_reviewers: {
              type: 'array',
              description: 'An array of team `slug`s that will be requested.',
              items: { type: 'string' }
            }
          },
          anyOf: [{ required: ['reviewers'] }, { required: ['team_reviewers'] }]
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<
        PullsRequestReviewersRequest,
        PullsRequestReviewersResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsRequestReviewersHandler>(
            Handlers.PullsRequestReviewersHandler
          );

        await controller.pullsRequestReviewers(req, res, next);
      })
    );
  }

  private addPullsRemoveRequestedReviewersHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/pulls/:pull_number/requested_reviewers',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            reviewers: {
              type: 'array',
              description: 'An array of user `login`s that will be removed.',
              items: { type: 'string' }
            },
            team_reviewers: {
              type: 'array',
              description: 'An array of team `slug`s that will be removed.',
              items: { type: 'string' }
            }
          },
          required: ['reviewers']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<
        PullsRemoveRequestedReviewersRequest,
        PullsRemoveRequestedReviewersResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsRemoveRequestedReviewersHandler>(
            Handlers.PullsRemoveRequestedReviewersHandler
          );

        await controller.pullsRemoveRequestedReviewers(req, res, next);
      })
    );
  }

  private addPullsListReviewsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pulls/:pull_number/reviews',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<PullsListReviewsRequest, PullsListReviewsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<PullsListReviewsHandler>(Handlers.PullsListReviewsHandler);

          await controller.pullsListReviews(req, res, next);
        }
      )
    );
  }

  private addPullsCreateReviewHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/pulls/:pull_number/reviews',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            commit_id: {
              type: 'string',
              description:
                'The SHA of the commit that needs a review. Not using the latest commit SHA may render your review comment outdated if a subsequent commit modifies the line you specify as the `position`. Defaults to the most recent commit in the pull request when you do not specify a value.'
            },
            body: {
              type: 'string',
              description:
                '**Required** when using `REQUEST_CHANGES` or `COMMENT` for the `event` parameter. The body text of the pull request review.'
            },
            event: {
              type: 'string',
              description:
                'The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. By leaving this blank, you set the review action state to `PENDING`, which means you will need to [submit the pull request review](https://docs.github.com/rest/pulls#submit-a-review-for-a-pull-request) when you are ready.',
              enum: ['APPROVE', 'REQUEST_CHANGES', 'COMMENT']
            },
            comments: {
              type: 'array',
              description:
                'Use the following table to specify the location, destination, and contents of the draft review comment.',
              items: {
                type: 'object',
                properties: {
                  path: {
                    type: 'string',
                    description:
                      'The relative path to the file that necessitates a review comment.'
                  },
                  position: {
                    type: 'integer',
                    description:
                      'The position in the diff where you want to add a review comment. Note this value is not the same as the line number in the file. For help finding the position value, read the note below.'
                  },
                  body: {
                    type: 'string',
                    description: 'Text of the review comment.'
                  },
                  line: { type: 'integer', example: 28 },
                  side: { type: 'string', example: 'RIGHT' },
                  start_line: { type: 'integer', example: 26 },
                  start_side: { type: 'string', example: 'LEFT' }
                },
                required: ['path', 'body']
              }
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<PullsCreateReviewRequest, PullsCreateReviewResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<PullsCreateReviewHandler>(
              Handlers.PullsCreateReviewHandler
            );

          await controller.pullsCreateReview(req, res, next);
        }
      )
    );
  }

  private addPullsGetReviewHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' },
            review_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number', 'review_id']
        }
      }),

      asyncRequestHandler<PullsGetReviewRequest, PullsGetReviewResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<PullsGetReviewHandler>(Handlers.PullsGetReviewHandler);

          await controller.pullsGetReview(req, res, next);
        }
      )
    );
  }

  private addPullsUpdateReviewHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
              description: 'The body text of the pull request review.'
            }
          },
          required: ['body']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' },
            review_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number', 'review_id']
        }
      }),

      asyncRequestHandler<PullsUpdateReviewRequest, PullsUpdateReviewResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<PullsUpdateReviewHandler>(
              Handlers.PullsUpdateReviewHandler
            );

          await controller.pullsUpdateReview(req, res, next);
        }
      )
    );
  }

  private addPullsDeletePendingReviewHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' },
            review_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number', 'review_id']
        }
      }),

      asyncRequestHandler<
        PullsDeletePendingReviewRequest,
        PullsDeletePendingReviewResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsDeletePendingReviewHandler>(
            Handlers.PullsDeletePendingReviewHandler
          );

        await controller.pullsDeletePendingReview(req, res, next);
      })
    );
  }

  private addPullsListCommentsForReviewHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/comments',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' },
            review_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number', 'review_id']
        }
      }),

      asyncRequestHandler<
        PullsListCommentsForReviewRequest,
        PullsListCommentsForReviewResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsListCommentsForReviewHandler>(
            Handlers.PullsListCommentsForReviewHandler
          );

        await controller.pullsListCommentsForReview(req, res, next);
      })
    );
  }

  private addPullsDismissReviewHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/dismissals',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            message: {
              type: 'string',
              description: 'The message for the pull request review dismissal'
            },
            event: { type: 'string', example: '"DISMISS"', enum: ['DISMISS'] }
          },
          required: ['message']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' },
            review_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number', 'review_id']
        }
      }),

      asyncRequestHandler<
        PullsDismissReviewRequest,
        PullsDismissReviewResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PullsDismissReviewHandler>(
            Handlers.PullsDismissReviewHandler
          );

        await controller.pullsDismissReview(req, res, next);
      })
    );
  }

  private addPullsSubmitReviewHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/pulls/:pull_number/reviews/:review_id/events',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
              description: 'The body text of the pull request review'
            },
            event: {
              type: 'string',
              description:
                'The review action you want to perform. The review actions include: `APPROVE`, `REQUEST_CHANGES`, or `COMMENT`. When you leave this blank, the API returns _HTTP 422 (Unrecognizable entity)_ and sets the review action state to `PENDING`, which means you will need to re-submit the pull request review using a review action.',
              enum: ['APPROVE', 'REQUEST_CHANGES', 'COMMENT']
            }
          },
          required: ['event']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' },
            review_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number', 'review_id']
        }
      }),

      asyncRequestHandler<PullsSubmitReviewRequest, PullsSubmitReviewResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<PullsSubmitReviewHandler>(
              Handlers.PullsSubmitReviewHandler
            );

          await controller.pullsSubmitReview(req, res, next);
        }
      )
    );
  }

  private addPullsUpdateBranchHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/pulls/:pull_number/update-branch',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          nullable: true,
          properties: {
            expected_head_sha: {
              type: 'string',
              description:
                "The expected SHA of the pull request's HEAD ref. This is the most recent commit on the pull request's branch. If the expected SHA does not match the pull request's HEAD, you will receive a `422 Unprocessable Entity` status. You can use the \"[List commits](https://docs.github.com/rest/reference/repos#list-commits)\" endpoint to find the most recent commit SHA. Default: SHA of the pull request's current HEAD ref."
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            pull_number: { type: 'integer' }
          },
          required: ['owner', 'repo', 'pull_number']
        }
      }),

      asyncRequestHandler<PullsUpdateBranchRequest, PullsUpdateBranchResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<PullsUpdateBranchHandler>(
              Handlers.PullsUpdateBranchHandler
            );

          await controller.pullsUpdateBranch(req, res, next);
        }
      )
    );
  }

  private addReposGetReadmeHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/readme',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { ref: { type: 'string' } },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposGetReadmeRequest, ReposGetReadmeResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetReadmeHandler>(Handlers.ReposGetReadmeHandler);

          await controller.reposGetReadme(req, res, next);
        }
      )
    );
  }

  private addReposGetReadmeInDirectoryHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/readme/:dir',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { ref: { type: 'string' } },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            dir: { type: 'string' }
          },
          required: ['owner', 'repo', 'dir']
        }
      }),

      asyncRequestHandler<
        ReposGetReadmeInDirectoryRequest,
        ReposGetReadmeInDirectoryResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetReadmeInDirectoryHandler>(
            Handlers.ReposGetReadmeInDirectoryHandler
          );

        await controller.reposGetReadmeInDirectory(req, res, next);
      })
    );
  }

  private addReposListReleasesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/releases',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposListReleasesRequest, ReposListReleasesResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposListReleasesHandler>(
              Handlers.ReposListReleasesHandler
            );

          await controller.reposListReleases(req, res, next);
        }
      )
    );
  }

  private addReposCreateReleaseHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/releases',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            tag_name: { type: 'string', description: 'The name of the tag.' },
            target_commitish: {
              type: 'string',
              description:
                "Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch (usually `master`)."
            },
            name: { type: 'string', description: 'The name of the release.' },
            body: {
              type: 'string',
              description: 'Text describing the contents of the tag.'
            },
            draft: {
              type: 'boolean',
              description:
                '`true` to create a draft (unpublished) release, `false` to create a published one.',
              default: false
            },
            prerelease: {
              type: 'boolean',
              description:
                '`true` to identify the release as a prerelease. `false` to identify the release as a full release.',
              default: false
            },
            discussion_category_name: {
              type: 'string',
              description:
                'If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."'
            },
            generate_release_notes: {
              type: 'boolean',
              description:
                'Whether to automatically generate the name and body for this release. If `name` is specified, the specified name will be used; otherwise, a name will be automatically generated. If `body` is specified, the body will be pre-pended to the automatically generated notes.',
              default: false
            }
          },
          required: ['tag_name']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposCreateReleaseRequest,
        ReposCreateReleaseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateReleaseHandler>(
            Handlers.ReposCreateReleaseHandler
          );

        await controller.reposCreateRelease(req, res, next);
      })
    );
  }

  private addReposGetReleaseAssetHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/releases/assets/:asset_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            asset_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'asset_id']
        }
      }),

      asyncRequestHandler<
        ReposGetReleaseAssetRequest,
        ReposGetReleaseAssetResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetReleaseAssetHandler>(
            Handlers.ReposGetReleaseAssetHandler
          );

        await controller.reposGetReleaseAsset(req, res, next);
      })
    );
  }

  private addReposUpdateReleaseAssetHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/releases/assets/:asset_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: {
              type: 'string',
              description: 'The file name of the asset.'
            },
            label: {
              type: 'string',
              description:
                'An alternate short description of the asset. Used in place of the filename.'
            },
            state: { type: 'string', example: '"uploaded"' }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            asset_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'asset_id']
        }
      }),

      asyncRequestHandler<
        ReposUpdateReleaseAssetRequest,
        ReposUpdateReleaseAssetResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposUpdateReleaseAssetHandler>(
            Handlers.ReposUpdateReleaseAssetHandler
          );

        await controller.reposUpdateReleaseAsset(req, res, next);
      })
    );
  }

  private addReposDeleteReleaseAssetHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/releases/assets/:asset_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            asset_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'asset_id']
        }
      }),

      asyncRequestHandler<
        ReposDeleteReleaseAssetRequest,
        ReposDeleteReleaseAssetResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteReleaseAssetHandler>(
            Handlers.ReposDeleteReleaseAssetHandler
          );

        await controller.reposDeleteReleaseAsset(req, res, next);
      })
    );
  }

  private addReposGenerateReleaseNotesHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/releases/generate-notes',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            tag_name: {
              type: 'string',
              description:
                'The tag name for the release. This can be an existing tag or a new one.'
            },
            target_commitish: {
              type: 'string',
              description:
                "Specifies the commitish value that will be the target for the release's tag. Required if the supplied tag_name does not reference an existing tag. Ignored if the tag_name already exists."
            },
            previous_tag_name: {
              type: 'string',
              description:
                'The name of the previous tag to use as the starting point for the release notes. Use to manually specify the range for the set of changes considered as part this release.'
            },
            configuration_file_path: {
              type: 'string',
              description:
                "Specifies a path to a file in the repository containing configuration settings used for generating the release notes. If unspecified, the configuration file located in the repository at '.github/release.yml' or '.github/release.yaml' will be used. If that is not present, the default configuration will be used."
            }
          },
          required: ['tag_name']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposGenerateReleaseNotesRequest,
        ReposGenerateReleaseNotesResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGenerateReleaseNotesHandler>(
            Handlers.ReposGenerateReleaseNotesHandler
          );

        await controller.reposGenerateReleaseNotes(req, res, next);
      })
    );
  }

  private addReposGetLatestReleaseHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/releases/latest',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposGetLatestReleaseRequest,
        ReposGetLatestReleaseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetLatestReleaseHandler>(
            Handlers.ReposGetLatestReleaseHandler
          );

        await controller.reposGetLatestRelease(req, res, next);
      })
    );
  }

  private addReposGetReleaseByTagHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/releases/tags/:tag',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            tag: { type: 'string' }
          },
          required: ['owner', 'repo', 'tag']
        }
      }),

      asyncRequestHandler<
        ReposGetReleaseByTagRequest,
        ReposGetReleaseByTagResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetReleaseByTagHandler>(
            Handlers.ReposGetReleaseByTagHandler
          );

        await controller.reposGetReleaseByTag(req, res, next);
      })
    );
  }

  private addReposGetReleaseHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/releases/:release_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            release_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'release_id']
        }
      }),

      asyncRequestHandler<ReposGetReleaseRequest, ReposGetReleaseResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetReleaseHandler>(Handlers.ReposGetReleaseHandler);

          await controller.reposGetRelease(req, res, next);
        }
      )
    );
  }

  private addReposUpdateReleaseHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/releases/:release_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            tag_name: { type: 'string', description: 'The name of the tag.' },
            target_commitish: {
              type: 'string',
              description:
                "Specifies the commitish value that determines where the Git tag is created from. Can be any branch or commit SHA. Unused if the Git tag already exists. Default: the repository's default branch (usually `master`)."
            },
            name: { type: 'string', description: 'The name of the release.' },
            body: {
              type: 'string',
              description: 'Text describing the contents of the tag.'
            },
            draft: {
              type: 'boolean',
              description:
                '`true` makes the release a draft, and `false` publishes the release.'
            },
            prerelease: {
              type: 'boolean',
              description:
                '`true` to identify the release as a prerelease, `false` to identify the release as a full release.'
            },
            discussion_category_name: {
              type: 'string',
              description:
                'If specified, a discussion of the specified category is created and linked to the release. The value must be a category that already exists in the repository. If there is already a discussion linked to the release, this parameter is ignored. For more information, see "[Managing categories for discussions in your repository](https://docs.github.com/discussions/managing-discussions-for-your-community/managing-categories-for-discussions-in-your-repository)."'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            release_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'release_id']
        }
      }),

      asyncRequestHandler<
        ReposUpdateReleaseRequest,
        ReposUpdateReleaseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposUpdateReleaseHandler>(
            Handlers.ReposUpdateReleaseHandler
          );

        await controller.reposUpdateRelease(req, res, next);
      })
    );
  }

  private addReposDeleteReleaseHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/releases/:release_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            release_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'release_id']
        }
      }),

      asyncRequestHandler<
        ReposDeleteReleaseRequest,
        ReposDeleteReleaseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteReleaseHandler>(
            Handlers.ReposDeleteReleaseHandler
          );

        await controller.reposDeleteRelease(req, res, next);
      })
    );
  }

  private addReposListReleaseAssetsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/releases/:release_id/assets',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            release_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'release_id']
        }
      }),

      asyncRequestHandler<
        ReposListReleaseAssetsRequest,
        ReposListReleaseAssetsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListReleaseAssetsHandler>(
            Handlers.ReposListReleaseAssetsHandler
          );

        await controller.reposListReleaseAssets(req, res, next);
      })
    );
  }

  private addReposUploadReleaseAssetHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/releases/:release_id/assets',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { name: { type: 'string' }, label: { type: 'string' } },
          required: ['name']
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            release_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'release_id']
        }
      }),

      asyncRequestHandler<
        ReposUploadReleaseAssetRequest,
        ReposUploadReleaseAssetResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposUploadReleaseAssetHandler>(
            Handlers.ReposUploadReleaseAssetHandler
          );

        await controller.reposUploadReleaseAsset(req, res, next);
      })
    );
  }

  private addReactionsListForReleaseHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/releases/:release_id/reactions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              enum: ['+1', 'laugh', 'heart', 'hooray', 'rocket', 'eyes']
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            release_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'release_id']
        }
      }),

      asyncRequestHandler<
        ReactionsListForReleaseRequest,
        ReactionsListForReleaseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsListForReleaseHandler>(
            Handlers.ReactionsListForReleaseHandler
          );

        await controller.reactionsListForRelease(req, res, next);
      })
    );
  }

  private addReactionsCreateForReleaseHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/releases/:release_id/reactions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              description:
                'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the release.',
              enum: ['+1', 'laugh', 'heart', 'hooray', 'rocket', 'eyes']
            }
          },
          required: ['content']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            release_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'release_id']
        }
      }),

      asyncRequestHandler<
        ReactionsCreateForReleaseRequest,
        ReactionsCreateForReleaseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsCreateForReleaseHandler>(
            Handlers.ReactionsCreateForReleaseHandler
          );

        await controller.reactionsCreateForRelease(req, res, next);
      })
    );
  }

  private addReactionsDeleteForReleaseHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/releases/:release_id/reactions/:reaction_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            release_id: { type: 'integer' },
            reaction_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'release_id', 'reaction_id']
        }
      }),

      asyncRequestHandler<
        ReactionsDeleteForReleaseRequest,
        ReactionsDeleteForReleaseResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsDeleteForReleaseHandler>(
            Handlers.ReactionsDeleteForReleaseHandler
          );

        await controller.reactionsDeleteForRelease(req, res, next);
      })
    );
  }

  private addSecretScanningListAlertsForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/secret-scanning/alerts',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            state: { type: 'string', enum: ['open', 'resolved'] },
            secret_type: { type: 'string' },
            resolution: { type: 'string' },
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 },
            before: { type: 'string' },
            after: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        SecretScanningListAlertsForRepoRequest,
        SecretScanningListAlertsForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<SecretScanningListAlertsForRepoHandler>(
            Handlers.SecretScanningListAlertsForRepoHandler
          );

        await controller.secretScanningListAlertsForRepo(req, res, next);
      })
    );
  }

  private addSecretScanningGetAlertHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/secret-scanning/alerts/:alert_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            alert_number: { $ref: '#/definitions/alert-number' }
          },
          required: ['owner', 'repo', 'alert_number'],
          definitions: {
            'alert-number': {
              type: 'integer',
              description: 'The security alert number.',
              readOnly: true,
              title: 'alert-number'
            }
          }
        }
      }),

      asyncRequestHandler<
        SecretScanningGetAlertRequest,
        SecretScanningGetAlertResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<SecretScanningGetAlertHandler>(
            Handlers.SecretScanningGetAlertHandler
          );

        await controller.secretScanningGetAlert(req, res, next);
      })
    );
  }

  private addSecretScanningUpdateAlertHandler(router: Router): void {
    router.patch(
      '/repos/:owner/:repo/secret-scanning/alerts/:alert_number',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            state: { $ref: '#/definitions/secret-scanning-alert-state' },
            resolution: {
              $ref: '#/definitions/secret-scanning-alert-resolution'
            },
            resolution_comment: {
              $ref: '#/definitions/secret-scanning-alert-resolution-comment'
            }
          },
          required: ['state'],
          definitions: {
            'secret-scanning-alert-state': {
              description:
                'Sets the state of the secret scanning alert. You must provide `resolution` when you set the state to `resolved`.',
              type: 'string',
              enum: ['open', 'resolved'],
              title: 'secret-scanning-alert-state'
            },
            'secret-scanning-alert-resolution': {
              type: 'string',
              description:
                '**Required when the `state` is `resolved`.** The reason for resolving the alert.',
              nullable: true,
              enum: [
                null,
                'false_positive',
                'wont_fix',
                'revoked',
                'used_in_tests'
              ],
              title: 'secret-scanning-alert-resolution'
            },
            'secret-scanning-alert-resolution-comment': {
              description:
                'An optional comment when closing an alert. Cannot be updated or deleted. Must be `null` when changing `state` to `open`.',
              type: 'string',
              nullable: true,
              title: 'secret-scanning-alert-resolution-comment'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            alert_number: { $ref: '#/definitions/alert-number' }
          },
          required: ['owner', 'repo', 'alert_number'],
          definitions: {
            'alert-number': {
              type: 'integer',
              description: 'The security alert number.',
              readOnly: true,
              title: 'alert-number'
            }
          }
        }
      }),

      asyncRequestHandler<
        SecretScanningUpdateAlertRequest,
        SecretScanningUpdateAlertResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<SecretScanningUpdateAlertHandler>(
            Handlers.SecretScanningUpdateAlertHandler
          );

        await controller.secretScanningUpdateAlert(req, res, next);
      })
    );
  }

  private addSecretScanningListLocationsForAlertHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/secret-scanning/alerts/:alert_number/locations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            alert_number: { $ref: '#/definitions/alert-number' }
          },
          required: ['owner', 'repo', 'alert_number'],
          definitions: {
            'alert-number': {
              type: 'integer',
              description: 'The security alert number.',
              readOnly: true,
              title: 'alert-number'
            }
          }
        }
      }),

      asyncRequestHandler<
        SecretScanningListLocationsForAlertRequest,
        SecretScanningListLocationsForAlertResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<SecretScanningListLocationsForAlertHandler>(
            Handlers.SecretScanningListLocationsForAlertHandler
          );

        await controller.secretScanningListLocationsForAlert(req, res, next);
      })
    );
  }

  private addActivityListStargazersForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/stargazers',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActivityListStargazersForRepoRequest,
        ActivityListStargazersForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListStargazersForRepoHandler>(
            Handlers.ActivityListStargazersForRepoHandler
          );

        await controller.activityListStargazersForRepo(req, res, next);
      })
    );
  }

  private addReposGetCodeFrequencyStatsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/stats/code_frequency',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposGetCodeFrequencyStatsRequest,
        ReposGetCodeFrequencyStatsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetCodeFrequencyStatsHandler>(
            Handlers.ReposGetCodeFrequencyStatsHandler
          );

        await controller.reposGetCodeFrequencyStats(req, res, next);
      })
    );
  }

  private addReposGetCommitActivityStatsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/stats/commit_activity',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposGetCommitActivityStatsRequest,
        ReposGetCommitActivityStatsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetCommitActivityStatsHandler>(
            Handlers.ReposGetCommitActivityStatsHandler
          );

        await controller.reposGetCommitActivityStats(req, res, next);
      })
    );
  }

  private addReposGetContributorsStatsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/stats/contributors',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposGetContributorsStatsRequest,
        ReposGetContributorsStatsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetContributorsStatsHandler>(
            Handlers.ReposGetContributorsStatsHandler
          );

        await controller.reposGetContributorsStats(req, res, next);
      })
    );
  }

  private addReposGetParticipationStatsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/stats/participation',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposGetParticipationStatsRequest,
        ReposGetParticipationStatsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetParticipationStatsHandler>(
            Handlers.ReposGetParticipationStatsHandler
          );

        await controller.reposGetParticipationStats(req, res, next);
      })
    );
  }

  private addReposGetPunchCardStatsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/stats/punch_card',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposGetPunchCardStatsRequest,
        ReposGetPunchCardStatsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetPunchCardStatsHandler>(
            Handlers.ReposGetPunchCardStatsHandler
          );

        await controller.reposGetPunchCardStats(req, res, next);
      })
    );
  }

  private addReposCreateCommitStatusHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/statuses/:sha',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            state: {
              type: 'string',
              description: 'The state of the status.',
              enum: ['error', 'failure', 'pending', 'success']
            },
            target_url: {
              type: 'string',
              nullable: true,
              description:
                'The target URL to associate with this status. This URL will be linked from the GitHub UI to allow users to easily see the source of the status.  \nFor example, if your continuous integration system is posting build status, you would want to provide the deep link for the build output for this specific SHA:  \n`http://ci.example.com/user/repo/build/sha`'
            },
            description: {
              type: 'string',
              nullable: true,
              description: 'A short description of the status.'
            },
            context: {
              type: 'string',
              description:
                'A string label to differentiate this status from the status of other systems. This field is case-insensitive.',
              default: 'default'
            }
          },
          required: ['state']
        },

        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            sha: { type: 'string' }
          },
          required: ['owner', 'repo', 'sha']
        }
      }),

      asyncRequestHandler<
        ReposCreateCommitStatusRequest,
        ReposCreateCommitStatusResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateCommitStatusHandler>(
            Handlers.ReposCreateCommitStatusHandler
          );

        await controller.reposCreateCommitStatus(req, res, next);
      })
    );
  }

  private addActivityListWatchersForRepoHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/subscribers',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActivityListWatchersForRepoRequest,
        ActivityListWatchersForRepoResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListWatchersForRepoHandler>(
            Handlers.ActivityListWatchersForRepoHandler
          );

        await controller.activityListWatchersForRepo(req, res, next);
      })
    );
  }

  private addActivityGetRepoSubscriptionHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/subscription',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActivityGetRepoSubscriptionRequest,
        ActivityGetRepoSubscriptionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityGetRepoSubscriptionHandler>(
            Handlers.ActivityGetRepoSubscriptionHandler
          );

        await controller.activityGetRepoSubscription(req, res, next);
      })
    );
  }

  private addActivitySetRepoSubscriptionHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/subscription',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            subscribed: {
              type: 'boolean',
              description:
                'Determines if notifications should be received from this repository.'
            },
            ignored: {
              type: 'boolean',
              description:
                'Determines if all notifications should be blocked from this repository.'
            }
          }
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActivitySetRepoSubscriptionRequest,
        ActivitySetRepoSubscriptionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivitySetRepoSubscriptionHandler>(
            Handlers.ActivitySetRepoSubscriptionHandler
          );

        await controller.activitySetRepoSubscription(req, res, next);
      })
    );
  }

  private addActivityDeleteRepoSubscriptionHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/subscription',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActivityDeleteRepoSubscriptionRequest,
        ActivityDeleteRepoSubscriptionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityDeleteRepoSubscriptionHandler>(
            Handlers.ActivityDeleteRepoSubscriptionHandler
          );

        await controller.activityDeleteRepoSubscription(req, res, next);
      })
    );
  }

  private addReposListTagsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/tags',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposListTagsRequest, ReposListTagsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposListTagsHandler>(Handlers.ReposListTagsHandler);

          await controller.reposListTags(req, res, next);
        }
      )
    );
  }

  private addReposListTagProtectionHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/tags/protection',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposListTagProtectionRequest,
        ReposListTagProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListTagProtectionHandler>(
            Handlers.ReposListTagProtectionHandler
          );

        await controller.reposListTagProtection(req, res, next);
      })
    );
  }

  private addReposCreateTagProtectionHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/tags/protection',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            pattern: {
              type: 'string',
              description:
                'An optional glob pattern to match against when enforcing tag protection.'
            }
          },
          required: ['pattern']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposCreateTagProtectionRequest,
        ReposCreateTagProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateTagProtectionHandler>(
            Handlers.ReposCreateTagProtectionHandler
          );

        await controller.reposCreateTagProtection(req, res, next);
      })
    );
  }

  private addReposDeleteTagProtectionHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/tags/protection/:tag_protection_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            tag_protection_id: { type: 'integer' }
          },
          required: ['owner', 'repo', 'tag_protection_id']
        }
      }),

      asyncRequestHandler<
        ReposDeleteTagProtectionRequest,
        ReposDeleteTagProtectionResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeleteTagProtectionHandler>(
            Handlers.ReposDeleteTagProtectionHandler
          );

        await controller.reposDeleteTagProtection(req, res, next);
      })
    );
  }

  private addReposDownloadTarballArchiveHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/tarball/:ref',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            ref: { type: 'string' }
          },
          required: ['owner', 'repo', 'ref']
        }
      }),

      asyncRequestHandler<
        ReposDownloadTarballArchiveRequest,
        ReposDownloadTarballArchiveResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDownloadTarballArchiveHandler>(
            Handlers.ReposDownloadTarballArchiveHandler
          );

        await controller.reposDownloadTarballArchive(req, res, next);
      })
    );
  }

  private addReposListTeamsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/teams',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposListTeamsRequest, ReposListTeamsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposListTeamsHandler>(Handlers.ReposListTeamsHandler);

          await controller.reposListTeams(req, res, next);
        }
      )
    );
  }

  private addReposGetAllTopicsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/topics',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposGetAllTopicsRequest, ReposGetAllTopicsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetAllTopicsHandler>(
              Handlers.ReposGetAllTopicsHandler
            );

          await controller.reposGetAllTopics(req, res, next);
        }
      )
    );
  }

  private addReposReplaceAllTopicsHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/topics',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            names: {
              type: 'array',
              description:
                'An array of topics to add to the repository. Pass one or more topics to _replace_ the set of existing topics. Send an empty array (`[]`) to clear all topics from the repository. **Note:** Topic `names` cannot contain uppercase letters.',
              items: { type: 'string' }
            }
          },
          required: ['names']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposReplaceAllTopicsRequest,
        ReposReplaceAllTopicsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposReplaceAllTopicsHandler>(
            Handlers.ReposReplaceAllTopicsHandler
          );

        await controller.reposReplaceAllTopics(req, res, next);
      })
    );
  }

  private addReposGetClonesHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/traffic/clones',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per: { type: 'string', enum: ['', 'day', 'week'], default: 'day' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposGetClonesRequest, ReposGetClonesResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetClonesHandler>(Handlers.ReposGetClonesHandler);

          await controller.reposGetClones(req, res, next);
        }
      )
    );
  }

  private addReposGetTopPathsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/traffic/popular/paths',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposGetTopPathsRequest, ReposGetTopPathsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetTopPathsHandler>(Handlers.ReposGetTopPathsHandler);

          await controller.reposGetTopPaths(req, res, next);
        }
      )
    );
  }

  private addReposGetTopReferrersHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/traffic/popular/referrers',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposGetTopReferrersRequest,
        ReposGetTopReferrersResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposGetTopReferrersHandler>(
            Handlers.ReposGetTopReferrersHandler
          );

        await controller.reposGetTopReferrers(req, res, next);
      })
    );
  }

  private addReposGetViewsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/traffic/views',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per: { type: 'string', enum: ['', 'day', 'week'], default: 'day' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposGetViewsRequest, ReposGetViewsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposGetViewsHandler>(Handlers.ReposGetViewsHandler);

          await controller.reposGetViews(req, res, next);
        }
      )
    );
  }

  private addReposTransferHandler(router: Router): void {
    router.post(
      '/repos/:owner/:repo/transfer',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            new_owner: {
              type: 'string',
              description:
                'The username or organization name the repository will be transferred to.'
            },
            team_ids: {
              type: 'array',
              description:
                'ID of the team or teams to add to the repository. Teams can only be added to organization-owned repositories.',
              items: { type: 'integer' }
            }
          },
          required: ['new_owner']
        },

        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<ReposTransferRequest, ReposTransferResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposTransferHandler>(Handlers.ReposTransferHandler);

          await controller.reposTransfer(req, res, next);
        }
      )
    );
  }

  private addReposCheckVulnerabilityAlertsHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/vulnerability-alerts',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposCheckVulnerabilityAlertsRequest,
        ReposCheckVulnerabilityAlertsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCheckVulnerabilityAlertsHandler>(
            Handlers.ReposCheckVulnerabilityAlertsHandler
          );

        await controller.reposCheckVulnerabilityAlerts(req, res, next);
      })
    );
  }

  private addReposEnableVulnerabilityAlertsHandler(router: Router): void {
    router.put(
      '/repos/:owner/:repo/vulnerability-alerts',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposEnableVulnerabilityAlertsRequest,
        ReposEnableVulnerabilityAlertsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposEnableVulnerabilityAlertsHandler>(
            Handlers.ReposEnableVulnerabilityAlertsHandler
          );

        await controller.reposEnableVulnerabilityAlerts(req, res, next);
      })
    );
  }

  private addReposDisableVulnerabilityAlertsHandler(router: Router): void {
    router.delete(
      '/repos/:owner/:repo/vulnerability-alerts',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ReposDisableVulnerabilityAlertsRequest,
        ReposDisableVulnerabilityAlertsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDisableVulnerabilityAlertsHandler>(
            Handlers.ReposDisableVulnerabilityAlertsHandler
          );

        await controller.reposDisableVulnerabilityAlerts(req, res, next);
      })
    );
  }

  private addReposDownloadZipballArchiveHandler(router: Router): void {
    router.get(
      '/repos/:owner/:repo/zipball/:ref',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            owner: { type: 'string' },
            repo: { type: 'string' },
            ref: { type: 'string' }
          },
          required: ['owner', 'repo', 'ref']
        }
      }),

      asyncRequestHandler<
        ReposDownloadZipballArchiveRequest,
        ReposDownloadZipballArchiveResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDownloadZipballArchiveHandler>(
            Handlers.ReposDownloadZipballArchiveHandler
          );

        await controller.reposDownloadZipballArchive(req, res, next);
      })
    );
  }

  private addReposCreateUsingTemplateHandler(router: Router): void {
    router.post(
      '/repos/:template_owner/:template_repo/generate',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            owner: {
              type: 'string',
              description:
                'The organization or person who will own the new repository. To create a new repository in an organization, the authenticated user must be a member of the specified organization.'
            },
            name: {
              type: 'string',
              description: 'The name of the new repository.'
            },
            description: {
              type: 'string',
              description: 'A short description of the new repository.'
            },
            include_all_branches: {
              type: 'boolean',
              description:
                'Set to `true` to include the directory structure and files from all branches in the template repository, and not just the default branch. Default: `false`.',
              default: false
            },
            private: {
              type: 'boolean',
              description:
                'Either `true` to create a new private repository or `false` to create a new public one.',
              default: false
            }
          },
          required: ['name']
        },

        params: {
          type: 'object',
          properties: {
            template_owner: { type: 'string' },
            template_repo: { type: 'string' }
          },
          required: ['template_owner', 'template_repo']
        }
      }),

      asyncRequestHandler<
        ReposCreateUsingTemplateRequest,
        ReposCreateUsingTemplateResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateUsingTemplateHandler>(
            Handlers.ReposCreateUsingTemplateHandler
          );

        await controller.reposCreateUsingTemplate(req, res, next);
      })
    );
  }

  private addReposListPublicHandler(router: Router): void {
    router.get(
      '/repositories',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { since: { type: 'integer' } },
          required: []
        }
      }),

      asyncRequestHandler<ReposListPublicRequest, ReposListPublicResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposListPublicHandler>(Handlers.ReposListPublicHandler);

          await controller.reposListPublic(req, res, next);
        }
      )
    );
  }

  private addActionsListEnvironmentSecretsHandler(router: Router): void {
    router.get(
      '/repositories/:repository_id/environments/:environment_name/secrets',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            repository_id: { type: 'integer' },
            environment_name: { type: 'string' }
          },
          required: ['repository_id', 'environment_name']
        }
      }),

      asyncRequestHandler<
        ActionsListEnvironmentSecretsRequest,
        ActionsListEnvironmentSecretsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsListEnvironmentSecretsHandler>(
            Handlers.ActionsListEnvironmentSecretsHandler
          );

        await controller.actionsListEnvironmentSecrets(req, res, next);
      })
    );
  }

  private addActionsGetEnvironmentPublicKeyHandler(router: Router): void {
    router.get(
      '/repositories/:repository_id/environments/:environment_name/secrets/public-key',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            repository_id: { type: 'integer' },
            environment_name: { type: 'string' }
          },
          required: ['repository_id', 'environment_name']
        }
      }),

      asyncRequestHandler<
        ActionsGetEnvironmentPublicKeyRequest,
        ActionsGetEnvironmentPublicKeyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetEnvironmentPublicKeyHandler>(
            Handlers.ActionsGetEnvironmentPublicKeyHandler
          );

        await controller.actionsGetEnvironmentPublicKey(req, res, next);
      })
    );
  }

  private addActionsGetEnvironmentSecretHandler(router: Router): void {
    router.get(
      '/repositories/:repository_id/environments/:environment_name/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            repository_id: { type: 'integer' },
            environment_name: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['repository_id', 'environment_name', 'secret_name']
        }
      }),

      asyncRequestHandler<
        ActionsGetEnvironmentSecretRequest,
        ActionsGetEnvironmentSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsGetEnvironmentSecretHandler>(
            Handlers.ActionsGetEnvironmentSecretHandler
          );

        await controller.actionsGetEnvironmentSecret(req, res, next);
      })
    );
  }

  private addActionsCreateOrUpdateEnvironmentSecretHandler(
    router: Router
  ): void {
    router.put(
      '/repositories/:repository_id/environments/:environment_name/secrets/:secret_name',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            encrypted_value: {
              type: 'string',
              description:
                'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get an environment public key](https://docs.github.com/rest/reference/actions#get-an-environment-public-key) endpoint.',
              pattern:
                '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
            },
            key_id: {
              type: 'string',
              description: 'ID of the key you used to encrypt the secret.'
            }
          },
          required: ['encrypted_value', 'key_id']
        },

        params: {
          type: 'object',
          properties: {
            repository_id: { type: 'integer' },
            environment_name: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['repository_id', 'environment_name', 'secret_name']
        }
      }),

      asyncRequestHandler<
        ActionsCreateOrUpdateEnvironmentSecretRequest,
        ActionsCreateOrUpdateEnvironmentSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsCreateOrUpdateEnvironmentSecretHandler>(
            Handlers.ActionsCreateOrUpdateEnvironmentSecretHandler
          );

        await controller.actionsCreateOrUpdateEnvironmentSecret(req, res, next);
      })
    );
  }

  private addActionsDeleteEnvironmentSecretHandler(router: Router): void {
    router.delete(
      '/repositories/:repository_id/environments/:environment_name/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            repository_id: { type: 'integer' },
            environment_name: { type: 'string' },
            secret_name: { type: 'string' }
          },
          required: ['repository_id', 'environment_name', 'secret_name']
        }
      }),

      asyncRequestHandler<
        ActionsDeleteEnvironmentSecretRequest,
        ActionsDeleteEnvironmentSecretResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActionsDeleteEnvironmentSecretHandler>(
            Handlers.ActionsDeleteEnvironmentSecretHandler
          );

        await controller.actionsDeleteEnvironmentSecret(req, res, next);
      })
    );
  }

  private addSearchCodeHandler(router: Router): void {
    router.get(
      '/search/code',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            q: { type: 'string' },
            sort: { type: 'string', enum: ['indexed'] },
            order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: ['q']
        }
      }),

      asyncRequestHandler<SearchCodeRequest, SearchCodeResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<SearchCodeHandler>(Handlers.SearchCodeHandler);

          await controller.searchCode(req, res, next);
        }
      )
    );
  }

  private addSearchCommitsHandler(router: Router): void {
    router.get(
      '/search/commits',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            q: { type: 'string' },
            sort: { type: 'string', enum: ['author-date', 'committer-date'] },
            order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: ['q']
        }
      }),

      asyncRequestHandler<SearchCommitsRequest, SearchCommitsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<SearchCommitsHandler>(Handlers.SearchCommitsHandler);

          await controller.searchCommits(req, res, next);
        }
      )
    );
  }

  private addSearchIssuesAndPullRequestsHandler(router: Router): void {
    router.get(
      '/search/issues',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            q: { type: 'string' },
            sort: {
              type: 'string',
              enum: [
                'comments',
                'reactions',
                'reactions-+1',
                'reactions--1',
                'reactions-smile',
                'reactions-thinking_face',
                'reactions-heart',
                'reactions-tada',
                'interactions',
                'created',
                'updated'
              ]
            },
            order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: ['q']
        }
      }),

      asyncRequestHandler<
        SearchIssuesAndPullRequestsRequest,
        SearchIssuesAndPullRequestsResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<SearchIssuesAndPullRequestsHandler>(
            Handlers.SearchIssuesAndPullRequestsHandler
          );

        await controller.searchIssuesAndPullRequests(req, res, next);
      })
    );
  }

  private addSearchLabelsHandler(router: Router): void {
    router.get(
      '/search/labels',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            repository_id: { type: 'integer' },
            q: { type: 'string' },
            sort: { type: 'string', enum: ['created', 'updated'] },
            order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: ['repository_id', 'q']
        }
      }),

      asyncRequestHandler<SearchLabelsRequest, SearchLabelsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<SearchLabelsHandler>(Handlers.SearchLabelsHandler);

          await controller.searchLabels(req, res, next);
        }
      )
    );
  }

  private addSearchReposHandler(router: Router): void {
    router.get(
      '/search/repositories',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            q: { type: 'string' },
            sort: {
              type: 'string',
              enum: ['stars', 'forks', 'help-wanted-issues', 'updated']
            },
            order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: ['q']
        }
      }),

      asyncRequestHandler<SearchReposRequest, SearchReposResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<SearchReposHandler>(Handlers.SearchReposHandler);

          await controller.searchRepos(req, res, next);
        }
      )
    );
  }

  private addSearchTopicsHandler(router: Router): void {
    router.get(
      '/search/topics',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            q: { type: 'string' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: ['q']
        }
      }),

      asyncRequestHandler<SearchTopicsRequest, SearchTopicsResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<SearchTopicsHandler>(Handlers.SearchTopicsHandler);

          await controller.searchTopics(req, res, next);
        }
      )
    );
  }

  private addSearchUsersHandler(router: Router): void {
    router.get(
      '/search/users',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            q: { type: 'string' },
            sort: {
              type: 'string',
              enum: ['followers', 'repositories', 'joined']
            },
            order: { type: 'string', enum: ['desc', 'asc'], default: 'desc' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: ['q']
        }
      }),

      asyncRequestHandler<SearchUsersRequest, SearchUsersResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<SearchUsersHandler>(Handlers.SearchUsersHandler);

          await controller.searchUsers(req, res, next);
        }
      )
    );
  }

  private addTeamsGetLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { team_id: { type: 'integer' } },
          required: ['team_id']
        }
      }),

      asyncRequestHandler<TeamsGetLegacyRequest, TeamsGetLegacyResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<TeamsGetLegacyHandler>(Handlers.TeamsGetLegacyHandler);

          await controller.teamsGetLegacy(req, res, next);
        }
      )
    );
  }

  private addTeamsUpdateLegacyHandler(router: Router): void {
    router.patch(
      '/teams/:team_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: { type: 'string', description: 'The name of the team.' },
            description: {
              type: 'string',
              description: 'The description of the team.'
            },
            privacy: {
              type: 'string',
              description:
                'The level of privacy this team should have. Editing teams without specifying this parameter leaves `privacy` intact. The options are:  \n**For a non-nested team:**  \n\\* `secret` - only visible to organization owners and members of this team.  \n\\* `closed` - visible to all members of this organization.  \n**For a parent or child team:**  \n\\* `closed` - visible to all members of this organization.',
              enum: ['secret', 'closed']
            },
            permission: {
              type: 'string',
              description:
                '**Deprecated**. The permission that new repositories will be added to the team with when none is specified.',
              enum: ['pull', 'push', 'admin'],
              default: 'pull'
            },
            parent_team_id: {
              type: 'integer',
              description: 'The ID of a team to set as the parent team.',
              nullable: true
            }
          },
          required: ['name']
        },

        params: {
          type: 'object',
          properties: { team_id: { type: 'integer' } },
          required: ['team_id']
        }
      }),

      asyncRequestHandler<TeamsUpdateLegacyRequest, TeamsUpdateLegacyResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<TeamsUpdateLegacyHandler>(
              Handlers.TeamsUpdateLegacyHandler
            );

          await controller.teamsUpdateLegacy(req, res, next);
        }
      )
    );
  }

  private addTeamsDeleteLegacyHandler(router: Router): void {
    router.delete(
      '/teams/:team_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { team_id: { type: 'integer' } },
          required: ['team_id']
        }
      }),

      asyncRequestHandler<TeamsDeleteLegacyRequest, TeamsDeleteLegacyResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<TeamsDeleteLegacyHandler>(
              Handlers.TeamsDeleteLegacyHandler
            );

          await controller.teamsDeleteLegacy(req, res, next);
        }
      )
    );
  }

  private addTeamsListDiscussionsLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id/discussions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { team_id: { type: 'integer' } },
          required: ['team_id']
        }
      }),

      asyncRequestHandler<
        TeamsListDiscussionsLegacyRequest,
        TeamsListDiscussionsLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListDiscussionsLegacyHandler>(
            Handlers.TeamsListDiscussionsLegacyHandler
          );

        await controller.teamsListDiscussionsLegacy(req, res, next);
      })
    );
  }

  private addTeamsCreateDiscussionLegacyHandler(router: Router): void {
    router.post(
      '/teams/:team_id/discussions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            title: {
              type: 'string',
              description: "The discussion post's title."
            },
            body: {
              type: 'string',
              description: "The discussion post's body text."
            },
            private: {
              type: 'boolean',
              description:
                'Private posts are only visible to team members, organization owners, and team maintainers. Public posts are visible to all members of the organization. Set to `true` to create a private post.',
              default: false
            }
          },
          required: ['title', 'body']
        },

        params: {
          type: 'object',
          properties: { team_id: { type: 'integer' } },
          required: ['team_id']
        }
      }),

      asyncRequestHandler<
        TeamsCreateDiscussionLegacyRequest,
        TeamsCreateDiscussionLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsCreateDiscussionLegacyHandler>(
            Handlers.TeamsCreateDiscussionLegacyHandler
          );

        await controller.teamsCreateDiscussionLegacy(req, res, next);
      })
    );
  }

  private addTeamsGetDiscussionLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id/discussions/:discussion_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            discussion_number: { type: 'integer' }
          },
          required: ['team_id', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        TeamsGetDiscussionLegacyRequest,
        TeamsGetDiscussionLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsGetDiscussionLegacyHandler>(
            Handlers.TeamsGetDiscussionLegacyHandler
          );

        await controller.teamsGetDiscussionLegacy(req, res, next);
      })
    );
  }

  private addTeamsUpdateDiscussionLegacyHandler(router: Router): void {
    router.patch(
      '/teams/:team_id/discussions/:discussion_number',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            title: {
              type: 'string',
              description: "The discussion post's title."
            },
            body: {
              type: 'string',
              description: "The discussion post's body text."
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            discussion_number: { type: 'integer' }
          },
          required: ['team_id', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        TeamsUpdateDiscussionLegacyRequest,
        TeamsUpdateDiscussionLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsUpdateDiscussionLegacyHandler>(
            Handlers.TeamsUpdateDiscussionLegacyHandler
          );

        await controller.teamsUpdateDiscussionLegacy(req, res, next);
      })
    );
  }

  private addTeamsDeleteDiscussionLegacyHandler(router: Router): void {
    router.delete(
      '/teams/:team_id/discussions/:discussion_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            discussion_number: { type: 'integer' }
          },
          required: ['team_id', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        TeamsDeleteDiscussionLegacyRequest,
        TeamsDeleteDiscussionLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsDeleteDiscussionLegacyHandler>(
            Handlers.TeamsDeleteDiscussionLegacyHandler
          );

        await controller.teamsDeleteDiscussionLegacy(req, res, next);
      })
    );
  }

  private addTeamsListDiscussionCommentsLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id/discussions/:discussion_number/comments',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            discussion_number: { type: 'integer' }
          },
          required: ['team_id', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        TeamsListDiscussionCommentsLegacyRequest,
        TeamsListDiscussionCommentsLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListDiscussionCommentsLegacyHandler>(
            Handlers.TeamsListDiscussionCommentsLegacyHandler
          );

        await controller.teamsListDiscussionCommentsLegacy(req, res, next);
      })
    );
  }

  private addTeamsCreateDiscussionCommentLegacyHandler(router: Router): void {
    router.post(
      '/teams/:team_id/discussions/:discussion_number/comments',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
              description: "The discussion comment's body text."
            }
          },
          required: ['body']
        },

        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            discussion_number: { type: 'integer' }
          },
          required: ['team_id', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        TeamsCreateDiscussionCommentLegacyRequest,
        TeamsCreateDiscussionCommentLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsCreateDiscussionCommentLegacyHandler>(
            Handlers.TeamsCreateDiscussionCommentLegacyHandler
          );

        await controller.teamsCreateDiscussionCommentLegacy(req, res, next);
      })
    );
  }

  private addTeamsGetDiscussionCommentLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id/discussions/:discussion_number/comments/:comment_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            discussion_number: { type: 'integer' },
            comment_number: { type: 'integer' }
          },
          required: ['team_id', 'discussion_number', 'comment_number']
        }
      }),

      asyncRequestHandler<
        TeamsGetDiscussionCommentLegacyRequest,
        TeamsGetDiscussionCommentLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsGetDiscussionCommentLegacyHandler>(
            Handlers.TeamsGetDiscussionCommentLegacyHandler
          );

        await controller.teamsGetDiscussionCommentLegacy(req, res, next);
      })
    );
  }

  private addTeamsUpdateDiscussionCommentLegacyHandler(router: Router): void {
    router.patch(
      '/teams/:team_id/discussions/:discussion_number/comments/:comment_number',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            body: {
              type: 'string',
              description: "The discussion comment's body text."
            }
          },
          required: ['body']
        },

        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            discussion_number: { type: 'integer' },
            comment_number: { type: 'integer' }
          },
          required: ['team_id', 'discussion_number', 'comment_number']
        }
      }),

      asyncRequestHandler<
        TeamsUpdateDiscussionCommentLegacyRequest,
        TeamsUpdateDiscussionCommentLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsUpdateDiscussionCommentLegacyHandler>(
            Handlers.TeamsUpdateDiscussionCommentLegacyHandler
          );

        await controller.teamsUpdateDiscussionCommentLegacy(req, res, next);
      })
    );
  }

  private addTeamsDeleteDiscussionCommentLegacyHandler(router: Router): void {
    router.delete(
      '/teams/:team_id/discussions/:discussion_number/comments/:comment_number',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            discussion_number: { type: 'integer' },
            comment_number: { type: 'integer' }
          },
          required: ['team_id', 'discussion_number', 'comment_number']
        }
      }),

      asyncRequestHandler<
        TeamsDeleteDiscussionCommentLegacyRequest,
        TeamsDeleteDiscussionCommentLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsDeleteDiscussionCommentLegacyHandler>(
            Handlers.TeamsDeleteDiscussionCommentLegacyHandler
          );

        await controller.teamsDeleteDiscussionCommentLegacy(req, res, next);
      })
    );
  }

  private addReactionsListForTeamDiscussionCommentLegacyHandler(
    router: Router
  ): void {
    router.get(
      '/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            discussion_number: { type: 'integer' },
            comment_number: { type: 'integer' }
          },
          required: ['team_id', 'discussion_number', 'comment_number']
        }
      }),

      asyncRequestHandler<
        ReactionsListForTeamDiscussionCommentLegacyRequest,
        ReactionsListForTeamDiscussionCommentLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsListForTeamDiscussionCommentLegacyHandler>(
            Handlers.ReactionsListForTeamDiscussionCommentLegacyHandler
          );

        await controller.reactionsListForTeamDiscussionCommentLegacy(
          req,
          res,
          next
        );
      })
    );
  }

  private addReactionsCreateForTeamDiscussionCommentLegacyHandler(
    router: Router
  ): void {
    router.post(
      '/teams/:team_id/discussions/:discussion_number/comments/:comment_number/reactions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              description:
                'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion comment.',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            }
          },
          required: ['content']
        },

        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            discussion_number: { type: 'integer' },
            comment_number: { type: 'integer' }
          },
          required: ['team_id', 'discussion_number', 'comment_number']
        }
      }),

      asyncRequestHandler<
        ReactionsCreateForTeamDiscussionCommentLegacyRequest,
        ReactionsCreateForTeamDiscussionCommentLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsCreateForTeamDiscussionCommentLegacyHandler>(
            Handlers.ReactionsCreateForTeamDiscussionCommentLegacyHandler
          );

        await controller.reactionsCreateForTeamDiscussionCommentLegacy(
          req,
          res,
          next
        );
      })
    );
  }

  private addReactionsListForTeamDiscussionLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id/discussions/:discussion_number/reactions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            discussion_number: { type: 'integer' }
          },
          required: ['team_id', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        ReactionsListForTeamDiscussionLegacyRequest,
        ReactionsListForTeamDiscussionLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsListForTeamDiscussionLegacyHandler>(
            Handlers.ReactionsListForTeamDiscussionLegacyHandler
          );

        await controller.reactionsListForTeamDiscussionLegacy(req, res, next);
      })
    );
  }

  private addReactionsCreateForTeamDiscussionLegacyHandler(
    router: Router
  ): void {
    router.post(
      '/teams/:team_id/discussions/:discussion_number/reactions',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            content: {
              type: 'string',
              description:
                'The [reaction type](https://docs.github.com/rest/reference/reactions#reaction-types) to add to the team discussion.',
              enum: [
                '+1',
                '-1',
                'laugh',
                'confused',
                'heart',
                'hooray',
                'rocket',
                'eyes'
              ]
            }
          },
          required: ['content']
        },

        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            discussion_number: { type: 'integer' }
          },
          required: ['team_id', 'discussion_number']
        }
      }),

      asyncRequestHandler<
        ReactionsCreateForTeamDiscussionLegacyRequest,
        ReactionsCreateForTeamDiscussionLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReactionsCreateForTeamDiscussionLegacyHandler>(
            Handlers.ReactionsCreateForTeamDiscussionLegacyHandler
          );

        await controller.reactionsCreateForTeamDiscussionLegacy(req, res, next);
      })
    );
  }

  private addTeamsListPendingInvitationsLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id/invitations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { team_id: { type: 'integer' } },
          required: ['team_id']
        }
      }),

      asyncRequestHandler<
        TeamsListPendingInvitationsLegacyRequest,
        TeamsListPendingInvitationsLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListPendingInvitationsLegacyHandler>(
            Handlers.TeamsListPendingInvitationsLegacyHandler
          );

        await controller.teamsListPendingInvitationsLegacy(req, res, next);
      })
    );
  }

  private addTeamsListMembersLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id/members',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            role: {
              type: 'string',
              enum: ['member', 'maintainer', 'all'],
              default: 'all'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { team_id: { type: 'integer' } },
          required: ['team_id']
        }
      }),

      asyncRequestHandler<
        TeamsListMembersLegacyRequest,
        TeamsListMembersLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListMembersLegacyHandler>(
            Handlers.TeamsListMembersLegacyHandler
          );

        await controller.teamsListMembersLegacy(req, res, next);
      })
    );
  }

  private addTeamsGetMemberLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id/members/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            username: { type: 'string' }
          },
          required: ['team_id', 'username']
        }
      }),

      asyncRequestHandler<
        TeamsGetMemberLegacyRequest,
        TeamsGetMemberLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsGetMemberLegacyHandler>(
            Handlers.TeamsGetMemberLegacyHandler
          );

        await controller.teamsGetMemberLegacy(req, res, next);
      })
    );
  }

  private addTeamsAddMemberLegacyHandler(router: Router): void {
    router.put(
      '/teams/:team_id/members/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            username: { type: 'string' }
          },
          required: ['team_id', 'username']
        }
      }),

      asyncRequestHandler<
        TeamsAddMemberLegacyRequest,
        TeamsAddMemberLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsAddMemberLegacyHandler>(
            Handlers.TeamsAddMemberLegacyHandler
          );

        await controller.teamsAddMemberLegacy(req, res, next);
      })
    );
  }

  private addTeamsRemoveMemberLegacyHandler(router: Router): void {
    router.delete(
      '/teams/:team_id/members/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            username: { type: 'string' }
          },
          required: ['team_id', 'username']
        }
      }),

      asyncRequestHandler<
        TeamsRemoveMemberLegacyRequest,
        TeamsRemoveMemberLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsRemoveMemberLegacyHandler>(
            Handlers.TeamsRemoveMemberLegacyHandler
          );

        await controller.teamsRemoveMemberLegacy(req, res, next);
      })
    );
  }

  private addTeamsGetMembershipForUserLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id/memberships/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            username: { type: 'string' }
          },
          required: ['team_id', 'username']
        }
      }),

      asyncRequestHandler<
        TeamsGetMembershipForUserLegacyRequest,
        TeamsGetMembershipForUserLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsGetMembershipForUserLegacyHandler>(
            Handlers.TeamsGetMembershipForUserLegacyHandler
          );

        await controller.teamsGetMembershipForUserLegacy(req, res, next);
      })
    );
  }

  private addTeamsAddOrUpdateMembershipForUserLegacyHandler(
    router: Router
  ): void {
    router.put(
      '/teams/:team_id/memberships/:username',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            role: {
              type: 'string',
              description: 'The role that this user should have in the team.',
              enum: ['member', 'maintainer'],
              default: 'member'
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            username: { type: 'string' }
          },
          required: ['team_id', 'username']
        }
      }),

      asyncRequestHandler<
        TeamsAddOrUpdateMembershipForUserLegacyRequest,
        TeamsAddOrUpdateMembershipForUserLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsAddOrUpdateMembershipForUserLegacyHandler>(
            Handlers.TeamsAddOrUpdateMembershipForUserLegacyHandler
          );

        await controller.teamsAddOrUpdateMembershipForUserLegacy(
          req,
          res,
          next
        );
      })
    );
  }

  private addTeamsRemoveMembershipForUserLegacyHandler(router: Router): void {
    router.delete(
      '/teams/:team_id/memberships/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            username: { type: 'string' }
          },
          required: ['team_id', 'username']
        }
      }),

      asyncRequestHandler<
        TeamsRemoveMembershipForUserLegacyRequest,
        TeamsRemoveMembershipForUserLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsRemoveMembershipForUserLegacyHandler>(
            Handlers.TeamsRemoveMembershipForUserLegacyHandler
          );

        await controller.teamsRemoveMembershipForUserLegacy(req, res, next);
      })
    );
  }

  private addTeamsListProjectsLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id/projects',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { team_id: { type: 'integer' } },
          required: ['team_id']
        }
      }),

      asyncRequestHandler<
        TeamsListProjectsLegacyRequest,
        TeamsListProjectsLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListProjectsLegacyHandler>(
            Handlers.TeamsListProjectsLegacyHandler
          );

        await controller.teamsListProjectsLegacy(req, res, next);
      })
    );
  }

  private addTeamsCheckPermissionsForProjectLegacyHandler(
    router: Router
  ): void {
    router.get(
      '/teams/:team_id/projects/:project_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            project_id: { type: 'integer' }
          },
          required: ['team_id', 'project_id']
        }
      }),

      asyncRequestHandler<
        TeamsCheckPermissionsForProjectLegacyRequest,
        TeamsCheckPermissionsForProjectLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsCheckPermissionsForProjectLegacyHandler>(
            Handlers.TeamsCheckPermissionsForProjectLegacyHandler
          );

        await controller.teamsCheckPermissionsForProjectLegacy(req, res, next);
      })
    );
  }

  private addTeamsAddOrUpdateProjectPermissionsLegacyHandler(
    router: Router
  ): void {
    router.put(
      '/teams/:team_id/projects/:project_id',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            permission: {
              type: 'string',
              description:
                'The permission to grant to the team for this project. Default: the team\'s `permission` attribute will be used to determine what permission to grant the team on this project. Note that, if you choose not to pass any parameters, you\'ll need to set `Content-Length` to zero when calling this endpoint. For more information, see "[HTTP verbs](https://docs.github.com/rest/overview/resources-in-the-rest-api#http-verbs)."',
              enum: ['read', 'write', 'admin']
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            project_id: { type: 'integer' }
          },
          required: ['team_id', 'project_id']
        }
      }),

      asyncRequestHandler<
        TeamsAddOrUpdateProjectPermissionsLegacyRequest,
        TeamsAddOrUpdateProjectPermissionsLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsAddOrUpdateProjectPermissionsLegacyHandler>(
            Handlers.TeamsAddOrUpdateProjectPermissionsLegacyHandler
          );

        await controller.teamsAddOrUpdateProjectPermissionsLegacy(
          req,
          res,
          next
        );
      })
    );
  }

  private addTeamsRemoveProjectLegacyHandler(router: Router): void {
    router.delete(
      '/teams/:team_id/projects/:project_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            project_id: { type: 'integer' }
          },
          required: ['team_id', 'project_id']
        }
      }),

      asyncRequestHandler<
        TeamsRemoveProjectLegacyRequest,
        TeamsRemoveProjectLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsRemoveProjectLegacyHandler>(
            Handlers.TeamsRemoveProjectLegacyHandler
          );

        await controller.teamsRemoveProjectLegacy(req, res, next);
      })
    );
  }

  private addTeamsListReposLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id/repos',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { team_id: { type: 'integer' } },
          required: ['team_id']
        }
      }),

      asyncRequestHandler<
        TeamsListReposLegacyRequest,
        TeamsListReposLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListReposLegacyHandler>(
            Handlers.TeamsListReposLegacyHandler
          );

        await controller.teamsListReposLegacy(req, res, next);
      })
    );
  }

  private addTeamsCheckPermissionsForRepoLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id/repos/:owner/:repo',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            owner: { type: 'string' },
            repo: { type: 'string' }
          },
          required: ['team_id', 'owner', 'repo']
        }
      }),

      asyncRequestHandler<
        TeamsCheckPermissionsForRepoLegacyRequest,
        TeamsCheckPermissionsForRepoLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsCheckPermissionsForRepoLegacyHandler>(
            Handlers.TeamsCheckPermissionsForRepoLegacyHandler
          );

        await controller.teamsCheckPermissionsForRepoLegacy(req, res, next);
      })
    );
  }

  private addTeamsAddOrUpdateRepoPermissionsLegacyHandler(
    router: Router
  ): void {
    router.put(
      '/teams/:team_id/repos/:owner/:repo',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            permission: {
              type: 'string',
              description:
                "The permission to grant the team on this repository. If no permission is specified, the team's `permission` attribute will be used to determine what permission to grant the team on this repository.",
              enum: ['pull', 'push', 'admin']
            }
          }
        },

        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            owner: { type: 'string' },
            repo: { type: 'string' }
          },
          required: ['team_id', 'owner', 'repo']
        }
      }),

      asyncRequestHandler<
        TeamsAddOrUpdateRepoPermissionsLegacyRequest,
        TeamsAddOrUpdateRepoPermissionsLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsAddOrUpdateRepoPermissionsLegacyHandler>(
            Handlers.TeamsAddOrUpdateRepoPermissionsLegacyHandler
          );

        await controller.teamsAddOrUpdateRepoPermissionsLegacy(req, res, next);
      })
    );
  }

  private addTeamsRemoveRepoLegacyHandler(router: Router): void {
    router.delete(
      '/teams/:team_id/repos/:owner/:repo',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            team_id: { type: 'integer' },
            owner: { type: 'string' },
            repo: { type: 'string' }
          },
          required: ['team_id', 'owner', 'repo']
        }
      }),

      asyncRequestHandler<
        TeamsRemoveRepoLegacyRequest,
        TeamsRemoveRepoLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsRemoveRepoLegacyHandler>(
            Handlers.TeamsRemoveRepoLegacyHandler
          );

        await controller.teamsRemoveRepoLegacy(req, res, next);
      })
    );
  }

  private addTeamsListChildLegacyHandler(router: Router): void {
    router.get(
      '/teams/:team_id/teams',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { team_id: { type: 'integer' } },
          required: ['team_id']
        }
      }),

      asyncRequestHandler<
        TeamsListChildLegacyRequest,
        TeamsListChildLegacyResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListChildLegacyHandler>(
            Handlers.TeamsListChildLegacyHandler
          );

        await controller.teamsListChildLegacy(req, res, next);
      })
    );
  }

  private addUsersGetAuthenticatedHandler(router: Router): void {
    router.get(
      '/user',

      asyncRequestHandler<
        UsersGetAuthenticatedRequest,
        UsersGetAuthenticatedResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersGetAuthenticatedHandler>(
            Handlers.UsersGetAuthenticatedHandler
          );

        await controller.usersGetAuthenticated(req, res, next);
      })
    );
  }

  private addUsersUpdateAuthenticatedHandler(router: Router): void {
    router.patch(
      '/user',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            name: {
              description: 'The new name of the user.',
              type: 'string',
              example: 'Omar Jahandar'
            },
            email: {
              description: 'The publicly visible email address of the user.',
              type: 'string',
              example: 'omar@example.com'
            },
            blog: {
              description: 'The new blog URL of the user.',
              type: 'string',
              example: 'blog.example.com'
            },
            twitter_username: {
              description: 'The new Twitter username of the user.',
              type: 'string',
              example: 'therealomarj',
              nullable: true
            },
            company: {
              description: 'The new company of the user.',
              type: 'string',
              example: 'Acme corporation'
            },
            location: {
              description: 'The new location of the user.',
              type: 'string',
              example: 'Berlin, Germany'
            },
            hireable: {
              description: 'The new hiring availability of the user.',
              type: 'boolean'
            },
            bio: {
              description: 'The new short biography of the user.',
              type: 'string'
            }
          }
        }
      }),

      asyncRequestHandler<
        UsersUpdateAuthenticatedRequest,
        UsersUpdateAuthenticatedResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersUpdateAuthenticatedHandler>(
            Handlers.UsersUpdateAuthenticatedHandler
          );

        await controller.usersUpdateAuthenticated(req, res, next);
      })
    );
  }

  private addUsersListBlockedByAuthenticatedUserHandler(router: Router): void {
    router.get(
      '/user/blocks',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        UsersListBlockedByAuthenticatedUserRequest,
        UsersListBlockedByAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersListBlockedByAuthenticatedUserHandler>(
            Handlers.UsersListBlockedByAuthenticatedUserHandler
          );

        await controller.usersListBlockedByAuthenticatedUser(req, res, next);
      })
    );
  }

  private addUsersCheckBlockedHandler(router: Router): void {
    router.get(
      '/user/blocks/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<UsersCheckBlockedRequest, UsersCheckBlockedResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<UsersCheckBlockedHandler>(
              Handlers.UsersCheckBlockedHandler
            );

          await controller.usersCheckBlocked(req, res, next);
        }
      )
    );
  }

  private addUsersBlockHandler(router: Router): void {
    router.put(
      '/user/blocks/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<UsersBlockRequest, UsersBlockResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<UsersBlockHandler>(Handlers.UsersBlockHandler);

          await controller.usersBlock(req, res, next);
        }
      )
    );
  }

  private addUsersUnblockHandler(router: Router): void {
    router.delete(
      '/user/blocks/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<UsersUnblockRequest, UsersUnblockResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<UsersUnblockHandler>(Handlers.UsersUnblockHandler);

          await controller.usersUnblock(req, res, next);
        }
      )
    );
  }

  private addCodespacesListForAuthenticatedUserHandler(router: Router): void {
    router.get(
      '/user/codespaces',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 },
            repository_id: { type: 'integer' }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        CodespacesListForAuthenticatedUserRequest,
        CodespacesListForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesListForAuthenticatedUserHandler>(
            Handlers.CodespacesListForAuthenticatedUserHandler
          );

        await controller.codespacesListForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addCodespacesCreateForAuthenticatedUserHandler(router: Router): void {
    router.post(
      '/user/codespaces',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              required: ['repository_id'],
              properties: {
                repository_id: {
                  description: 'Repository id for this codespace',
                  type: 'integer'
                },
                ref: {
                  description:
                    'Git ref (typically a branch name) for this codespace',
                  type: 'string'
                },
                location: {
                  description:
                    'Location for this codespace. Assigned by IP if not provided',
                  type: 'string'
                },
                client_ip: {
                  description:
                    'IP for location auto-detection when proxying a request',
                  type: 'string'
                },
                machine: {
                  description: 'Machine type to use for this codespace',
                  type: 'string'
                },
                devcontainer_path: {
                  description:
                    'Path to devcontainer.json config to use for this codespace',
                  type: 'string'
                },
                multi_repo_permissions_opt_out: {
                  description:
                    'Whether to authorize requested permissions from devcontainer.json',
                  type: 'boolean'
                },
                working_directory: {
                  description: 'Working directory for this codespace',
                  type: 'string'
                },
                idle_timeout_minutes: {
                  description:
                    'Time in minutes before codespace stops from inactivity',
                  type: 'integer'
                },
                display_name: {
                  description: 'Display name for this codespace',
                  type: 'string'
                },
                retention_period_minutes: {
                  description:
                    'Duration in minutes after codespace has gone idle in which it will be deleted. Must be integer minutes between 0 and 43200 (30 days).',
                  type: 'integer'
                }
              }
            },
            {
              type: 'object',
              required: ['pull_request'],
              properties: {
                pull_request: {
                  required: ['pull_request_number', 'repository_id'],
                  description: 'Pull request number for this codespace',
                  type: 'object',
                  properties: {
                    pull_request_number: {
                      description: 'Pull request number',
                      type: 'integer'
                    },
                    repository_id: {
                      description: 'Repository id for this codespace',
                      type: 'integer'
                    }
                  }
                },
                location: {
                  description:
                    'Location for this codespace. Assigned by IP if not provided',
                  type: 'string'
                },
                machine: {
                  description: 'Machine type to use for this codespace',
                  type: 'string'
                },
                devcontainer_path: {
                  description:
                    'Path to devcontainer.json config to use for this codespace',
                  type: 'string'
                },
                working_directory: {
                  description: 'Working directory for this codespace',
                  type: 'string'
                },
                idle_timeout_minutes: {
                  description:
                    'Time in minutes before codespace stops from inactivity',
                  type: 'integer'
                }
              }
            }
          ]
        }
      }),

      asyncRequestHandler<
        CodespacesCreateForAuthenticatedUserRequest,
        CodespacesCreateForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesCreateForAuthenticatedUserHandler>(
            Handlers.CodespacesCreateForAuthenticatedUserHandler
          );

        await controller.codespacesCreateForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addCodespacesListSecretsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/codespaces/secrets',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        CodespacesListSecretsForAuthenticatedUserRequest,
        CodespacesListSecretsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesListSecretsForAuthenticatedUserHandler>(
            Handlers.CodespacesListSecretsForAuthenticatedUserHandler
          );

        await controller.codespacesListSecretsForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesGetPublicKeyForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/codespaces/secrets/public-key',

      asyncRequestHandler<
        CodespacesGetPublicKeyForAuthenticatedUserRequest,
        CodespacesGetPublicKeyForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesGetPublicKeyForAuthenticatedUserHandler>(
            Handlers.CodespacesGetPublicKeyForAuthenticatedUserHandler
          );

        await controller.codespacesGetPublicKeyForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesGetSecretForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/codespaces/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { secret_name: { type: 'string' } },
          required: ['secret_name']
        }
      }),

      asyncRequestHandler<
        CodespacesGetSecretForAuthenticatedUserRequest,
        CodespacesGetSecretForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesGetSecretForAuthenticatedUserHandler>(
            Handlers.CodespacesGetSecretForAuthenticatedUserHandler
          );

        await controller.codespacesGetSecretForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesCreateOrUpdateSecretForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.put(
      '/user/codespaces/secrets/:secret_name',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            encrypted_value: {
              type: 'string',
              description:
                'Value for your secret, encrypted with [LibSodium](https://libsodium.gitbook.io/doc/bindings_for_other_languages) using the public key retrieved from the [Get the public key for the authenticated user](https://docs.github.com/rest/reference/codespaces#get-the-public-key-for-the-authenticated-user) endpoint.',
              pattern:
                '^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4})$'
            },
            key_id: {
              type: 'string',
              description: 'ID of the key you used to encrypt the secret.'
            },
            selected_repository_ids: {
              type: 'array',
              description:
                'An array of repository ids that can access the user secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/reference/codespaces#list-selected-repositories-for-a-user-secret), [Set selected repositories for a user secret](https://docs.github.com/rest/reference/codespaces#set-selected-repositories-for-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/reference/codespaces#remove-a-selected-repository-from-a-user-secret) endpoints.',
              items: { type: 'string' }
            }
          },
          required: ['key_id']
        },

        params: {
          type: 'object',
          properties: { secret_name: { type: 'string' } },
          required: ['secret_name']
        }
      }),

      asyncRequestHandler<
        CodespacesCreateOrUpdateSecretForAuthenticatedUserRequest,
        CodespacesCreateOrUpdateSecretForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesCreateOrUpdateSecretForAuthenticatedUserHandler>(
            Handlers.CodespacesCreateOrUpdateSecretForAuthenticatedUserHandler
          );

        await controller.codespacesCreateOrUpdateSecretForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesDeleteSecretForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/user/codespaces/secrets/:secret_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { secret_name: { type: 'string' } },
          required: ['secret_name']
        }
      }),

      asyncRequestHandler<
        CodespacesDeleteSecretForAuthenticatedUserRequest,
        CodespacesDeleteSecretForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesDeleteSecretForAuthenticatedUserHandler>(
            Handlers.CodespacesDeleteSecretForAuthenticatedUserHandler
          );

        await controller.codespacesDeleteSecretForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesListRepositoriesForSecretForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/codespaces/secrets/:secret_name/repositories',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { secret_name: { type: 'string' } },
          required: ['secret_name']
        }
      }),

      asyncRequestHandler<
        CodespacesListRepositoriesForSecretForAuthenticatedUserRequest,
        CodespacesListRepositoriesForSecretForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesListRepositoriesForSecretForAuthenticatedUserHandler>(
            Handlers.CodespacesListRepositoriesForSecretForAuthenticatedUserHandler
          );

        await controller.codespacesListRepositoriesForSecretForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesSetRepositoriesForSecretForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.put(
      '/user/codespaces/secrets/:secret_name/repositories',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            selected_repository_ids: {
              type: 'array',
              description:
                'An array of repository ids for which a codespace can access the secret. You can manage the list of selected repositories using the [List selected repositories for a user secret](https://docs.github.com/rest/reference/codespaces#list-selected-repositories-for-a-user-secret), [Add a selected repository to a user secret](https://docs.github.com/rest/reference/codespaces#add-a-selected-repository-to-a-user-secret), and [Remove a selected repository from a user secret](https://docs.github.com/rest/reference/codespaces#remove-a-selected-repository-from-a-user-secret) endpoints.',
              items: { type: 'integer' }
            }
          },
          required: ['selected_repository_ids']
        },

        params: {
          type: 'object',
          properties: { secret_name: { type: 'string' } },
          required: ['secret_name']
        }
      }),

      asyncRequestHandler<
        CodespacesSetRepositoriesForSecretForAuthenticatedUserRequest,
        CodespacesSetRepositoriesForSecretForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesSetRepositoriesForSecretForAuthenticatedUserHandler>(
            Handlers.CodespacesSetRepositoriesForSecretForAuthenticatedUserHandler
          );

        await controller.codespacesSetRepositoriesForSecretForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesAddRepositoryForSecretForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.put(
      '/user/codespaces/secrets/:secret_name/repositories/:repository_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            secret_name: { type: 'string' },
            repository_id: { type: 'integer' }
          },
          required: ['secret_name', 'repository_id']
        }
      }),

      asyncRequestHandler<
        CodespacesAddRepositoryForSecretForAuthenticatedUserRequest,
        CodespacesAddRepositoryForSecretForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesAddRepositoryForSecretForAuthenticatedUserHandler>(
            Handlers.CodespacesAddRepositoryForSecretForAuthenticatedUserHandler
          );

        await controller.codespacesAddRepositoryForSecretForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesRemoveRepositoryForSecretForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/user/codespaces/secrets/:secret_name/repositories/:repository_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            secret_name: { type: 'string' },
            repository_id: { type: 'integer' }
          },
          required: ['secret_name', 'repository_id']
        }
      }),

      asyncRequestHandler<
        CodespacesRemoveRepositoryForSecretForAuthenticatedUserRequest,
        CodespacesRemoveRepositoryForSecretForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesRemoveRepositoryForSecretForAuthenticatedUserHandler>(
            Handlers.CodespacesRemoveRepositoryForSecretForAuthenticatedUserHandler
          );

        await controller.codespacesRemoveRepositoryForSecretForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesGetForAuthenticatedUserHandler(router: Router): void {
    router.get(
      '/user/codespaces/:codespace_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { codespace_name: { type: 'string' } },
          required: ['codespace_name']
        }
      }),

      asyncRequestHandler<
        CodespacesGetForAuthenticatedUserRequest,
        CodespacesGetForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesGetForAuthenticatedUserHandler>(
            Handlers.CodespacesGetForAuthenticatedUserHandler
          );

        await controller.codespacesGetForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addCodespacesUpdateForAuthenticatedUserHandler(router: Router): void {
    router.patch(
      '/user/codespaces/:codespace_name',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            machine: {
              description: 'A valid machine to transition this codespace to.',
              type: 'string'
            },
            display_name: {
              description: 'Display name for this codespace',
              type: 'string'
            },
            recent_folders: {
              description:
                'Recently opened folders inside the codespace. It is currently used by the clients to determine the folder path to load the codespace in.',
              type: 'array',
              items: { type: 'string' }
            }
          }
        },

        params: {
          type: 'object',
          properties: { codespace_name: { type: 'string' } },
          required: ['codespace_name']
        }
      }),

      asyncRequestHandler<
        CodespacesUpdateForAuthenticatedUserRequest,
        CodespacesUpdateForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesUpdateForAuthenticatedUserHandler>(
            Handlers.CodespacesUpdateForAuthenticatedUserHandler
          );

        await controller.codespacesUpdateForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addCodespacesDeleteForAuthenticatedUserHandler(router: Router): void {
    router.delete(
      '/user/codespaces/:codespace_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { codespace_name: { type: 'string' } },
          required: ['codespace_name']
        }
      }),

      asyncRequestHandler<
        CodespacesDeleteForAuthenticatedUserRequest,
        CodespacesDeleteForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesDeleteForAuthenticatedUserHandler>(
            Handlers.CodespacesDeleteForAuthenticatedUserHandler
          );

        await controller.codespacesDeleteForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addCodespacesExportForAuthenticatedUserHandler(router: Router): void {
    router.post(
      '/user/codespaces/:codespace_name/exports',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { codespace_name: { type: 'string' } },
          required: ['codespace_name']
        }
      }),

      asyncRequestHandler<
        CodespacesExportForAuthenticatedUserRequest,
        CodespacesExportForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesExportForAuthenticatedUserHandler>(
            Handlers.CodespacesExportForAuthenticatedUserHandler
          );

        await controller.codespacesExportForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addCodespacesGetExportDetailsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/codespaces/:codespace_name/exports/:export_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            codespace_name: { type: 'string' },
            export_id: { type: 'string' }
          },
          required: ['codespace_name', 'export_id']
        }
      }),

      asyncRequestHandler<
        CodespacesGetExportDetailsForAuthenticatedUserRequest,
        CodespacesGetExportDetailsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesGetExportDetailsForAuthenticatedUserHandler>(
            Handlers.CodespacesGetExportDetailsForAuthenticatedUserHandler
          );

        await controller.codespacesGetExportDetailsForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesCodespaceMachinesForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/codespaces/:codespace_name/machines',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { codespace_name: { type: 'string' } },
          required: ['codespace_name']
        }
      }),

      asyncRequestHandler<
        CodespacesCodespaceMachinesForAuthenticatedUserRequest,
        CodespacesCodespaceMachinesForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesCodespaceMachinesForAuthenticatedUserHandler>(
            Handlers.CodespacesCodespaceMachinesForAuthenticatedUserHandler
          );

        await controller.codespacesCodespaceMachinesForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addCodespacesStartForAuthenticatedUserHandler(router: Router): void {
    router.post(
      '/user/codespaces/:codespace_name/start',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { codespace_name: { type: 'string' } },
          required: ['codespace_name']
        }
      }),

      asyncRequestHandler<
        CodespacesStartForAuthenticatedUserRequest,
        CodespacesStartForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesStartForAuthenticatedUserHandler>(
            Handlers.CodespacesStartForAuthenticatedUserHandler
          );

        await controller.codespacesStartForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addCodespacesStopForAuthenticatedUserHandler(router: Router): void {
    router.post(
      '/user/codespaces/:codespace_name/stop',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { codespace_name: { type: 'string' } },
          required: ['codespace_name']
        }
      }),

      asyncRequestHandler<
        CodespacesStopForAuthenticatedUserRequest,
        CodespacesStopForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<CodespacesStopForAuthenticatedUserHandler>(
            Handlers.CodespacesStopForAuthenticatedUserHandler
          );

        await controller.codespacesStopForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addUsersSetPrimaryEmailVisibilityForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.patch(
      '/user/email/visibility',

      ControllerMiddleware.validate({
        body: {
          properties: {
            visibility: {
              description: 'Denotes whether an email is publicly visible.',
              type: 'string',
              enum: ['public', 'private']
            }
          },
          required: ['visibility'],
          type: 'object'
        }
      }),

      asyncRequestHandler<
        UsersSetPrimaryEmailVisibilityForAuthenticatedUserRequest,
        UsersSetPrimaryEmailVisibilityForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersSetPrimaryEmailVisibilityForAuthenticatedUserHandler>(
            Handlers.UsersSetPrimaryEmailVisibilityForAuthenticatedUserHandler
          );

        await controller.usersSetPrimaryEmailVisibilityForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addUsersListEmailsForAuthenticatedUserHandler(router: Router): void {
    router.get(
      '/user/emails',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        UsersListEmailsForAuthenticatedUserRequest,
        UsersListEmailsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersListEmailsForAuthenticatedUserHandler>(
            Handlers.UsersListEmailsForAuthenticatedUserHandler
          );

        await controller.usersListEmailsForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addUsersAddEmailForAuthenticatedUserHandler(router: Router): void {
    router.post(
      '/user/emails',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              properties: {
                emails: {
                  description:
                    'Adds one or more email addresses to your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.',
                  type: 'array',
                  items: {
                    type: 'string',
                    example: 'username@example.com',
                    minItems: 1
                  },
                  example: []
                }
              },
              required: ['emails'],
              example: { emails: ['octocat@github.com', 'mona@github.com'] }
            },
            {
              type: 'array',
              items: {
                type: 'string',
                example: 'username@example.com',
                minItems: 1
              }
            },
            { type: 'string' }
          ]
        }
      }),

      asyncRequestHandler<
        UsersAddEmailForAuthenticatedUserRequest,
        UsersAddEmailForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersAddEmailForAuthenticatedUserHandler>(
            Handlers.UsersAddEmailForAuthenticatedUserHandler
          );

        await controller.usersAddEmailForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addUsersDeleteEmailForAuthenticatedUserHandler(router: Router): void {
    router.delete(
      '/user/emails',

      ControllerMiddleware.validate({
        body: {
          oneOf: [
            {
              type: 'object',
              description:
                'Deletes one or more email addresses from your GitHub account. Must contain at least one email address. **Note:** Alternatively, you can pass a single email address or an `array` of emails addresses directly, but we recommend that you pass an object using the `emails` key.',
              properties: {
                emails: {
                  description:
                    'Email addresses associated with the GitHub user account.',
                  type: 'array',
                  items: {
                    type: 'string',
                    example: 'username@example.com',
                    minItems: 1
                  }
                }
              },
              example: { emails: ['octocat@github.com', 'mona@github.com'] },
              required: ['emails']
            },
            {
              type: 'array',
              items: {
                type: 'string',
                example: 'username@example.com',
                minItems: 1
              }
            },
            { type: 'string' }
          ]
        }
      }),

      asyncRequestHandler<
        UsersDeleteEmailForAuthenticatedUserRequest,
        UsersDeleteEmailForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersDeleteEmailForAuthenticatedUserHandler>(
            Handlers.UsersDeleteEmailForAuthenticatedUserHandler
          );

        await controller.usersDeleteEmailForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addUsersListFollowersForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/followers',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        UsersListFollowersForAuthenticatedUserRequest,
        UsersListFollowersForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersListFollowersForAuthenticatedUserHandler>(
            Handlers.UsersListFollowersForAuthenticatedUserHandler
          );

        await controller.usersListFollowersForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addUsersListFollowedByAuthenticatedUserHandler(router: Router): void {
    router.get(
      '/user/following',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        UsersListFollowedByAuthenticatedUserRequest,
        UsersListFollowedByAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersListFollowedByAuthenticatedUserHandler>(
            Handlers.UsersListFollowedByAuthenticatedUserHandler
          );

        await controller.usersListFollowedByAuthenticatedUser(req, res, next);
      })
    );
  }

  private addUsersCheckPersonIsFollowedByAuthenticatedHandler(
    router: Router
  ): void {
    router.get(
      '/user/following/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        UsersCheckPersonIsFollowedByAuthenticatedRequest,
        UsersCheckPersonIsFollowedByAuthenticatedResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersCheckPersonIsFollowedByAuthenticatedHandler>(
            Handlers.UsersCheckPersonIsFollowedByAuthenticatedHandler
          );

        await controller.usersCheckPersonIsFollowedByAuthenticated(
          req,
          res,
          next
        );
      })
    );
  }

  private addUsersFollowHandler(router: Router): void {
    router.put(
      '/user/following/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<UsersFollowRequest, UsersFollowResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<UsersFollowHandler>(Handlers.UsersFollowHandler);

          await controller.usersFollow(req, res, next);
        }
      )
    );
  }

  private addUsersUnfollowHandler(router: Router): void {
    router.delete(
      '/user/following/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<UsersUnfollowRequest, UsersUnfollowResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<UsersUnfollowHandler>(Handlers.UsersUnfollowHandler);

          await controller.usersUnfollow(req, res, next);
        }
      )
    );
  }

  private addUsersListGpgKeysForAuthenticatedUserHandler(router: Router): void {
    router.get(
      '/user/gpg_keys',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        UsersListGpgKeysForAuthenticatedUserRequest,
        UsersListGpgKeysForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersListGpgKeysForAuthenticatedUserHandler>(
            Handlers.UsersListGpgKeysForAuthenticatedUserHandler
          );

        await controller.usersListGpgKeysForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addUsersCreateGpgKeyForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.post(
      '/user/gpg_keys',

      ControllerMiddleware.validate({
        body: {
          properties: {
            name: {
              description: 'A descriptive name for the new key.',
              type: 'string'
            },
            armored_public_key: {
              description: 'A GPG key in ASCII-armored format.',
              type: 'string'
            }
          },
          type: 'object',
          required: ['armored_public_key']
        }
      }),

      asyncRequestHandler<
        UsersCreateGpgKeyForAuthenticatedUserRequest,
        UsersCreateGpgKeyForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersCreateGpgKeyForAuthenticatedUserHandler>(
            Handlers.UsersCreateGpgKeyForAuthenticatedUserHandler
          );

        await controller.usersCreateGpgKeyForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addUsersGetGpgKeyForAuthenticatedUserHandler(router: Router): void {
    router.get(
      '/user/gpg_keys/:gpg_key_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { gpg_key_id: { type: 'integer' } },
          required: ['gpg_key_id']
        }
      }),

      asyncRequestHandler<
        UsersGetGpgKeyForAuthenticatedUserRequest,
        UsersGetGpgKeyForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersGetGpgKeyForAuthenticatedUserHandler>(
            Handlers.UsersGetGpgKeyForAuthenticatedUserHandler
          );

        await controller.usersGetGpgKeyForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addUsersDeleteGpgKeyForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/user/gpg_keys/:gpg_key_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { gpg_key_id: { type: 'integer' } },
          required: ['gpg_key_id']
        }
      }),

      asyncRequestHandler<
        UsersDeleteGpgKeyForAuthenticatedUserRequest,
        UsersDeleteGpgKeyForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersDeleteGpgKeyForAuthenticatedUserHandler>(
            Handlers.UsersDeleteGpgKeyForAuthenticatedUserHandler
          );

        await controller.usersDeleteGpgKeyForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addAppsListInstallationsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/installations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        AppsListInstallationsForAuthenticatedUserRequest,
        AppsListInstallationsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsListInstallationsForAuthenticatedUserHandler>(
            Handlers.AppsListInstallationsForAuthenticatedUserHandler
          );

        await controller.appsListInstallationsForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addAppsListInstallationReposForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/installations/:installation_id/repositories',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { installation_id: { type: 'integer' } },
          required: ['installation_id']
        }
      }),

      asyncRequestHandler<
        AppsListInstallationReposForAuthenticatedUserRequest,
        AppsListInstallationReposForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsListInstallationReposForAuthenticatedUserHandler>(
            Handlers.AppsListInstallationReposForAuthenticatedUserHandler
          );

        await controller.appsListInstallationReposForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addAppsAddRepoToInstallationForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.put(
      '/user/installations/:installation_id/repositories/:repository_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            installation_id: { type: 'integer' },
            repository_id: { type: 'integer' }
          },
          required: ['installation_id', 'repository_id']
        }
      }),

      asyncRequestHandler<
        AppsAddRepoToInstallationForAuthenticatedUserRequest,
        AppsAddRepoToInstallationForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsAddRepoToInstallationForAuthenticatedUserHandler>(
            Handlers.AppsAddRepoToInstallationForAuthenticatedUserHandler
          );

        await controller.appsAddRepoToInstallationForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addAppsRemoveRepoFromInstallationForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/user/installations/:installation_id/repositories/:repository_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            installation_id: { type: 'integer' },
            repository_id: { type: 'integer' }
          },
          required: ['installation_id', 'repository_id']
        }
      }),

      asyncRequestHandler<
        AppsRemoveRepoFromInstallationForAuthenticatedUserRequest,
        AppsRemoveRepoFromInstallationForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsRemoveRepoFromInstallationForAuthenticatedUserHandler>(
            Handlers.AppsRemoveRepoFromInstallationForAuthenticatedUserHandler
          );

        await controller.appsRemoveRepoFromInstallationForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addInteractionsGetRestrictionsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/interaction-limits',

      asyncRequestHandler<
        InteractionsGetRestrictionsForAuthenticatedUserRequest,
        InteractionsGetRestrictionsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<InteractionsGetRestrictionsForAuthenticatedUserHandler>(
            Handlers.InteractionsGetRestrictionsForAuthenticatedUserHandler
          );

        await controller.interactionsGetRestrictionsForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addInteractionsSetRestrictionsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.put(
      '/user/interaction-limits',

      ControllerMiddleware.validate({
        body: {
          $ref: '#/definitions/interaction-limit',
          definitions: {
            'interaction-limit': {
              title: 'Interaction Restrictions',
              description:
                'Limit interactions to a specific type of user for a specified duration',
              type: 'object',
              properties: {
                limit: { $ref: '#/definitions/interaction-group' },
                expiry: { $ref: '#/definitions/interaction-expiry' }
              },
              required: ['limit']
            },
            'interaction-group': {
              type: 'string',
              description:
                'The type of GitHub user that can comment, open issues, or create pull requests while the interaction limit is in effect.',
              example: 'collaborators_only',
              enum: [
                'existing_users',
                'contributors_only',
                'collaborators_only'
              ],
              title: 'interaction-group'
            },
            'interaction-expiry': {
              type: 'string',
              description:
                'The duration of the interaction restriction. Default: `one_day`.',
              example: 'one_month',
              enum: [
                'one_day',
                'three_days',
                'one_week',
                'one_month',
                'six_months'
              ],
              title: 'interaction-expiry'
            }
          }
        }
      }),

      asyncRequestHandler<
        InteractionsSetRestrictionsForAuthenticatedUserRequest,
        InteractionsSetRestrictionsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<InteractionsSetRestrictionsForAuthenticatedUserHandler>(
            Handlers.InteractionsSetRestrictionsForAuthenticatedUserHandler
          );

        await controller.interactionsSetRestrictionsForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addInteractionsRemoveRestrictionsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/user/interaction-limits',

      asyncRequestHandler<
        InteractionsRemoveRestrictionsForAuthenticatedUserRequest,
        InteractionsRemoveRestrictionsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<InteractionsRemoveRestrictionsForAuthenticatedUserHandler>(
            Handlers.InteractionsRemoveRestrictionsForAuthenticatedUserHandler
          );

        await controller.interactionsRemoveRestrictionsForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addIssuesListForAuthenticatedUserHandler(router: Router): void {
    router.get(
      '/user/issues',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            filter: {
              type: 'string',
              enum: [
                'assigned',
                'created',
                'mentioned',
                'subscribed',
                'repos',
                'all'
              ],
              default: 'assigned'
            },
            state: {
              type: 'string',
              enum: ['open', 'closed', 'all'],
              default: 'open'
            },
            labels: { type: 'string' },
            sort: {
              type: 'string',
              enum: ['created', 'updated', 'comments'],
              default: 'created'
            },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            since: { type: 'string', format: 'date-time' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        IssuesListForAuthenticatedUserRequest,
        IssuesListForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<IssuesListForAuthenticatedUserHandler>(
            Handlers.IssuesListForAuthenticatedUserHandler
          );

        await controller.issuesListForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addUsersListPublicSshKeysForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/keys',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        UsersListPublicSshKeysForAuthenticatedUserRequest,
        UsersListPublicSshKeysForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersListPublicSshKeysForAuthenticatedUserHandler>(
            Handlers.UsersListPublicSshKeysForAuthenticatedUserHandler
          );

        await controller.usersListPublicSshKeysForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addUsersCreatePublicSshKeyForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.post(
      '/user/keys',

      ControllerMiddleware.validate({
        body: {
          properties: {
            title: {
              description: 'A descriptive name for the new key.',
              type: 'string',
              example: 'Personal MacBook Air'
            },
            key: {
              description: 'The public SSH key to add to your GitHub account.',
              type: 'string',
              pattern: '^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) '
            }
          },
          required: ['key'],
          type: 'object'
        }
      }),

      asyncRequestHandler<
        UsersCreatePublicSshKeyForAuthenticatedUserRequest,
        UsersCreatePublicSshKeyForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersCreatePublicSshKeyForAuthenticatedUserHandler>(
            Handlers.UsersCreatePublicSshKeyForAuthenticatedUserHandler
          );

        await controller.usersCreatePublicSshKeyForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addUsersGetPublicSshKeyForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/keys/:key_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { key_id: { type: 'integer' } },
          required: ['key_id']
        }
      }),

      asyncRequestHandler<
        UsersGetPublicSshKeyForAuthenticatedUserRequest,
        UsersGetPublicSshKeyForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersGetPublicSshKeyForAuthenticatedUserHandler>(
            Handlers.UsersGetPublicSshKeyForAuthenticatedUserHandler
          );

        await controller.usersGetPublicSshKeyForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addUsersDeletePublicSshKeyForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/user/keys/:key_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { key_id: { type: 'integer' } },
          required: ['key_id']
        }
      }),

      asyncRequestHandler<
        UsersDeletePublicSshKeyForAuthenticatedUserRequest,
        UsersDeletePublicSshKeyForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersDeletePublicSshKeyForAuthenticatedUserHandler>(
            Handlers.UsersDeletePublicSshKeyForAuthenticatedUserHandler
          );

        await controller.usersDeletePublicSshKeyForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addAppsListSubscriptionsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/marketplace_purchases',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        AppsListSubscriptionsForAuthenticatedUserRequest,
        AppsListSubscriptionsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsListSubscriptionsForAuthenticatedUserHandler>(
            Handlers.AppsListSubscriptionsForAuthenticatedUserHandler
          );

        await controller.appsListSubscriptionsForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addAppsListSubscriptionsForAuthenticatedUserStubbedHandler(
    router: Router
  ): void {
    router.get(
      '/user/marketplace_purchases/stubbed',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        AppsListSubscriptionsForAuthenticatedUserStubbedRequest,
        AppsListSubscriptionsForAuthenticatedUserStubbedResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsListSubscriptionsForAuthenticatedUserStubbedHandler>(
            Handlers.AppsListSubscriptionsForAuthenticatedUserStubbedHandler
          );

        await controller.appsListSubscriptionsForAuthenticatedUserStubbed(
          req,
          res,
          next
        );
      })
    );
  }

  private addOrgsListMembershipsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/memberships/orgs',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            state: { type: 'string', enum: ['active', 'pending'] },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        OrgsListMembershipsForAuthenticatedUserRequest,
        OrgsListMembershipsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsListMembershipsForAuthenticatedUserHandler>(
            Handlers.OrgsListMembershipsForAuthenticatedUserHandler
          );

        await controller.orgsListMembershipsForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addOrgsGetMembershipForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/memberships/orgs/:org',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        OrgsGetMembershipForAuthenticatedUserRequest,
        OrgsGetMembershipForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsGetMembershipForAuthenticatedUserHandler>(
            Handlers.OrgsGetMembershipForAuthenticatedUserHandler
          );

        await controller.orgsGetMembershipForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addOrgsUpdateMembershipForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.patch(
      '/user/memberships/orgs/:org',

      ControllerMiddleware.validate({
        body: {
          type: 'object',
          properties: {
            state: {
              type: 'string',
              description:
                'The state that the membership should be in. Only `"active"` will be accepted.',
              enum: ['active']
            }
          },
          required: ['state']
        },

        params: {
          type: 'object',
          properties: { org: { type: 'string' } },
          required: ['org']
        }
      }),

      asyncRequestHandler<
        OrgsUpdateMembershipForAuthenticatedUserRequest,
        OrgsUpdateMembershipForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsUpdateMembershipForAuthenticatedUserHandler>(
            Handlers.OrgsUpdateMembershipForAuthenticatedUserHandler
          );

        await controller.orgsUpdateMembershipForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addMigrationsListForAuthenticatedUserHandler(router: Router): void {
    router.get(
      '/user/migrations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        MigrationsListForAuthenticatedUserRequest,
        MigrationsListForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsListForAuthenticatedUserHandler>(
            Handlers.MigrationsListForAuthenticatedUserHandler
          );

        await controller.migrationsListForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addMigrationsStartForAuthenticatedUserHandler(router: Router): void {
    router.post(
      '/user/migrations',

      ControllerMiddleware.validate({
        body: {
          properties: {
            lock_repositories: {
              description:
                'Lock the repositories being migrated at the start of the migration',
              example: true,
              readOnly: false,
              type: 'boolean'
            },
            exclude_metadata: {
              description:
                'Indicates whether metadata should be excluded and only git source should be included for the migration.',
              example: true,
              readOnly: false,
              type: 'boolean'
            },
            exclude_git_data: {
              description:
                'Indicates whether the repository git data should be excluded from the migration.',
              example: true,
              readOnly: false,
              type: 'boolean'
            },
            exclude_attachments: {
              description: 'Do not include attachments in the migration',
              example: true,
              readOnly: false,
              type: 'boolean'
            },
            exclude_releases: {
              description: 'Do not include releases in the migration',
              example: true,
              readOnly: false,
              type: 'boolean'
            },
            exclude_owner_projects: {
              description:
                'Indicates whether projects owned by the organization or users should be excluded.',
              example: true,
              readOnly: false,
              type: 'boolean'
            },
            org_metadata_only: {
              type: 'boolean',
              example: true,
              description:
                'Indicates whether this should only include organization metadata (repositories array should be empty and will ignore other flags).',
              default: false
            },
            exclude: {
              description:
                'Exclude attributes from the API response to improve performance',
              example: ['repositories'],
              readOnly: false,
              type: 'array',
              items: {
                description:
                  'Allowed values that can be passed to the exclude param.',
                enum: ['repositories'],
                example: 'repositories',
                type: 'string'
              }
            },
            repositories: {
              type: 'array',
              items: {
                description: 'Repository path, owner and name',
                example: 'acme/widgets',
                type: 'string'
              }
            }
          },
          required: ['repositories'],
          type: 'object'
        }
      }),

      asyncRequestHandler<
        MigrationsStartForAuthenticatedUserRequest,
        MigrationsStartForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsStartForAuthenticatedUserHandler>(
            Handlers.MigrationsStartForAuthenticatedUserHandler
          );

        await controller.migrationsStartForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addMigrationsGetStatusForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/migrations/:migration_id',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            exclude: {
              anyOf: [
                { type: 'array', items: { type: 'string' } },
                { type: 'string' }
              ]
            }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { migration_id: { type: 'integer' } },
          required: ['migration_id']
        }
      }),

      asyncRequestHandler<
        MigrationsGetStatusForAuthenticatedUserRequest,
        MigrationsGetStatusForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsGetStatusForAuthenticatedUserHandler>(
            Handlers.MigrationsGetStatusForAuthenticatedUserHandler
          );

        await controller.migrationsGetStatusForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addMigrationsGetArchiveForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/migrations/:migration_id/archive',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { migration_id: { type: 'integer' } },
          required: ['migration_id']
        }
      }),

      asyncRequestHandler<
        MigrationsGetArchiveForAuthenticatedUserRequest,
        MigrationsGetArchiveForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsGetArchiveForAuthenticatedUserHandler>(
            Handlers.MigrationsGetArchiveForAuthenticatedUserHandler
          );

        await controller.migrationsGetArchiveForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addMigrationsDeleteArchiveForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/user/migrations/:migration_id/archive',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { migration_id: { type: 'integer' } },
          required: ['migration_id']
        }
      }),

      asyncRequestHandler<
        MigrationsDeleteArchiveForAuthenticatedUserRequest,
        MigrationsDeleteArchiveForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsDeleteArchiveForAuthenticatedUserHandler>(
            Handlers.MigrationsDeleteArchiveForAuthenticatedUserHandler
          );

        await controller.migrationsDeleteArchiveForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addMigrationsUnlockRepoForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/user/migrations/:migration_id/repos/:repo_name/lock',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            migration_id: { type: 'integer' },
            repo_name: { type: 'string' }
          },
          required: ['migration_id', 'repo_name']
        }
      }),

      asyncRequestHandler<
        MigrationsUnlockRepoForAuthenticatedUserRequest,
        MigrationsUnlockRepoForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsUnlockRepoForAuthenticatedUserHandler>(
            Handlers.MigrationsUnlockRepoForAuthenticatedUserHandler
          );

        await controller.migrationsUnlockRepoForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addMigrationsListReposForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/migrations/:migration_id/repositories',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { migration_id: { type: 'integer' } },
          required: ['migration_id']
        }
      }),

      asyncRequestHandler<
        MigrationsListReposForAuthenticatedUserRequest,
        MigrationsListReposForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<MigrationsListReposForAuthenticatedUserHandler>(
            Handlers.MigrationsListReposForAuthenticatedUserHandler
          );

        await controller.migrationsListReposForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addOrgsListForAuthenticatedUserHandler(router: Router): void {
    router.get(
      '/user/orgs',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        OrgsListForAuthenticatedUserRequest,
        OrgsListForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<OrgsListForAuthenticatedUserHandler>(
            Handlers.OrgsListForAuthenticatedUserHandler
          );

        await controller.orgsListForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addPackagesListPackagesForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/packages',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            visibility: {
              type: 'string',
              enum: ['public', 'private', 'internal']
            }
          },
          required: ['package_type']
        }
      }),

      asyncRequestHandler<
        PackagesListPackagesForAuthenticatedUserRequest,
        PackagesListPackagesForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesListPackagesForAuthenticatedUserHandler>(
            Handlers.PackagesListPackagesForAuthenticatedUserHandler
          );

        await controller.packagesListPackagesForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addPackagesGetPackageForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/packages/:package_type/:package_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' }
          },
          required: ['package_type', 'package_name']
        }
      }),

      asyncRequestHandler<
        PackagesGetPackageForAuthenticatedUserRequest,
        PackagesGetPackageForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesGetPackageForAuthenticatedUserHandler>(
            Handlers.PackagesGetPackageForAuthenticatedUserHandler
          );

        await controller.packagesGetPackageForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addPackagesDeletePackageForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/user/packages/:package_type/:package_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' }
          },
          required: ['package_type', 'package_name']
        }
      }),

      asyncRequestHandler<
        PackagesDeletePackageForAuthenticatedUserRequest,
        PackagesDeletePackageForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesDeletePackageForAuthenticatedUserHandler>(
            Handlers.PackagesDeletePackageForAuthenticatedUserHandler
          );

        await controller.packagesDeletePackageForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addPackagesRestorePackageForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.post(
      '/user/packages/:package_type/:package_name/restore',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { token: { type: 'string' } },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' }
          },
          required: ['package_type', 'package_name']
        }
      }),

      asyncRequestHandler<
        PackagesRestorePackageForAuthenticatedUserRequest,
        PackagesRestorePackageForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesRestorePackageForAuthenticatedUserHandler>(
            Handlers.PackagesRestorePackageForAuthenticatedUserHandler
          );

        await controller.packagesRestorePackageForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/packages/:package_type/:package_name/versions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            page: { type: 'integer', default: 1 },
            per_page: { type: 'integer', default: 30 },
            state: {
              type: 'string',
              enum: ['active', 'deleted'],
              default: 'active'
            }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' }
          },
          required: ['package_type', 'package_name']
        }
      }),

      asyncRequestHandler<
        PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserRequest,
        PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserHandler>(
            Handlers.PackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserHandler
          );

        await controller.packagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addPackagesGetPackageVersionForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/packages/:package_type/:package_name/versions/:package_version_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            package_version_id: { type: 'integer' }
          },
          required: ['package_type', 'package_name', 'package_version_id']
        }
      }),

      asyncRequestHandler<
        PackagesGetPackageVersionForAuthenticatedUserRequest,
        PackagesGetPackageVersionForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesGetPackageVersionForAuthenticatedUserHandler>(
            Handlers.PackagesGetPackageVersionForAuthenticatedUserHandler
          );

        await controller.packagesGetPackageVersionForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addPackagesDeletePackageVersionForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/user/packages/:package_type/:package_name/versions/:package_version_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            package_version_id: { type: 'integer' }
          },
          required: ['package_type', 'package_name', 'package_version_id']
        }
      }),

      asyncRequestHandler<
        PackagesDeletePackageVersionForAuthenticatedUserRequest,
        PackagesDeletePackageVersionForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesDeletePackageVersionForAuthenticatedUserHandler>(
            Handlers.PackagesDeletePackageVersionForAuthenticatedUserHandler
          );

        await controller.packagesDeletePackageVersionForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addPackagesRestorePackageVersionForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.post(
      '/user/packages/:package_type/:package_name/versions/:package_version_id/restore',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            package_version_id: { type: 'integer' }
          },
          required: ['package_type', 'package_name', 'package_version_id']
        }
      }),

      asyncRequestHandler<
        PackagesRestorePackageVersionForAuthenticatedUserRequest,
        PackagesRestorePackageVersionForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesRestorePackageVersionForAuthenticatedUserHandler>(
            Handlers.PackagesRestorePackageVersionForAuthenticatedUserHandler
          );

        await controller.packagesRestorePackageVersionForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addProjectsCreateForAuthenticatedUserHandler(router: Router): void {
    router.post(
      '/user/projects',

      ControllerMiddleware.validate({
        body: {
          properties: {
            name: {
              description: 'Name of the project',
              example: 'Week One Sprint',
              type: 'string'
            },
            body: {
              description: 'Body of the project',
              example:
                'This project represents the sprint of the first week in January',
              type: 'string',
              nullable: true
            }
          },
          required: ['name'],
          type: 'object'
        }
      }),

      asyncRequestHandler<
        ProjectsCreateForAuthenticatedUserRequest,
        ProjectsCreateForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsCreateForAuthenticatedUserHandler>(
            Handlers.ProjectsCreateForAuthenticatedUserHandler
          );

        await controller.projectsCreateForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addUsersListPublicEmailsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/public_emails',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        UsersListPublicEmailsForAuthenticatedUserRequest,
        UsersListPublicEmailsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersListPublicEmailsForAuthenticatedUserHandler>(
            Handlers.UsersListPublicEmailsForAuthenticatedUserHandler
          );

        await controller.usersListPublicEmailsForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addReposListForAuthenticatedUserHandler(router: Router): void {
    router.get(
      '/user/repos',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            visibility: {
              type: 'string',
              enum: ['all', 'public', 'private'],
              default: 'all'
            },
            affiliation: {
              type: 'string',
              default: 'owner,collaborator,organization_member'
            },
            type: {
              type: 'string',
              enum: ['all', 'owner', 'public', 'private', 'member'],
              default: 'all'
            },
            sort: {
              type: 'string',
              enum: ['created', 'updated', 'pushed', 'full_name'],
              default: 'full_name'
            },
            direction: { type: 'string', enum: ['asc', 'desc'] },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 },
            since: { type: 'string', format: 'date-time' },
            before: { type: 'string', format: 'date-time' }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        ReposListForAuthenticatedUserRequest,
        ReposListForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListForAuthenticatedUserHandler>(
            Handlers.ReposListForAuthenticatedUserHandler
          );

        await controller.reposListForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addReposCreateForAuthenticatedUserHandler(router: Router): void {
    router.post(
      '/user/repos',

      ControllerMiddleware.validate({
        body: {
          properties: {
            name: {
              description: 'The name of the repository.',
              type: 'string',
              example: 'Team Environment'
            },
            description: {
              description: 'A short description of the repository.',
              type: 'string'
            },
            homepage: {
              description: 'A URL with more information about the repository.',
              type: 'string'
            },
            private: {
              description: 'Whether the repository is private.',
              default: false,
              type: 'boolean'
            },
            has_issues: {
              description: 'Whether issues are enabled.',
              default: true,
              type: 'boolean',
              example: true
            },
            has_projects: {
              description: 'Whether projects are enabled.',
              default: true,
              type: 'boolean',
              example: true
            },
            has_wiki: {
              description: 'Whether the wiki is enabled.',
              default: true,
              type: 'boolean',
              example: true
            },
            team_id: {
              description:
                'The id of the team that will be granted access to this repository. This is only valid when creating a repository in an organization.',
              type: 'integer'
            },
            auto_init: {
              description:
                'Whether the repository is initialized with a minimal README.',
              default: false,
              type: 'boolean'
            },
            gitignore_template: {
              description:
                'The desired language or platform to apply to the .gitignore.',
              example: 'Haskell',
              type: 'string'
            },
            license_template: {
              description:
                'The license keyword of the open source license for this repository.',
              example: 'mit',
              type: 'string'
            },
            allow_squash_merge: {
              description: 'Whether to allow squash merges for pull requests.',
              default: true,
              type: 'boolean',
              example: true
            },
            allow_merge_commit: {
              description: 'Whether to allow merge commits for pull requests.',
              default: true,
              type: 'boolean',
              example: true
            },
            allow_rebase_merge: {
              description: 'Whether to allow rebase merges for pull requests.',
              default: true,
              type: 'boolean',
              example: true
            },
            allow_auto_merge: {
              description:
                'Whether to allow Auto-merge to be used on pull requests.',
              default: false,
              type: 'boolean',
              example: false
            },
            delete_branch_on_merge: {
              description:
                'Whether to delete head branches when pull requests are merged',
              default: false,
              type: 'boolean',
              example: false
            },
            squash_merge_commit_title: {
              type: 'string',
              enum: ['PR_TITLE', 'COMMIT_OR_PR_TITLE'],
              description:
                "The default value for a squash merge commit title:\n\n- `PR_TITLE` - default to the pull request's title.\n- `COMMIT_OR_PR_TITLE` - default to the commit's title (if only one commit) or the pull request's title (when more than one commit)."
            },
            squash_merge_commit_message: {
              type: 'string',
              enum: ['PR_BODY', 'COMMIT_MESSAGES', 'BLANK'],
              description:
                "The default value for a squash merge commit message:\n\n- `PR_BODY` - default to the pull request's body.\n- `COMMIT_MESSAGES` - default to the branch's commit messages.\n- `BLANK` - default to a blank commit message."
            },
            merge_commit_title: {
              type: 'string',
              enum: ['PR_TITLE', 'MERGE_MESSAGE'],
              description:
                "The default value for a merge commit title.\n\n- `PR_TITLE` - default to the pull request's title.\n- `MERGE_MESSAGE` - default to the classic title for a merge message (e.g., Merge pull request #123 from branch-name)."
            },
            merge_commit_message: {
              type: 'string',
              enum: ['PR_BODY', 'PR_TITLE', 'BLANK'],
              description:
                "The default value for a merge commit message.\n\n- `PR_TITLE` - default to the pull request's title.\n- `PR_BODY` - default to the pull request's body.\n- `BLANK` - default to a blank commit message."
            },
            has_downloads: {
              description: 'Whether downloads are enabled.',
              default: true,
              type: 'boolean',
              example: true
            },
            is_template: {
              description:
                'Whether this repository acts as a template that can be used to generate new repositories.',
              default: false,
              type: 'boolean',
              example: true
            }
          },
          required: ['name'],
          type: 'object'
        }
      }),

      asyncRequestHandler<
        ReposCreateForAuthenticatedUserRequest,
        ReposCreateForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposCreateForAuthenticatedUserHandler>(
            Handlers.ReposCreateForAuthenticatedUserHandler
          );

        await controller.reposCreateForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addReposListInvitationsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/repository_invitations',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        ReposListInvitationsForAuthenticatedUserRequest,
        ReposListInvitationsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposListInvitationsForAuthenticatedUserHandler>(
            Handlers.ReposListInvitationsForAuthenticatedUserHandler
          );

        await controller.reposListInvitationsForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addReposAcceptInvitationForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.patch(
      '/user/repository_invitations/:invitation_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { invitation_id: { type: 'integer' } },
          required: ['invitation_id']
        }
      }),

      asyncRequestHandler<
        ReposAcceptInvitationForAuthenticatedUserRequest,
        ReposAcceptInvitationForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposAcceptInvitationForAuthenticatedUserHandler>(
            Handlers.ReposAcceptInvitationForAuthenticatedUserHandler
          );

        await controller.reposAcceptInvitationForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addReposDeclineInvitationForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/user/repository_invitations/:invitation_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { invitation_id: { type: 'integer' } },
          required: ['invitation_id']
        }
      }),

      asyncRequestHandler<
        ReposDeclineInvitationForAuthenticatedUserRequest,
        ReposDeclineInvitationForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ReposDeclineInvitationForAuthenticatedUserHandler>(
            Handlers.ReposDeclineInvitationForAuthenticatedUserHandler
          );

        await controller.reposDeclineInvitationForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addUsersListSshSigningKeysForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/ssh_signing_keys',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        UsersListSshSigningKeysForAuthenticatedUserRequest,
        UsersListSshSigningKeysForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersListSshSigningKeysForAuthenticatedUserHandler>(
            Handlers.UsersListSshSigningKeysForAuthenticatedUserHandler
          );

        await controller.usersListSshSigningKeysForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addUsersCreateSshSigningKeyForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.post(
      '/user/ssh_signing_keys',

      ControllerMiddleware.validate({
        body: {
          properties: {
            title: {
              description: 'A descriptive name for the new key.',
              type: 'string',
              example: 'Personal MacBook Air'
            },
            key: {
              description:
                'The public SSH key to add to your GitHub account. For more information, see "[Checking for existing SSH keys](https://docs.github.com/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys)."',
              type: 'string',
              pattern:
                '^ssh-(rsa|dss|ed25519) |^ecdsa-sha2-nistp(256|384|521) |^(sk-ssh-ed25519|sk-ecdsa-sha2-nistp256)@openssh.com '
            }
          },
          required: ['key'],
          type: 'object'
        }
      }),

      asyncRequestHandler<
        UsersCreateSshSigningKeyForAuthenticatedUserRequest,
        UsersCreateSshSigningKeyForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersCreateSshSigningKeyForAuthenticatedUserHandler>(
            Handlers.UsersCreateSshSigningKeyForAuthenticatedUserHandler
          );

        await controller.usersCreateSshSigningKeyForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addUsersGetSshSigningKeyForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/ssh_signing_keys/:ssh_signing_key_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { ssh_signing_key_id: { type: 'integer' } },
          required: ['ssh_signing_key_id']
        }
      }),

      asyncRequestHandler<
        UsersGetSshSigningKeyForAuthenticatedUserRequest,
        UsersGetSshSigningKeyForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersGetSshSigningKeyForAuthenticatedUserHandler>(
            Handlers.UsersGetSshSigningKeyForAuthenticatedUserHandler
          );

        await controller.usersGetSshSigningKeyForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addUsersDeleteSshSigningKeyForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/user/ssh_signing_keys/:ssh_signing_key_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { ssh_signing_key_id: { type: 'integer' } },
          required: ['ssh_signing_key_id']
        }
      }),

      asyncRequestHandler<
        UsersDeleteSshSigningKeyForAuthenticatedUserRequest,
        UsersDeleteSshSigningKeyForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersDeleteSshSigningKeyForAuthenticatedUserHandler>(
            Handlers.UsersDeleteSshSigningKeyForAuthenticatedUserHandler
          );

        await controller.usersDeleteSshSigningKeyForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addActivityListReposStarredByAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/starred',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        ActivityListReposStarredByAuthenticatedUserRequest,
        ActivityListReposStarredByAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListReposStarredByAuthenticatedUserHandler>(
            Handlers.ActivityListReposStarredByAuthenticatedUserHandler
          );

        await controller.activityListReposStarredByAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addActivityCheckRepoIsStarredByAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/starred/:owner/:repo',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActivityCheckRepoIsStarredByAuthenticatedUserRequest,
        ActivityCheckRepoIsStarredByAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityCheckRepoIsStarredByAuthenticatedUserHandler>(
            Handlers.ActivityCheckRepoIsStarredByAuthenticatedUserHandler
          );

        await controller.activityCheckRepoIsStarredByAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addActivityStarRepoForAuthenticatedUserHandler(router: Router): void {
    router.put(
      '/user/starred/:owner/:repo',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActivityStarRepoForAuthenticatedUserRequest,
        ActivityStarRepoForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityStarRepoForAuthenticatedUserHandler>(
            Handlers.ActivityStarRepoForAuthenticatedUserHandler
          );

        await controller.activityStarRepoForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addActivityUnstarRepoForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.delete(
      '/user/starred/:owner/:repo',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { owner: { type: 'string' }, repo: { type: 'string' } },
          required: ['owner', 'repo']
        }
      }),

      asyncRequestHandler<
        ActivityUnstarRepoForAuthenticatedUserRequest,
        ActivityUnstarRepoForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityUnstarRepoForAuthenticatedUserHandler>(
            Handlers.ActivityUnstarRepoForAuthenticatedUserHandler
          );

        await controller.activityUnstarRepoForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addActivityListWatchedReposForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/user/subscriptions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        ActivityListWatchedReposForAuthenticatedUserRequest,
        ActivityListWatchedReposForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListWatchedReposForAuthenticatedUserHandler>(
            Handlers.ActivityListWatchedReposForAuthenticatedUserHandler
          );

        await controller.activityListWatchedReposForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addTeamsListForAuthenticatedUserHandler(router: Router): void {
    router.get(
      '/user/teams',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        }
      }),

      asyncRequestHandler<
        TeamsListForAuthenticatedUserRequest,
        TeamsListForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<TeamsListForAuthenticatedUserHandler>(
            Handlers.TeamsListForAuthenticatedUserHandler
          );

        await controller.teamsListForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addUsersListHandler(router: Router): void {
    router.get(
      '/users',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            since: { type: 'integer' },
            per_page: { type: 'integer', default: 30 }
          },
          required: []
        }
      }),

      asyncRequestHandler<UsersListRequest, UsersListResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<UsersListHandler>(Handlers.UsersListHandler);

          await controller.usersList(req, res, next);
        }
      )
    );
  }

  private addUsersGetByUsernameHandler(router: Router): void {
    router.get(
      '/users/:username',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        UsersGetByUsernameRequest,
        UsersGetByUsernameResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersGetByUsernameHandler>(
            Handlers.UsersGetByUsernameHandler
          );

        await controller.usersGetByUsername(req, res, next);
      })
    );
  }

  private addActivityListEventsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/users/:username/events',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        ActivityListEventsForAuthenticatedUserRequest,
        ActivityListEventsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListEventsForAuthenticatedUserHandler>(
            Handlers.ActivityListEventsForAuthenticatedUserHandler
          );

        await controller.activityListEventsForAuthenticatedUser(req, res, next);
      })
    );
  }

  private addActivityListOrgEventsForAuthenticatedUserHandler(
    router: Router
  ): void {
    router.get(
      '/users/:username/events/orgs/:org',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' }, org: { type: 'string' } },
          required: ['username', 'org']
        }
      }),

      asyncRequestHandler<
        ActivityListOrgEventsForAuthenticatedUserRequest,
        ActivityListOrgEventsForAuthenticatedUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListOrgEventsForAuthenticatedUserHandler>(
            Handlers.ActivityListOrgEventsForAuthenticatedUserHandler
          );

        await controller.activityListOrgEventsForAuthenticatedUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addActivityListPublicEventsForUserHandler(router: Router): void {
    router.get(
      '/users/:username/events/public',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        ActivityListPublicEventsForUserRequest,
        ActivityListPublicEventsForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListPublicEventsForUserHandler>(
            Handlers.ActivityListPublicEventsForUserHandler
          );

        await controller.activityListPublicEventsForUser(req, res, next);
      })
    );
  }

  private addUsersListFollowersForUserHandler(router: Router): void {
    router.get(
      '/users/:username/followers',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        UsersListFollowersForUserRequest,
        UsersListFollowersForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersListFollowersForUserHandler>(
            Handlers.UsersListFollowersForUserHandler
          );

        await controller.usersListFollowersForUser(req, res, next);
      })
    );
  }

  private addUsersListFollowingForUserHandler(router: Router): void {
    router.get(
      '/users/:username/following',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        UsersListFollowingForUserRequest,
        UsersListFollowingForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersListFollowingForUserHandler>(
            Handlers.UsersListFollowingForUserHandler
          );

        await controller.usersListFollowingForUser(req, res, next);
      })
    );
  }

  private addUsersCheckFollowingForUserHandler(router: Router): void {
    router.get(
      '/users/:username/following/:target_user',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            username: { type: 'string' },
            target_user: { type: 'string' }
          },
          required: ['username', 'target_user']
        }
      }),

      asyncRequestHandler<
        UsersCheckFollowingForUserRequest,
        UsersCheckFollowingForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersCheckFollowingForUserHandler>(
            Handlers.UsersCheckFollowingForUserHandler
          );

        await controller.usersCheckFollowingForUser(req, res, next);
      })
    );
  }

  private addGistsListForUserHandler(router: Router): void {
    router.get(
      '/users/:username/gists',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            since: { type: 'string', format: 'date-time' },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<GistsListForUserRequest, GistsListForUserResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<GistsListForUserHandler>(Handlers.GistsListForUserHandler);

          await controller.gistsListForUser(req, res, next);
        }
      )
    );
  }

  private addUsersListGpgKeysForUserHandler(router: Router): void {
    router.get(
      '/users/:username/gpg_keys',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        UsersListGpgKeysForUserRequest,
        UsersListGpgKeysForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersListGpgKeysForUserHandler>(
            Handlers.UsersListGpgKeysForUserHandler
          );

        await controller.usersListGpgKeysForUser(req, res, next);
      })
    );
  }

  private addUsersGetContextForUserHandler(router: Router): void {
    router.get(
      '/users/:username/hovercard',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            subject_type: {
              type: 'string',
              enum: ['organization', 'repository', 'issue', 'pull_request']
            },
            subject_id: { type: 'string' }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        UsersGetContextForUserRequest,
        UsersGetContextForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersGetContextForUserHandler>(
            Handlers.UsersGetContextForUserHandler
          );

        await controller.usersGetContextForUser(req, res, next);
      })
    );
  }

  private addAppsGetUserInstallationHandler(router: Router): void {
    router.get(
      '/users/:username/installation',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        AppsGetUserInstallationRequest,
        AppsGetUserInstallationResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<AppsGetUserInstallationHandler>(
            Handlers.AppsGetUserInstallationHandler
          );

        await controller.appsGetUserInstallation(req, res, next);
      })
    );
  }

  private addUsersListPublicKeysForUserHandler(router: Router): void {
    router.get(
      '/users/:username/keys',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        UsersListPublicKeysForUserRequest,
        UsersListPublicKeysForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersListPublicKeysForUserHandler>(
            Handlers.UsersListPublicKeysForUserHandler
          );

        await controller.usersListPublicKeysForUser(req, res, next);
      })
    );
  }

  private addOrgsListForUserHandler(router: Router): void {
    router.get(
      '/users/:username/orgs',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<OrgsListForUserRequest, OrgsListForUserResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<OrgsListForUserHandler>(Handlers.OrgsListForUserHandler);

          await controller.orgsListForUser(req, res, next);
        }
      )
    );
  }

  private addPackagesListPackagesForUserHandler(router: Router): void {
    router.get(
      '/users/:username/packages',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            visibility: {
              type: 'string',
              enum: ['public', 'private', 'internal']
            }
          },
          required: ['package_type']
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        PackagesListPackagesForUserRequest,
        PackagesListPackagesForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesListPackagesForUserHandler>(
            Handlers.PackagesListPackagesForUserHandler
          );

        await controller.packagesListPackagesForUser(req, res, next);
      })
    );
  }

  private addPackagesGetPackageForUserHandler(router: Router): void {
    router.get(
      '/users/:username/packages/:package_type/:package_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            username: { type: 'string' }
          },
          required: ['package_type', 'package_name', 'username']
        }
      }),

      asyncRequestHandler<
        PackagesGetPackageForUserRequest,
        PackagesGetPackageForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesGetPackageForUserHandler>(
            Handlers.PackagesGetPackageForUserHandler
          );

        await controller.packagesGetPackageForUser(req, res, next);
      })
    );
  }

  private addPackagesDeletePackageForUserHandler(router: Router): void {
    router.delete(
      '/users/:username/packages/:package_type/:package_name',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            username: { type: 'string' }
          },
          required: ['package_type', 'package_name', 'username']
        }
      }),

      asyncRequestHandler<
        PackagesDeletePackageForUserRequest,
        PackagesDeletePackageForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesDeletePackageForUserHandler>(
            Handlers.PackagesDeletePackageForUserHandler
          );

        await controller.packagesDeletePackageForUser(req, res, next);
      })
    );
  }

  private addPackagesRestorePackageForUserHandler(router: Router): void {
    router.post(
      '/users/:username/packages/:package_type/:package_name/restore',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: { token: { type: 'string' } },
          required: []
        },
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            username: { type: 'string' }
          },
          required: ['package_type', 'package_name', 'username']
        }
      }),

      asyncRequestHandler<
        PackagesRestorePackageForUserRequest,
        PackagesRestorePackageForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesRestorePackageForUserHandler>(
            Handlers.PackagesRestorePackageForUserHandler
          );

        await controller.packagesRestorePackageForUser(req, res, next);
      })
    );
  }

  private addPackagesGetAllPackageVersionsForPackageOwnedByUserHandler(
    router: Router
  ): void {
    router.get(
      '/users/:username/packages/:package_type/:package_name/versions',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            username: { type: 'string' }
          },
          required: ['package_type', 'package_name', 'username']
        }
      }),

      asyncRequestHandler<
        PackagesGetAllPackageVersionsForPackageOwnedByUserRequest,
        PackagesGetAllPackageVersionsForPackageOwnedByUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesGetAllPackageVersionsForPackageOwnedByUserHandler>(
            Handlers.PackagesGetAllPackageVersionsForPackageOwnedByUserHandler
          );

        await controller.packagesGetAllPackageVersionsForPackageOwnedByUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addPackagesGetPackageVersionForUserHandler(router: Router): void {
    router.get(
      '/users/:username/packages/:package_type/:package_name/versions/:package_version_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            package_version_id: { type: 'integer' },
            username: { type: 'string' }
          },
          required: [
            'package_type',
            'package_name',
            'package_version_id',
            'username'
          ]
        }
      }),

      asyncRequestHandler<
        PackagesGetPackageVersionForUserRequest,
        PackagesGetPackageVersionForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesGetPackageVersionForUserHandler>(
            Handlers.PackagesGetPackageVersionForUserHandler
          );

        await controller.packagesGetPackageVersionForUser(req, res, next);
      })
    );
  }

  private addPackagesDeletePackageVersionForUserHandler(router: Router): void {
    router.delete(
      '/users/:username/packages/:package_type/:package_name/versions/:package_version_id',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            username: { type: 'string' },
            package_version_id: { type: 'integer' }
          },
          required: [
            'package_type',
            'package_name',
            'username',
            'package_version_id'
          ]
        }
      }),

      asyncRequestHandler<
        PackagesDeletePackageVersionForUserRequest,
        PackagesDeletePackageVersionForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesDeletePackageVersionForUserHandler>(
            Handlers.PackagesDeletePackageVersionForUserHandler
          );

        await controller.packagesDeletePackageVersionForUser(req, res, next);
      })
    );
  }

  private addPackagesRestorePackageVersionForUserHandler(router: Router): void {
    router.post(
      '/users/:username/packages/:package_type/:package_name/versions/:package_version_id/restore',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: {
            package_type: {
              type: 'string',
              enum: ['npm', 'maven', 'rubygems', 'docker', 'nuget', 'container']
            },
            package_name: { type: 'string' },
            username: { type: 'string' },
            package_version_id: { type: 'integer' }
          },
          required: [
            'package_type',
            'package_name',
            'username',
            'package_version_id'
          ]
        }
      }),

      asyncRequestHandler<
        PackagesRestorePackageVersionForUserRequest,
        PackagesRestorePackageVersionForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<PackagesRestorePackageVersionForUserHandler>(
            Handlers.PackagesRestorePackageVersionForUserHandler
          );

        await controller.packagesRestorePackageVersionForUser(req, res, next);
      })
    );
  }

  private addProjectsListForUserHandler(router: Router): void {
    router.get(
      '/users/:username/projects',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            state: {
              type: 'string',
              enum: ['open', 'closed', 'all'],
              default: 'open'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        ProjectsListForUserRequest,
        ProjectsListForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ProjectsListForUserHandler>(
            Handlers.ProjectsListForUserHandler
          );

        await controller.projectsListForUser(req, res, next);
      })
    );
  }

  private addActivityListReceivedEventsForUserHandler(router: Router): void {
    router.get(
      '/users/:username/received_events',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        ActivityListReceivedEventsForUserRequest,
        ActivityListReceivedEventsForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListReceivedEventsForUserHandler>(
            Handlers.ActivityListReceivedEventsForUserHandler
          );

        await controller.activityListReceivedEventsForUser(req, res, next);
      })
    );
  }

  private addActivityListReceivedPublicEventsForUserHandler(
    router: Router
  ): void {
    router.get(
      '/users/:username/received_events/public',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        ActivityListReceivedPublicEventsForUserRequest,
        ActivityListReceivedPublicEventsForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListReceivedPublicEventsForUserHandler>(
            Handlers.ActivityListReceivedPublicEventsForUserHandler
          );

        await controller.activityListReceivedPublicEventsForUser(
          req,
          res,
          next
        );
      })
    );
  }

  private addReposListForUserHandler(router: Router): void {
    router.get(
      '/users/:username/repos',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            type: {
              type: 'string',
              enum: ['all', 'owner', 'member'],
              default: 'owner'
            },
            sort: {
              type: 'string',
              enum: ['created', 'updated', 'pushed', 'full_name'],
              default: 'full_name'
            },
            direction: { type: 'string', enum: ['asc', 'desc'] },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<ReposListForUserRequest, ReposListForUserResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<ReposListForUserHandler>(Handlers.ReposListForUserHandler);

          await controller.reposListForUser(req, res, next);
        }
      )
    );
  }

  private addBillingGetGithubActionsBillingUserHandler(router: Router): void {
    router.get(
      '/users/:username/settings/billing/actions',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        BillingGetGithubActionsBillingUserRequest,
        BillingGetGithubActionsBillingUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<BillingGetGithubActionsBillingUserHandler>(
            Handlers.BillingGetGithubActionsBillingUserHandler
          );

        await controller.billingGetGithubActionsBillingUser(req, res, next);
      })
    );
  }

  private addBillingGetGithubPackagesBillingUserHandler(router: Router): void {
    router.get(
      '/users/:username/settings/billing/packages',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        BillingGetGithubPackagesBillingUserRequest,
        BillingGetGithubPackagesBillingUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<BillingGetGithubPackagesBillingUserHandler>(
            Handlers.BillingGetGithubPackagesBillingUserHandler
          );

        await controller.billingGetGithubPackagesBillingUser(req, res, next);
      })
    );
  }

  private addBillingGetSharedStorageBillingUserHandler(router: Router): void {
    router.get(
      '/users/:username/settings/billing/shared-storage',

      ControllerMiddleware.validate({
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        BillingGetSharedStorageBillingUserRequest,
        BillingGetSharedStorageBillingUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<BillingGetSharedStorageBillingUserHandler>(
            Handlers.BillingGetSharedStorageBillingUserHandler
          );

        await controller.billingGetSharedStorageBillingUser(req, res, next);
      })
    );
  }

  private addUsersListSshSigningKeysForUserHandler(router: Router): void {
    router.get(
      '/users/:username/ssh_signing_keys',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        UsersListSshSigningKeysForUserRequest,
        UsersListSshSigningKeysForUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<UsersListSshSigningKeysForUserHandler>(
            Handlers.UsersListSshSigningKeysForUserHandler
          );

        await controller.usersListSshSigningKeysForUser(req, res, next);
      })
    );
  }

  private addActivityListReposStarredByUserHandler(router: Router): void {
    router.get(
      '/users/:username/starred',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            sort: {
              type: 'string',
              enum: ['created', 'updated'],
              default: 'created'
            },
            direction: {
              type: 'string',
              enum: ['asc', 'desc'],
              default: 'desc'
            },
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        ActivityListReposStarredByUserRequest,
        ActivityListReposStarredByUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListReposStarredByUserHandler>(
            Handlers.ActivityListReposStarredByUserHandler
          );

        await controller.activityListReposStarredByUser(req, res, next);
      })
    );
  }

  private addActivityListReposWatchedByUserHandler(router: Router): void {
    router.get(
      '/users/:username/subscriptions',

      ControllerMiddleware.validate({
        query: {
          type: 'object',
          properties: {
            per_page: { type: 'integer', default: 30 },
            page: { type: 'integer', default: 1 }
          },
          required: []
        },
        params: {
          type: 'object',
          properties: { username: { type: 'string' } },
          required: ['username']
        }
      }),

      asyncRequestHandler<
        ActivityListReposWatchedByUserRequest,
        ActivityListReposWatchedByUserResponse
      >(async (req, res, next) => {
        const controller = this.resolver
          .forRequest(req)
          .resolve<ActivityListReposWatchedByUserHandler>(
            Handlers.ActivityListReposWatchedByUserHandler
          );

        await controller.activityListReposWatchedByUser(req, res, next);
      })
    );
  }

  private addMetaGetZenHandler(router: Router): void {
    router.get(
      '/zen',

      asyncRequestHandler<MetaGetZenRequest, MetaGetZenResponse>(
        async (req, res, next) => {
          const controller = this.resolver
            .forRequest(req)
            .resolve<MetaGetZenHandler>(Handlers.MetaGetZenHandler);

          await controller.metaGetZen(req, res, next);
        }
      )
    );
  }

  private static validationErrorMiddleware: ErrorRequestHandler = (
    error,
    _,
    response,
    next
  ) => {
    if (error instanceof ValidationError) {
      response.status(400).send({
        type: 'REQUEST_VALIDATION_FAILED',
        fields: error.validationErrors
      });
      next();
    } else {
      next(error);
    }
  };

  public apply(expressApp: Express): void {
    const router = Router();

    this.addMetaRootHandler(router);
    this.addAppsGetAuthenticatedHandler(router);
    this.addAppsCreateFromManifestHandler(router);
    this.addAppsGetWebhookConfigForAppHandler(router);
    this.addAppsUpdateWebhookConfigForAppHandler(router);
    this.addAppsListWebhookDeliveriesHandler(router);
    this.addAppsGetWebhookDeliveryHandler(router);
    this.addAppsRedeliverWebhookDeliveryHandler(router);
    this.addAppsListInstallationsHandler(router);
    this.addAppsGetInstallationHandler(router);
    this.addAppsDeleteInstallationHandler(router);
    this.addAppsCreateInstallationAccessTokenHandler(router);
    this.addAppsSuspendInstallationHandler(router);
    this.addAppsUnsuspendInstallationHandler(router);
    this.addAppsDeleteAuthorizationHandler(router);
    this.addAppsCheckTokenHandler(router);
    this.addAppsResetTokenHandler(router);
    this.addAppsDeleteTokenHandler(router);
    this.addAppsScopeTokenHandler(router);
    this.addAppsGetBySlugHandler(router);
    this.addCodesOfConductGetAllCodesOfConductHandler(router);
    this.addCodesOfConductGetConductCodeHandler(router);
    this.addEmojisGetHandler(router);
    this.addEnterpriseAdminGetServerStatisticsHandler(router);
    this.addActionsGetActionsCacheUsageForEnterpriseHandler(router);
    this.addEnterpriseAdminGetGithubActionsPermissionsEnterpriseHandler(router);
    this.addEnterpriseAdminSetGithubActionsPermissionsEnterpriseHandler(router);
    this.addEnterpriseAdminListSelectedOrganizationsEnabledGithubActionsEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminSetSelectedOrganizationsEnabledGithubActionsEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminEnableSelectedOrganizationGithubActionsEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminDisableSelectedOrganizationGithubActionsEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminGetAllowedActionsEnterpriseHandler(router);
    this.addEnterpriseAdminSetAllowedActionsEnterpriseHandler(router);
    this.addActionsGetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler(
      router
    );
    this.addActionsSetGithubActionsDefaultWorkflowPermissionsEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminListSelfHostedRunnerGroupsForEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminCreateSelfHostedRunnerGroupForEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminGetSelfHostedRunnerGroupForEnterpriseHandler(router);
    this.addEnterpriseAdminUpdateSelfHostedRunnerGroupForEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminDeleteSelfHostedRunnerGroupFromEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminListOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminSetOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminAddOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminRemoveOrgAccessToSelfHostedRunnerGroupInEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminListSelfHostedRunnersInGroupForEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminSetSelfHostedRunnersInGroupForEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminAddSelfHostedRunnerToGroupForEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminRemoveSelfHostedRunnerFromGroupForEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminListSelfHostedRunnersForEnterpriseHandler(router);
    this.addEnterpriseAdminListRunnerApplicationsForEnterpriseHandler(router);
    this.addEnterpriseAdminCreateRegistrationTokenForEnterpriseHandler(router);
    this.addEnterpriseAdminCreateRemoveTokenForEnterpriseHandler(router);
    this.addEnterpriseAdminGetSelfHostedRunnerForEnterpriseHandler(router);
    this.addEnterpriseAdminDeleteSelfHostedRunnerFromEnterpriseHandler(router);
    this.addEnterpriseAdminListLabelsForSelfHostedRunnerForEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminAddCustomLabelsToSelfHostedRunnerForEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminSetCustomLabelsForSelfHostedRunnerForEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminRemoveAllCustomLabelsFromSelfHostedRunnerForEnterpriseHandler(
      router
    );
    this.addEnterpriseAdminRemoveCustomLabelFromSelfHostedRunnerForEnterpriseHandler(
      router
    );
    this.addCodeScanningListAlertsForEnterpriseHandler(router);
    this.addSecretScanningListAlertsForEnterpriseHandler(router);
    this.addBillingGetGithubAdvancedSecurityBillingGheHandler(router);
    this.addActivityListPublicEventsHandler(router);
    this.addActivityGetFeedsHandler(router);
    this.addGistsListHandler(router);
    this.addGistsCreateHandler(router);
    this.addGistsListPublicHandler(router);
    this.addGistsListStarredHandler(router);
    this.addGistsGetHandler(router);
    this.addGistsUpdateHandler(router);
    this.addGistsDeleteHandler(router);
    this.addGistsListCommentsHandler(router);
    this.addGistsCreateCommentHandler(router);
    this.addGistsGetCommentHandler(router);
    this.addGistsUpdateCommentHandler(router);
    this.addGistsDeleteCommentHandler(router);
    this.addGistsListCommitsHandler(router);
    this.addGistsListForksHandler(router);
    this.addGistsForkHandler(router);
    this.addGistsCheckIsStarredHandler(router);
    this.addGistsStarHandler(router);
    this.addGistsUnstarHandler(router);
    this.addGistsGetRevisionHandler(router);
    this.addGitignoreGetAllTemplatesHandler(router);
    this.addGitignoreGetTemplateHandler(router);
    this.addAppsListReposAccessibleToInstallationHandler(router);
    this.addAppsRevokeInstallationAccessTokenHandler(router);
    this.addIssuesListHandler(router);
    this.addLicensesGetAllCommonlyUsedHandler(router);
    this.addLicensesGetHandler(router);
    this.addMarkdownRenderHandler(router);
    this.addMarkdownRenderRawHandler(router);
    this.addAppsGetSubscriptionPlanForAccountHandler(router);
    this.addAppsListPlansHandler(router);
    this.addAppsListAccountsForPlanHandler(router);
    this.addAppsGetSubscriptionPlanForAccountStubbedHandler(router);
    this.addAppsListPlansStubbedHandler(router);
    this.addAppsListAccountsForPlanStubbedHandler(router);
    this.addMetaGetHandler(router);
    this.addActivityListPublicEventsForRepoNetworkHandler(router);
    this.addActivityListNotificationsForAuthenticatedUserHandler(router);
    this.addActivityMarkNotificationsAsReadHandler(router);
    this.addActivityGetThreadHandler(router);
    this.addActivityMarkThreadAsReadHandler(router);
    this.addActivityGetThreadSubscriptionForAuthenticatedUserHandler(router);
    this.addActivitySetThreadSubscriptionHandler(router);
    this.addActivityDeleteThreadSubscriptionHandler(router);
    this.addMetaGetOctocatHandler(router);
    this.addOrgsListHandler(router);
    this.addOrgsListCustomRolesHandler(router);
    this.addOrgsGetHandler(router);
    this.addOrgsUpdateHandler(router);
    this.addActionsGetActionsCacheUsageForOrgHandler(router);
    this.addActionsGetActionsCacheUsageByRepoForOrgHandler(router);
    this.addActionsGetGithubActionsPermissionsOrganizationHandler(router);
    this.addActionsSetGithubActionsPermissionsOrganizationHandler(router);
    this.addActionsListSelectedRepositoriesEnabledGithubActionsOrganizationHandler(
      router
    );
    this.addActionsSetSelectedRepositoriesEnabledGithubActionsOrganizationHandler(
      router
    );
    this.addActionsEnableSelectedRepositoryGithubActionsOrganizationHandler(
      router
    );
    this.addActionsDisableSelectedRepositoryGithubActionsOrganizationHandler(
      router
    );
    this.addActionsGetAllowedActionsOrganizationHandler(router);
    this.addActionsSetAllowedActionsOrganizationHandler(router);
    this.addActionsGetGithubActionsDefaultWorkflowPermissionsOrganizationHandler(
      router
    );
    this.addActionsSetGithubActionsDefaultWorkflowPermissionsOrganizationHandler(
      router
    );
    this.addActionsListSelfHostedRunnerGroupsForOrgHandler(router);
    this.addActionsCreateSelfHostedRunnerGroupForOrgHandler(router);
    this.addActionsGetSelfHostedRunnerGroupForOrgHandler(router);
    this.addActionsUpdateSelfHostedRunnerGroupForOrgHandler(router);
    this.addActionsDeleteSelfHostedRunnerGroupFromOrgHandler(router);
    this.addActionsListRepoAccessToSelfHostedRunnerGroupInOrgHandler(router);
    this.addActionsSetRepoAccessToSelfHostedRunnerGroupInOrgHandler(router);
    this.addActionsRemoveRepoAccessToSelfHostedRunnerGroupInOrgHandler(router);
    this.addActionsListSelfHostedRunnersInGroupForOrgHandler(router);
    this.addActionsSetSelfHostedRunnersInGroupForOrgHandler(router);
    this.addActionsAddSelfHostedRunnerToGroupForOrgHandler(router);
    this.addActionsRemoveSelfHostedRunnerFromGroupForOrgHandler(router);
    this.addActionsListSelfHostedRunnersForOrgHandler(router);
    this.addActionsListRunnerApplicationsForOrgHandler(router);
    this.addActionsCreateRegistrationTokenForOrgHandler(router);
    this.addActionsCreateRemoveTokenForOrgHandler(router);
    this.addActionsGetSelfHostedRunnerForOrgHandler(router);
    this.addActionsDeleteSelfHostedRunnerFromOrgHandler(router);
    this.addActionsListLabelsForSelfHostedRunnerForOrgHandler(router);
    this.addActionsAddCustomLabelsToSelfHostedRunnerForOrgHandler(router);
    this.addActionsSetCustomLabelsForSelfHostedRunnerForOrgHandler(router);
    this.addActionsRemoveAllCustomLabelsFromSelfHostedRunnerForOrgHandler(
      router
    );
    this.addActionsRemoveCustomLabelFromSelfHostedRunnerForOrgHandler(router);
    this.addActionsListOrgSecretsHandler(router);
    this.addActionsGetOrgPublicKeyHandler(router);
    this.addActionsGetOrgSecretHandler(router);
    this.addActionsCreateOrUpdateOrgSecretHandler(router);
    this.addActionsDeleteOrgSecretHandler(router);
    this.addActionsListSelectedReposForOrgSecretHandler(router);
    this.addActionsSetSelectedReposForOrgSecretHandler(router);
    this.addActionsAddSelectedRepoToOrgSecretHandler(router);
    this.addActionsRemoveSelectedRepoFromOrgSecretHandler(router);
    this.addOrgsListBlockedUsersHandler(router);
    this.addOrgsCheckBlockedUserHandler(router);
    this.addOrgsBlockUserHandler(router);
    this.addOrgsUnblockUserHandler(router);
    this.addCodeScanningListAlertsForOrgHandler(router);
    this.addCodespacesListInOrganizationHandler(router);
    this.addCodespacesSetCodespacesBillingHandler(router);
    this.addCodespacesListOrgSecretsHandler(router);
    this.addCodespacesGetOrgPublicKeyHandler(router);
    this.addCodespacesGetOrgSecretHandler(router);
    this.addCodespacesCreateOrUpdateOrgSecretHandler(router);
    this.addCodespacesDeleteOrgSecretHandler(router);
    this.addCodespacesListSelectedReposForOrgSecretHandler(router);
    this.addCodespacesSetSelectedReposForOrgSecretHandler(router);
    this.addCodespacesAddSelectedRepoToOrgSecretHandler(router);
    this.addCodespacesRemoveSelectedRepoFromOrgSecretHandler(router);
    this.addOrgsCreateCustomRoleHandler(router);
    this.addOrgsGetCustomRoleHandler(router);
    this.addOrgsUpdateCustomRoleHandler(router);
    this.addOrgsDeleteCustomRoleHandler(router);
    this.addDependabotListAlertsForOrgHandler(router);
    this.addDependabotListOrgSecretsHandler(router);
    this.addDependabotGetOrgPublicKeyHandler(router);
    this.addDependabotGetOrgSecretHandler(router);
    this.addDependabotCreateOrUpdateOrgSecretHandler(router);
    this.addDependabotDeleteOrgSecretHandler(router);
    this.addDependabotListSelectedReposForOrgSecretHandler(router);
    this.addDependabotSetSelectedReposForOrgSecretHandler(router);
    this.addDependabotAddSelectedRepoToOrgSecretHandler(router);
    this.addDependabotRemoveSelectedRepoFromOrgSecretHandler(router);
    this.addActivityListPublicOrgEventsHandler(router);
    this.addOrgsListFailedInvitationsHandler(router);
    this.addOrgsListFineGrainedPermissionsHandler(router);
    this.addOrgsListWebhooksHandler(router);
    this.addOrgsCreateWebhookHandler(router);
    this.addOrgsGetWebhookHandler(router);
    this.addOrgsUpdateWebhookHandler(router);
    this.addOrgsDeleteWebhookHandler(router);
    this.addOrgsGetWebhookConfigForOrgHandler(router);
    this.addOrgsUpdateWebhookConfigForOrgHandler(router);
    this.addOrgsListWebhookDeliveriesHandler(router);
    this.addOrgsGetWebhookDeliveryHandler(router);
    this.addOrgsRedeliverWebhookDeliveryHandler(router);
    this.addOrgsPingWebhookHandler(router);
    this.addAppsGetOrgInstallationHandler(router);
    this.addOrgsListAppInstallationsHandler(router);
    this.addInteractionsGetRestrictionsForOrgHandler(router);
    this.addInteractionsSetRestrictionsForOrgHandler(router);
    this.addInteractionsRemoveRestrictionsForOrgHandler(router);
    this.addOrgsListPendingInvitationsHandler(router);
    this.addOrgsCreateInvitationHandler(router);
    this.addOrgsCancelInvitationHandler(router);
    this.addOrgsListInvitationTeamsHandler(router);
    this.addIssuesListForOrgHandler(router);
    this.addOrgsListMembersHandler(router);
    this.addOrgsCheckMembershipForUserHandler(router);
    this.addOrgsRemoveMemberHandler(router);
    this.addCodespacesGetCodespacesForUserInOrgHandler(router);
    this.addCodespacesDeleteFromOrganizationHandler(router);
    this.addCodespacesStopInOrganizationHandler(router);
    this.addOrgsGetMembershipForUserHandler(router);
    this.addOrgsSetMembershipForUserHandler(router);
    this.addOrgsRemoveMembershipForUserHandler(router);
    this.addMigrationsListForOrgHandler(router);
    this.addMigrationsStartForOrgHandler(router);
    this.addMigrationsGetStatusForOrgHandler(router);
    this.addMigrationsDownloadArchiveForOrgHandler(router);
    this.addMigrationsDeleteArchiveForOrgHandler(router);
    this.addMigrationsUnlockRepoForOrgHandler(router);
    this.addMigrationsListReposForOrgHandler(router);
    this.addOrgsListOutsideCollaboratorsHandler(router);
    this.addOrgsConvertMemberToOutsideCollaboratorHandler(router);
    this.addOrgsRemoveOutsideCollaboratorHandler(router);
    this.addPackagesListPackagesForOrganizationHandler(router);
    this.addPackagesGetPackageForOrganizationHandler(router);
    this.addPackagesDeletePackageForOrgHandler(router);
    this.addPackagesRestorePackageForOrgHandler(router);
    this.addPackagesGetAllPackageVersionsForPackageOwnedByOrgHandler(router);
    this.addPackagesGetPackageVersionForOrganizationHandler(router);
    this.addPackagesDeletePackageVersionForOrgHandler(router);
    this.addPackagesRestorePackageVersionForOrgHandler(router);
    this.addProjectsListForOrgHandler(router);
    this.addProjectsCreateForOrgHandler(router);
    this.addOrgsListPublicMembersHandler(router);
    this.addOrgsCheckPublicMembershipForUserHandler(router);
    this.addOrgsSetPublicMembershipForAuthenticatedUserHandler(router);
    this.addOrgsRemovePublicMembershipForAuthenticatedUserHandler(router);
    this.addReposListForOrgHandler(router);
    this.addReposCreateInOrgHandler(router);
    this.addSecretScanningListAlertsForOrgHandler(router);
    this.addOrgsListSecurityManagerTeamsHandler(router);
    this.addOrgsAddSecurityManagerTeamHandler(router);
    this.addOrgsRemoveSecurityManagerTeamHandler(router);
    this.addBillingGetGithubActionsBillingOrgHandler(router);
    this.addBillingGetGithubAdvancedSecurityBillingOrgHandler(router);
    this.addBillingGetGithubPackagesBillingOrgHandler(router);
    this.addBillingGetSharedStorageBillingOrgHandler(router);
    this.addTeamsListHandler(router);
    this.addTeamsCreateHandler(router);
    this.addTeamsGetByNameHandler(router);
    this.addTeamsUpdateInOrgHandler(router);
    this.addTeamsDeleteInOrgHandler(router);
    this.addTeamsListDiscussionsInOrgHandler(router);
    this.addTeamsCreateDiscussionInOrgHandler(router);
    this.addTeamsGetDiscussionInOrgHandler(router);
    this.addTeamsUpdateDiscussionInOrgHandler(router);
    this.addTeamsDeleteDiscussionInOrgHandler(router);
    this.addTeamsListDiscussionCommentsInOrgHandler(router);
    this.addTeamsCreateDiscussionCommentInOrgHandler(router);
    this.addTeamsGetDiscussionCommentInOrgHandler(router);
    this.addTeamsUpdateDiscussionCommentInOrgHandler(router);
    this.addTeamsDeleteDiscussionCommentInOrgHandler(router);
    this.addReactionsListForTeamDiscussionCommentInOrgHandler(router);
    this.addReactionsCreateForTeamDiscussionCommentInOrgHandler(router);
    this.addReactionsDeleteForTeamDiscussionCommentHandler(router);
    this.addReactionsListForTeamDiscussionInOrgHandler(router);
    this.addReactionsCreateForTeamDiscussionInOrgHandler(router);
    this.addReactionsDeleteForTeamDiscussionHandler(router);
    this.addTeamsListPendingInvitationsInOrgHandler(router);
    this.addTeamsListMembersInOrgHandler(router);
    this.addTeamsGetMembershipForUserInOrgHandler(router);
    this.addTeamsAddOrUpdateMembershipForUserInOrgHandler(router);
    this.addTeamsRemoveMembershipForUserInOrgHandler(router);
    this.addTeamsListProjectsInOrgHandler(router);
    this.addTeamsCheckPermissionsForProjectInOrgHandler(router);
    this.addTeamsAddOrUpdateProjectPermissionsInOrgHandler(router);
    this.addTeamsRemoveProjectInOrgHandler(router);
    this.addTeamsListReposInOrgHandler(router);
    this.addTeamsCheckPermissionsForRepoInOrgHandler(router);
    this.addTeamsAddOrUpdateRepoPermissionsInOrgHandler(router);
    this.addTeamsRemoveRepoInOrgHandler(router);
    this.addTeamsListChildInOrgHandler(router);
    this.addOrgsEnableOrDisableSecurityProductOnAllOrgReposHandler(router);
    this.addProjectsGetCardHandler(router);
    this.addProjectsUpdateCardHandler(router);
    this.addProjectsDeleteCardHandler(router);
    this.addProjectsMoveCardHandler(router);
    this.addProjectsGetColumnHandler(router);
    this.addProjectsUpdateColumnHandler(router);
    this.addProjectsDeleteColumnHandler(router);
    this.addProjectsListCardsHandler(router);
    this.addProjectsCreateCardHandler(router);
    this.addProjectsMoveColumnHandler(router);
    this.addProjectsGetHandler(router);
    this.addProjectsUpdateHandler(router);
    this.addProjectsDeleteHandler(router);
    this.addProjectsListCollaboratorsHandler(router);
    this.addProjectsAddCollaboratorHandler(router);
    this.addProjectsRemoveCollaboratorHandler(router);
    this.addProjectsGetPermissionForUserHandler(router);
    this.addProjectsListColumnsHandler(router);
    this.addProjectsCreateColumnHandler(router);
    this.addRateLimitGetHandler(router);
    this.addReposGetHandler(router);
    this.addReposUpdateHandler(router);
    this.addReposDeleteHandler(router);
    this.addActionsListArtifactsForRepoHandler(router);
    this.addActionsGetArtifactHandler(router);
    this.addActionsDeleteArtifactHandler(router);
    this.addActionsDownloadArtifactHandler(router);
    this.addActionsGetActionsCacheUsageHandler(router);
    this.addActionsGetActionsCacheListHandler(router);
    this.addActionsDeleteActionsCacheByKeyHandler(router);
    this.addActionsDeleteActionsCacheByIdHandler(router);
    this.addActionsGetJobForWorkflowRunHandler(router);
    this.addActionsDownloadJobLogsForWorkflowRunHandler(router);
    this.addActionsReRunJobForWorkflowRunHandler(router);
    this.addActionsGetGithubActionsPermissionsRepositoryHandler(router);
    this.addActionsSetGithubActionsPermissionsRepositoryHandler(router);
    this.addActionsGetWorkflowAccessToRepositoryHandler(router);
    this.addActionsSetWorkflowAccessToRepositoryHandler(router);
    this.addActionsGetAllowedActionsRepositoryHandler(router);
    this.addActionsSetAllowedActionsRepositoryHandler(router);
    this.addActionsGetGithubActionsDefaultWorkflowPermissionsRepositoryHandler(
      router
    );
    this.addActionsSetGithubActionsDefaultWorkflowPermissionsRepositoryHandler(
      router
    );
    this.addActionsListSelfHostedRunnersForRepoHandler(router);
    this.addActionsListRunnerApplicationsForRepoHandler(router);
    this.addActionsCreateRegistrationTokenForRepoHandler(router);
    this.addActionsCreateRemoveTokenForRepoHandler(router);
    this.addActionsGetSelfHostedRunnerForRepoHandler(router);
    this.addActionsDeleteSelfHostedRunnerFromRepoHandler(router);
    this.addActionsListLabelsForSelfHostedRunnerForRepoHandler(router);
    this.addActionsAddCustomLabelsToSelfHostedRunnerForRepoHandler(router);
    this.addActionsSetCustomLabelsForSelfHostedRunnerForRepoHandler(router);
    this.addActionsRemoveAllCustomLabelsFromSelfHostedRunnerForRepoHandler(
      router
    );
    this.addActionsRemoveCustomLabelFromSelfHostedRunnerForRepoHandler(router);
    this.addActionsListWorkflowRunsForRepoHandler(router);
    this.addActionsGetWorkflowRunHandler(router);
    this.addActionsDeleteWorkflowRunHandler(router);
    this.addActionsGetReviewsForRunHandler(router);
    this.addActionsApproveWorkflowRunHandler(router);
    this.addActionsListWorkflowRunArtifactsHandler(router);
    this.addActionsGetWorkflowRunAttemptHandler(router);
    this.addActionsListJobsForWorkflowRunAttemptHandler(router);
    this.addActionsDownloadWorkflowRunAttemptLogsHandler(router);
    this.addActionsCancelWorkflowRunHandler(router);
    this.addActionsListJobsForWorkflowRunHandler(router);
    this.addActionsDownloadWorkflowRunLogsHandler(router);
    this.addActionsDeleteWorkflowRunLogsHandler(router);
    this.addActionsGetPendingDeploymentsForRunHandler(router);
    this.addActionsReviewPendingDeploymentsForRunHandler(router);
    this.addActionsReRunWorkflowHandler(router);
    this.addActionsReRunWorkflowFailedJobsHandler(router);
    this.addActionsGetWorkflowRunUsageHandler(router);
    this.addActionsListRepoSecretsHandler(router);
    this.addActionsGetRepoPublicKeyHandler(router);
    this.addActionsGetRepoSecretHandler(router);
    this.addActionsCreateOrUpdateRepoSecretHandler(router);
    this.addActionsDeleteRepoSecretHandler(router);
    this.addActionsListRepoWorkflowsHandler(router);
    this.addActionsGetWorkflowHandler(router);
    this.addActionsDisableWorkflowHandler(router);
    this.addActionsCreateWorkflowDispatchHandler(router);
    this.addActionsEnableWorkflowHandler(router);
    this.addActionsListWorkflowRunsHandler(router);
    this.addActionsGetWorkflowUsageHandler(router);
    this.addIssuesListAssigneesHandler(router);
    this.addIssuesCheckUserCanBeAssignedHandler(router);
    this.addReposListAutolinksHandler(router);
    this.addReposCreateAutolinkHandler(router);
    this.addReposGetAutolinkHandler(router);
    this.addReposDeleteAutolinkHandler(router);
    this.addReposEnableAutomatedSecurityFixesHandler(router);
    this.addReposDisableAutomatedSecurityFixesHandler(router);
    this.addReposListBranchesHandler(router);
    this.addReposGetBranchHandler(router);
    this.addReposGetBranchProtectionHandler(router);
    this.addReposUpdateBranchProtectionHandler(router);
    this.addReposDeleteBranchProtectionHandler(router);
    this.addReposGetAdminBranchProtectionHandler(router);
    this.addReposSetAdminBranchProtectionHandler(router);
    this.addReposDeleteAdminBranchProtectionHandler(router);
    this.addReposGetPullRequestReviewProtectionHandler(router);
    this.addReposUpdatePullRequestReviewProtectionHandler(router);
    this.addReposDeletePullRequestReviewProtectionHandler(router);
    this.addReposGetCommitSignatureProtectionHandler(router);
    this.addReposCreateCommitSignatureProtectionHandler(router);
    this.addReposDeleteCommitSignatureProtectionHandler(router);
    this.addReposGetStatusChecksProtectionHandler(router);
    this.addReposUpdateStatusCheckProtectionHandler(router);
    this.addReposRemoveStatusCheckProtectionHandler(router);
    this.addReposGetAllStatusCheckContextsHandler(router);
    this.addReposAddStatusCheckContextsHandler(router);
    this.addReposSetStatusCheckContextsHandler(router);
    this.addReposRemoveStatusCheckContextsHandler(router);
    this.addReposGetAccessRestrictionsHandler(router);
    this.addReposDeleteAccessRestrictionsHandler(router);
    this.addReposGetAppsWithAccessToProtectedBranchHandler(router);
    this.addReposAddAppAccessRestrictionsHandler(router);
    this.addReposSetAppAccessRestrictionsHandler(router);
    this.addReposRemoveAppAccessRestrictionsHandler(router);
    this.addReposGetTeamsWithAccessToProtectedBranchHandler(router);
    this.addReposAddTeamAccessRestrictionsHandler(router);
    this.addReposSetTeamAccessRestrictionsHandler(router);
    this.addReposRemoveTeamAccessRestrictionsHandler(router);
    this.addReposGetUsersWithAccessToProtectedBranchHandler(router);
    this.addReposAddUserAccessRestrictionsHandler(router);
    this.addReposSetUserAccessRestrictionsHandler(router);
    this.addReposRemoveUserAccessRestrictionsHandler(router);
    this.addReposRenameBranchHandler(router);
    this.addChecksCreateHandler(router);
    this.addChecksGetHandler(router);
    this.addChecksUpdateHandler(router);
    this.addChecksListAnnotationsHandler(router);
    this.addChecksRerequestRunHandler(router);
    this.addChecksCreateSuiteHandler(router);
    this.addChecksSetSuitesPreferencesHandler(router);
    this.addChecksGetSuiteHandler(router);
    this.addChecksListForSuiteHandler(router);
    this.addChecksRerequestSuiteHandler(router);
    this.addCodeScanningListAlertsForRepoHandler(router);
    this.addCodeScanningGetAlertHandler(router);
    this.addCodeScanningUpdateAlertHandler(router);
    this.addCodeScanningListAlertInstancesHandler(router);
    this.addCodeScanningListRecentAnalysesHandler(router);
    this.addCodeScanningGetAnalysisHandler(router);
    this.addCodeScanningDeleteAnalysisHandler(router);
    this.addCodeScanningListCodeqlDatabasesHandler(router);
    this.addCodeScanningGetCodeqlDatabaseHandler(router);
    this.addCodeScanningUploadSarifHandler(router);
    this.addCodeScanningGetSarifHandler(router);
    this.addReposCodeownersErrorsHandler(router);
    this.addCodespacesListInRepositoryForAuthenticatedUserHandler(router);
    this.addCodespacesCreateWithRepoForAuthenticatedUserHandler(router);
    this.addCodespacesListDevcontainersInRepositoryForAuthenticatedUserHandler(
      router
    );
    this.addCodespacesRepoMachinesForAuthenticatedUserHandler(router);
    this.addCodespacesPreFlightWithRepoForAuthenticatedUserHandler(router);
    this.addCodespacesListRepoSecretsHandler(router);
    this.addCodespacesGetRepoPublicKeyHandler(router);
    this.addCodespacesGetRepoSecretHandler(router);
    this.addCodespacesCreateOrUpdateRepoSecretHandler(router);
    this.addCodespacesDeleteRepoSecretHandler(router);
    this.addReposListCollaboratorsHandler(router);
    this.addReposCheckCollaboratorHandler(router);
    this.addReposAddCollaboratorHandler(router);
    this.addReposRemoveCollaboratorHandler(router);
    this.addReposGetCollaboratorPermissionLevelHandler(router);
    this.addReposListCommitCommentsForRepoHandler(router);
    this.addReposGetCommitCommentHandler(router);
    this.addReposUpdateCommitCommentHandler(router);
    this.addReposDeleteCommitCommentHandler(router);
    this.addReactionsListForCommitCommentHandler(router);
    this.addReactionsCreateForCommitCommentHandler(router);
    this.addReactionsDeleteForCommitCommentHandler(router);
    this.addReposListCommitsHandler(router);
    this.addReposListBranchesForHeadCommitHandler(router);
    this.addReposListCommentsForCommitHandler(router);
    this.addReposCreateCommitCommentHandler(router);
    this.addReposListPullRequestsAssociatedWithCommitHandler(router);
    this.addReposGetCommitHandler(router);
    this.addChecksListForRefHandler(router);
    this.addChecksListSuitesForRefHandler(router);
    this.addReposGetCombinedStatusForRefHandler(router);
    this.addReposListCommitStatusesForRefHandler(router);
    this.addReposGetCommunityProfileMetricsHandler(router);
    this.addReposCompareCommitsHandler(router);
    this.addReposGetContentHandler(router);
    this.addReposCreateOrUpdateFileContentsHandler(router);
    this.addReposDeleteFileHandler(router);
    this.addReposListContributorsHandler(router);
    this.addDependabotListAlertsForRepoHandler(router);
    this.addDependabotGetAlertHandler(router);
    this.addDependabotUpdateAlertHandler(router);
    this.addDependabotListRepoSecretsHandler(router);
    this.addDependabotGetRepoPublicKeyHandler(router);
    this.addDependabotGetRepoSecretHandler(router);
    this.addDependabotCreateOrUpdateRepoSecretHandler(router);
    this.addDependabotDeleteRepoSecretHandler(router);
    this.addDependencyGraphDiffRangeHandler(router);
    this.addDependencyGraphCreateRepositorySnapshotHandler(router);
    this.addReposListDeploymentsHandler(router);
    this.addReposCreateDeploymentHandler(router);
    this.addReposGetDeploymentHandler(router);
    this.addReposDeleteDeploymentHandler(router);
    this.addReposListDeploymentStatusesHandler(router);
    this.addReposCreateDeploymentStatusHandler(router);
    this.addReposGetDeploymentStatusHandler(router);
    this.addReposCreateDispatchEventHandler(router);
    this.addReposGetAllEnvironmentsHandler(router);
    this.addReposGetEnvironmentHandler(router);
    this.addReposCreateOrUpdateEnvironmentHandler(router);
    this.addReposDeleteAnEnvironmentHandler(router);
    this.addReposListDeploymentBranchPoliciesHandler(router);
    this.addReposCreateDeploymentBranchPolicyHandler(router);
    this.addReposGetDeploymentBranchPolicyHandler(router);
    this.addReposUpdateDeploymentBranchPolicyHandler(router);
    this.addReposDeleteDeploymentBranchPolicyHandler(router);
    this.addActivityListRepoEventsHandler(router);
    this.addReposListForksHandler(router);
    this.addReposCreateForkHandler(router);
    this.addGitCreateBlobHandler(router);
    this.addGitGetBlobHandler(router);
    this.addGitCreateCommitHandler(router);
    this.addGitGetCommitHandler(router);
    this.addGitListMatchingRefsHandler(router);
    this.addGitGetRefHandler(router);
    this.addGitCreateRefHandler(router);
    this.addGitUpdateRefHandler(router);
    this.addGitDeleteRefHandler(router);
    this.addGitCreateTagHandler(router);
    this.addGitGetTagHandler(router);
    this.addGitCreateTreeHandler(router);
    this.addGitGetTreeHandler(router);
    this.addReposListWebhooksHandler(router);
    this.addReposCreateWebhookHandler(router);
    this.addReposGetWebhookHandler(router);
    this.addReposUpdateWebhookHandler(router);
    this.addReposDeleteWebhookHandler(router);
    this.addReposGetWebhookConfigForRepoHandler(router);
    this.addReposUpdateWebhookConfigForRepoHandler(router);
    this.addReposListWebhookDeliveriesHandler(router);
    this.addReposGetWebhookDeliveryHandler(router);
    this.addReposRedeliverWebhookDeliveryHandler(router);
    this.addReposPingWebhookHandler(router);
    this.addReposTestPushWebhookHandler(router);
    this.addMigrationsGetImportStatusHandler(router);
    this.addMigrationsStartImportHandler(router);
    this.addMigrationsUpdateImportHandler(router);
    this.addMigrationsCancelImportHandler(router);
    this.addMigrationsGetCommitAuthorsHandler(router);
    this.addMigrationsMapCommitAuthorHandler(router);
    this.addMigrationsGetLargeFilesHandler(router);
    this.addMigrationsSetLfsPreferenceHandler(router);
    this.addAppsGetRepoInstallationHandler(router);
    this.addInteractionsGetRestrictionsForRepoHandler(router);
    this.addInteractionsSetRestrictionsForRepoHandler(router);
    this.addInteractionsRemoveRestrictionsForRepoHandler(router);
    this.addReposListInvitationsHandler(router);
    this.addReposUpdateInvitationHandler(router);
    this.addReposDeleteInvitationHandler(router);
    this.addIssuesListForRepoHandler(router);
    this.addIssuesCreateHandler(router);
    this.addIssuesListCommentsForRepoHandler(router);
    this.addIssuesGetCommentHandler(router);
    this.addIssuesUpdateCommentHandler(router);
    this.addIssuesDeleteCommentHandler(router);
    this.addReactionsListForIssueCommentHandler(router);
    this.addReactionsCreateForIssueCommentHandler(router);
    this.addReactionsDeleteForIssueCommentHandler(router);
    this.addIssuesListEventsForRepoHandler(router);
    this.addIssuesGetEventHandler(router);
    this.addIssuesGetHandler(router);
    this.addIssuesUpdateHandler(router);
    this.addIssuesAddAssigneesHandler(router);
    this.addIssuesRemoveAssigneesHandler(router);
    this.addIssuesListCommentsHandler(router);
    this.addIssuesCreateCommentHandler(router);
    this.addIssuesListEventsHandler(router);
    this.addIssuesListLabelsOnIssueHandler(router);
    this.addIssuesAddLabelsHandler(router);
    this.addIssuesSetLabelsHandler(router);
    this.addIssuesRemoveAllLabelsHandler(router);
    this.addIssuesRemoveLabelHandler(router);
    this.addIssuesLockHandler(router);
    this.addIssuesUnlockHandler(router);
    this.addReactionsListForIssueHandler(router);
    this.addReactionsCreateForIssueHandler(router);
    this.addReactionsDeleteForIssueHandler(router);
    this.addIssuesListEventsForTimelineHandler(router);
    this.addReposListDeployKeysHandler(router);
    this.addReposCreateDeployKeyHandler(router);
    this.addReposGetDeployKeyHandler(router);
    this.addReposDeleteDeployKeyHandler(router);
    this.addIssuesListLabelsForRepoHandler(router);
    this.addIssuesCreateLabelHandler(router);
    this.addIssuesGetLabelHandler(router);
    this.addIssuesUpdateLabelHandler(router);
    this.addIssuesDeleteLabelHandler(router);
    this.addReposListLanguagesHandler(router);
    this.addReposEnableLfsForRepoHandler(router);
    this.addReposDisableLfsForRepoHandler(router);
    this.addLicensesGetForRepoHandler(router);
    this.addReposMergeUpstreamHandler(router);
    this.addReposMergeHandler(router);
    this.addIssuesListMilestonesHandler(router);
    this.addIssuesCreateMilestoneHandler(router);
    this.addIssuesGetMilestoneHandler(router);
    this.addIssuesUpdateMilestoneHandler(router);
    this.addIssuesDeleteMilestoneHandler(router);
    this.addIssuesListLabelsForMilestoneHandler(router);
    this.addActivityListRepoNotificationsForAuthenticatedUserHandler(router);
    this.addActivityMarkRepoNotificationsAsReadHandler(router);
    this.addReposGetPagesHandler(router);
    this.addReposCreatePagesSiteHandler(router);
    this.addReposUpdateInformationAboutPagesSiteHandler(router);
    this.addReposDeletePagesSiteHandler(router);
    this.addReposListPagesBuildsHandler(router);
    this.addReposRequestPagesBuildHandler(router);
    this.addReposGetLatestPagesBuildHandler(router);
    this.addReposGetPagesBuildHandler(router);
    this.addReposCreatePagesDeploymentHandler(router);
    this.addReposGetPagesHealthCheckHandler(router);
    this.addProjectsListForRepoHandler(router);
    this.addProjectsCreateForRepoHandler(router);
    this.addPullsListHandler(router);
    this.addPullsCreateHandler(router);
    this.addPullsListReviewCommentsForRepoHandler(router);
    this.addPullsGetReviewCommentHandler(router);
    this.addPullsUpdateReviewCommentHandler(router);
    this.addPullsDeleteReviewCommentHandler(router);
    this.addReactionsListForPullRequestReviewCommentHandler(router);
    this.addReactionsCreateForPullRequestReviewCommentHandler(router);
    this.addReactionsDeleteForPullRequestCommentHandler(router);
    this.addPullsGetHandler(router);
    this.addPullsUpdateHandler(router);
    this.addCodespacesCreateWithPrForAuthenticatedUserHandler(router);
    this.addPullsListReviewCommentsHandler(router);
    this.addPullsCreateReviewCommentHandler(router);
    this.addPullsCreateReplyForReviewCommentHandler(router);
    this.addPullsListCommitsHandler(router);
    this.addPullsListFilesHandler(router);
    this.addPullsCheckIfMergedHandler(router);
    this.addPullsMergeHandler(router);
    this.addPullsListRequestedReviewersHandler(router);
    this.addPullsRequestReviewersHandler(router);
    this.addPullsRemoveRequestedReviewersHandler(router);
    this.addPullsListReviewsHandler(router);
    this.addPullsCreateReviewHandler(router);
    this.addPullsGetReviewHandler(router);
    this.addPullsUpdateReviewHandler(router);
    this.addPullsDeletePendingReviewHandler(router);
    this.addPullsListCommentsForReviewHandler(router);
    this.addPullsDismissReviewHandler(router);
    this.addPullsSubmitReviewHandler(router);
    this.addPullsUpdateBranchHandler(router);
    this.addReposGetReadmeHandler(router);
    this.addReposGetReadmeInDirectoryHandler(router);
    this.addReposListReleasesHandler(router);
    this.addReposCreateReleaseHandler(router);
    this.addReposGetReleaseAssetHandler(router);
    this.addReposUpdateReleaseAssetHandler(router);
    this.addReposDeleteReleaseAssetHandler(router);
    this.addReposGenerateReleaseNotesHandler(router);
    this.addReposGetLatestReleaseHandler(router);
    this.addReposGetReleaseByTagHandler(router);
    this.addReposGetReleaseHandler(router);
    this.addReposUpdateReleaseHandler(router);
    this.addReposDeleteReleaseHandler(router);
    this.addReposListReleaseAssetsHandler(router);
    this.addReposUploadReleaseAssetHandler(router);
    this.addReactionsListForReleaseHandler(router);
    this.addReactionsCreateForReleaseHandler(router);
    this.addReactionsDeleteForReleaseHandler(router);
    this.addSecretScanningListAlertsForRepoHandler(router);
    this.addSecretScanningGetAlertHandler(router);
    this.addSecretScanningUpdateAlertHandler(router);
    this.addSecretScanningListLocationsForAlertHandler(router);
    this.addActivityListStargazersForRepoHandler(router);
    this.addReposGetCodeFrequencyStatsHandler(router);
    this.addReposGetCommitActivityStatsHandler(router);
    this.addReposGetContributorsStatsHandler(router);
    this.addReposGetParticipationStatsHandler(router);
    this.addReposGetPunchCardStatsHandler(router);
    this.addReposCreateCommitStatusHandler(router);
    this.addActivityListWatchersForRepoHandler(router);
    this.addActivityGetRepoSubscriptionHandler(router);
    this.addActivitySetRepoSubscriptionHandler(router);
    this.addActivityDeleteRepoSubscriptionHandler(router);
    this.addReposListTagsHandler(router);
    this.addReposListTagProtectionHandler(router);
    this.addReposCreateTagProtectionHandler(router);
    this.addReposDeleteTagProtectionHandler(router);
    this.addReposDownloadTarballArchiveHandler(router);
    this.addReposListTeamsHandler(router);
    this.addReposGetAllTopicsHandler(router);
    this.addReposReplaceAllTopicsHandler(router);
    this.addReposGetClonesHandler(router);
    this.addReposGetTopPathsHandler(router);
    this.addReposGetTopReferrersHandler(router);
    this.addReposGetViewsHandler(router);
    this.addReposTransferHandler(router);
    this.addReposCheckVulnerabilityAlertsHandler(router);
    this.addReposEnableVulnerabilityAlertsHandler(router);
    this.addReposDisableVulnerabilityAlertsHandler(router);
    this.addReposDownloadZipballArchiveHandler(router);
    this.addReposCreateUsingTemplateHandler(router);
    this.addReposListPublicHandler(router);
    this.addActionsListEnvironmentSecretsHandler(router);
    this.addActionsGetEnvironmentPublicKeyHandler(router);
    this.addActionsGetEnvironmentSecretHandler(router);
    this.addActionsCreateOrUpdateEnvironmentSecretHandler(router);
    this.addActionsDeleteEnvironmentSecretHandler(router);
    this.addSearchCodeHandler(router);
    this.addSearchCommitsHandler(router);
    this.addSearchIssuesAndPullRequestsHandler(router);
    this.addSearchLabelsHandler(router);
    this.addSearchReposHandler(router);
    this.addSearchTopicsHandler(router);
    this.addSearchUsersHandler(router);
    this.addTeamsGetLegacyHandler(router);
    this.addTeamsUpdateLegacyHandler(router);
    this.addTeamsDeleteLegacyHandler(router);
    this.addTeamsListDiscussionsLegacyHandler(router);
    this.addTeamsCreateDiscussionLegacyHandler(router);
    this.addTeamsGetDiscussionLegacyHandler(router);
    this.addTeamsUpdateDiscussionLegacyHandler(router);
    this.addTeamsDeleteDiscussionLegacyHandler(router);
    this.addTeamsListDiscussionCommentsLegacyHandler(router);
    this.addTeamsCreateDiscussionCommentLegacyHandler(router);
    this.addTeamsGetDiscussionCommentLegacyHandler(router);
    this.addTeamsUpdateDiscussionCommentLegacyHandler(router);
    this.addTeamsDeleteDiscussionCommentLegacyHandler(router);
    this.addReactionsListForTeamDiscussionCommentLegacyHandler(router);
    this.addReactionsCreateForTeamDiscussionCommentLegacyHandler(router);
    this.addReactionsListForTeamDiscussionLegacyHandler(router);
    this.addReactionsCreateForTeamDiscussionLegacyHandler(router);
    this.addTeamsListPendingInvitationsLegacyHandler(router);
    this.addTeamsListMembersLegacyHandler(router);
    this.addTeamsGetMemberLegacyHandler(router);
    this.addTeamsAddMemberLegacyHandler(router);
    this.addTeamsRemoveMemberLegacyHandler(router);
    this.addTeamsGetMembershipForUserLegacyHandler(router);
    this.addTeamsAddOrUpdateMembershipForUserLegacyHandler(router);
    this.addTeamsRemoveMembershipForUserLegacyHandler(router);
    this.addTeamsListProjectsLegacyHandler(router);
    this.addTeamsCheckPermissionsForProjectLegacyHandler(router);
    this.addTeamsAddOrUpdateProjectPermissionsLegacyHandler(router);
    this.addTeamsRemoveProjectLegacyHandler(router);
    this.addTeamsListReposLegacyHandler(router);
    this.addTeamsCheckPermissionsForRepoLegacyHandler(router);
    this.addTeamsAddOrUpdateRepoPermissionsLegacyHandler(router);
    this.addTeamsRemoveRepoLegacyHandler(router);
    this.addTeamsListChildLegacyHandler(router);
    this.addUsersGetAuthenticatedHandler(router);
    this.addUsersUpdateAuthenticatedHandler(router);
    this.addUsersListBlockedByAuthenticatedUserHandler(router);
    this.addUsersCheckBlockedHandler(router);
    this.addUsersBlockHandler(router);
    this.addUsersUnblockHandler(router);
    this.addCodespacesListForAuthenticatedUserHandler(router);
    this.addCodespacesCreateForAuthenticatedUserHandler(router);
    this.addCodespacesListSecretsForAuthenticatedUserHandler(router);
    this.addCodespacesGetPublicKeyForAuthenticatedUserHandler(router);
    this.addCodespacesGetSecretForAuthenticatedUserHandler(router);
    this.addCodespacesCreateOrUpdateSecretForAuthenticatedUserHandler(router);
    this.addCodespacesDeleteSecretForAuthenticatedUserHandler(router);
    this.addCodespacesListRepositoriesForSecretForAuthenticatedUserHandler(
      router
    );
    this.addCodespacesSetRepositoriesForSecretForAuthenticatedUserHandler(
      router
    );
    this.addCodespacesAddRepositoryForSecretForAuthenticatedUserHandler(router);
    this.addCodespacesRemoveRepositoryForSecretForAuthenticatedUserHandler(
      router
    );
    this.addCodespacesGetForAuthenticatedUserHandler(router);
    this.addCodespacesUpdateForAuthenticatedUserHandler(router);
    this.addCodespacesDeleteForAuthenticatedUserHandler(router);
    this.addCodespacesExportForAuthenticatedUserHandler(router);
    this.addCodespacesGetExportDetailsForAuthenticatedUserHandler(router);
    this.addCodespacesCodespaceMachinesForAuthenticatedUserHandler(router);
    this.addCodespacesStartForAuthenticatedUserHandler(router);
    this.addCodespacesStopForAuthenticatedUserHandler(router);
    this.addUsersSetPrimaryEmailVisibilityForAuthenticatedUserHandler(router);
    this.addUsersListEmailsForAuthenticatedUserHandler(router);
    this.addUsersAddEmailForAuthenticatedUserHandler(router);
    this.addUsersDeleteEmailForAuthenticatedUserHandler(router);
    this.addUsersListFollowersForAuthenticatedUserHandler(router);
    this.addUsersListFollowedByAuthenticatedUserHandler(router);
    this.addUsersCheckPersonIsFollowedByAuthenticatedHandler(router);
    this.addUsersFollowHandler(router);
    this.addUsersUnfollowHandler(router);
    this.addUsersListGpgKeysForAuthenticatedUserHandler(router);
    this.addUsersCreateGpgKeyForAuthenticatedUserHandler(router);
    this.addUsersGetGpgKeyForAuthenticatedUserHandler(router);
    this.addUsersDeleteGpgKeyForAuthenticatedUserHandler(router);
    this.addAppsListInstallationsForAuthenticatedUserHandler(router);
    this.addAppsListInstallationReposForAuthenticatedUserHandler(router);
    this.addAppsAddRepoToInstallationForAuthenticatedUserHandler(router);
    this.addAppsRemoveRepoFromInstallationForAuthenticatedUserHandler(router);
    this.addInteractionsGetRestrictionsForAuthenticatedUserHandler(router);
    this.addInteractionsSetRestrictionsForAuthenticatedUserHandler(router);
    this.addInteractionsRemoveRestrictionsForAuthenticatedUserHandler(router);
    this.addIssuesListForAuthenticatedUserHandler(router);
    this.addUsersListPublicSshKeysForAuthenticatedUserHandler(router);
    this.addUsersCreatePublicSshKeyForAuthenticatedUserHandler(router);
    this.addUsersGetPublicSshKeyForAuthenticatedUserHandler(router);
    this.addUsersDeletePublicSshKeyForAuthenticatedUserHandler(router);
    this.addAppsListSubscriptionsForAuthenticatedUserHandler(router);
    this.addAppsListSubscriptionsForAuthenticatedUserStubbedHandler(router);
    this.addOrgsListMembershipsForAuthenticatedUserHandler(router);
    this.addOrgsGetMembershipForAuthenticatedUserHandler(router);
    this.addOrgsUpdateMembershipForAuthenticatedUserHandler(router);
    this.addMigrationsListForAuthenticatedUserHandler(router);
    this.addMigrationsStartForAuthenticatedUserHandler(router);
    this.addMigrationsGetStatusForAuthenticatedUserHandler(router);
    this.addMigrationsGetArchiveForAuthenticatedUserHandler(router);
    this.addMigrationsDeleteArchiveForAuthenticatedUserHandler(router);
    this.addMigrationsUnlockRepoForAuthenticatedUserHandler(router);
    this.addMigrationsListReposForAuthenticatedUserHandler(router);
    this.addOrgsListForAuthenticatedUserHandler(router);
    this.addPackagesListPackagesForAuthenticatedUserHandler(router);
    this.addPackagesGetPackageForAuthenticatedUserHandler(router);
    this.addPackagesDeletePackageForAuthenticatedUserHandler(router);
    this.addPackagesRestorePackageForAuthenticatedUserHandler(router);
    this.addPackagesGetAllPackageVersionsForPackageOwnedByAuthenticatedUserHandler(
      router
    );
    this.addPackagesGetPackageVersionForAuthenticatedUserHandler(router);
    this.addPackagesDeletePackageVersionForAuthenticatedUserHandler(router);
    this.addPackagesRestorePackageVersionForAuthenticatedUserHandler(router);
    this.addProjectsCreateForAuthenticatedUserHandler(router);
    this.addUsersListPublicEmailsForAuthenticatedUserHandler(router);
    this.addReposListForAuthenticatedUserHandler(router);
    this.addReposCreateForAuthenticatedUserHandler(router);
    this.addReposListInvitationsForAuthenticatedUserHandler(router);
    this.addReposAcceptInvitationForAuthenticatedUserHandler(router);
    this.addReposDeclineInvitationForAuthenticatedUserHandler(router);
    this.addUsersListSshSigningKeysForAuthenticatedUserHandler(router);
    this.addUsersCreateSshSigningKeyForAuthenticatedUserHandler(router);
    this.addUsersGetSshSigningKeyForAuthenticatedUserHandler(router);
    this.addUsersDeleteSshSigningKeyForAuthenticatedUserHandler(router);
    this.addActivityListReposStarredByAuthenticatedUserHandler(router);
    this.addActivityCheckRepoIsStarredByAuthenticatedUserHandler(router);
    this.addActivityStarRepoForAuthenticatedUserHandler(router);
    this.addActivityUnstarRepoForAuthenticatedUserHandler(router);
    this.addActivityListWatchedReposForAuthenticatedUserHandler(router);
    this.addTeamsListForAuthenticatedUserHandler(router);
    this.addUsersListHandler(router);
    this.addUsersGetByUsernameHandler(router);
    this.addActivityListEventsForAuthenticatedUserHandler(router);
    this.addActivityListOrgEventsForAuthenticatedUserHandler(router);
    this.addActivityListPublicEventsForUserHandler(router);
    this.addUsersListFollowersForUserHandler(router);
    this.addUsersListFollowingForUserHandler(router);
    this.addUsersCheckFollowingForUserHandler(router);
    this.addGistsListForUserHandler(router);
    this.addUsersListGpgKeysForUserHandler(router);
    this.addUsersGetContextForUserHandler(router);
    this.addAppsGetUserInstallationHandler(router);
    this.addUsersListPublicKeysForUserHandler(router);
    this.addOrgsListForUserHandler(router);
    this.addPackagesListPackagesForUserHandler(router);
    this.addPackagesGetPackageForUserHandler(router);
    this.addPackagesDeletePackageForUserHandler(router);
    this.addPackagesRestorePackageForUserHandler(router);
    this.addPackagesGetAllPackageVersionsForPackageOwnedByUserHandler(router);
    this.addPackagesGetPackageVersionForUserHandler(router);
    this.addPackagesDeletePackageVersionForUserHandler(router);
    this.addPackagesRestorePackageVersionForUserHandler(router);
    this.addProjectsListForUserHandler(router);
    this.addActivityListReceivedEventsForUserHandler(router);
    this.addActivityListReceivedPublicEventsForUserHandler(router);
    this.addReposListForUserHandler(router);
    this.addBillingGetGithubActionsBillingUserHandler(router);
    this.addBillingGetGithubPackagesBillingUserHandler(router);
    this.addBillingGetSharedStorageBillingUserHandler(router);
    this.addUsersListSshSigningKeysForUserHandler(router);
    this.addActivityListReposStarredByUserHandler(router);
    this.addActivityListReposWatchedByUserHandler(router);
    this.addMetaGetZenHandler(router);

    expressApp.use(router);

    expressApp.use(ControllerMiddleware.validationErrorMiddleware);
  }
}
